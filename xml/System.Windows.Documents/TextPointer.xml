<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>内の位置を表す、 <see cref="T:System.Windows.Documents.FlowDocument" /> または <see cref="T:System.Windows.Controls.TextBlock" />です。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Documents.TextPointer> クラスは、次の用語を紹介します。  
  
-   配置の本質的に、 <xref:System.Windows.Documents.TextPointer> 常を指します、 *位置* コンテンツにします。  このような位置のいずれかの分類、コンテンツ内の文字間、またはフロー間コンテンツ要素タグは、コンテンツの構造を定義します。  
  
-   現在位置にあるため、 <xref:System.Windows.Documents.TextPointer> 常に、位置を示すで実行できる操作の多く、 <xref:System.Windows.Documents.TextPointer> によって示される現在の位置は、 <xref:System.Windows.Documents.TextPointer>, で指定された位置を指す理にかなって、 <xref:System.Windows.Documents.TextPointer> として、 *の現在の位置*します。  
  
-   挿入位置の *挿入位置* 、位置は、関連付けられたコンテンツのセマンティクスの規則を損なうことがなく新しいコンテンツを追加する場合があります。  実際には、挿入位置はどこにでもコンテンツのキャレットを配置する場所です。  有効な例 <xref:System.Windows.Documents.TextPointer> 挿入位置ではない位置は 2 つの隣接する位置 <xref:System.Windows.Documents.Paragraph> タグ \(つまり、前の段落の終了タグと次の段落の開始タグの間\)。  
  
-   ためのシンボル <xref:System.Windows.Documents.TextPointer> 記号に関連する操作の場合は、次のいずれかと見なされます、 *シンボル*:  
  
    -   開始タグまたはの終了タグ、 <xref:System.Windows.Documents.TextElement> 要素。  
  
    -   A <xref:System.Windows.UIElement> 要素内に含まれる、 <xref:System.Windows.Documents.InlineUIContainer> または <xref:System.Windows.Documents.BlockUIContainer>です。  このようなメモ、 <xref:System.Windows.UIElement> 、常に正確に 1 つの記号は任意の他のコンテンツまたはに含まれる要素としてカウント、 <xref:System.Windows.UIElement> シンボルとしてはカウントされません。  
  
    -   各 16 ビット [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] テキスト内で文字 <xref:System.Windows.Documents.Run> 要素。  
  
-   テキスト コンテナー \- *テキスト コンテナー* が手元にフロー コンテンツの最終的な境界を形成する要素で指定された位置、 <xref:System.Windows.Documents.TextPointer> が常にテキスト コンテナー内にあります。  現時点では、テキスト コンテナーがある必要がありますか、 <xref:System.Windows.Documents.FlowDocument> または <xref:System.Windows.Controls.TextBlock>です。  一般的には、操作の間で <xref:System.Windows.Documents.TextPointer> 別のテキスト コンテナー内のインスタンスがサポートされていません。  
  
-   文書のテキスト コンテナー内のコンテンツと呼びます、 *ドキュメント*, お、 <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> メソッドおよび <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> と <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> プロパティです。  
  
 <xref:System.Windows.Documents.TextPointer> クラスは走査およびによって表されるコンテンツの操作を容易にするため、 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] フロー コンテンツ要素; からこのような要素が一般に、派生 <xref:System.Windows.Documents.TextElement>します。  一部の操作を <xref:System.Windows.Documents.TextPointer> を容易に以下のもの。  
  
-   2 番目の指定した位置の現在位置を示す序数に基づく比較を実行します。  参照してください、 <xref:System.Windows.Documents.TextPointer.CompareTo%2A> メソッドです。  
  
-   指定した方向で現在の位置に隣接するコンテンツの種類を決定します。  参照してください、 <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> メソッドと <xref:System.Windows.Documents.TextPointerContext> 列挙します。  
  
-   取得、 <xref:System.Windows.Documents.TextElement> スコープまたは現在の位置に隣接しています。  参照してください <xref:System.Windows.Documents.Paragraph> と <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> メソッドです。  
  
-   現在のドキュメントのスコープとなるテキスト コンテナーを取得します。<xref:System.Windows.Documents.TextPointer.Parent%2A> プロパティを参照してください。  
  
-   指定の数の文字の前または後の現在の位置を取得します。  参照してください、 <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> メソッドです。  
  
-   現在の位置にある文字の文字列を挿入します。  参照してください、 <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> メソッドです。  
  
-   コンテンツの行の境界を検索します。  参照してください、 <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> メソッドと <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> プロパティです。  
  
-   間で変換 <xref:System.Windows.Documents.TextPointer> の位置とシンボルのコンテンツにオフセットします。  参照してください、 <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> と <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> メソッドです。  
  
-   間で変換することによってビジュアル ヒット テストを実行する、 <xref:System.Windows.Documents.TextPointer> 位置と <xref:System.Windows.Point> 相対座標を表します。  
  
-   近くの挿入位置を見つけます。 または、現在の位置がカーソル位置であるかどうかを確認します。  参照してください、 <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> と <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> メソッドおよび <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> プロパティです。  
  
 位置と <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> によって示される、 <xref:System.Windows.Documents.TextPointer> オブジェクトは変更できません。  コンテンツの編集または変更で指定された位置の場合、 <xref:System.Windows.Documents.TextPointer> 周囲のテキストの基準とした変わらないではなく内容の先頭からその位置のオフセットは調整コンテンツ内の新しい相対位置を反映するようにします。  たとえば、 <xref:System.Windows.Documents.TextPointer> をコンテンツが挿入または削除する前に、または段落の後である場合でも、その段落の先頭を指す特定の段落の先頭に位置を続行することを示します。  
  
 <xref:System.Windows.Documents.TextPointer> クラスは、パブリック コンス トラクターを提供しません。  インスタンス <xref:System.Windows.Documents.TextPointer> プロパティまたはその他のオブジェクトのメソッドを使用して作成された \(などその他の <xref:System.Windows.Documents.TextPointer> オブジェクト\)。 次の一覧のメソッドとプロパティを作成して返す例をいくつかの提供、 <xref:System.Windows.Documents.TextPointer>です。  この一覧は完全ではありません。  
  
-   <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> と <xref:System.Windows.Documents.TextRange.End%2A>です。  
  
-   From a <xref:System.Windows.Documents.TextElement>:  <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, and <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   <xref:System.Windows.Controls.TextBlock> \(テキスト コンテナー\): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, 、<xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, 、および <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>です。  
  
-   <xref:System.Windows.Documents.FlowDocument> \(テキスト コンテナー\): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, と <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   既存の <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, 、<xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, 、<xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, 、および <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>です。  
  
   
  
## 例  
 次の例では、使用して、 <xref:System.Windows.Documents.TextPointer> 1 つ目の内部でだけの位置を検索する <xref:System.Windows.Documents.Run> 指定したテキスト コンテナー内の要素。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 次の例を使用して単純検索アルゴリズムを実装する <xref:System.Windows.Documents.TextPointer> 機能します。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> を現在の位置を比較する位置を指定します。</param>
        <summary>現在の指定した位置の間の序数の比較を行い <see cref="T:System.Windows.Documents.TextPointer" /> 秒を指定して <see cref="T:System.Windows.Documents.TextPointer" />します。</summary>
        <returns>– 場合は、1 現在 <see cref="T:System.Windows.Documents.TextPointer" /> の前に <paramref name="position" />; 場所が同じである場合は 0; \+ 1 の場合、現在 <see cref="T:System.Windows.Documents.TextPointer" /> に依存して <paramref name="position" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値\-1 は、現在の位置が指定されていることを示します <xref:System.Windows.Documents.TextPointer> で指定した位置の前に `position`します。  値 0 は、指定された位置が等しいことを示します。  \+1 の正の値は、現在の位置が指定されていることを示します <xref:System.Windows.Documents.TextPointer> で指定した位置に依存して `position`します。  
  
   
  
## 例  
 次の例では、このメソッドの用途を示します。  例では、 <xref:System.Windows.Documents.TextPointer.CompareTo%2A> と組み合わせてメソッドを使用、 <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> メソッドを指定したかどうかをテストする <xref:System.Windows.Documents.TextElement> が空です。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> 現在の位置に関連付けられているテキスト コンテナーの外部での位置を指定します。</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">を削除する文字数の現在の位置。 現在の位置より後に続く文字を削除するのには正の値を指定します。現在の位置を前にある文字を削除するのには負の値を指定します。</param>
        <summary>現在の指定された位置から指定数の文字を削除 <see cref="T:System.Windows.Documents.TextPointer" />します。</summary>
        <returns>実際に削除される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在の位置の後の文字を削除するのには正の値を指定 \(ように <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=fullName>\); 現在の位置を前にある文字を削除するのには負の値を指定 \(ように <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=fullName>\)。  
  
 実際に削除される文字数で指定された数よりも少ないあります `count`します。  ような場合、 `count` を削除するよりも多くの文字を指定します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">テキストが許可されていない位置で呼び出されます。</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Windows.Documents.TextPointer" /> の現在の位置に関連付けられているテキスト コンテナー内のコンテンツの終わりにします。</summary>
        <value>A <see cref="T:System.Windows.Documents.TextPointer" /> の現在の位置に関連付けられているテキスト コンテナー内のコンテンツの終わりにします。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> の返された <xref:System.Windows.Documents.TextPointer> テキスト コンテナーは、常に \(<xref:System.Windows.Controls.TextBlock> または <xref:System.Windows.Documents.FlowDocument>\) ではなく、 <xref:System.Windows.Documents.TextElement>です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Windows.Documents.TextPointer" /> の現在の位置に関連付けられているテキスト コンテナー内のコンテンツの先頭。</summary>
        <value>A <see cref="T:System.Windows.Documents.TextPointer" /> の現在の位置に関連付けられているテキスト コンテナー内のコンテンツの先頭。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 他の位置への相対オフセットを使用するベースライン位置として、このプロパティによって返される位置を使用します。<xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> と <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> メソッドは、位置と位置の間に変換する方法を提供します。 数分オフセットします。  
  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> の返された <xref:System.Windows.Documents.TextPointer> テキスト コンテナーは、常に \(<xref:System.Windows.Controls.TextBlock> または <xref:System.Windows.Documents.FlowDocument>\) ではなく、 <xref:System.Windows.Documents.TextElement>です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">いずれか、 <see cref="T:System.Windows.Documents.LogicalDirection" /> 隣接する要素を検索するための論理の方向を指定する値。</param>
        <summary>存在する場合、その現在の境界線、要素を返す <see cref="T:System.Windows.Documents.TextPointer" /> 指定した論理方向にします。</summary>
        <returns>指定した隣接する要素 <paramref name="direction" />, 、または <see langword="null" /> 隣接する要素が存在しない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返される要素は、通常、 <xref:System.Windows.Documents.TextElement>です。  A <xref:System.Windows.UIElement> 場合、返されることができます、 <xref:System.Windows.Documents.TextPointer> 内の位置を示す、 <xref:System.Windows.Documents.BlockUIContainer> 要素または <xref:System.Windows.Documents.InlineUIContainer> 要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">いずれか、 <see cref="T:System.Windows.Documents.LogicalDirection" /> 境界ボックスのコンテンツを検索するための論理の方向を指定する値。</param>
        <summary>境界ボックスを返します \(<see cref="T:System.Windows.Rect" />\) コンテンツを囲む境界線の現在の <see cref="T:System.Windows.Documents.TextPointer" /> 指定した論理方向にします。</summary>
        <returns>コンテンツを囲む境界線の現在の境界ボックス <see cref="T:System.Windows.Documents.TextPointer" /> 指定方向または <see cref="P:System.Windows.Rect.Empty" /> 最新場合は有効なレイアウト情報は使用できません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Documents.TextElement> エッジでは、このメソッドのためのコンテンツは考慮されません。  場合、 <xref:System.Windows.Documents.TextPointer> 前に位置付けられますが、 <xref:System.Windows.Documents.TextElement> エッジ、戻り値は、次の境界ボックス以外<xref:System.Windows.Documents.TextElement> 指定した方向にコンテンツです。  ゼロ幅の指定した方向にコンテンツがないかどうかは <xref:System.Windows.Rect> の前にすべてのコンテンツの高さに一致する高さが返されます。  
  
 このメソッドによって実行される操作は、有効なレイアウトに依存します。  必要に応じて、このメソッドは、操作を続行する前に有効なレイアウトを自動的に再生成しようとします。  レイアウトを再生成すると、比較的負荷のかかる操作を指定できます。  使用して、 <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> レイアウトを再生成する操作を実行する前に有効なレイアウトを確認するプロパティです。  詳細については、次を参照してください。 [レイアウト](http://msdn.microsoft.com/ja-jp/3eecdced-3623-403a-a077-7595453a9221)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">いずれか、 <see cref="T:System.Windows.Documents.LogicalDirection" /> 最も近い挿入位置を検索するための論理の方向を指定する値。</param>
        <summary>返します。、 <see cref="T:System.Windows.Documents.TextPointer" /> を指定した論理方向に最も近いのカーソル位置にします。</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> を指定した方向に最も近いカーソル位置にします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 挿入位置とは、位置、セマンティクスの規則に関連するコンテンツを損なうことがなく新しいコンテンツを追加する場合があります。  実際には、挿入位置はどこにでもコンテンツのキャレットを配置する場所です。  有効な例 <xref:System.Windows.Documents.TextPointer> 挿入位置ではない位置は 2 つの隣接する位置 <xref:System.Windows.Documents.Paragraph> タグ \(つまり、前の段落の終了タグと次の段落の開始タグの間\)。  
  
 場合、 <xref:System.Windows.Documents.TextPointer> 空でない書式シーケンスのすぐ後ろに指定した方向にその位置が、有効なカーソルの位置、終了タグを既に指して、 <xref:System.Windows.Documents.TextPointer> これによって返されるメソッドは、書式設定のシーケンスの終了直後に挿入位置を指すに調整します。    たとえば、マークアップ シーケンス `<Bold>``a``</Bold>``b`します。  文字の間の 2 つのカーソル位置があることに注意してください `a` と `b`— いずれかの終了前に表示される `Bold` タグ、および終了に続けて 1 `Bold` タグ。  場合 <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> で呼び出される、 <xref:System.Windows.Documents.TextPointer> 文字の直後後の位置に `a` とする前に閉じるときの `Bold` タグを使用して、 `direction` の <xref:System.Windows.Documents.LogicalDirection.Forward>, 、返された <xref:System.Windows.Documents.TextPointer> 文字の前に位置をポイントするように調整 `b`, 、閉じた後 `Bold` タグ。  論理方向が逆で作業する場合は、書式設定タグを開くような調整が可能です。  このメソッドは、ような場合に、挿入位置の間のあいまいさを提供します。  
  
 このメソッドは、構造タグのシーケンスが含まれている場合に、挿入ポイントを選択することもできます。 たとえば、決算残高と期首段落タグの間での位置にあるときに、方向パラメーターできますを使用する次の段落の先頭に最も近いカーソルで選択して \(を指定して <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=fullName>\) または前の段落の末尾 \(を指定して <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=fullName>\)。  
  
 マウス ポインターがカーソル位置にあるが既にあり、指定した隣接する書式設定タグがない場合 `direction`, 、返された <xref:System.Windows.Documents.TextPointer> 、呼び出し元と同じ位置を指す <xref:System.Windows.Documents.TextPointer>します。  
  
 指す位置に有効な挿入位置が存在しないことが可能であれば、 <xref:System.Windows.Documents.TextPointer>です。  これは、参照されたコンテンツが空のテーブルまたは一覧と同様に構造的に完了していない場合に発生することができます。  このような場合、このメソッドは単を返します、 <xref:System.Windows.Documents.TextPointer> と同じ位置に、 <xref:System.Windows.Documents.TextPointer> からこのメソッドが呼び出されました。  このメソッドは常に有効な返します <xref:System.Windows.Documents.TextPointer>します。  
  
   
  
## 例  
 この例では、使用、 <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> 、指定したかどうかを確認する方法を <xref:System.Windows.Documents.TextElement> が印刷可能なコンテンツの空です。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">開始位置を取得する行を決定するときにスキップする行の先頭にマーカーの数。 負の値が前の行を指定、0 が現在の行を指定し、正の値は、次の行を指定します。</param>
        <summary>返します。、 <see cref="T:System.Windows.Documents.TextPointer" /> 現在に対して相対的に指定されている行の先頭に <see cref="T:System.Windows.Documents.TextPointer" />します。</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> 指定した行の先頭を指す \(で、 <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> 設定 <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />\)、または <see langword="null" /> 指定した行が範囲外か、それ以外の場合を検出できない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Windows.Documents.TextPointer> を指すあいまいな位置、たとえば、2 行の間で指定した方向に行 <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> 相対開始行を選択しています。  
  
 このメソッドによって実行される操作は、有効なレイアウトに依存します。  必要に応じて、このメソッドは、操作を続行する前に有効なレイアウトを自動的に再生成しようとします。  レイアウトを再生成すると、比較的負荷のかかる操作を指定できます。  使用 <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> レイアウトを再生成する操作を実行する前に有効なレイアウトを確認します。  詳細については、次を参照してください。 [レイアウト](http://msdn.microsoft.com/ja-jp/3eecdced-3623-403a-a077-7595453a9221)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, int32 actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">開始位置を取得する行を決定するときにスキップする行の先頭にマーカーの数。 負の値が前の行を指定、0 が現在の行を指定し、正の値は、次の行を指定します。</param>
        <param name="actualCount">このメソッドが戻るときに、実際の数開始位置を返す対象の行を決定するときにスキップされた行の先頭にマーカーにはが含まれています。  この値より小さい <c>count</c> 先頭またはコンテンツの終わりが検出されたかどうかに指定された数の行はスキップされます。 このパラメーターは初期化せずに渡されます。</param>
        <summary>返します。、 <see cref="T:System.Windows.Documents.TextPointer" /> 現在に対して相対的に指定されている行の先頭に <see cref="T:System.Windows.Documents.TextPointer" />, 、およびスキップされた行の数をレポートします。</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> 指定した行の先頭を指す \(で、 <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> 設定 <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />\)、または指定した行が範囲外の場合は、指定した行に最も近い行の先頭にします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Windows.Documents.TextPointer> を指すあいまいな位置、たとえば、2 行の間で指定した方向の行、 <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> プロパティが相対の開始行として選択されています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">いずれか、 <see cref="T:System.Windows.Documents.LogicalDirection" /> 次のシンボルを検索するための論理の方向を指定する値。</param>
        <summary>指定した論理方向では、次のシンボルへのポインターを返します。</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> 要求された方向では、次のシンボルへまたは <see langword="null" /> 場合、現在 <see cref="T:System.Windows.Documents.TextPointer" /> 開始またはコンテンツの終わりの罫線します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シンボルを使用する、次のいずれかと見なされます。  
  
-   開始タグまたはの終了タグ、 <xref:System.Windows.Documents.TextElement> 要素。  
  
-   A <xref:System.Windows.UIElement> 要素に含まれている、 <xref:System.Windows.Documents.InlineUIContainer> または <xref:System.Windows.Documents.BlockUIContainer>です。  このようなメモ、 <xref:System.Windows.UIElement> 、常に正確に 1 つの記号は任意の他のコンテンツまたはに含まれる要素としてカウント、 <xref:System.Windows.UIElement> シンボルとしてはカウントされません。  
  
-   16 ビット [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] テキスト内で文字 <xref:System.Windows.Documents.Run> 要素。  
  
 次のシンボルとしてカテゴリ化される場合 <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, 、<xref:System.Windows.Documents.TextPointerContext.ElementStart>, 、または <xref:System.Windows.Documents.TextPointerContext.ElementEnd> \(で識別される、 <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> メソッド\)、 <xref:System.Windows.Documents.TextPointer> これによって返されるメソッドは現在の位置から 1 つの記号で高度なです。  
  
 次のシンボルとしてカテゴリ化される場合 <xref:System.Windows.Documents.TextPointerContext.Text>, 、 <xref:System.Windows.Documents.TextPointer> これによって返されるメソッドは次のテキスト以外のシンボルへテキスト過去の高度な \(は、次が位置、 <xref:System.Windows.Documents.TextPointerContext> は <xref:System.Windows.Documents.TextPointerContext.Text>\)。  超えました。 正確なシンボルの数は、呼び出すことによって事前に計算することができます、 <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> メソッドです。  
  
   
  
## 例  
 次の例では、このメソッドの用途を示します。  例では、 <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> メソッドと組み合わせて、 <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> を走査し、指定したシンボルを展開する方法 <xref:System.Windows.Documents.TextElement>します。  
  
 抽出する例を使用できますが、 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 構造体の内容を指定された <xref:System.Windows.Documents.TextElement>, 、説明のために、対象としていますが、実稼働コードでは使用しないでします。  参照してください、 <xref:System.Xml> を使用して XML を処理するためにデザインされた型の豊富なセットの名前空間。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">いずれか、 <see cref="T:System.Windows.Documents.LogicalDirection" /> 次の挿入位置を検索するための論理の方向を指定する値。</param>
        <summary>返します。、 <see cref="T:System.Windows.Documents.TextPointer" /> に指定した論理方向では、次の挿入位置。</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> 要求された方向では、次の挿入位置を識別する、または <see langword="null" /> 次の挿入位置が見つからない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 *挿入位置* 、位置は、関連付けられたコンテンツのセマンティクスの規則を損なうことがなく新しいコンテンツを追加する場合があります。  実際には、挿入位置はどこにでもコンテンツのキャレットを配置する場所です。  有効な例 <xref:System.Windows.Documents.TextPointer> 挿入位置ではない位置は 2 つの隣接する位置 <xref:System.Windows.Documents.Paragraph> タグ \(つまり、前の段落の終了タグと次の段落の開始タグの間\)。  
  
   
  
## 例  
 次の例では、このメソッドの用途を示します。 例では、 <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> メソッドの数をカウントするためにコンテンツの要素の境界を通過する <xref:System.Windows.Documents.Paragraph> 要素が指定した 2 つの間で提示 <xref:System.Windows.Documents.TextPointer> インスタンス。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> に \(シンボル\) の距離を検索する位置を指定します。</param>
        <summary>現在のシンボルの数を返します <see cref="T:System.Windows.Documents.TextPointer" /> 秒を指定して <see cref="T:System.Windows.Documents.TextPointer" />します。</summary>
        <returns>現在のシンボルの相対数 <see cref="T:System.Windows.Documents.TextPointer" /> と <paramref name="position" />です。  負の値を現在 <see cref="T:System.Windows.Documents.TextPointer" /> で指定した位置に依存して <paramref name="position" />, 、0 ことを示し、位置が等しいか、正の値を現在 <see cref="T:System.Windows.Documents.TextPointer" /> で指定した位置の前に <paramref name="position" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シンボルを使用する、次のいずれかと見なされます。  
  
-   開始タグまたはの終了タグ、 <xref:System.Windows.Documents.TextElement> 要素。  
  
-   A <xref:System.Windows.UIElement> 要素に含まれている、 <xref:System.Windows.Documents.InlineUIContainer> または <xref:System.Windows.Documents.BlockUIContainer>です。  このようなメモ、 <xref:System.Windows.UIElement> 、常に正確に 1 つの記号は任意の他のコンテンツまたはに含まれる要素としてカウント、 <xref:System.Windows.UIElement> シンボルとしてはカウントされません。  
  
-   16 ビット [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] テキスト内で文字 <xref:System.Windows.Documents.Run> 要素。  
  
   
  
## 例  
 次の例では、このメソッドの用途を示します。 例では、 <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> メソッドという 2 つのオフセットを <xref:System.Windows.Documents.TextPointer> をインスタンス化、および、この情報を保存および復元の選択内容を使用して、 <xref:System.Windows.Controls.RichTextBox>です。  例では、内容、 <xref:System.Windows.Controls.RichTextBox> が、選択範囲を保存して復元する間は変更されていません。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> 現在の位置に関連付けられているテキスト コンテナーの外部での位置を指定します。</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">いずれか、 <see cref="T:System.Windows.Documents.LogicalDirection" /> 隣接するコンテンツのカテゴリを確認するための論理の方向を指定する値。</param>
        <summary>現在の横にあるコンテンツのカテゴリ インジケーターを返す <see cref="T:System.Windows.Documents.TextPointer" /> 指定した論理方向にします。</summary>
        <returns>いずれか、 <see cref="T:System.Windows.Documents.TextPointerContext" /> を指定した論理方向の横にあるコンテンツのカテゴリを示す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、このメソッドの用途を示します。 例では、 <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> タグと終了要素タグが指定した 2 つの間の分散を計算するためのアルゴリズムを実装するメソッド <xref:System.Windows.Documents.TextPointer> 位置。  各 \+1、および各カウントが開始要素タグ終了要素タグは – 1 としてカウントされます。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">計算して位置を返す対象の記号でのオフセット。  示されるは、逆の論理方向の位置が計算のオフセットが負の場合、 <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> プロパティです。</param>
        <summary>返します。、 <see cref="T:System.Windows.Documents.TextPointer" /> を現在の先頭からのシンボルで指定したオフセットで示される位置に <see cref="T:System.Windows.Documents.TextPointer" />します。</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> を指定したオフセットで示される位置または<see langword=" null " />対応する位置が見つからない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シンボルを使用する、次のいずれかと見なされます。  
  
-   開始タグまたはの終了タグ、 <xref:System.Windows.Documents.TextElement> 要素。  
  
-   A <xref:System.Windows.UIElement> 要素に含まれている、 <xref:System.Windows.Documents.InlineUIContainer> または <xref:System.Windows.Documents.BlockUIContainer>です。  このようなメモ、 <xref:System.Windows.UIElement> 、常に正確に 1 つの記号は任意の他のコンテンツまたはに含まれる要素としてカウント、 <xref:System.Windows.UIElement> シンボルとしてはカウントされません。  
  
-   16 ビット [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] テキスト内で文字 <xref:System.Windows.Documents.Run> 要素。  
  
   
  
## 例  
 次の例では、このメソッドの用途を示します。 例では、 <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> を基準にして、ホスティングの段落を返す、もう一方の指定した位置のオフセットを計算するいずれかのメソッドのペアを実装するメソッド、 <xref:System.Windows.Documents.TextPointer> 指定段落内の指定したオフセット。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">計算して位置を返す対象の記号でのオフセット。  オフセットが負の場合、返された <see cref="T:System.Windows.Documents.TextPointer" /> 、現在の前に <see cref="T:System.Windows.Documents.TextPointer" />。 そうしないと、これに従います。</param>
        <param name="direction">いずれか、 <see cref="T:System.Windows.Documents.LogicalDirection" /> 、返された論理方向を指定する値 <see cref="T:System.Windows.Documents.TextPointer" />です。</param>
        <summary>返します。、 <see cref="T:System.Windows.Documents.TextPointer" /> を現在の先頭からのシンボルで指定したオフセットで示される位置に <see cref="T:System.Windows.Documents.TextPointer" /> と指定した方向にします。</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> を指定したオフセットで示される位置または<see langword=" null " />コンテンツの末尾オフセットを拡張した場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シンボルを使用する、次のいずれかと見なされます。  
  
-   開始タグまたはの終了タグ、 <xref:System.Windows.Documents.TextElement> 要素。  
  
-   A <xref:System.Windows.UIElement> 要素に含まれている、 <xref:System.Windows.Documents.InlineUIContainer> または <xref:System.Windows.Documents.BlockUIContainer>です。  このようなメモ、 <xref:System.Windows.UIElement> 、常に正確に 1 つの記号は任意の他のコンテンツまたはに含まれる要素としてカウント、 <xref:System.Windows.UIElement> シンボルとしてはカウントされません。  
  
-   16 ビット [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] テキスト内で文字 <xref:System.Windows.Documents.Run> 要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">いずれか、 <see cref="T:System.Windows.Documents.LogicalDirection" /> を検索し、隣接するテキストを返す論理方向を指定する値。</param>
        <summary>現在の横にある任意のテキストを含む文字列を返します <see cref="T:System.Windows.Documents.TextPointer" /> 指定した論理方向にします。</summary>
        <returns>指定した論理方向に隣接するテキストを含む文字列または <see cref="F:System.String.Empty" /> 隣接するテキストが見つからない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、中断のない個のみのテキストを返します。  いずれかの記号型以外の場合は、何も返されない <xref:System.Windows.Documents.TextPointerContext.Text> は現在の横にある <xref:System.Windows.Documents.TextPointer> 指定した方向にします。  同様に、次のテキスト以外のシンボルまでしかテキストが返されます。  
  
   
  
## 例  
 次の例では、このメソッドの用途を示します。 例では、 <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> 単純なテキストの抽出を実装するメソッドです。  指定した 2 つの間のすべてのテキストの文字列の連結を返します <xref:System.Windows.Documents.TextPointer> インスタンス。  
  
 2 つの任意のテキストを抽出する例を使用できますが <xref:System.Windows.Documents.TextPointer> インスタンス、それは、説明のためのものでは、および実稼働コードでは使用しないでします。  代わりに、<xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=fullName> プロパティを使用してください。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">いずれか、 <see cref="T:System.Windows.Documents.LogicalDirection" /> を検索し、隣接するテキストをコピーするための論理の方向を指定する値。</param>
        <param name="textBuffer">任意のテキストのコピー先バッファー。</param>
        <param name="startIndex">インデックスを <c>textBuffer</c> のテキストのコピー書き込みを開始する位置。</param>
        <param name="count">コピーする文字の最大数。</param>
        <summary>呼び出し元が指定した文字配列に指定した方向に隣接するテキストから、指定した最大文字数をコピーします。</summary>
        <returns>実際にコピーされた文字数 <paramref name="textBuffer" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、中断のない個のみのテキストを返します。  いずれかの記号型以外の場合は、何も返されない [GetTextInRun メソッド \(LogicalDirection, Char\<xref:System.Windows.Documents.TextPointerContext.Text> は現在の横にある [GetTextInRun メソッド \(LogicalDirection, Char\<xref:System.Windows.Documents.TextPointer> 指定した方向にします。  同様に、次のテキスト以外のシンボルまでしかテキストが返されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> 0 未満かより大きい、 <see cref="P:System.Array.Length" /> の <paramref name="textBuffer" />です。  
  
 または  
  
 <paramref name="count" /> 0 未満かの残りの領域を超える <paramref name="textBuffer" /> \(<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> マイナス <paramref name="startIndex" />\)。</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">いずれか、 <see cref="T:System.Windows.Documents.LogicalDirection" /> 文字数をカウントする論理方向を指定する値。</param>
        <summary>現在の間の Unicode 文字の数値を返す <see cref="T:System.Windows.Documents.TextPointer" /> と、指定した論理方向では、次の非テキスト シンボルです。</summary>
        <returns>現在の間での Unicode 文字の数 <see cref="T:System.Windows.Documents.TextPointer" /> と次のテキスト以外の記号。  この番号は、隣接するテキストが存在しない場合、0 にすることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シンボルを使用する、次のいずれかと見なされます。  
  
-   開始タグまたはの終了タグ、 <xref:System.Windows.Documents.TextElement> 要素。  
  
-   A <xref:System.Windows.UIElement> 要素に含まれている、 <xref:System.Windows.Documents.InlineUIContainer> または <xref:System.Windows.Documents.BlockUIContainer>です。  このようなメモ、 <xref:System.Windows.UIElement> 、常に正確に 1 つの記号は任意の他のコンテンツまたはに含まれる要素としてカウント、 <xref:System.Windows.UIElement> シンボルとしてはカウントされません。  
  
-   16 ビット [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] テキスト内で文字 <xref:System.Windows.Documents.Run> 要素。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の位置に関連付けられているテキスト コンテナー \(最新\) レイアウトが有効であるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> レイアウトは現在、有効である場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要に応じて、有効なレイアウトに依存する操作 \(など、 <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> メソッド、 <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> メソッド、および <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> プロパティ\) 操作を続行する前に有効なレイアウトを自動的に再生成しようとしています。  レイアウトを再生成すると、比較的負荷のかかる操作を指定できます。  このプロパティを使用して、レイアウトを再生成操作を実行する前に有効なレイアウトをチェックします。  詳細については、次を参照してください。 [レイアウト](http://msdn.microsoft.com/ja-jp/3eecdced-3623-403a-a077-7595453a9221)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の位置で改行を挿入します。</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> すぐ後ろに配置され、 <see cref="T:System.Windows.Documents.LineBreak" /> このメソッドによって挿入される要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の位置にある段落改行を挿入します。</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> を最初に \(<see cref="P:System.Windows.Documents.TextElement.ContentStart" />\) 新しい段落のです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在の位置が、既存の内部にある場合、このメソッドが呼び出された場合 <xref:System.Windows.Documents.Paragraph> 要素、既存の段落およびそのコンテンツが含まれていますが、現在の位置で 2 つの段落に分かれています。  現在の位置が既存の段落内にない場合に、このメソッドを呼び出すと、新しい空の段落が挿入されます。  このメソッドが呼び出された場合、位置で分割するか、段落を挿入するのには適していません \(内の現在の位置が場合など、 <xref:System.Windows.Documents.Hyperlink> 要素\)、例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">このメソッドに対応する新しい段落などの範囲に分割できない位置で呼び出されます、 <see cref="T:System.Windows.Documents.Hyperlink" /> または <see cref="T:System.Windows.Documents.InlineUIContainer" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">挿入するテキスト。</param>
        <summary>テキストに指定したテキストを挿入 <see cref="T:System.Windows.Documents.Run" /> 現在位置にあります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Windows.Documents.TextPointer> がない範囲によって決まります、 <xref:System.Windows.Documents.Run> 要素、 <xref:System.Windows.Documents.Run> と共に挿入される、 `textData`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の位置が適用されない、 <see cref="T:System.Windows.Documents.Run" /> 要素。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の位置がカーソル位置であるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 現在の位置が、挿入位置である場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 挿入位置とは、位置、セマンティクスの規則に関連するコンテンツを損なうことがなく新しいコンテンツを追加する場合があります。  実際には、挿入位置はどこにでもコンテンツのキャレットを配置する場所です。  有効な例 <xref:System.Windows.Documents.TextPointer> 挿入位置ではない位置は 2 つの隣接する位置 <xref:System.Windows.Documents.Paragraph> タグ \(つまり、前の段落の終了タグと次の段落の開始タグの間\)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の位置が行の先頭であるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 現在の位置が、2 行の先頭にある場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Windows.Documents.TextPointer> を指すあいまいな位置、たとえば、2 行の間で指定した方向の行、 <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> プロパティが相対の開始行として選択されています。  
  
 このプロパティによって実行される操作は、有効なレイアウトに依存します。  必要に応じて、このメソッドは、操作を続行する前に有効なレイアウトを自動的に再生成しようとします。  レイアウトを再生成すると、比較的負荷のかかる操作を指定できます。  使用して、 <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> レイアウトを再生成する操作を実行する前に有効なレイアウトを確認するプロパティです。  詳細については、次を参照してください。 [レイアウト](http://msdn.microsoft.com/ja-jp/3eecdced-3623-403a-a077-7595453a9221)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">A <see cref="T:System.Windows.Documents.TextPointer" /> を現在の位置を比較する位置を指定します。</param>
        <summary>指定した位置が現在の位置と同じテキスト コンテナー内にするかどうかを示します。</summary>
        <returns>
          <see langword="true" /> 場合 <paramref name="textPosition" /> 現在の位置と同じテキスト コンテナー内の位置を示す場合は、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複数の関連するほとんどの操作 <xref:System.Windows.Documents.TextPointer> インスタンスは、対象のインスタンスには、同じテキスト コンテナーのスコープ内の位置が示されている場合にのみ有効です。  たとえば、 <xref:System.Windows.Documents.TextPointer.CompareTo%2A> と <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> メソッドでは使用できません、 <xref:System.Windows.Documents.TextPointer> を現在の位置に関連付けられているテキスト コンテナーの外部での位置。  このメソッドを使用していることを確認、指定した <xref:System.Windows.Documents.TextPointer> はこのような操作の現在の位置と互換性ができます。  
  
   
  
## 例  
 次の例では、このメソッドの用途を示します。  例では、 <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> 、指定したかどうかを確認する方法を <xref:System.Windows.Documents.TextPointer> 他の指定した 2 つの間に配置 <xref:System.Windows.Documents.TextPointer> インスタンスで、状況がすべての 3 つの位置が同じテキスト コンテナーに属していることの保証はありません。  
  
 [!code-csharp[TextPointer\_Snippets\#\_TextPointer\_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer\_Snippets\#\_TextPointer\_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の位置に関連付けられているコンテンツを区別するために使用される現在の位置に関連付けられている論理方向を取得します。</summary>
        <value>
          <see cref="T:System.Windows.Documents.LogicalDirection" /> 現在位置に関連付けられている値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの使用方法の例として、 <xref:System.Windows.Documents.LogicalDirection> の <xref:System.Windows.Documents.TextPointer> 返されるヒット テストでメソッドは 2 つの文字のテキストの間にあるヒットを行います。 2 つの文字のうち、実際にヒットした論理の方向を指定: 左または右です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>存在する場合は、現在の位置のスコープの段落を取得します。</summary>
        <value>
          <see cref="T:System.Windows.Documents.Paragraph" /> スコープを現在の位置または<see langword=" null " />このような段落が存在しない場合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の位置のスコープとなる論理上の親を取得します。</summary>
        <value>現在の位置のスコープとなる論理上の親です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この型またはメンバーをサポートしています、 Windows Presentation Foundation (WPF) インフラストラクチャ コードから直接使用するものではありません。</summary>
        <returns>オブジェクトを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返します。、 <see cref="T:System.Windows.Documents.TextPointer" /> 現在に対して相対的に指定されている行の先頭に <see cref="T:System.Windows.Documents.TextPointer" />します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の横にあるテキストを返す <see cref="T:System.Windows.Documents.TextPointer" />します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返します。、 <see cref="T:System.Windows.Documents.TextPointer" /> コンテンツの先頭からのシンボルで指定したオフセットで指定された位置にします。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>