<Type Name="AnchoredBlock" FullName="System.Windows.Documents.AnchoredBlock">
  <TypeSignature Language="C#" Value="public abstract class AnchoredBlock : System.Windows.Documents.Inline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AnchoredBlock extends System.Windows.Documents.Inline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.AnchoredBlock" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.Inline</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Blocks")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>基になる抽象クラス <see cref="T:System.Windows.Documents.Inline" /> 使用される要素のアンカーに <see cref="T:System.Windows.Documents.Block" /> フロー コンテンツ要素。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AnchoredBlock (System.Windows.Documents.Block block, System.Windows.Documents.TextPointer insertionPosition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.Block block, class System.Windows.Documents.TextPointer insertionPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.AnchoredBlock.#ctor(System.Windows.Documents.Block,System.Windows.Documents.TextPointer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="block" Type="System.Windows.Documents.Block" />
        <Parameter Name="insertionPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="block">A <see cref="T:System.Windows.Documents.Block" /> オブジェクトを新しい要素の初期コンテンツを指定します。  このパラメーターがあります <see langword="null" />, その場合はない <see cref="T:System.Windows.Documents.Block" /> が挿入されます。</param>
        <param name="insertionPosition">A <see cref="T:System.Windows.Documents.TextPointer" /> は作成後に要素を挿入する位置の挿入位置を指定または <see langword="null" /> のない自動挿入します。</param>
        <summary>クラスの値を指定した派生クラスによって呼び出されると、基本初期化 <see cref="T:System.Windows.Documents.Block" /> オブジェクトの新しい子の初期コンテンツとして <see cref="T:System.Windows.Documents.AnchoredBlock" />, 、および <see cref="T:System.Windows.Documents.TextPointer" /> 新しいの挿入位置を指定する <see cref="T:System.Windows.Documents.AnchoredBlock" /> 子孫です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blocks">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.BlockCollection Blocks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.BlockCollection Blocks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.Blocks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.BlockCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の内容を構成する最上位レベルの <see cref="T:System.Windows.Documents.Block" /> 要素を含む <see cref="T:System.Windows.Documents.BlockCollection" /> を取得します。</summary>
        <value>要素の内容を構成する <see cref="T:System.Windows.Documents.Block" /> 要素を含む <see cref="T:System.Windows.Documents.BlockCollection" />。  
  
 このプロパティに既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush BorderBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush BorderBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.BorderBrush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 <see cref="T:System.Windows.Media.Brush" /> 要素の境界を描画するときに使用します。</summary>
        <value>要素の罫線を適用するために使用するブラシ。  
  
 既定値は、 **null** ブラシ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用可能な事前定義されたブラシの色の見本のテーブルを参照してください。 <xref:System.Windows.Media.Brushes>します。  
  
<a name="dependencyPropertyInfo_BorderBrush"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Documents.AnchoredBlock.BorderBrushProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## 例  
 次の例では、設定する方法、 <xref:System.Windows.Documents.Block.BorderBrush%2A> 要素の属性 \(<xref:System.Windows.Documents.Paragraph>\)。  
  
 [!code-xml[BlockSnippets\#\_Block\_BordersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_bordersxaml)]  
  
 次の図は、この例をレンダリングする方法を示しています。  
  
 20491906-5a09-4675-8f70-c9c6283b1b63  
  
 次の例では、設定する方法、 <xref:System.Windows.Documents.Block.BorderBrush%2A> プロパティ プログラムを使用しています。  
  
 [!code-csharp[BlockSnippets\#\_Block\_Borders](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_borders)]
 [!code-vb[BlockSnippets\#\_Block\_Borders](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_borders)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.AnchoredBlock.BorderThickness" />
      </Docs>
    </Member>
    <Member MemberName="BorderBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.BorderBrushProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.AnchoredBlock.BorderBrush" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderThickness">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness BorderThickness { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness BorderThickness" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.BorderThickness" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の境界線の太さを取得または設定します。</summary>
        <value>適用する境界線の量を指定する <see cref="T:System.Windows.Thickness" /> 構造体。デバイス非依存のピクセル単位で指定します。  
  
 既定値は 0 \(**0.0**\) の均一な厚みです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="xamlAttributeUsage_BorderThickness"></a>   
## XAML 属性の使用方法  
  
```  
<object BorderThickness="uniformThickness"/>  
- or -  
<object BorderThickness="independentThickness"/>  
- or -  
<object BorderThickness="qualifiedUniformThickness"/>  
- or -  
<object BorderThickness="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_BorderThickness"></a>   
## XAML 値  
 *uniformThickness*  
 1 つの文字列表現 <xref:System.Double> 4 つすべての厚みに一様に分布を適用する値。  たとえばの値 `"10"` はの値と同じ `"10,10,10,10"`します。  修飾されていない値は、デバイス非依存のピクセル単位で計測されます。 文字列が必要な小数点を明示的に含まれません。  
  
 *independentThickness*  
 順序付けになる 4 つの文字列表現 <xref:System.Double> 上、左の太さの独立したディメンションに対応する値が右、および、下には、次の順序で。  4 つの値をコンマで区切る必要があります。スペースは使用できません。  たとえば、「5,10,15,20」によって 5 ピクセルの境界線のコンテンツ、上の枠線のピクセルを 10、15 ピクセル、コンテンツの右に罫線のおよびコンテンツの下の境界線の 20 ピクセルの左側です。  
  
 *qualifiedUniformThickness*  
 記述された値 *uniformThickness* 次の単位指定子のいずれかが続きます。 `px`, 、`in`です。  
  
 `px` \(既定値\) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px \= \=  
  
 たとえば、 `"1in"` すべての方向に 1 インチの均一の境界を提供します。  
  
 *qualifiedIndependentThickness*  
 記述された値 *independentThickness*, 、独立した各値は、次の単位指定子のいずれかが続きます。 `px`, 、`in`です。  
  
 `px` \(既定値\) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px \= \=  
  
 たとえば、`"1.5in,0.8in,1.5in,0.8in"` のようにします。  単位指定子は、混合または 1 つまたは複数の値からを省略すると場合があります。  
  
<a name="dependencyPropertyInfo_BorderThickness"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Documents.AnchoredBlock.BorderThicknessProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## 例  
 次の例では、設定する方法、 <xref:System.Windows.Documents.Block.BorderThickness%2A> の属性、 <xref:System.Windows.Documents.Block> 要素 \(<xref:System.Windows.Documents.Paragraph>\)。  
  
 [!code-xml[BlockSnippets\#\_Block\_BordersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_bordersxaml)]  
  
 次の図は、この例をレンダリングする方法を示しています。  
  
 20491906-5a09-4675-8f70-c9c6283b1b63  
  
 次の例では、設定する方法、 <xref:System.Windows.Documents.Block.BorderThickness%2A> プロパティ プログラムを使用しています。  
  
 [!code-csharp[BlockSnippets\#\_Block\_Borders](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_borders)]
 [!code-vb[BlockSnippets\#\_Block\_Borders](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_borders)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.AnchoredBlock.BorderBrush" />
      </Docs>
    </Member>
    <Member MemberName="BorderThicknessProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderThicknessProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderThicknessProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.BorderThicknessProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.AnchoredBlock.BorderThickness" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineHeight">
      <MemberSignature Language="C#" Value="public double LineHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LineHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.LineHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンテンツの各行の高さを取得または設定します。</summary>
        <value>デバイスに依存しないピクセルで行の高さを指定する double 値。<see cref="P:System.Windows.Documents.AnchoredBlock.LineHeight" /> は、<c>0.0034</c> 以上、かつ <c>160000</c> 以下でなければなりません。  
  
 値 <see cref="F:System.Double.NaN" /> \(属性値 "<c>Auto</c>" に相当するもの\) に設定すると、行の高さは現在のフォント特性から自動的に決定されます。  
  
 既定値は <see cref="F:System.Double.NaN" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この値を変更しても、関連付けられているテキストの高さは変更されません。代わりに、テキストを含む行の高さを変更します。  
  
 このプロパティでは、内の行のレイアウトだけでなく、 <xref:System.Windows.Documents.AnchoredBlock> の影響を受けるその <xref:System.Windows.Documents.AnchoredBlock.LineStackingStrategy%2A> プロパティです。  
  
<a name="xamlAttributeUsage_LineHeight"></a>   
## XAML 属性の使用方法  
  
```  
<object LineHeight="double"/>  
- or -  
<object LineHeight="qualifiedDouble"/>  
- or -  
<object LineHeight="Auto"/>  
```  
  
<a name="xamlValues_LineHeight"></a>   
## XAML 値  
 *double*  
 文字列表現、 <xref:System.Double> 値以上になる `0.0034` よりも等しいか小さいが、 `160000`です。 修飾されていない値は、デバイス非依存のピクセル単位で計測されます。 文字列が必要な小数点を明示的に含まれません。  
  
 *qualifiedDouble*  
 A *二重* 、前述の値 \(ドキュメントを除く `Auto`\) 後に、次の単位指定子の 1 つ: `px`, 、`in`, 、`cm`, 、`pt`です。  
  
 `px` \(既定値\) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px \= \=  
  
 `cm` センチメートルを表します。1cm\=\=\(96\/2.54\) px  
  
 `pt` ポイントです。1pt\=\=\(96\/72\) px  
  
 自動  
 原因は現在のフォント特性から行の高さが自動的に決定されます。  プロパティの値と等価 <xref:System.Double.NaN>します。  
  
<a name="dependencyPropertyInfo_LineHeight"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Documents.AnchoredBlock.LineHeightProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 次の例では、設定する方法、 <xref:System.Windows.Documents.AnchoredBlock.LineHeight%2A> の属性、 <xref:System.Windows.Documents.Block> 要素。  
  
 [!code-xml[BlockSnippets\#\_Block\_LineHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_lineheightxaml)]  
  
 次の図は、前の例をレンダリングする方法を示しています。  
  
 e530e9d3-8ec0-46eb-88c7-d0a0928bdf6f  
  
 既定の設定の例と同じをレンダリングする方法を次に示します <xref:System.Windows.Documents.AnchoredBlock.LineHeight%2A>\=<xref:System.Double.NaN>です。  
  
 313722fd-53a8-4011-937e-1f24aab57c86  
  
 次の例では、設定する方法、 <xref:System.Windows.Documents.AnchoredBlock.LineHeight%2A> プロパティ プログラムを使用しています。  
  
 [!code-csharp[BlockSnippets\#\_Block\_LineHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_lineheight)]
 [!code-vb[BlockSnippets\#\_Block\_LineHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_lineheight)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> を正でない値に設定しようとすると発生します。</exception>
      </Docs>
    </Member>
    <Member MemberName="LineHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.LineHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.AnchoredBlock.LineHeight" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategy">
      <MemberSignature Language="C#" Value="public System.Windows.LineStackingStrategy LineStackingStrategy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineStackingStrategy LineStackingStrategy" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.LineStackingStrategy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはテキスト要素内のテキストの行ごとに行ボックスを決定する際のメカニズムを設定します。</summary>
        <value>テキスト要素内のテキストの各行の行のボックスを決定する際メカニズム。 既定値は <see cref="F:System.Windows.LineStackingStrategy.MaxHeight" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="dependencyPropertyInfo_LineStackingStrategyProperty"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Documents.AnchoredBlock.LineStackingStrategyProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 次の例を使用する方法を示しています、 <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> テキスト行の行のボックスを作成する方法を決定するプロパティ、 <xref:System.Windows.Controls.TextBlock>です。 最初の <xref:System.Windows.Controls.TextBlock> が、 <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> の値 <xref:System.Windows.LineStackingStrategy.MaxHeight> 、2 番目 <xref:System.Windows.Controls.TextBlock> の値を持つ <xref:System.Windows.LineStackingStrategy.BlockLineHeight>です。  
  
 [!code-xml[FlowMiscSnippets\_snip\#LineStackingStrategyExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowMiscSnippets_snip/cs/linestackingstrategyexample.xaml#linestackingstrategyexamplewholepage)]  
  
 次の図は、上記のコードの結果を示しています。  
  
 a45cbc99-0776-48dc-82f0-05ebbb744b85  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineStackingStrategyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineStackingStrategyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.LineStackingStrategyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.AnchoredBlock.LineStackingStrategy" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の余白の厚みを取得または設定します。</summary>
        <value>適用する余白の量を指定する <see cref="T:System.Windows.Thickness" /> 構造体。デバイス非依存のピクセル単位で指定します。  
  
 既定値は 0 \(**0.0**\) の均一な厚みです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Documents.ListItem.Margin%2A> 要素のコンテンツ領域の端と親要素の端との間での要素のコンテンツ領域の外側まで広がるバッファー領域がいます。  比較して <xref:System.Windows.Documents.ListItem.Padding%2A>, 、要素のコンテンツと要素の内側の端の間での要素のコンテンツ領域内にあるバッファー領域があります。  
  
<a name="xamlAttributeUsage_Margin"></a>   
## XAML 属性の使用方法  
  
```  
<object Margin="uniformThickness"/>  
- or -  
<object Margin="independentThickness"/>  
- or -  
<object Margin="qualifiedUniformThickness"/>  
- or -  
<object Margin="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Margin"></a>   
## XAML 値  
 *uniformThickness*  
 1 つの文字列表現 <xref:System.Double> 4 つすべての厚みに一様に分布を適用する値。  たとえばの値 `"10"` はの値と同じ `"10,10,10,10"`します。  修飾されていない値は、デバイス非依存のピクセル単位で計測されます。 文字列が必要な小数点を明示的に含まれません。  
  
 *independentThickness*  
 順序付けになる 4 つの文字列表現 <xref:System.Double> 上、左の太さの独立したディメンションに対応する値が右、および、下には、次の順序で。  4 つの値をコンマで区切る必要があります。スペースは使用できません。  たとえば、「5,10,15,20」結果の余白の 5 ピクセル コンテンツ、コンテンツの上余白の 10 ピクセル、コンテンツの右側の余白 \(ピクセル\) を 15 およびコンテンツ下の余白 20 ピクセルの左側にします。  
  
 *qualifiedUniformThickness*  
 記述された値 *uniformThickness* 次の単位指定子のいずれかが続きます。 `px`, 、`in`です。  
  
 `px` \(既定値\) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px \= \=  
  
 たとえば、 `"1in"` すべての方向に 1 インチの統一された余白を提供します。  
  
 *qualifiedIndependentThickness*  
 記述された値 *independentThickness*, 、独立した各値は、次の単位指定子のいずれかが続きます。 `px`, 、`in`です。  
  
 `px` \(既定値\) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px \= \=  
  
 たとえば、`"1.5in,0.8in,1.5in,0.8in"` のようにします。  単位指定子は、混合または 1 つまたは複数の値からを省略すると場合があります。  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Documents.AnchoredBlock.MarginProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## 例  
 次の例では、設定する方法、 <xref:System.Windows.Documents.AnchoredBlock.Margin%2A> の属性、 <xref:System.Windows.Documents.Block> 要素 \(<xref:System.Windows.Documents.Paragraph>\)。  
  
 [!code-xml[BlockSnippets\#\_Block\_MarginPaddingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_marginpaddingxaml)]  
  
 次の図は、この例をレンダリングする方法を示しています。  誇張された太さや色は、図に使用されます。  
  
 23d0adec-0937-4a13-8b42-010952d28fa2  
  
 次の例では、設定する方法、 <xref:System.Windows.Documents.AnchoredBlock.Margin%2A> プロパティ プログラムを使用しています。  
  
 [!code-csharp[BlockSnippets\#\_Block\_MarginPadding](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_marginpadding)]
 [!code-vb[BlockSnippets\#\_Block\_MarginPadding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_marginpadding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.AnchoredBlock.Margin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のパディングの厚みを取得または設定します。</summary>
        <value>適用するパディングの量を指定する <see cref="T:System.Windows.Thickness" /> 構造体。デバイス非依存のピクセル単位で指定します。  
  
 既定値は 0 \(**0.0**\) の均一な厚みです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Documents.ListItem.Padding%2A> 要素のコンテンツと要素の内側の端の間での要素のコンテンツ領域の内側にあるバッファー領域がいます。  比較して <xref:System.Windows.Documents.ListItem.Margin%2A>, 、要素のコンテンツ領域の端と親要素の端との間での要素のコンテンツ領域の外側まで広がるバッファー領域があります。  
  
<a name="xamlAttributeUsage_Padding"></a>   
## XAML 属性の使用方法  
  
```  
<object Padding="uniformThickness"/>  
- or -  
<object Padding="independentThickness"/>  
- or -  
<object Padding="qualifiedUniformThickness"/>  
- or -  
<object Padding="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Padding"></a>   
## XAML 値  
 *uniformThickness*  
 1 つの文字列表現 <xref:System.Double> 4 つすべての厚みに一様に分布を適用する値。  たとえばの値 `"10"` はの値と同じ `"10,10,10,10"`します。  修飾されていない値は、デバイス非依存のピクセル単位で計測されます。 文字列が必要な小数点を明示的に含まれません。  
  
 *independentThickness*  
 順序付けになる 4 つの文字列表現 <xref:System.Double> 上、左の太さの独立したディメンションに対応する値が右、および、下には、次の順序で。  4 つの値をコンマで区切る必要があります。スペースは使用できません。  たとえば、「5,10,15,20」によって 5 ピクセルの余白のコンテンツ、コンテンツの上の余白が 10 ピクセル、右の余白の 15 のピクセルおよびコンテンツの下の余白の 20 ピクセルの左側です。  
  
 *qualifiedUniformThickness*  
 記述された値 *uniformThickness* 次の単位指定子のいずれかが続きます。 `px`, 、`in`です。  
  
 `px` \(既定値\) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px \= \=  
  
 たとえば、 `"1in"` すべての方向に 1 インチの統一されたパディングを提供します。  
  
 *qualifiedIndependentThickness*  
 記述された値 *independentThickness*, 、独立した各値は、次の単位指定子のいずれかが続きます。 `px`, 、`in`です。  
  
 `px` \(既定値\) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px \= \=  
  
 たとえば、`"1.5in,0.8in,1.5in,0.8in"` のようにします。  単位指定子は、混合または 1 つまたは複数の値からを省略すると場合があります。  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Documents.AnchoredBlock.PaddingProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## 例  
 次の例では、設定する方法、 <xref:System.Windows.Documents.AnchoredBlock.Padding%2A> の属性、 <xref:System.Windows.Documents.Block> 要素 \(<xref:System.Windows.Documents.Paragraph>\)。  
  
 [!code-xml[BlockSnippets\#\_Block\_MarginPaddingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_marginpaddingxaml)]  
  
 次の図は、この例をレンダリングする方法を示しています。  誇張された太さや色は、図に使用されます。  
  
 23d0adec-0937-4a13-8b42-010952d28fa2  
  
 次の例では、設定する方法、 <xref:System.Windows.Documents.AnchoredBlock.Padding%2A> プロパティ プログラムを使用しています。  
  
 [!code-csharp[BlockSnippets\#\_Block\_MarginPadding](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_marginpadding)]
 [!code-vb[BlockSnippets\#\_Block\_MarginPadding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_marginpadding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.PaddingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.AnchoredBlock.Padding" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeBlocks">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeBlocks (System.Windows.Markup.XamlDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeBlocks(class System.Windows.Markup.XamlDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.AnchoredBlock.ShouldSerializeBlocks(System.Windows.Markup.XamlDesignerSerializationManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.Windows.Markup.XamlDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">このオブジェクトのシリアル化サービス マネージャー オブジェクトです。</param>
        <summary>示す値を返すかどうかの有効な値、 <see cref="P:System.Windows.Documents.AnchoredBlock.Blocks" /> から派生するオブジェクトのシリアル化中にプロパティをシリアル化する <see cref="T:System.Windows.Documents.AnchoredBlock" />です。</summary>
        <returns>**true** 場合、 <see cref="P:System.Windows.Documents.AnchoredBlock.Blocks" /> シリアル化された以外の場合、プロパティを指定してください **false**します。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="manager" /> が **null** の場合に発生します。</exception>
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.TextAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テキスト コンテンツの水平方向の配置を示す値を取得または設定します。</summary>
        <value>メンバー、 <see cref="T:System.Windows.TextAlignment" /> 目的の配置を指定します。  
  
 既定値は <see cref="F:System.Windows.TextAlignment.Left" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Documents.AnchoredBlock.TextAlignmentProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 次の例では、設定する方法、 <xref:System.Windows.Documents.AnchoredBlock.TextAlignment%2A> の属性、 <xref:System.Windows.Documents.Block> 要素。  
  
 [!code-xml[BlockSnippets\#\_Block\_TextAlignmentXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_textalignmentxaml)]  
  
 前の例を表示する方法を次に示します **左** テキストの配置 \(既定値\)。  
  
 bfdea1ed-24e6-4686-b104-65547b2b692e  
  
 同じ例を表示する方法を次に示します **右** テキストの配置。  
  
 a786348b-6084-4bc3-808a-15c8479cee6f  
  
 同じ例を表示する方法を次に示します **Center** テキストの配置。  
  
 16731071-bd55-489e-9015-601fdffcde8c  
  
 次の例では、設定する方法、 <xref:System.Windows.Documents.AnchoredBlock.TextAlignment%2A> プロパティ プログラムを使用しています。  
  
 [!code-csharp[BlockSnippets\#\_Block\_TextAlignment](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_textalignment)]
 [!code-vb[BlockSnippets\#\_Block\_TextAlignment](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_textalignment)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.TextAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.AnchoredBlock.TextAlignment" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>