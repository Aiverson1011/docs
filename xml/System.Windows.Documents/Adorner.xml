<Type Name="Adorner" FullName="System.Windows.Documents.Adorner">
  <TypeSignature Language="C#" Value="public abstract class Adorner : System.Windows.FrameworkElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Adorner extends System.Windows.FrameworkElement" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.Adorner" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.Windows.UIElement" /> を装飾する <see cref="T:System.Windows.FrameworkElement" /> を表す抽象クラスです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 装飾は、カスタム <xref:System.Windows.FrameworkElement> にバインドされた、 <xref:System.Windows.UIElement>です。 装飾は装飾された要素または装飾対象の要素のコレクションの上には、常に、表示サーフェイス装飾レイヤーの描画します。装飾の表示がのレンダリングから独立して、 <xref:System.Windows.UIElement> に装飾をバインドします。 装飾は通常装飾する要素の左上に標準的な 2 次元座標系の原点にあるを使用して、バインドする要素に相対的な位置に配置します。  
  
> [!NOTE]
>  親、 <xref:System.Windows.Documents.Adorner> は、 <xref:System.Windows.Documents.AdornerLayer> 表示するための <xref:System.Windows.Documents.Adorner>, 、装飾される要素ではないです。  
  
> [!NOTE]
>  何も装飾レイヤーに配置を設定するスタイルの残りの部分の上にレンダリングされます。 つまり、装飾が視覚的に、一番上に常におよび、z オーダーではオーバーライドできません。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.AdornerDecorator" />
    <altmember cref="T:System.Windows.Documents.AdornerLayer" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Adorner (System.Windows.UIElement adornedElement);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Windows.UIElement adornedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Adorner.#ctor(System.Windows.UIElement)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="adornedElement" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="adornedElement">装飾をバインドする要素。</param>
        <summary>
          <see cref="T:System.Windows.Documents.Adorner" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 継承するクラスを実装するときに <xref:System.Windows.Documents.Adorner>, 、継承したクラスのコンス トラクターが基本クラス コンス トラクターを呼び出していることを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">*adornedElement* は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AdornedElement">
      <MemberSignature Language="C#" Value="public System.Windows.UIElement AdornedElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.UIElement AdornedElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Adorner.AdornedElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.UIElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Windows.UIElement" /> にこの装飾をバインドします。</summary>
        <value>このガイドにバインドされている要素です。 既定値は <see langword="null" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDesiredTransform">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Media.GeneralTransform GetDesiredTransform (System.Windows.Media.GeneralTransform transform);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Media.GeneralTransform GetDesiredTransform(class System.Windows.Media.GeneralTransform transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Adorner.GetDesiredTransform(System.Windows.Media.GeneralTransform)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transform" Type="System.Windows.Media.GeneralTransform" />
      </Parameters>
      <Docs>
        <param name="transform">装飾された要素に現在適用されている変換します。</param>
        <summary>返します。、 <see cref="T:System.Windows.Media.Transform" /> 装飾、装飾された要素に現在適用されている変換に基づきます。</summary>
        <returns>装飾に適用する変換です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 装飾は、修飾要素とは異なる変換する必要があります。 たとえばなど、ポイントと同様に動作する装飾サイズ変更ハンドルを必要がある変換および装飾される要素と一緒に回転させるが拡大縮小されません。 これに対し、スクロール文字を要素に表示されるガイドでは、装飾された要素と同じ変換が必要です。  
  
 このメソッドは、関連する <xref:System.Windows.Documents.AdornerLayer> をフィルター処理が不要なまたは変換が不要なを提供します。 このメソッドの実装は必要があります \(ある装飾対象の要素に対して変換\) 受信した変換を確認し、有用ではないか、装飾自体には適用しないとなる側面を削除します。 このメソッドは、装飾装飾される要素に相対的な位置を制御することができる翻訳を追加するこの時点でその他の変換の詳細を追加することもできます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Adorner.GetLayoutClip(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">要素によって提供される使用可能なサイズ。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)" />」を参照してください。</summary>
        <returns>潜在的なクリッピング ジオメトリ。 「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この実装は常に `null`します。  
  
 このメソッドは <xref:System.Windows.FrameworkElement.GetLayoutClip%2A>です。  
  
 ように、常に装飾は一番上にある場合を除き、クリッピングの制約は無視されます <xref:System.Windows.Documents.Adorner.IsClipEnabled%2A> は `true`です。 これにより、対象の要素の外接する四角形の外のレンダリングを装飾できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClipEnabled">
      <MemberSignature Language="C#" Value="public bool IsClipEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClipEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Adorner.IsClipEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または装飾のクリッピングが有効になっているかどうかを示す値を設定します。</summary>
        <value>A <see langword="Boolean" /> 装飾のクリッピングが有効になっているかどうかを示す値。  
  
 このプロパティが場合 <see langword="false" />, 、装飾はクリップされません。  
  
 場合は、このプロパティは <see langword="true" />, 、装飾された要素と同じクリッピング ジオメトリを使用して、ガイドが切り取られます。  
  
 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 装飾のクリッピングを有効にすると、大幅なパフォーマンス コストが発生します。 一般に、装飾のクリッピングを無効にする必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Adorner.MeasureOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">装飾を制限するためにサイズです。</param>
        <summary>装飾のカスタムの測定の動作を実装します。</summary>
        <returns>A <see cref="T:System.Windows.Size" /> 装飾によって必要なレイアウト領域の量を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、装飾の装飾された要素と一致するサイズです。  
  
 このメソッドは <xref:System.Windows.FrameworkElement.MeasureOverride%2A>です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      </Docs>
    </Member>
  </Members>
</Type>