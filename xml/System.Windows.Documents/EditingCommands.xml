<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>編集関連コマンドの標準セットを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表が、キーのジェスチャ編集コマンドと関連付けられている既定値を示します \(からキーの名前を持つ、 <xref:System.Windows.Input.Key> と <xref:System.Windows.Input.ModifierKeys> 列挙型\)。  
  
|編集コマンド|既定のキー ジェスチャ|  
|------------|-----------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`\+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`\+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`\+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`\+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|既定のキー ジェスチャはありません。|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`\+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`\+`Shift`\+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`\+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`\+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`\+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|既定のキー ジェスチャはありません。|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`\+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`\+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`\+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`\+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`\+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`\+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`\+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`\+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`\+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`\+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`\+`Shift`\+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`\+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`\+`Shift`\+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`\+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`\+`Shift`\+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`\+`Shift`\+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`\+`Shift`\+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`\+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`\+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`\+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`\+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`\+`Shift`\+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`\+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`\+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`\+`Shift`\+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`\+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`\+`Shift`\+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`\+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`\+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`\+`U`|  
  
 キャレットの移動コマンドとコマンドの展開の選択共有既定キー ジェスチャでは、一連の共通の追加に全般的な違い、 <xref:System.Windows.Input.ModifierKeys.Shift> キャレット移動コマンドと選択コマンドを区別するためのキー。  たとえば、 <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> コマンドの既定のキー ジェスチャには <xref:System.Windows.Input.Key.Left>, 、および対応する <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> コマンドの既定のキー ジェスチャには <xref:System.Windows.Input.ModifierKeys.Shift>\+<xref:System.Windows.Input.Key.Left>します。  
  
 によって一般に、コマンドの定義が提供される、 <xref:System.Windows.Documents.EditingCommands> クラスを行わないコマンドのパラメーターの使用 \(、 `parameter` で想定されているパラメーター、 <xref:System.Windows.Input.ICommand.Execute%2A> メソッド\)。  
  
 コマンドとコマンド処理の詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" /> コマンドを現在の段落または選択した段落の中央揃えにするよう要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="E" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、 <xref:System.Windows.Documents.Paragraph> レベルです。  \(キャレットが段落内にある空の選択範囲を含む\)、段落内のコンテンツの部分的な選択でこのコマンドが呼び出された場合、要求した効果は、段落全体に適用されます。  このコマンドが複数の段落にわたる選択時に呼び出される場合、効果は、選択範囲に含まれる各段落の内容全体に適用されます。  
  
 次の図では、中央揃えのコンテンツの例です。  
  
 16731071-bd55-489e-9015-601fdffcde8c  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## XAML 属性の使用方法  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" /> コマンドで、現在の段落または段落の選択範囲を正当化を要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="J" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、 <xref:System.Windows.Documents.Paragraph> レベルです。  \(キャレットが段落内にある空の選択範囲を含む\)、段落内のコンテンツの部分的な選択でこのコマンドが呼び出された場合、要求した効果は、段落全体に適用されます。  このコマンドが複数の段落にわたる選択時に呼び出される場合、選択範囲内のすべての段落に効果が適用されます。  
  
 コンテンツを正当な根拠のある行が同じかまたは等しい近くの幅になるようコンテンツの各行内の左右の間隔が調整されます。  コンテンツのコンテンツ辺の縁を滑らかを作成する通常位置揃え。  
  
 残りの部分よりも短いは多くの場合であるため、段落の最後の行が引き続き両端このコマンドが呼び出された後。  
  
 次の図は、両端の \(左揃え\) の内容を示しています。  
  
 bfb3913b-3765-48ea-b0bc-4d0f1768c4e3  
  
 次の図は、両端揃えが後に、同じコンテンツを示します。  
  
 50242a36-b363-4971-95f0-13158dc5a4cc  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## XAML 属性の使用方法  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" /> コマンドで、コンテンツの選択範囲が左側に配置することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="L" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、 <xref:System.Windows.Documents.Paragraph> レベルです。  \(キャレットが段落内にある空の選択範囲を含む\)、段落内のコンテンツの部分的な選択でこのコマンドが呼び出された場合、要求した効果は、段落全体に適用されます。  このコマンドが複数の段落にわたる選択時に呼び出される場合、効果は、選択範囲に含まれる各段落の内容全体に適用されます。  
  
 次の図では、左揃えの内容の例です。  
  
 bfdea1ed-24e6-4686-b104-65547b2b692e  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## XAML 属性の使用方法  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" /> コマンドで、コンテンツの選択範囲が右揃えすることを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="R" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、 <xref:System.Windows.Documents.Paragraph> レベルです。  \(キャレットが段落内にある空の選択範囲を含む\)、段落内のコンテンツの部分的な選択でこのコマンドが呼び出された場合、要求した効果は、段落全体に適用されます。  このコマンドが複数の段落にわたる選択時に呼び出される場合、効果は、選択範囲に含まれる各段落の内容全体に適用されます。  
  
 次の図では、右揃えの例を示しています。  
  
 a786348b-6084-4bc3-808a-15c8479cee6f  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## XAML 属性の使用方法  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.Backspace" /> コマンドは、backspace キーが現在位置にある、または現在の選択範囲を入力することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Backspace" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 空の選択時に呼び出されたときに、このコマンドは、キャレットの直前に、文字または段落区切り記号を削除します。 空でない選択時に呼び出されたときに、このコマンドは、選択範囲を削除します。  
  
 このコマンドは、このコマンドが呼び出された直後に、同じ位置に挿入されたコンテンツの削除された選択範囲の書式設定を保持します。  比較して、 <xref:System.Windows.Documents.EditingCommands.Delete%2A> コマンドで、以前の書式設定は保持されません。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## XAML 属性の使用方法  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" /> コマンドで、現在の位置では、スペルミスを修正することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドには、既定のキー ジェスチャはありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## XAML 属性の使用方法  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" /> コマンドで、現在の選択範囲のフォント サイズを 1 ポイントが減少していることを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="OemOpenBrackets" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャレットが単語内にある空の選択範囲に対してこのコマンドが呼び出される場合は、単語全体にコマンドを適用する選択範囲が自動的に展開します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## XAML 属性の使用方法  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" /> コマンドを 1 つのタブ ストップが現在の段落を下げるをそのインデントを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Shift" />\+<see langword="T" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
> [!IMPORTANT]
>  このコマンドも何も起こりませんテキスト要素にしない限り、 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> にテキスト要素のプロパティが設定されている `true`します。  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## XAML 属性の使用方法  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.Delete" /> コマンドで、現在の選択項目を削除するように要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Delete" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、削除された選択範囲の書式設定を破棄します。  比較して、 <xref:System.Windows.Documents.EditingCommands.Backspace%2A> コマンドでは、このコマンドが呼び出された直後に、同じ位置に挿入されたコンテンツの削除された選択範囲の書式設定を保持します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_Delete"></a>   
## XAML 属性の使用方法  
  
```  
<object property="Delete"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" /> コマンドで、\(現在の位置\) を基準とは、次の単語を削除するように要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Delete" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャレットが単語内にある場合は、現在の位置と、単語の末尾の間の残りの部分は削除されます。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## XAML 属性の使用方法  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" /> コマンドで、\(現在の位置\) を基準と前の単語を削除するように要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Backspace" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャレットが単語内にある場合は、現在の位置と、単語の先頭の間の残りの部分は削除されます。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## XAML 属性の使用方法  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" /> コマンドで、現在位置にある、または現在の選択範囲に改行を挿入することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Shift" />\+<see langword="Enter" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フロー コンテンツをサポートするエディターの <xref:System.Windows.Controls.RichTextBox>, 、このコマンドの原因、 <xref:System.Windows.Documents.LineBreak> に現在の位置に挿入される要素。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>です。  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## XAML 属性の使用方法  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" /> コマンドで、現在位置にある、または現在の選択範囲に段落改行を挿入することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Enter" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、ユーザーが ENTER キーを押すことに相当します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox> \(ときに、 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> プロパティは `true`\)。  
  
> [!IMPORTANT]
>  このコマンドも何も起こりませんテキスト要素にしない限り、 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> にテキスト要素のプロパティが設定されている `true`します。  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## XAML 属性の使用方法  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" /> コマンドで、現在位置にある、または現在の選択で、スペル ミスの語句のすべてのインスタンスを無視することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドには、既定のキー ジェスチャはありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## XAML 属性の使用方法  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" /> 1 ポイントして、現在の選択範囲のフォント サイズを増加することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="OemCloseBrackets" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャレットが単語内にある空の選択範囲に対してこのコマンドが呼び出される場合、選択範囲を拡張して、単語全体にコマンドを適用します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## XAML 属性の使用方法  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" /> コマンドを 1 つのタブ ストップを現在の段落を引き上げるをそのインデントを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="T" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
> [!IMPORTANT]
>  このコマンドも何も起こりませんテキスト要素にしない限り、 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> にテキスト要素のプロパティが設定されている `true`します。  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## XAML 属性の使用方法  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" /> 要求キャレットを 1 行下に移動します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Down" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>です。  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" /> 要求キャレットを 1 ページ下に移動します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="PageDown" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>です。  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" /> 要求キャレット 1 つの段落をに移動します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Down" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、次の段落の先頭のキャレットを配置します。  
  
 このコマンドは、のように動作 <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> で呼び出されると、 <xref:System.Windows.Controls.TextBox>です。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>です。  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" /> コマンドを 1 つの文字がカレットに左に移動するよう要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Left" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" /> 要求キャレットが 1 つの単語を左に移動します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Left" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャレットが単語内にある場合は、このコマンドは、その単語の先頭にキャレットを移動します。  それ以外の場合、このコマンドは、カレットを前の単語の先頭に移動します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" /> コマンドを 1 つの文字がカレットに右に移動するよう要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Right" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" /> よう要求するキャレットを 1 つの単語を右に移動します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Right" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャレットが単語内にある場合は、このコマンドは、その単語の末尾にキャレットを移動します。  それ以外の場合、このコマンドは、次の単語の先頭にキャレットを移動します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" /> コマンドで、要求コンテンツの末尾にキャレットを移動します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="End" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A *テキスト コンテナー* は最終的なコンテンツの境界を形成する要素。<xref:System.Windows.Controls.TextBlock><xref:System.Windows.Documents.FlowDocument> テキスト コンテナーの例を示します。  テキスト コンテナーにまとめて格納されたコンテンツと呼ばれます、 *ドキュメント*します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" /> コマンドは、コンテンツの先頭に移動するよう要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Home" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A *テキスト コンテナー* は最終的なコンテンツの境界を形成する要素。<xref:System.Windows.Controls.TextBlock><xref:System.Windows.Documents.FlowDocument> テキスト コンテナーの例を示します。  テキスト コンテナーにまとめて格納されたコンテンツと呼ばれます、 *ドキュメント*します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" /> コマンド、現在の行の末尾に移動するよう要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="End" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" /> カレットを現在の行の先頭に進むことを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Home" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" /> 要求キャレットを 1 行上に移動します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Up" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>です。  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" /> 要求キャレットを 1 ページ上に移動します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="PageUp" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>です。  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" /> 要求キャレットを 1 段落上に移動します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Up" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、次の段落の先頭のキャレットを配置します。  
  
 このコマンドは、のように動作 <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> で呼び出されると、 <xref:System.Windows.Controls.TextBox>です。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>です。  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## XAML 属性の使用方法  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" /> コマンドで、1 行ずつ下、現在の選択に拡張することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Shift" />\+<see langword="Down" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" /> を 1 ページ下、現在の選択に拡張することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Shift" />\+<see langword="PageDown" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" /> コマンドで、要求を 1 つの段落を現在の選択項目を展開します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Shift" />\+<see langword="Down" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、次の段落の先頭に、選択範囲を展開します。  それ以外の場合、このコマンドは、現在の段落の末尾に、選択範囲を展開します。  拡張された選択範囲には、段落の末尾を示す段落改行が含まれています。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" /> コマンドで、現在の選択が 1 つの文字によって左展開できることを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Shift" />\+<see langword="Left" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" /> コマンドで、現在の選択範囲が 1 つの単語によって左展開できることを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Shift" />\+<see langword="Left" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャレットが単語内にある場合は、このコマンドは、選択範囲をその単語の先頭まで拡張します。  それ以外の場合、このコマンドは、前の単語の先頭に、選択範囲を展開します。  
  
 拡張された選択範囲には、単語区切り記号は含まれません。  比較して <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, 、拡張された選択範囲に単語の区切り記号は含まれています。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" /> コマンドで、要求する現在の選択範囲を 1 文字右です。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Shift" />\+<see langword="Right" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" /> コマンドで、1 つの単語を現在の選択項目を展開することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Shift" />\+<see langword="Right" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャレットが単語内にある場合は、このコマンドは、選択範囲をその単語の末尾まで拡張します。  それ以外の場合、このコマンドは、次の単語の末尾に、選択範囲を展開します。  
  
 拡張された選択範囲には、単語区切り記号が含まれています。  比較して <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> 単語の区切り記号拡張された選択範囲に含まれません。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" /> コマンドで、コンテンツの末尾に現在の選択項目を展開することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Shift" />\+<see langword="End" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A *テキスト コンテナー* は最終的なコンテンツの境界を形成する要素。<xref:System.Windows.Controls.TextBlock><xref:System.Windows.Documents.FlowDocument> テキスト コンテナーの例を示します。  テキスト コンテナーにまとめて格納されたコンテンツと呼ばれます、 *ドキュメント*します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" /> コマンド、現在の選択項目を展開するコンテンツの先頭とするよう要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Shift" />\+<see langword="Home" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A *テキスト コンテナー* は最終的なコンテンツの境界を形成する要素。<xref:System.Windows.Controls.TextBlock><xref:System.Windows.Documents.FlowDocument> テキスト コンテナーの例を示します。  テキスト コンテナーにまとめて格納されたコンテンツと呼ばれます、 *ドキュメント*します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" /> コマンドで、現在の行の末尾に現在の選択項目を展開することを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Shift" />\+<see langword="End" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" /> コマンド、現在の行の先頭に現在の選択項目を展開するよう要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Shift" />\+<see langword="Home" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" /> コマンドで、要求を 1 行を現在の選択項目を展開します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Shift" />\+<see langword="Up" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" /> コマンドで、要求を 1 ページずつ場合は、現在の選択項目を展開します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Shift" />\+<see langword="PageUp" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" /> コマンドで、要求を 1 つの段落を現在の選択項目を展開します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Shift" />\+<see langword="Up" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャレットが段落の先頭にある場合は、このコマンドは、選択範囲を前の段落の先頭まで拡張します。  それ以外の場合、このコマンドは、現在の段落の先頭に、選択範囲を展開します。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## XAML 属性の使用方法  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Shift" />\+<see langword="Tab" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドの動作は、現在の選択によって異なります。 選択範囲が空でない場合は、このコマンドは <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>です。 キャレットが表のセル内にある場合 \(によって表される、 <xref:System.Windows.Documents.TableCell> 要素\)、このコマンドは、前のセルにキャレットを移動します。 それ以外の場合、現在の位置にタブ文字が挿入されます。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox> \(ときに、 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> プロパティは `true`\)。  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## XAML 属性の使用方法  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
			Dim rTB As New RichTextBox()  
  
			EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.EditingCommands.TabForward" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Tab" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドの動作は、現在の選択によって異なります。 選択範囲が空でないかどうか、または項目し、現在のキャレット位置が、段落の先頭に、このコマンドは <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>です。 キャレットが表のセル内にある場合 \(によって表される、 <xref:System.Windows.Documents.TableCell> 要素\)、このコマンドは、次のセルにキャレットを移動します。 キャレットは、テーブルの最後のセルには、このコマンドは、新しい行の最初のセルに配置され、テーブルに追加される新しい行を実行します。  それ以外の場合、現在の位置にタブ文字が挿入されます。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox> \(ときに、 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> プロパティは `true`\)。  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## XAML 属性の使用方法  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
			Dim rTB As New RichTextBox()  
  
			EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" /> からの要求のコマンド <see cref="T:System.Windows.Documents.Bold" /> 書式設定を現在の選択に切り替えます。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="B" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Windows.FontWeight> の範囲内での現在の選択は <xref:System.Windows.FontWeights.Thin%2A> に <xref:System.Windows.FontWeights.SemiBold%2A>, 、<xref:System.Windows.FontWeights.Bold%2A> は現在の選択項目に適用します。  それ以外の場合、 <xref:System.Windows.FontWeights.Normal%2A> を適用します。  比較の一覧については <xref:System.Windows.FontWeight> の値を参照してください <xref:System.Windows.FontWeights>します。  
  
 選択されていませんし、単語内にあるが、カレット、単語全体を含める選択範囲が拡張されます。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## XAML 属性の使用方法  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" /> コマンドで、現在の選択項目 \(箇条書きリストとも呼ばれる\) 記号付きリストが書式設定を切り替えることを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Shift" />\+<see langword="L" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、 <xref:System.Windows.Documents.Paragraph> レベルです。  \(キャレットが段落内にある空の選択範囲を含む\)、段落内のコンテンツの部分的な選択でこのコマンドが呼び出された場合、要求した効果は、段落全体に適用されます。  このコマンドが複数の段落にわたる選択時に呼び出される場合、効果は、選択範囲に含まれる各段落の内容全体に適用されます。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## XAML 属性の使用方法  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" /> コマンドで、挿入と上書き入力モードを切り替えます。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Insert" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>, 、<xref:System.Windows.Controls.TextBox>, 、および <xref:System.Windows.Controls.PasswordBox>です。  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## XAML 属性の使用方法  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" /> からの要求のコマンド <see cref="T:System.Windows.Documents.Italic" /> 書式設定を現在の選択に切り替えます。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="I" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Windows.FontStyle> 現在の選択範囲の <xref:System.Windows.FontStyles.Normal%2A>, 、<xref:System.Windows.FontStyles.Italic%2A> は現在の選択項目に適用します。  それ以外の場合、 <xref:System.Windows.FontStyles.Normal%2A> を適用します。  
  
 選択されていませんし、単語内にあるが、カレット、単語全体を含める選択範囲が拡張されます。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## XAML 属性の使用方法  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" /> コマンドで、現在の選択項目の順序付きのリスト \(番号付きリストとも呼ばれる\) の書式設定を切り替えることを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Shift" />\+<see langword="N" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコマンドは、 <xref:System.Windows.Documents.Paragraph> レベルです。  \(キャレットが段落内にある空の選択範囲を含む\)、段落内のコンテンツの部分的な選択でこのコマンドが呼び出された場合、要求した効果は、段落全体に適用されます。  このコマンドが複数の段落にわたる選択時に呼び出される場合、効果は、選択範囲に含まれる各段落の内容全体に適用されます。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## XAML 属性の使用方法  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" /> コマンドで、現在の選択に添字の書式設定を切り替えることを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="OemPlus" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## XAML 属性の使用方法  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" /> コマンドで、現在の選択項目で上付き文字の書式を切り替えることを要求します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="Shift" />\+<see langword="OemPlus" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## XAML 属性の使用方法  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す、 <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" /> からの要求のコマンド <see cref="T:System.Windows.Documents.Underline" /> 書式設定を現在の選択に切り替えます。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは <see langword="Ctrl" />\+<see langword="U" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 選択されていませんし、単語内にあるが、カレット、単語全体を含める選択範囲が拡張されます。  
  
 必ずしもすべての指定したオブジェクトでは、このコマンドに応答する実際の実装多くの場合は、コマンドに対応する実装は、アプリケーションの作成者の役割です。  
  
 このコマンドが本来サポートして <xref:System.Windows.Controls.RichTextBox>します。  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## XAML 属性の使用方法  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## 例  
 次の例では、コマンドをサポートするオブジェクトの編集のコマンドを呼び出す方法を示します。  
  
 この例で、 <xref:System.Windows.Controls.RichTextBox> コマンドの対象として機能します。  注意 <xref:System.Windows.Controls.RichTextBox> を実装して、 <xref:System.Windows.IInputElement> インターフェイス \(から継承された <xref:System.Windows.FrameworkElement>\)、編集コマンドの多くのネイティブ サポートが含まれているとします。  
  
 最初の引数、 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドは、コマンド パラメーター。  ほとんどの編集コマンド、コマンド パラメーターを無視します。一般に、このパラメーターは必ず `null` コマンドを編集するためです。  
  
 2 番目の引数は、コマンドをルーティングするオブジェクトを指定します。  このオブジェクトを実装する必要があります、 <xref:System.Windows.IInputElement> インターフェイス、および指定されたコマンドのハンドラーを含める必要があります。  一般に、コマンドには、コマンドを処理しないオブジェクトに対して呼び出されたときに無視されます。  
  
 [!code-csharp[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets\#\_EditingCommands\_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>