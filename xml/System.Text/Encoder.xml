<Type Name="Encoder" FullName="System.Text.Encoder">
  <TypeSignature Language="C#" Value="public abstract class Encoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoder" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>文字のセットをバイトのシーケンスに変換します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 To obtain an instance of an implementation of the <xref:System.Text.Encoder> class, the application should use the <xref:System.Text.Encoding.GetEncoder%2A> method of an <xref:System.Text.Encoding> implementation.  
  
 The <xref:System.Text.Encoder.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoder.GetBytes%2A> method performs the actual encoding. There are several versions of both of these methods available in the <xref:System.Text.Encoder> class. For more information, see <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName>.  
  
 A <xref:System.Text.Encoder> object maintains state information between successive calls to **languageKeyword tag is not supported!!!!**  
 or <xref:System.Text.Decoder.Convert%2A> methods so that it can correctly encode character sequences that span blocks. The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block. Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.  
  
> [!NOTE]
>  When the application is done with a stream of data it should make sure that the state information is flushed by setting the **parameterReference tag is not supported!!!!**  
>  parameter to **languageKeyword tag is not supported!!!!**  
>  in the appropriate method call. If an exception occurs or if the application switches streams, it should call <xref:System.Text.Encoder.Reset%2A> to clear the internal state of the **languageKeyword tag is not supported!!!!**  
>  object.  
  
## Version Considerations  
 A <xref:System.Text.Decoder> or <xref:System.Text.Encoder> object can be serialized during a conversion operation. The state of the object is retained if it is deserialized in the same version of the .NET Framework, but lost if it is deserialized in another version.  
  
   
  
## 例  
 The following example demonstrates how to convert an array of Unicode characters into blocks of bytes using a specified encoding. For comparison, the array of characters is first encoded using <xref:System.Text.UTF7Encoding>. Next, the array of characters is encoded using an <xref:System.Text.Encoder>.  
  
 [!code-cpp[System.Text.Encoder Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.Encoder Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.Encoder Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder Example/VB/snippet.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>When your application inherits from this class, it must override all the members.</para>
    </block>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoding" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Text.Encoder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 To obtain an instance of an implementation of this class, the application should use the <xref:System.Text.Encoding.GetEncoder%2A> method of an <xref:System.Text.Encoding> implementation.  
  
   
  
## 例  
 The following example demonstrates two techniques for initializing a new <xref:System.Text.Encoder> instance.  
  
 [!code-cpp[System.Text.Encoder.ctor Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Encoder.ctor Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Encoder.ctor Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char* chars, int charCount, byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush, int32 charsUsed, int32 bytesUsed, bool completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">UTF\-16 でエンコードされた変換対象の文字の文字列のアドレス。</param>
        <param name="charCount">変換する <c>chars</c> 内の文字の数。</param>
        <param name="bytes">変換後のバイトを格納するバッファーのアドレス。</param>
        <param name="byteCount">変換に使用する <c>bytes</c> 内の最大バイト数。</param>
        <param name="flush">これ以上データの変換を行わないことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="charsUsed">このメソッドから制御が戻るときに、<c>chars</c> で変換に使用された文字数を格納します。 このパラメーターは初期化せずに渡されます。</param>
        <param name="bytesUsed">このメソッドから制御が戻るときに、変換に使用されたバイト数を格納します。 このパラメーターは初期化せずに渡されます。</param>
        <param name="completed">このメソッドから制御が戻るときに、<c>charCount</c> で指定したすべての文字が変換された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このパラメーターは初期化せずに渡されます。</param>
        <summary>バッファーに格納されている Unicode 文字をエンコード済みバイト シーケンスに変換し、その結果を別のバッファーに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 注意して、<xref:System.Text.Encoder>オブジェクトへの呼び出しの間で状態を保存する<xref:System.Text.Encoder.Convert%2A>です。 設定の必要があるアプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`状態情報がフラッシュされるかどうかを確認します。 この設定では、エンコーダーはデータ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。 サロゲート ペアの上位サロゲートなどの論理ユニットの一部である残り処理後のデータは、現在のフォールバック設定に従って変換されます。  
  
 `Convert`メソッドが任意の量の入力のエンコードにはループ内で使用するように設計ファイルまたはストリームから読み取られるデータなどです。 エンコード操作の出力は、固定サイズのバッファーに格納します。<xref:System.Text.Encoder.GetBytes%2A>出力バッファーが十分でない場合、例外がスローされますが、<xref:System.Text.Encoder.Convert%2A>は、できるだけ多くの領域を入力し、読み取りと書き込みバイト数の文字を返します。 参照してください、<xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName>詳細コメントのトピックです。  
  
 `completed`出力パラメーターは、入力バッファー内のすべてのデータが変換され、出力バッファーに格納されているかどうかを示します。 このパラメーターに設定されている`false`で文字の数が指定されている場合、`charCount`パラメーターによって指定されたバイト数を超えずに変換できません、`byteCount`パラメーター。 状況では、アプリケーション、出力バッファーの内容を使用してか、新しい出力バッファーを提供インクリメント、`chars`パラメーターで指定された文字の数によって、`charsUsed`パラメーターを呼び出して、`Convert`残りの入力を処理するには、もう一度メソッドです。  
  
 `completed`パラメーターを設定することも`false`場合でも、`charsUsed`と`charCount`パラメーターが等しい。 内のデータが解決しない場合、このような状況が発生した、<xref:System.Text.Encoder>内に保存されていないオブジェクト、`chars`バッファー。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> または <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">出力バッファーが小さすぎて、変換した入力を格納できません。 出力バッファーは、<see cref="Overload:System.Text.Encoder.GetByteCount" /> メソッドで示されるサイズ以上である必要があります。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(完全な説明については、「[.NET Framework における文字エンコーディング](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altCompliant cref="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, int32 byteCount, bool flush, int32 charsUsed, int32 bytesUsed, bool completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">変換する文字の配列。</param>
        <param name="charIndex">変換する <c>chars</c> の最初の要素。</param>
        <param name="charCount">変換する <c>chars</c> の要素の数。</param>
        <param name="bytes">変換後のバイトを格納する配列。</param>
        <param name="byteIndex">データを格納する <c>bytes</c> の最初の要素。</param>
        <param name="byteCount">変換に使用する <c>bytes</c> 内の最大要素数。</param>
        <param name="flush">これ以上データの変換を行わないことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="charsUsed">このメソッドから制御が戻るときに、<c>chars</c> で変換に使用された文字数を格納します。 このパラメーターは初期化せずに渡されます。</param>
        <param name="bytesUsed">このメソッドから制御が戻るときに、変換の結果生成されたバイト数を格納します。 このパラメーターは初期化せずに渡されます。</param>
        <param name="completed">このメソッドから制御が戻るときに、<c>charCount</c> で指定したすべての文字が変換された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このパラメーターは初期化せずに渡されます。</param>
        <summary>Unicode 文字の配列をエンコード済みバイト シーケンスに変換し、その結果をバイト配列に格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 注意して、[Convert メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder>オブジェクトへの呼び出しの間で状態を保存する[Convert メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.Convert%2A>です。 設定の必要があるアプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`状態情報がフラッシュされるかどうかを確認します。 この設定では、エンコーダーは、データ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。 サロゲート ペアの上位サロゲートなどの論理ユニットの一部である残り処理後のデータは、現在のフォールバック設定に従って変換されます。  
  
 `Convert`メソッドが、入力の任意の大きさをデコードするループ内で使用するため、ファイルまたはストリームから読み取られるデータなどです。 エンコード操作の出力は、固定サイズのバッファーに格納します。[Convert メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.GetBytes%2A>出力バッファーが十分でない場合、例外がスローされますが、[Convert メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.Convert%2A>は、できるだけ多くの領域を入力し、読み取りと書き込みバイト数の文字を返します。 参照してください、[Convert メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName>詳細コメントのトピックです。  
  
 `completed`出力パラメーターは、入力バッファー内のすべてのデータが変換され、出力バッファーに格納されているかどうかを示します。 このパラメーターに設定されている`false`で文字の数が指定されている場合、`charCount`パラメーターによって指定されたバイト数を超えずに変換できません、`byteCount`パラメーター。 状況では、アプリケーション、出力バッファーの内容を使用か、新しい出力バッファーを提供インクリメント、`chars`パラメーターで指定された文字の数によって、 `charsUsed` 、パラメーターを呼び出す、`Convert`残りの入力を処理するには、もう一度メソッドです。  
  
 `completed`パラメーターを設定することも`false`場合でも、`charsUsed`と`charCount`パラメーターが等しい。 内のデータが解決しない場合、このような状況が発生した、[Convert メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder>内に保存されていないオブジェクト、`chars`バッファー。  
  
   
  
## 例  
 次の例では、 [Convert メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.Convert%2A> utf\-16 のファイルに変換するメソッドが、utf\-8 文字列の文字を使用して、 [Convert メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Decoder.Convert%2A> utf\-8 文字を utf\-16 文字に変換します。  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> または <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />、<paramref name="charCount" />、<paramref name="byteIndex" />、または <paramref name="byteCount" /> が 0 未満です。  
  
 または  
  
 <paramref name="chars" /> の長さから <paramref name="charIndex" /> を引いた長さが <paramref name="charCount" /> 未満です。  
  
 または  
  
 <paramref name="bytes" /> の長さから <paramref name="byteIndex" /> を引いた長さが <paramref name="byteCount" /> 未満です。</exception>
        <exception cref="T:System.ArgumentException">出力バッファーが小さすぎて、変換した入力を格納できません。 出力バッファーは、<see cref="Overload:System.Text.Encoder.GetByteCount" /> メソッドで示されるサイズ以上である必要があります。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(完全な説明については、「[.NET Framework における文字エンコーディング](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.Fallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 <see cref="T:System.Text.EncoderFallback" /> 現在のオブジェクト <see cref="T:System.Text.Encoder" /> オブジェクトです。</summary>
        <value>
          <see cref="T:System.Text.EncoderFallback" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.EncoderFallback> オブジェクトは、文字をエンコード済みバイト シーケンスに変換できないときに呼び出されるエラー ハンドラーを表します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">設定操作の値は <see langword="null " />\(<see langword="Nothing" />\)。</exception>
        <exception cref="T:System.ArgumentException">設定操作で新しい値を割り当てることができません現在 <see cref="T:System.Text.EncoderFallbackBuffer" /> オブジェクトには、まだエンコードされていないデータが含まれています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(完全な説明については、「[.NET Framework における文字エンコーディング](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.FallbackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Text.EncoderFallbackBuffer" /> オブジェクトに現在関連付けられている <see cref="T:System.Text.Encoder" /> オブジェクトです。</summary>
        <value>
          <see cref="T:System.Text.EncoderFallbackBuffer" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Encoder.FallbackBuffer%2A> オブジェクトによって使用されるデータを表す、 <xref:System.Text.EncoderFallback> オブジェクトです。<xref:System.Text.EncoderFallback> オブジェクトは、文字をエンコード済みバイト シーケンスに変換できないときに呼び出されるエラー ハンドラーを表します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="count">エンコードする文字数。</param>
        <param name="flush">
          <see langword="true" /> 計算の後に、エンコーダーの内部状態をクリアするをシミュレートするにはそれ以外の場合、 <see langword="false" />です。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字ポインターから始まる文字のセットをエンコードすることによって生成されるバイト数を計算します。 パラメーターでは、計算後に、エンコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns>指定した文字と内部バッファー内のすべての文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、エンコーダーの状態には影響しません。  
  
 計算する正確な配列のサイズを <xref:System.Text.Encoder.GetBytes%2A> 必要と結果のバイトを格納するアプリケーションを使用する必要があります <xref:System.Text.Encoder.GetByteCount%2A>します。  
  
 場合 `GetBytes` で呼び出された `flush` 設定 `false`, 、エンコーダーは、データ ブロックの最後に末尾の文字を内部バッファーに格納しの次のエンコード操作に使用します。 アプリケーションを呼び出す必要があります `GetByteCount` 呼び出す前にすぐにデータのブロックに `GetBytes` 同じブロックのため、前のブロックから文字の後続のすべてが含まれることの計算にします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> <see langword="null" /> \(<see langword="Nothing" /> Visual Basic .NET で\)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(完全な説明については、「[.NET Framework における文字エンコーディング](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <param name="flush">
          <see langword="true" /> 計算の後に、エンコーダーの内部状態をクリアするをシミュレートするにはそれ以外の場合、 <see langword="false" />です。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットをエンコードすることによって生成されるバイト数を計算します。 パラメーターでは、計算後に、エンコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns>指定した文字と内部バッファー内のすべての文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、エンコーダーの状態には影響しません。  
  
 計算する正確な配列のサイズを [GetByteCount メソッド \(Char\<xref:System.Text.Encoder.GetBytes%2A> 必要と結果のバイトを格納するアプリケーションを使用する必要があります [GetByteCount メソッド \(Char\<xref:System.Text.Encoder.GetByteCount%2A>します。  
  
 場合 `GetBytes` で呼び出された `flush` 設定 `false`, 、エンコーダーは、データ ブロックの最後に末尾の文字を内部バッファーに格納しの次のエンコード操作に使用します。 アプリケーションを呼び出す必要があります `GetByteCount` 呼び出す前にすぐにデータのブロックに `GetBytes` 同じブロックのため、前のブロックから文字の後続のすべてが含まれることの計算にします。  
  
   
  
## 例  
 次のコード例では、使用して、 [GetByteCount メソッド \(Char\<xref:System.Text.Encoder.GetByteCount%2A> 、Unicode を使用して文字の配列をエンコードするために必要なバイト数を返すメソッドを [GetByteCount メソッド \(Char\<xref:System.Text.Encoder>します。  
  
 [!code-cpp[System.Text.Encoder.GetByteCount Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetByteCount Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetByteCount Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(完全な説明については、「[.NET Framework における文字エンコーディング](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスの書き込みを開始する位置へのポインター。</param>
        <param name="byteCount">書き込む最大バイト数。</param>
        <param name="flush">
          <see langword="true" /> 変換後に、エンコーダーの内部状態をクリアするにはそれ以外の場合、 <see langword="false" />です。</param>
        <summary>派生クラスでオーバーライドされた場合は、指定したバイト ポインターで始まる格納されるバイトのシーケンスに指定した文字ポインターと、内部バッファー内のすべての文字で始まる文字のセットをエンコードします。 パラメーターでは、変換した後に、エンコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns>
          <paramref name="bytes" /> パラメーターによって示される位置に書き込む実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 注意して、 <xref:System.Text.Encoder> オブジェクトへの呼び出しの間で状態を保存する <xref:System.Text.Encoder.GetBytes%2A>です。 設定の必要があるアプリケーションでは、データ ストリームの処理が終わったら、 `flush` パラメーターを `true` 最後の呼び出しで `GetBytes` 状態情報がフラッシュされ、エンコード済みバイトが正しく終了しているかどうかを確認します。 この設定では、エンコーダーは、比類のないサロゲートまたは不完全な組み合わせシーケンスなどのデータ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。  
  
 計算する正確なバッファーのサイズを `GetBytes` 必要と結果の文字を格納するアプリケーションを使用する必要があります <xref:System.Text.Encoder.GetByteCount%2A>します。  
  
 場合 `GetBytes` で呼び出された `flush` 設定 `false`, 、エンコーダーはデータ ブロックの末尾にある後続バイトを内部のバッファーに格納し、次のエンコード処理に使用します。 アプリケーションを呼び出す必要があります `GetByteCount` 呼び出す前にすぐにデータのブロックに `GetBytes` 同じブロックのため、前のブロックから文字の後続のすべてが含まれることの計算にします。  
  
 入力ストリームの数のセグメントに変換する、アプリケーションがある場合は、使用を検討して、 <xref:System.Text.Encoder.Convert%2A> メソッドです。<xref:System.Text.Encoder.GetBytes%2A> 出力バッファーが十分でない場合、例外がスローされますが、 <xref:System.Text.Encoder.Convert%2A> はできるだけ多くの領域を入力し、読み取りおよび書き込みバイト数に、文字を返します。 参照してください、 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> 他のコメントのトピックです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> が <see langword="null " />\(<see langword="Nothing" />\) です。  
  
 または  
  
 <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> 結果のバイト数より少ない。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(完全な説明については、「[.NET Framework における文字エンコーディング](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <param name="flush">
          <see langword="true" /> 変換後に、エンコーダーの内部状態をクリアするにはそれ以外の場合、 <see langword="false" />です。</param>
        <summary>派生クラスでオーバーライドされた場合は、指定したバイト配列に指定した文字配列から文字と内部のバッファーに含まれる文字のセットをエンコードします。 パラメーターでは、変換した後に、エンコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns>
          <paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 注意して、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder> オブジェクトへの呼び出しの間で状態を保存する [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.GetBytes%2A>です。 設定の必要があるアプリケーションでは、データ ストリームの処理が終わったら、 `flush` パラメーターを `true` 最後の呼び出しで `GetBytes` 状態情報がフラッシュされ、エンコード済みバイトが正しく終了しているかどうかを確認します。 この設定では、エンコーダーは、比類のないサロゲートまたは不完全な組み合わせシーケンスなどのデータ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。  
  
 計算する正確なバッファーのサイズを `GetBytes` 必要と結果の文字を格納するアプリケーションを使用する必要があります [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.GetByteCount%2A>します。  
  
 場合 `GetBytes` で呼び出された `flush` 設定 `false`, 、エンコーダーはデータ ブロックの末尾にある後続バイトを内部のバッファーに格納し、次のエンコード処理に使用します。 アプリケーションを呼び出す必要があります `GetByteCount` 呼び出す前にすぐにデータのブロックに `GetBytes` 同じブロックのため、前のブロックから文字の後続のすべてが含まれることの計算にします。  
  
 入力ストリームの数のセグメントに変換する、アプリケーションがある場合は、使用を検討して、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.Convert%2A> メソッドです。[GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.GetBytes%2A> 出力バッファーが十分でない場合、例外がスローされますが、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.Convert%2A> はできるだけ多くの領域を入力し、読み取りおよび書き込みバイト数に、文字を返します。 参照してください、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> 他のコメントのトピックです。  
  
   
  
## 例  
 次の例では、一連の文字配列から要素をエンコードおよびバイト配列の要素の範囲内でエンコードされたバイトを格納する方法を示します。[GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.GetByteCount%2A> メソッドを使用して必要な配列のサイズを判断を [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.GetBytes%2A>します。  
  
 [!code-cpp[System.Text.Encoder.GetBytes Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetBytes Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetBytes Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> が <see langword="null " />\(<see langword="Nothing" />\) です。  
  
 または  
  
 <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> または <paramref name="charCount" /> または <paramref name="byteIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
 または  
  
 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> 十分な容量がない <paramref name="byteIndex" /> に結果のバイトを合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(完全な説明については、「[.NET Framework における文字エンコーディング](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoder.Fallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合は、その初期状態に戻す、エンコーダーを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの内部状態をクリアする、 <xref:System.Text.Encoder> オブジェクトです。 メソッドを前回呼び出したときから保持状態情報をクリアする <xref:System.Text.Encoder.GetBytes%2A> または <xref:System.Text.Decoder.Convert%2A>, など、後続の上位サロゲートなど、前のデータ ブロックの末尾にある文字。  
  
 アプリケーションを呼び出す必要があります、 `Reset` メソッドによって例外がスローされた後でも同じエンコーダーを再利用する必要がある場合 <xref:System.Text.Encoder.GetBytes%2A> または <xref:System.Text.Encoder.GetByteCount%2A>, 、またはアプリケーションがストリームを切り替えた場合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、文字のセットをバイト シーケンスにエンコードします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バッファーまたは Unicode 文字の配列をエンコード済みバイト シーケンスに変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>