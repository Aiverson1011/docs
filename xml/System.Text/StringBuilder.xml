<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>可変型の文字列を表します。 このクラスは継承できません。  
  
 この型の .NET Framework ソース コードを参照するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/text/stringbuilder.cs#adf60ee46ebd299f)します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを参照してください、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/text/stringbuilder.cs#adf60ee46ebd299f)します。 ソース コードをオンラインで参照、オフライン表示のリファレンスをダウンロードおよびデバッグ中にソース \(パッチや更新を含む\) をステップsee [instructions](http://referencesource.microsoft.com/).  
  
 このクラスは、値が変更可能な一連の文字の文字列のようなオブジェクトを表します。  
  
 このセクションの内容:  
  
-   [文字列と StringBuilder の種類](#StringAndSB)  
  
-   [StringBuilder のしくみ](#HowWorks)  
  
-   [メモリの割り当て](#Memory)  
  
-   [StringBuilder オブジェクトをインスタンス化します。](#Instantiating)  
  
-   [StringBuilder メソッドを呼び出す](#Calling)  
  
-   [StringBuilder の操作を実行します。](#Operations)  
  
    -   [StringBuilder の文字を反復処理します。](#Iterating)  
  
    -   [StringBuilder オブジェクトにテキストを追加します。](#Adding)  
  
    -   [StringBuilder オブジェクトからテキストを削除します。](#Deleting)  
  
    -   [StringBuilder オブジェクトの文字列を変更します。](#Modifying)  
  
-   [StringBuilder オブジェクトのテキストを検索](#Searching)  
  
-   [StringBuilder オブジェクトを文字列に変換します。](#Converting)  
  
<a name="StringAndSB"></a>   
## 文字列と StringBuilder の種類  
 <xref:System.Text.StringBuilder> と <xref:System.String> シーケンスを表す両方の文字の実装は異なります。<xref:System.String> 変更できない型です。 変更が、各操作は、 <xref:System.String> オブジェクトが実際に新しい文字列を作成します。  
  
 たとえばを呼び出して、 <xref:System.String.Concat%2A?displayProperty=fullName> という名前の文字列変数の値を変更する次の c\# の例ではメソッドが表示されます `value`します。 実際には、 <xref:System.String.Concat%2A> メソッドが返される、 `value` 別の値とからアドレスを持つオブジェクト、 `value` メソッドに渡されたオブジェクト。 使用する例をコンパイルする必要があることに注意してください、 `/unsafe` コンパイラ オプション。  
  
 [!code-csharp[System.Text.StringBuilder.Class\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 \(何回もループ内で文字列を変更してアプリ\) などの広範な文字列操作を行うルーチンでは、文字列を繰り返し変更が、大幅なパフォーマンスの低下に正確なことができます。 使用する方法、 <xref:System.Text.StringBuilder>, 、変更可能な文字列のクラスであります。 変更可能性は、クラスのインスタンスが作成されたら、変更できることを追加、削除、置換、または文字を挿入することを意味します。 A <xref:System.Text.StringBuilder> オブジェクトは、文字列の拡張に対応するためのバッファーを保持します。 ルームがある場合にバッファーに新しいデータが追加されます。それ以外の場合より大きなバッファーが割り当てられている、元のバッファーからのデータは新しいバッファーにコピーし、新しいデータは、新しいバッファーに追加されます。  
  
> [!IMPORTANT]
>  ですが、 <xref:System.Text.StringBuilder> クラスが通常よりも優れたパフォーマンスを提供、 <xref:System.String> クラスを自動的には交換できません <xref:System.String> と <xref:System.Text.StringBuilder> 文字列操作に必要な場合にします。 パフォーマンスは、新しい文字列、アプリが実行されて、システムおよび操作の種類に割り当てられるメモリの量、文字列のサイズによって異なります。 決定するアプリをテストする準備をしておく必要があるかどうか <xref:System.Text.StringBuilder> 実際に大幅なパフォーマンス向上を提供します。  
  
 使用を検討して、 <xref:System.String> ような状況クラス。  
  
-   文字列にアプリケーションが加えた変更の数が小さい場合です。 このような場合は、 <xref:System.Text.StringBuilder> がごくわずかのプランまたは経由でパフォーマンスが向上しない <xref:System.String>します。  
  
-   ときに特にと文字列リテラルの連結操作の数を実行します。 この場合、コンパイラは、1 回の操作を連結演算を組み合わせることがあります。  
  
-   ある場合、文字列を構築しているときに、包括的な検索操作を実行します。<xref:System.Text.StringBuilder> クラスが不足しているメソッドのなど、検索 `IndexOf` または `StartsWith`です。 変換する必要があります、 <xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> を使用してパフォーマンス上の利点を無効にでき、これらの操作の <xref:System.Text.StringBuilder>です。 詳細については、次を参照してください。、 [StringBuilder オブジェクトのテキストを検索](#Searching) セクションです。  
  
 使用を検討して、 <xref:System.Text.StringBuilder> ような状況クラス。  
  
-   文字列に \(たとえば、ユーザー入力を格納する文字列のランダムな数値を連結するループを使用している場合\) のデザイン時に、不明な数の変更を加えるにアプリを予期したタイミングです。  
  
-   文字列に多数の変更を加えるにアプリを予期したタイミングです。  
  
<a name="HowWorks"></a>   
## StringBuilder のしくみ  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=fullName> プロパティは、文字数を示す、 <xref:System.Text.StringBuilder> オブジェクトが現在含まれています。 対象の文字を追加する場合、 <xref:System.Text.StringBuilder> オブジェクト、その長さのサイズと等しいしない限り増加する、 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=fullName> オブジェクトに格納できる文字数を定義するプロパティです。 追加された文字数の長さが発生した場合、 <xref:System.Text.StringBuilder> をその現在の容量、新しいメモリを超えるオブジェクトは、割り当て済みの値、 <xref:System.Text.StringBuilder.Capacity%2A> プロパティが倍になり、新しい文字に追加され、 <xref:System.Text.StringBuilder> オブジェクト、およびその <xref:System.Text.StringBuilder.Length%2A> プロパティを調整します。 追加のメモリを <xref:System.Text.StringBuilder> によって定義された値に達するまででオブジェクトを動的に割り当て、 <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=fullName> プロパティです。 最大容量に達すると、さらにメモリに割り当て可能なし、 <xref:System.Text.StringBuilder> オブジェクト、および文字を追加または最大の容量以上に拡張しようとしています。 をスローするか、 <xref:System.ArgumentOutOfRangeException> または <xref:System.OutOfMemoryException> 例外です。  
  
 次の例に示す方法、 <xref:System.Text.StringBuilder> オブジェクトが新しいメモリを割り当て、オブジェクトに割り当てられた文字列の拡張に伴い、その容量を動的に大きくなります。 します。 このコードを作成、 <xref:System.Text.StringBuilder> 既定 \(パラメーターなし\) コンス トラクターを呼び出すことによってオブジェクトです。 このオブジェクトの既定の容量は 16 文字で、容量が最大 20億を超える文字です。 「文はこの」文字列を追加 文字列の長さ \(19 文字\) は、既定の容量を超えているため、新しいメモリ割り当ての結果、 <xref:System.Text.StringBuilder> オブジェクトです。 オブジェクトの容量を 32 文字以内に 2 倍に、新しい文字列が追加され、オブジェクトの長さとに 19 文字を同じにするようになりました。 コード、文字列を追加「これは、追加の文です」です。 値に、 <xref:System.Text.StringBuilder> 11 回のオブジェクトします。 追加操作の長さが発生するたびに、 <xref:System.Text.StringBuilder> をその容量は、既存の容量を超えるオブジェクトが 2 倍になり、 <xref:System.Text.StringBuilder.Append%2A> 操作が成功しました。  
  
 [!code-csharp[System.Text.StringBuilder.Class\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## メモリの割り当て  
 既定の容量、 <xref:System.Text.StringBuilder> オブジェクトが 16 文字とその既定の最大容量は <xref:System.Int32.MaxValue?displayProperty=fullName>です。 呼び出した場合、これらの既定値が使用される、 <xref:System.Text.StringBuilder.%23ctor> と <xref:System.Text.StringBuilder.%23ctor%28System.String%29> コンス トラクターです。  
  
 初期容量を明示的に定義することができます、 <xref:System.Text.StringBuilder> 次の方法でオブジェクト。  
  
-   いずれかを呼び出すことによって、 <xref:System.Text.StringBuilder> を含むコンス トラクター、 `capacity` パラメーターは、オブジェクトを作成する場合。  
  
-   明示的に新しい値を割り当てることによって、 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=fullName> プロパティを既存の展開 <xref:System.Text.StringBuilder> オブジェクトです。 プロパティが、新しい領域が、既存の容量またはより大きいより小さい場合に、例外をスローする、 <xref:System.Text.StringBuilder> オブジェクトの最大容量です。  
  
-   呼び出して、 <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=fullName> 新しい容量を持つメソッドです。 新しい容量をより大きくなければなりません、 <xref:System.Text.StringBuilder> オブジェクトの最大容量です。 代入とは異なり、 <xref:System.Text.StringBuilder.Capacity%2A> プロパティには、 <xref:System.Text.StringBuilder.EnsureCapacity%2A> 、例外をスローしない場合は、目的の新しい容量は、既存の容量より小さい。 この場合、メソッドの呼び出しは無効です。  
  
 文字列の長さが割り当てられている場合、 <xref:System.Text.StringBuilder> コンス トラクターの呼び出し内のオブジェクトは、既定の量、または指定した容量を超えています。、 <xref:System.Text.StringBuilder.Capacity%2A> プロパティで指定した文字列の長さに設定されて、 `value` パラメーター。  
  
 最大容量を明示的に定義することができます、 <xref:System.Text.StringBuilder> オブジェクトを呼び出して、 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> コンス トラクターです。 新しい値を割り当てることによって最大容量を変更することはできません、 <xref:System.Text.StringBuilder.MaxCapacity%2A> プロパティには、読み取り専用であるためです。  
  
 前のセクションに示すように、既存の容量が不十分な追加のメモリが割り当てられているとの容量、 <xref:System.Text.StringBuilder> オブジェクトの倍精度小数点数で定義された値になるまで、 <xref:System.Text.StringBuilder.MaxCapacity%2A> プロパティです。  
  
 一般に、既定の量と最大容量が、ほとんどのアプリケーションに適してします。 次の条件下でこれらの値の設定を考慮することがあります。  
  
-   場合の最終的なサイズ、 <xref:System.Text.StringBuilder> オブジェクトは通常数メガ バイトを超える非常に大きくなる可能性があります。 ここである可能性がありますから、最初の設定のパフォーマンスが向上 <xref:System.Text.StringBuilder.Capacity%2A> プロパティを大幅に高の値が多すぎるのメモリ再割り当てが不要にします。  
  
-   場合は、アプリが制限されたメモリを搭載しています。 ことを検討が必要な場合は、 <xref:System.Text.StringBuilder.MaxCapacity%2A> プロパティをより小さい <xref:System.Int32.MaxValue?displayProperty=fullName> 場合は、アプリケーションが、メモリの制約がある環境で実行する可能性のある長い文字列を処理します。  
  
<a name="Instantiating"></a>   
## StringBuilder オブジェクトをインスタンス化します。  
 インスタンス化する、 <xref:System.Text.StringBuilder> その 6 つクラスをオーバー ロードされたコンス トラクターの次の表に示されているいずれかを呼び出してオブジェクトです。 コンス トラクターの 3 つのインスタンスを作成、 <xref:System.Text.StringBuilder> した空の文字列の値をオブジェクトに設定がその <xref:System.Text.StringBuilder.Capacity%2A> と <xref:System.Text.StringBuilder.MaxCapacity%2A> が異なる値します。 残りの 3 つのコンス トラクターを定義、 <xref:System.Text.StringBuilder> 特定の文字列値と容量を持つオブジェクト。 既定の最大容量を使用して 3 つのコンス トラクターの 2 つ <xref:System.Int32.MaxValue?displayProperty=fullName>, 、3 つ目では、最大容量を設定することができます。  
  
|コンストラクター|文字列値|キャパシティ|最大容量|  
|--------------|----------|------------|----------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=fullName>|16|<xref:System.Int32.MaxValue?displayProperty=fullName>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=fullName>|定義される、 `capacity` パラメーター|<xref:System.Int32.MaxValue?displayProperty=fullName>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=fullName>|定義される、 `capacity` パラメーター|定義される、 `maxCapacity` パラメーター|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|定義される、 `value` パラメーター|16 または `value`です。<xref:System.String.Length%2A>, 、大きい方|<xref:System.Int32.MaxValue?displayProperty=fullName>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|定義される、 `value` パラメーター|定義される、 `capacity` パラメーターまたは `value`です。<xref:System.String.Length%2A>, 、大きい方します。|<xref:System.Int32.MaxValue?displayProperty=fullName>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|定義される `value`します。<xref:System.String.Substring%2A>\(`startIndex`, `length`\)|定義される、 `capacity` パラメーターまたは `value`です。<xref:System.String.Length%2A>, 、大きい方します。|定義される、 `maxCapacity` パラメーター|  
  
 次の例がこれらのコンス トラクター オーバー ロードのうち 3 つのインスタンスを作成するには <xref:System.Text.StringBuilder> オブジェクトです。  
  
 [!code-csharp[System.Text.StringBuilder.Class\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## StringBuilder メソッドを呼び出す  
 内の文字列を変更するメソッドのほとんどを <xref:System.Text.StringBuilder> インスタンスが同じインスタンスへの参照を返します。 これによりを呼び出すか <xref:System.Text.StringBuilder> 方法は 2 つのメソッド。  
  
-   個々 のメソッドを呼び出すことし、次の例では、戻り値を無視することができます。  
  
     [!code-csharp[System.Text.StringBuilder.Class\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   単一のステートメントでは、一連のメソッド呼び出しを行うことができます。 連続した操作が関連付けられている 1 つのステートメントを記述する場合に便利なことができます。 次の例では、次の 3 つのメソッド呼び出し、前の例を 1 行のコードに統合します。  
  
     [!code-csharp[System.Text.StringBuilder.Class\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## StringBuilder の操作を実行します。  
 メソッドを使用する、 <xref:System.Text.StringBuilder> 反復処理する、追加、削除、または文字を変更するクラス、 <xref:System.Text.StringBuilder> オブジェクトです。  
  
<a name="Iterating"></a>   
### StringBuilder の文字を反復処理します。  
 内の文字にアクセスすることができます、 <xref:System.Text.StringBuilder> オブジェクトを使用して、 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=fullName> プロパティです。 C\# の場合、 <xref:System.Text.StringBuilder.Chars%2A> インデクサー; は、Visual basic での既定のプロパティでは、 <xref:System.Text.StringBuilder> クラスです。 これにより、設定するか明示的に参照しなくても、インデックスのみを使用して、個々 の文字を取得する、 <xref:System.Text.StringBuilder.Chars%2A> プロパティです。 内の文字、 <xref:System.Text.StringBuilder> オブジェクトのインデックスは 0 \(ゼロ\) から始まり、インデックスを引き続き <xref:System.Text.StringBuilder.Length%2A> \- 1 です。  
  
 次の例を示しています、 <xref:System.Text.StringBuilder.Chars%2A> プロパティです。 10 個のランダムな数字を追加、 <xref:System.Text.StringBuilder> オブジェクト、および各文字を反復処理し、します。 文字の Unicode カテゴリの場合 <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=fullName>, 、1 で数を減らすこと \(またはその値が 0 の場合、番号は 9 に変更\)。 この例の内容を表示する、 <xref:System.Text.StringBuilder> 前に、と個々 の文字の値が変更された後にオブジェクトの両方です。  
  
 [!code-csharp[System.Text.StringBuilder.Class\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  
  
<a name="Adding"></a>   
### StringBuilder オブジェクトにテキストを追加します。  
 <xref:System.Text.StringBuilder> クラスには内容を展開するには、以下の方法が含まれています、 <xref:System.Text.StringBuilder> オブジェクト。  
  
-   <xref:System.Text.StringBuilder.Append%2A> メソッドを追加する文字配列の一部、文字列、部分文字列、文字配列、一文字複数回繰り返す、またはプリミティブ データの文字列形式を入力、 <xref:System.Text.StringBuilder> オブジェクトです。  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A> メソッドには、行終端記号またはに沿ってに行終端記号の文字列が追加され、 <xref:System.Text.StringBuilder> オブジェクトです。  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを追加に、 <xref:System.Text.StringBuilder> オブジェクトです。 結果の文字列に含まれるオブジェクトの文字列形式には、現在のシステムのカルチャまたは指定されたカルチャの書式指定規則を反映できます。  
  
-   <xref:System.Text.StringBuilder.Insert%2A> メソッドを挿入、文字列、部分文字列を複数回繰り返される、文字列の指定した位置にある文字の配列は、文字配列の一部またはプリミティブ データの文字列形式を入力、 <xref:System.Text.StringBuilder> オブジェクトです。 位置は、0 から始まるインデックスによって定義されます。  
  
 次の例では、 <xref:System.Text.StringBuilder.Append%2A>, 、<xref:System.Text.StringBuilder.AppendLine%2A>, 、<xref:System.Text.StringBuilder.AppendFormat%2A>, 、および <xref:System.Text.StringBuilder.Insert%2A> のテキストを展開する方法、 <xref:System.Text.StringBuilder> オブジェクトです。  
  
 [!code-csharp[System.Text.StringBuilder.Class\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### StringBuilder オブジェクトからテキストを削除します。  
 <xref:System.Text.StringBuilder> クラスには、現在のサイズを削減できるメソッドが含まれています <xref:System.Text.StringBuilder> インスタンス。<xref:System.Text.StringBuilder.Clear%2A> メソッドは、すべての文字を削除し、設定、 <xref:System.Text.StringBuilder.Length%2A> プロパティを 0 にします。<xref:System.Text.StringBuilder.Remove%2A> メソッドは、特定のインデックス位置から始まる文字の指定した数を削除します。 末尾から文字を削除するさらに、 <xref:System.Text.StringBuilder> オブジェクトを設定してその <xref:System.Text.StringBuilder.Length%2A> プロパティを現在のインスタンスの長さより小さい値にします。  
  
 次の例では、削除からテキストの一部、 <xref:System.Text.StringBuilder> オブジェクト、その結果として得られる容量、最大容量は、および長さのプロパティの値を表示しを呼び出します、 <xref:System.Text.StringBuilder.Clear%2A> からすべての文字を削除する方法、 <xref:System.Text.StringBuilder> オブジェクトです。  
  
 [!code-csharp[System.Text.StringBuilder.Class\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### StringBuilder オブジェクトの文字列を変更します。  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=fullName> メソッド、一文字または文字列全体で出現するすべての置換 <xref:System.Text.StringBuilder> オブジェクトまたは特定の文字範囲内です。 次の例では、 <xref:System.Text.StringBuilder.Replace%2A> に疑問符 \(?\) のすべての感嘆符 \(\!\) するメソッド、 <xref:System.Text.StringBuilder> オブジェクトです。  
  
 [!code-csharp[System.Text.StringBuilder.Class\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## StringBuilder オブジェクトのテキストを検索  
 <xref:System.Text.StringBuilder> クラスでは、ようなメソッドは含まれません、 <xref:System.String.Contains%2A?displayProperty=fullName>, 、<xref:System.String.IndexOf%2A?displayProperty=fullName>, 、および <xref:System.String.StartsWith%2A?displayProperty=fullName> によって提供されるメソッド、 <xref:System.String> クラスは、特定の文字または部分文字列のオブジェクトを検索できます。 存在することを決定または部分文字列の文字位置を開始は、検索することが必要です、 <xref:System.String> 文字列検索メソッドまたは正規表現メソッドを使用して値。 このような検索は、次の表に示すように実装する 4 つの方法があります。  
  
|手法|プロフェッショナル|短所|  
|--------|---------------|--------|  
|追加する前に文字列値を検索、 <xref:System.Text.StringBuilder> オブジェクトです。|部分文字列が存在するかどうかを確認するのに役立ちます。|部分文字列のインデックス位置が重要である場合は使用できません。|  
|呼び出す <xref:System.Text.StringBuilder.ToString%2A> および返された検索 <xref:System.String> オブジェクトです。|簡単に使用するすべてのテキストを割り当てる場合、 <xref:System.Text.StringBuilder> オブジェクト、および変更を開始します。|繰り返し呼び出す扱いにくい <xref:System.Text.StringBuilder.ToString%2A> かどうかは、変更をすべてのテキストが追加される前に、 <xref:System.Text.StringBuilder> オブジェクトです。<br /><br /> 最後から作業することを忘れないでください、 <xref:System.Text.StringBuilder> 変更を加える場合、オブジェクトのテキスト。|  
|使用して、 <xref:System.Text.StringBuilder.Chars%2A> 文字の範囲を順番に検索するプロパティです。|個々 の文字または小さな部分に問題がある場合に役立ちます。|検索する文字数が多い場合、または検索ロジックが複雑な場合は煩雑です。|  
|変換、 <xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> に変更を行い、オブジェクトを <xref:System.String> オブジェクトです。|変更の数が少ない場合に役立ちます。|パフォーマンス上の利点を否定、 <xref:System.Text.StringBuilder> クラスの変更の数が大きい場合。|  
  
 これらの手法をさらに詳しく見ていきましょう。  
  
-   検索の目的に保存する前に文字列を検索することができます \(つまり、部分文字列の位置に興味がない\) 場合に特定の部分文字列が存在するかどうかを決定する場合、 <xref:System.Text.StringBuilder> オブジェクトです。 次の例では、1 つとして考えられる実装を提供します。 定義、 `StringBuilderFinder` クラスのコンス トラクターがへの参照を渡し、 <xref:System.Text.StringBuilder> オブジェクトと、文字列内で検索するサブスト リングします。 例が記録された温度が華氏または摂氏がありの先頭に適切な説明テキストを追加するかどうかを判断しようとした場合は、 <xref:System.Text.StringBuilder> オブジェクトです。 乱数ジェネレーターを使用して、摂氏または華氏のいずれかでデータを格納する配列を選択します。  
  
     [!code-csharp[System.Text.StringBuilder.Class\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   呼び出す、 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=fullName> に変換する方法、 <xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> オブジェクトです。 などのメソッドを使用して、文字列を検索する <xref:System.String.LastIndexOf%2A?displayProperty=fullName> または <xref:System.String.StartsWith%2A?displayProperty=fullName>, 、正規表現を使用することも、 <xref:System.Text.RegularExpressions.Regex> パターンを検索するクラス。 両方 <xref:System.Text.StringBuilder> と <xref:System.String> オブジェクトは、utf\-16 文字の部分文字列の文字のインデックス位置を格納するエンコーディングを使用して、正規表現の一致は、両方のオブジェクトで同じです。 これによりを使用して <xref:System.Text.StringBuilder> でそのテキストを検出する位置の同じ位置にある変更を加える方法、 <xref:System.String> オブジェクトです。  
  
    > [!NOTE]
    >  このアプローチを採用している場合は、最後から作業する必要があります、 <xref:System.Text.StringBuilder> オブジェクトを繰り返しに変換する必要があるないように、その開始するとき、 <xref:System.Text.StringBuilder> オブジェクトを文字列。  
  
     このアプローチの例を次に示します。 英語のアルファベットの各文字の 4 つのオカレンスを格納、 <xref:System.Text.StringBuilder> オブジェクトです。 テキストを次に、変換、 <xref:System.String> オブジェクトごとの 4 文字のシーケンスの開始位置を識別するために、正規表現を使用しています。 最後に、最初のシーケンスを除く各 4 文字のシーケンスの前にアンダー スコアを追加し、大文字に、シーケンスの最初の文字に変換します。  
  
     [!code-csharp[System.Text.StringBuilder.Class\#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class\#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   使用して、 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=fullName> 内の文字の範囲を順番に検索するプロパティ、 <xref:System.Text.StringBuilder> オブジェクトです。 この方法は、検索する文字数が多いか、検索ロジックが特に複雑な場合は、実用的なできません。  
  
     次の例では、前の例と同じ機能ですが、実装が異なります。 使用して、 <xref:System.Text.StringBuilder.Chars%2A> 文字の値が変更されたときを検出するためにプロパティが、その位置にアンダー スコアを挿入して、新しいシーケンスの最初の文字を大文字に変換します。  
  
     [!code-csharp[System.Text.StringBuilder.Class\#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class\#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   内のすべての変更されていないテキストを格納、 <xref:System.Text.StringBuilder> オブジェクトを呼び出す、 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=fullName> に変換する方法、 <xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> に変更を行い、オブジェクトを <xref:System.String> オブジェクトです。 いくつか変更にのみがある場合は、この方法を使用することができます。それ以外の場合、変更できない文字列を操作のコストを使用するパフォーマンスの利点をなくなる場合があります、 <xref:System.Text.StringBuilder> オブジェクトです。  
  
     次の例では、前の 2 つの例と同じ機能ですが、実装が異なります。 作成、 <xref:System.Text.StringBuilder> オブジェクトに変換する、 <xref:System.String> オブジェクト、および正規表現を使用して、文字列の残りのすべての変更を実行します。<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=fullName> メソッドでは、ラムダ式を使用して、一致した各文字列の置換を実行します。  
  
     [!code-csharp[System.Text.StringBuilder.Class\#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class\#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## StringBuilder オブジェクトを文字列に変換します。  
 変換する必要があります、 <xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> オブジェクトで表される文字列を渡す前に、 <xref:System.Text.StringBuilder> オブジェクトを持つメソッドを <xref:System.String> パラメーターまたはユーザー インターフェイスで表示します。 呼び出してこの変換を実行する、 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=fullName> メソッドです。 例については、呼び出しの前の例を参照してください、 <xref:System.Text.StringBuilder.ToString%2A> に変換する方法、 <xref:System.Text.StringBuilder> 文字列オブジェクトの正規表現メソッドに渡すことができるようにします。  
  
   
  
## 例  
 次の例で定義されたメソッドの多くを呼び出す方法を示しています、 <xref:System.Text.StringBuilder> クラスです。  
  
 [!code-cpp[StringBuilder\#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder\#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このインスタンスの文字列値に設定 <xref:System.String.Empty?displayProperty=fullName>, 、容量が、既定の実装に固有の量に設定されているとします。  
  
   
  
## 例  
 次の例では、呼び出し、 <xref:System.Text.StringBuilder.%23ctor%2A> パラメーターなしのコンス トラクターです。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">このインスタンスの推奨される開始サイズ。</param>
        <summary>指定した容量を使用して、<see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `capacity` パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる文字の最大数を定義します。 その値は、 <xref:System.Text.StringBuilder.Capacity%2A> プロパティです。 現在のインスタンスに格納される文字数に、これを超えたかどうか `capacity` 値、 <xref:System.Text.StringBuilder> オブジェクトはそれらを格納する追加のメモリを割り当てます。  
  
 このインスタンスの文字列値の設定 <xref:System.String.Empty?displayProperty=fullName>します。 場合 `capacity` 0 の場合は、実装固有の既定の容量が使用されます。  
  
   
  
## 例  
 次の例では、呼び出し、 <xref:System.Text.StringBuilder.%23ctor%2A> 容量を指定してコンス トラクターです。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">インスタンスの値を初期化するために使用される文字列。<c>value</c> が <see langword="null" /> の場合、新しい <see cref="T:System.Text.StringBuilder" /> は空の文字列、つまり、<see cref="F:System.String.Empty" /> を含みます。</param>
        <summary>指定した文字列を使用して、<see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `value` が `null` の場合、新しい <xref:System.Text.StringBuilder> は空の文字列、つまり、<xref:System.String.Empty> を含みます。  
  
   
  
## 例  
 次の例では、呼び出し、 <xref:System.Text.StringBuilder.%23ctor%2A> 、指定した文字列を持つコンス トラクターです。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" /> の推奨される開始サイズ。</param>
        <param name="maxCapacity">現在の文字列が含むことができる最大文字数。</param>
        <summary>指定した容量で始まり、指定した最大容量まで大きくなる <see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `capacity` パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる文字の最大数を定義します。 その値は、 <xref:System.Text.StringBuilder.Capacity%2A> プロパティです。 現在のインスタンスに格納される文字数に、これを超えたかどうか `capacity` 値、 <xref:System.Text.StringBuilder> オブジェクトはそれらを格納する追加のメモリを割り当てます。  
  
 場合 `capacity` 0 の場合は、実装固有の既定の容量が使用されます。  
  
 `maxCapacity` プロパティは、現在のインスタンスが保持できる文字の最大数を定義します。 その値は、 <xref:System.Text.StringBuilder.MaxCapacity%2A> プロパティです。 現在のインスタンスに格納される文字数に、これを超えたかどうか `maxCapacity` 値、 <xref:System.Text.StringBuilder> オブジェクトは、追加のメモリを割り当てられませんが、代わりに、例外をスローします。  
  
   
  
## 例  
 次の例では、呼び出し、 <xref:System.Text.StringBuilder.%23ctor%2A> 容量を指定し、最大容量を持つコンス トラクターです。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> が 1 未満か、<paramref name="capacity" /> が 0 未満か、<paramref name="capacity" /> が <paramref name="maxCapacity" /> より大きいです。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">インスタンスの値を初期化するために使用される文字列。<c>value</c> が <see langword="null" /> の場合、新しい <see cref="T:System.Text.StringBuilder" /> は空の文字列、つまり、<see cref="F:System.String.Empty" /> を含みます。</param>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" /> の推奨される開始サイズ。</param>
        <summary>指定した文字列および容量を使用して、<see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `capacity` パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる文字の最大数を定義します。 その値は、 <xref:System.Text.StringBuilder.Capacity%2A> プロパティです。 現在のインスタンスに格納される文字数に、これを超えたかどうか `capacity` 値、 <xref:System.Text.StringBuilder> オブジェクトはそれらを格納する追加のメモリを割り当てます。  
  
 場合 `capacity` 0 の場合は、実装固有の既定の容量が使用されます。  
  
   
  
## 例  
 次の例では、呼び出し、 <xref:System.Text.StringBuilder.%23ctor%2A> コンス トラクターの既定の文字列と容量を指定します。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors\#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの値を初期化するために使用される部分文字列を含む文字列。<c>value</c> が <see langword="null" /> の場合、新しい <see cref="T:System.Text.StringBuilder" /> は空の文字列、つまり、<see cref="F:System.String.Empty" /> を含みます。</param>
        <param name="startIndex">
          <c>value</c> における部分文字列の開始位置。</param>
        <param name="length">部分文字列の文字数。</param>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" /> の推奨される開始サイズ。</param>
        <summary>指定した部分文字列および容量から <see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `capacity` パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる文字の最大数を定義します。 その値は、 <xref:System.Text.StringBuilder.Capacity%2A> プロパティです。 現在のインスタンスに格納される文字数に、これを超えたかどうか `capacity` 値、 <xref:System.Text.StringBuilder> オブジェクトはそれらを格納する追加のメモリを割り当てます。  
  
 場合 `capacity` 0 の場合は、実装固有の既定の容量が使用されます。  
  
   
  
## 例  
 次の例では、呼び出し、 <xref:System.Text.StringBuilder.%23ctor%2A> 、指定した文字列を持つコンス トラクターです。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors\#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> に <paramref name="length" /> を加算した値が <paramref name="value" /> 内の位置にありません。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">追加するブール値。</param>
        <summary>指定したブール値の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> メソッドの呼び出し、 <xref:System.Boolean.ToString?displayProperty=fullName> の文字列形式を取得するメソッド `value`します。 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 8 ビット符号なし整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> メソッドの呼び出し、 <xref:System.Byte.ToString%28System.IFormatProvider%29> の文字列形式を取得するメソッド `value` 、現在のカルチャ。 書式を制御する `value`, を呼び出す、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">追加する UTF\-16 でエンコードされたコード単位。</param>
        <summary>指定した <see cref="T:System.Char" /> オブジェクトの文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.Char%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字の配列。</param>
        <summary>指定した配列内の Unicode 文字の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method appends all the characters in the specified array to the current instance in the same order as they appear in **parameterReference tag is not supported!!!!**  
. If **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, no changes are made.  
  
 The <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.  
  
 [!code-csharp[System.Text.StringBuilder.Append\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 The capacity of this instance is adjusted as needed.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 10 進数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> メソッドの呼び出し、 <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=fullName> の文字列形式を取得するメソッド `value` 、現在のカルチャ。 書式を制御する `value`, を呼び出す、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した倍精度浮動小数点数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> メソッドの呼び出し、 <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=fullName> の文字列形式を取得するメソッド `value` 、現在のカルチャ。 書式を制御する `value`, を呼び出す、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 16 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> メソッドの呼び出し、 <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=fullName> の文字列形式を取得するメソッド `value` 、現在のカルチャ。 書式を制御する `value`, を呼び出す、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 32 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Text.StringBuilder.Append%28System.Int32%29> method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.  
  
 [!code-csharp[System.Text.StringBuilder.Append\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 The <xref:System.Text.StringBuilder.Append%28System.Int32%29> method calls the <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=fullName> method to get the string representation of **parameterReference tag is not supported!!!!**  
 for the current culture. To control the formatting of **parameterReference tag is not supported!!!!**  
, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.  
  
 The capacity of this instance is adjusted as needed.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 64 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> メソッドの呼び出し、 <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=fullName> の文字列表現を取得する `value` 、現在のカルチャ。 書式を制御する `value`, を呼び出す、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">追加するオブジェクト。</param>
        <summary>指定したオブジェクトの文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。 定義する、`Dog`よびは、クラスを作成、`Dog`オブジェクト、およびを 3 回の呼び出しでは、 <xref:System.Text.StringBuilder.Append%2A> dog の名前と種類を表す文字列を作成します。  
  
 [!code-csharp[System.Text.Stringbuilder.Append\#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append\#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>メソッドの呼び出し、<xref:System.Object.ToString%2A?displayProperty=fullName>の文字列形式を取得するメソッド`value`です。 場合`value`は`null`、に対する変更は行われません、<xref:System.Text.StringBuilder>オブジェクト。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 8 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append\#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> メソッドの呼び出し、 <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=fullName> の文字列形式を取得するメソッド `value` 、現在のカルチャ。 書式を制御する `value`, を呼び出す、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した単精度浮動小数点数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append\#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> メソッドの呼び出し、 <xref:System.Single.ToString%2A?displayProperty=fullName> の文字列形式を取得するメソッド `value` 、現在のカルチャ。 書式を制御する `value`, を呼び出す、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字列。</param>
        <summary>指定した文字列のコピーをこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.String%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 場合 `value` は `null`, 、変更は行われません。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 16 ビット符号なし整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append\#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> メソッドの呼び出し、 <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=fullName> の文字列形式を取得するメソッド `value`します。 書式を制御する `value`, を呼び出す、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定された 32 ビット符号なし整数の文字列表記をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> 呼び出し、 <xref:System.UInt32.ToString%2A?displayProperty=fullName> の文字列形式を取得するメソッド `value` 、現在のカルチャ。 書式を制御する `value`, を呼び出す、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 64 ビット符号なし整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append\#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> メソッドの呼び出し、 <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=fullName> の文字列形式を取得するメソッド `value` 、現在のカルチャ。 書式を制御する `value`, を呼び出す、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字。</param>
        <param name="repeatCount">
          <c>value</c> を追加する回数。</param>
        <summary>Unicode 文字の文字列形式の、指定した数のコピーをこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> が 0 未満です。  
  
 \-または\-  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">文字の配列を指すポインター。</param>
        <param name="valueCount">配列の文字数。</param>
        <summary>指定したアドレスで始まる Unicode 文字の配列をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを追加 `valueCount` アドレスで始まる文字 `value` 現在のインスタンスにします。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> が 0 未満です。  
  
 \-または\-  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> が null ポインターです。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">文字配列。</param>
        <param name="startIndex">
          <c>value</c> 内の開始位置。</param>
        <param name="charCount">追加する文字数。</param>
        <summary>Unicode 文字の指定した部分配列の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、指定した範囲内の文字を追加 `value` 現在のインスタンスにします。 場合 `value` は `null` と `startIndex` と `count` はどちらもゼロの変更が加えられました。  
  
 [Append メソッド \(Char\<xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 [Append メソッド \(Char\<xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> が <see langword="null" /> で、<paramref name="startIndex" /> と <paramref name="charCount" /> が 0 ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> が 0 未満です。  
  
 \-または\-  
  
 <paramref name="startIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> に <paramref name="charCount" /> を加算した値が <paramref name="value" /> の長さを超えています。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">追加する部分文字列を含む文字列。</param>
        <param name="startIndex">
          <c>value</c> 内の部分文字列の開始位置。</param>
        <param name="count">
          <c>value</c> 内の追加する文字数。</param>
        <summary>指定した部分文字列のコピーをこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、指定した範囲内の文字を追加 `value` 現在のインスタンスにします。 場合 `value` は `null` と `startIndex` と `count` はどちらもゼロの変更が加えられました。  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、呼び出せるメソッドまたはプロパティに既存の参照および戻り値を代入する必要はありません、 <xref:System.Text.StringBuilder> オブジェクトを次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append\#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append\#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> であり、<paramref name="startIndex" /> と <paramref name="count" /> は 0 ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">0 より小さい <paramref name="count" />。  
  
 または  
  
 0 より小さい <paramref name="startIndex" />。  
  
 または  
  
 <paramref name="startIndex" /> に <paramref name="count" /> を加算した値が <paramref name="value" /> の長さを超えています。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">複合書式指定文字列 \(「解説」を参照\)。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに追加します。 各書式項目は、単一の引数の文字列表記に置換されます。</summary>
        <returns>
          <paramref name="format" /> が追加されたこのインスタンスへの参照。<paramref name="format" /> の各書式指定項目は、<paramref name="arg0" /> の文字列表記に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、 [複合書式指定機能](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49) オブジェクトの値をそのテキスト表現に変換され、現在の表現を埋め込むには、.NET Framework の <xref:System.Text.StringBuilder> オブジェクトです。  
  
 `format` パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、書式指定項目と呼ばれる個以上のテキストが混在します。 書式指定項目のインデックスに対応する場合は 0 にする必要があります `arg0`, 、このメソッドのパラメーター リスト内の 1 つのオブジェクト。 書式設定のプロセスでは、各書式項目を置換の文字列表記を表す `arg0`します。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*\[、*長さ*\] \[:*formatString*\]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトが指定された場合 *インデックス* は `null`, 、書式指定項目が置き換え <xref:System.String.Empty?displayProperty=fullName>します。 内のパラメーターがない場合、 *インデックス* 、位置、 <xref:System.FormatException> がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字列の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタム書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b) と [Custom Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)です。 数値と共に使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。 列挙体と共に使用する標準書式指定文字列を参照してください。 [Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)します。  
  
 `arg0` 書式設定するオブジェクトを表します。 各書式項目 `format` の文字列形式に置き換えられます `arg0`します。 書式指定項目が含まれる場合 `formatString` と `arg0` を実装して、 <xref:System.IFormattable> インターフェイス、 `arg0.ToString(formatString, null)` 書式を定義します。 それ以外の場合、 `arg0.ToString()` 書式を定義します。  
  
 代入された文字列の場合 `format` は"いただき、献血の {0: \#\#\#} charitable 組織には、食料の缶"。`arg0` 整数値 10 を戻り値は「your donation of 10 cans of food to our charitable organization いただきありがとうございます」になります。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.appendformat\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 \(ゼロ\) 未満か、1 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">複合書式指定文字列 \(「解説」を参照\)。</param>
        <param name="args">書式指定するオブジェクトの配列。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、パラメーター配列内の対応する引数の文字列形式に置換されます。</summary>
        <returns>
          <paramref name="format" /> が追加されたこのインスタンスへの参照。<paramref name="format" /> の各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、 [複合書式指定機能](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49) オブジェクトの値をそのテキスト表現に変換され、現在の表現を埋め込むには、.NET Framework の <xref:System.Text.StringBuilder> オブジェクトです。  
  
 `format` パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、このメソッドのパラメーター リスト内のオブジェクトに対応する書式指定項目と呼ばれる個以上のテキストが混在します。 書式設定のプロセスでは、対応するオブジェクトの文字列表記を表す各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*\[、*長さ*\] \[:*formatString*\]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトが指定された場合 *インデックス* は `null`, 、書式指定項目が置き換え <xref:System.String.Empty?displayProperty=fullName>します。 内のパラメーターがない場合、 *インデックス* 、位置、 <xref:System.FormatException> がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字列の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタム書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b) と [Custom Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)です。 数値と共に使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。 列挙体と共に使用する標準書式指定文字列を参照してください。 [Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)します。  
  
 `args` 書式設定するオブジェクトを表します。 各書式項目 `format` に対応するオブジェクトの文字列形式に置き換えられます `args`します。 書式指定項目が含まれる場合 `formatString` との対応するオブジェクト `args` を実装して、 <xref:System.IFormattable> インターフェイス、 `args[index].ToString(formatString, provider)` 書式を定義します。 それ以外の場合、 `args[index].ToString()` 書式を定義します。  
  
 代入された文字列の場合 `format` は"いただき、献血の {0: \#\#\#} charitable 組織には、食料の缶"。`arg0` 整数値 10 を戻り値は「your donation of 10 cans of food to our charitable organization いただきありがとうございます」になります。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.appendformat\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 \(ゼロ\) 未満であるか、<paramref name="args" /> 配列の長さ以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式指定文字列 \(「解説」を参照\)。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、指定された書式プロバイダーを使用して単一の引数の文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、<paramref name="arg0" /> の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、  [複合書式指定機能](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49) の値に変換する .NET Framework の `arg0` をテキスト形式および現在の表現を埋め込む <xref:System.Text.StringBuilder> オブジェクトです。  
  
 `format` パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、書式指定項目と呼ばれる個以上のテキストが混在します。 このメソッドには、単一の引数、引数リストが含まれているために、各書式指定項目のインデックスはゼロ \(0\) にする必要があります。 書式設定のプロセスでは、各書式項目を置換の文字列表記を表す `arg0`します。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*\[、*長さ*\] \[:*formatString*\]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトが指定された場合 *インデックス* は `null`, 、書式指定項目が置き換え <xref:System.String.Empty?displayProperty=fullName>します。 この場合、以降、 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> メソッドは、引数リストの値の 1 つの引数を持つ *インデックス* 常に 0 があります。 でない場合、 <xref:System.FormatException> がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字列の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタム書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b) と [Custom Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)です。 数値と共に使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。 列挙体と共に使用する標準書式指定文字列を参照してください。 [Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)します。  
  
 `provider` パラメーターを指定する <xref:System.IFormatProvider> 内のオブジェクトの書式設定情報を提供する実装 `args`します。`provider` は、次のいずれかになります。  
  
-   A <xref:System.Globalization.CultureInfo> カルチャ固有の書式情報を提供するオブジェクト。  
  
-   A <xref:System.Globalization.NumberFormatInfo> カルチャ固有の書式設定情報を提供するオブジェクト `arg0` 数値である場合。  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> カルチャ固有の書式設定情報を提供するオブジェクト `arg0` が日付と時刻の値の場合。  
  
-   カスタム <xref:System.IFormatProvider> に対する書式設定情報を提供する実装 `arg0`します。 通常、このような実装もを実装する、 <xref:System.ICustomFormatter> インターフェイスです。  
  
 場合、 `provider` パラメーターは `null`, 、書式設定情報は、現在のカルチャから取得します。  
  
 `arg0` 書式設定するオブジェクトを表します。 各書式項目 `format` の文字列形式に置き換えられます `arg0`します。 書式指定項目が含まれる場合 `formatString` と `arg0` を実装して、 <xref:System.IFormattable> インターフェイス、 `arg0.ToString(formatString, provider)` 書式を定義します。 それ以外の場合、 `arg0.ToString()` 書式を定義します。  
  
   
  
## 例  
 以下に 2 つの呼び出し、 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> メソッドです。 両方は、英語英国 \(EN\-GB\) カルチャの書式指定規則を使用します。 最初の文字列表現を挿入する、 <xref:System.Decimal> 結果の文字列に通貨の値します。 2 番目の挿入、 <xref:System.DateTime> 結果の 2 か所で値を文字列だけで、短い日付文字列と 2 番目短い形式の時刻の文字列の最初のなどです。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 \-または\-  
  
 書式項目のインデックスが 0 \(ゼロ\) より小さいか、または 1 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式指定文字列 \(「解説」を参照\)。</param>
        <param name="args">書式指定するオブジェクトの配列。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、指定された書式プロバイダーを使用した、パラメーター配列内の対応する引数の文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、対応するオブジェクト引数の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、 [複合書式指定機能](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49) オブジェクトの値をそのテキスト表現に変換され、現在の表現を埋め込むには、.NET Framework の <xref:System.Text.StringBuilder> オブジェクトです。  
  
 `format` パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、このメソッドのパラメーター リスト内のオブジェクトに対応する書式指定項目と呼ばれる個以上のテキストが混在します。 書式設定のプロセスでは、対応するオブジェクトの文字列表記を表す各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*\[、*長さ*\] \[:*formatString*\]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトが指定された場合 *インデックス* は `null`, 、書式指定項目が置き換え <xref:System.String.Empty?displayProperty=fullName>します。 内のパラメーターがない場合、 *インデックス* 、位置、 <xref:System.FormatException> がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字列の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタム書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b) と [Custom Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)です。 数値と共に使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。 列挙体と共に使用する標準書式指定文字列を参照してください。 [Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)します。  
  
 `provider` パラメーターを指定する <xref:System.IFormatProvider> 内のオブジェクトの書式設定情報を提供する実装 `args`します。`provider` は、次のいずれかになります。  
  
-   A <xref:System.Globalization.CultureInfo> カルチャ固有の書式情報を提供するオブジェクト。  
  
-   A <xref:System.Globalization.NumberFormatInfo> 内の数値のカルチャに固有の書式情報を提供するオブジェクト `args`します。  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> で日付と時刻の値をカルチャに固有の書式情報を提供するオブジェクト `args`します。  
  
-   カスタム <xref:System.IFormatProvider> 内のオブジェクトの 1 つ以上の書式情報を提供する実装 `args`します。 通常、このような実装もを実装する、 <xref:System.ICustomFormatter> インターフェイスです。 次のセクションで、2 番目の例に示す、 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName> メソッドの呼び出しをカスタム <xref:System.IFormatProvider> 実装します。  
  
 場合、 `provider` パラメーターは `null`, 、現在のカルチャから書式プロバイダーの情報を取得します。  
  
 `args` 書式設定するオブジェクトを表します。 各書式項目 `format` に対応するオブジェクトの文字列形式に置き換えられます `args`します。 書式指定項目が含まれる場合 `formatString` との対応するオブジェクト `args` を実装して、 <xref:System.IFormattable> インターフェイス、 `args[index].ToString(formatString, provider)` 書式を定義します。 それ以外の場合、 `args[index].ToString()` 書式を定義します。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.appendformat\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 次の例では、カスタム <xref:System.IFormatProvider> という名前の実装 `CustomerFormatter` 4 番目と 7 番目の数字の後 10 桁の顧客番号をハイフンをフォーマットします。 渡される、 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName> メソッドには、書式設定された顧客番号や顧客名、文字列を作成します。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 \(ゼロ\) 未満であるか、<paramref name="args" /> 配列の長さ以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">複合書式指定文字列 \(「解説」を参照\)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、2 つの引数のどちらかの文字列形式に置換されます。</summary>
        <returns>
          <paramref name="format" /> が追加されたこのインスタンスへの参照。<paramref name="format" /> の各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、 [複合書式指定機能](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49) オブジェクトの値をそのテキスト表現に変換され、現在の表現を埋め込むには、.NET Framework の <xref:System.Text.StringBuilder> オブジェクトです。  
  
 `format` パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダーに対応する書式指定項目と呼ばれる個以上のテキストが混在 `arg0` と `arg1`, 、このメソッドのパラメーター リスト内の 2 つのオブジェクト。 書式設定のプロセスでは、対応するオブジェクトの文字列表記を表す各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*\[、*長さ*\] \[:*formatString*\]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトが指定された場合 *インデックス* は `null`, 、書式指定項目が置き換え <xref:System.String.Empty?displayProperty=fullName>します。 内のパラメーターがない場合、 *インデックス* 、位置、 <xref:System.FormatException> がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字列の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタム書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b) と [Custom Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)です。 数値と共に使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。 列挙体と共に使用する標準書式指定文字列を参照してください。 [Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)します。  
  
 `arg0` `arg1` を書式設定オブジェクトを表します。 各書式項目 `format` はいずれかの文字列形式に置き換えられます `arg0` または `arg1`です。 書式指定項目が含まれている場合 `formatString` し、対応するオブジェクトを実装する、 <xref:System.IFormattable> インターフェイス、 `arg`*x*`.ToString(formatString, provider)` を定義、書式設定、ここで *x* 引数のインデックスです。 それ以外の場合、 `arg`*x*`.ToString()` 書式を定義します。  
  
 代入された文字列の場合 `format` は"いただき、献血の {0: \#\#\#} charitable 組織には、食料の缶"。`arg0` 整数値 10 を戻り値は「your donation of 10 cans of food to our charitable organization いただきありがとうございます」になります。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.appendformat\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 \(ゼロ\) 未満か、または 2 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式指定文字列 \(「解説」を参照\)。複合書式指定文字列 \(「解説」を参照\)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、指定された書式プロバイダーを使用して 2 つの引数のいずれかの文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、対応するオブジェクト引数の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、 [複合書式指定機能](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49) オブジェクトの値をそのテキスト表現に変換され、現在の表現を埋め込むには、.NET Framework の <xref:System.Text.StringBuilder> オブジェクトです。  
  
 `format` パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、このメソッドのパラメーター リスト内のオブジェクトに対応する書式指定項目と呼ばれる個以上のテキストが混在します。 書式設定のプロセスでは、対応するオブジェクトの文字列表記を表す各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*\[、*長さ*\] \[:*formatString*\]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトが指定された場合 *インデックス* は `null`, 、書式指定項目が置き換え <xref:System.String.Empty?displayProperty=fullName>します。 内のパラメーターがない場合、 *インデックス* 、位置、 <xref:System.FormatException> がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字列の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタム書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b) と [Custom Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)です。 数値と共に使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。 列挙体と共に使用する標準書式指定文字列を参照してください。 [Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)します。  
  
 `provider` パラメーターを指定する <xref:System.IFormatProvider> の書式設定情報を提供する実装 `arg0` と `arg1`です。`provider` は、次のいずれかになります。  
  
-   A <xref:System.Globalization.CultureInfo> カルチャ固有の書式情報を提供するオブジェクト。  
  
-   A <xref:System.Globalization.NumberFormatInfo> カルチャ固有の書式設定情報を提供するオブジェクト `arg0` または `arg1` 数値を指定している場合。  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> カルチャ固有の書式設定情報を提供するオブジェクト `arg0` または `arg1` 場合は、日付と時刻の値。  
  
-   カスタム <xref:System.IFormatProvider> に対する書式設定情報を提供する実装 `arg0` と `arg1`です。 通常、このような実装もを実装する、 <xref:System.ICustomFormatter> インターフェイスです。  
  
 場合、 `provider` パラメーターは `null`, 、現在のカルチャから書式プロバイダーの情報を取得します。  
  
 `arg0` `arg1` を書式設定オブジェクトを表します。 各書式項目 `format` を対応するインデックスを持つオブジェクトの文字列形式に置き換えられます。 書式指定項目が含まれる場合 `formatString` し、対応する引数を実装する、 <xref:System.IFormattable> インターフェイスを引数の `ToString(formatString, provider)` メソッドは、書式を定義します。 それ以外の場合、引数の `ToString()` メソッドは、書式を定義します。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> ジェネリックに格納されている時刻と温度のデータを表示するメソッドを <xref:System.Collections.Generic.Dictionary%602> オブジェクトです。 書式設定するオブジェクトのみにありますが、書式指定文字列に次の 3 つの書式指定項目に注意してください。 これは、\(日付と時刻の値\) の一覧の最初のオブジェクトが 2 つの書式指定項目によって使用されるため、: 時間、および 2 番目の日付を表示します。 最初の書式項目表示します。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 \(ゼロ\) 未満か、または 2 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">複合書式指定文字列 \(「解説」を参照\)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、3 つの引数のいずれかの文字列形式に置換されます。</summary>
        <returns>
          <paramref name="format" /> が追加されたこのインスタンスへの参照。<paramref name="format" /> の各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、 [複合書式指定機能](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49) オブジェクトの値をそのテキスト表現に変換され、現在の表現を埋め込むには、.NET Framework の <xref:System.Text.StringBuilder> オブジェクトです。  
  
 `format` パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダーに対応する書式指定項目と呼ばれる個以上のテキストが混在 `arg0` を通じて `arg2`, 、このメソッドのパラメーター リスト内のオブジェクト。 書式設定のプロセスでは、対応するオブジェクトの文字列表記を表す各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*\[、*長さ*\] \[:*formatString*\]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトが指定された場合 *インデックス* は `null`, 、書式指定項目が置き換え <xref:System.String.Empty?displayProperty=fullName>します。 内のパラメーターがない場合、 *インデックス* 、位置、 <xref:System.FormatException> がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字列の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタム書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b) と [Custom Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)です。 数値と共に使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。 列挙体と共に使用する標準書式指定文字列を参照してください。 [Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)します。  
  
 `arg0`, 、`arg1`, 、および `arg2` を書式設定オブジェクトを表します。 各書式項目 `format` はいずれかの文字列形式に置き換えられます `arg0`, 、`arg1`, 、または `arg2`, 書式指定項目のインデックスによって異なります。 書式指定項目が含まれている場合 `formatString` との対応するオブジェクト `args` を実装して、 <xref:System.IFormattable> インターフェイス、 `arg`*x*`.ToString(formatString, null)` を定義、書式設定、ここで *x* 引数のインデックスは、です。 それ以外の場合、 `arg`*x*`.ToString()` 書式を定義します。  
  
 代入された文字列の場合 `format` は"いただき、献血の {0: \#\#\#} charitable 組織には、食料の缶"。`arg0` 整数値 10 を戻り値は「your donation of 10 cans of food to our charitable organization いただきありがとうございます」になります。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.appendformat\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 \(ゼロ\) 未満か、または 3 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式指定文字列 \(「解説」を参照\)。複合書式指定文字列 \(「解説」を参照\)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。3 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、指定された書式プロバイダーを使用して 3 つの引数のいずれかの文字列形式に置換されます。各書式項目は、指定された書式プロバイダーを使用して 3 つの引数のいずれかの文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、対応するオブジェクト引数の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、 [複合書式指定機能](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49) オブジェクトの値をそのテキスト表現に変換され、現在の表現を埋め込むには、.NET Framework の <xref:System.Text.StringBuilder> オブジェクトです。  
  
 `format` パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、このメソッドのパラメーター リスト内のオブジェクトに対応する書式指定項目と呼ばれる個以上のテキストが混在します。 書式設定のプロセスでは、対応するオブジェクトの文字列表記を表す各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*\[、*長さ*\] \[:*formatString*\]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトが指定された場合 *インデックス* は `null`, 、書式指定項目が置き換え <xref:System.String.Empty?displayProperty=fullName>します。 内のパラメーターがない場合、 *インデックス* 、位置、 <xref:System.FormatException> がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字列の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタム書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b) と [Custom Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)です。 数値と共に使用される標準とカスタムの書式指定文字列を参照してください。 [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。 列挙体と共に使用する標準書式指定文字列を参照してください。 [Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)します。  
  
 `provider` パラメーターを指定する <xref:System.IFormatProvider> の書式設定情報を提供する実装 `arg0` と `arg1`です。`provider` は、次のいずれかになります。  
  
-   A <xref:System.Globalization.CultureInfo> カルチャ固有の書式情報を提供するオブジェクト。  
  
-   A <xref:System.Globalization.NumberFormatInfo> カルチャ固有の書式設定情報を提供するオブジェクト `arg0` または `arg1` 数値を指定している場合。  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> カルチャ固有の書式設定情報を提供するオブジェクト `arg0`, 、`arg1`, 、または `arg2` 場合は、日付と時刻の値。  
  
-   カスタム <xref:System.IFormatProvider> に対する書式設定情報を提供する実装 `arg0`,  、`arg1`, 、および `arg2`です。 通常、このような実装もを実装する、 <xref:System.ICustomFormatter> インターフェイスです。  
  
 場合、 `provider` パラメーターは `null`, 、現在のカルチャから書式プロバイダーの情報を取得します。  
  
 `arg0`, 、`arg1`, 、および `arg2` を書式設定オブジェクトを表します。 各書式項目 `format` を対応するインデックスを持つオブジェクトの文字列形式に置き換えられます。 書式指定項目が含まれる場合 `formatString` し、対応する引数を実装する、 <xref:System.IFormattable> インターフェイスを引数の `ToString(formatString, provider)` メソッドは、書式を定義します。 それ以外の場合、引数の `ToString()` メソッドは、書式を定義します。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> ブール値の結果を示すためにメソッド `And` 整数値で操作します。 各項目が 2 つの方法で書式設定されたために、書式指定文字列には、6 つの書式項目が含まれますが、メソッドは、引数リスト内のみの 3 つの項目を持つことを注意してください。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 \(ゼロ\) 未満か、3 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定の行終端記号を現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの末尾に追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の行終端記号はの現在の値、 <xref:System.Environment.NewLine%2A?displayProperty=fullName> プロパティです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.AppendLine%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.appendline\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字列。</param>
        <summary>指定した文字列のコピーと既定の行終端記号を、現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの末尾に追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The default line terminator is the current value of the <xref:System.Environment.NewLine%2A?displayProperty=fullName> property.  
  
 The capacity of this instance is adjusted as needed.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property. This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のインスタンスによって割り当てられたメモリに格納できる最大文字数を取得または設定します。</summary>
        <value>現在のインスタンスによって割り当てられたメモリに格納できる最大文字数。 この値の範囲は <see cref="P:System.Text.StringBuilder.Length" /> ～ <see cref="P:System.Text.StringBuilder.MaxCapacity" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Capacity%2A> does not affect the string value of the current instance. <xref:System.Text.StringBuilder.Capacity%2A> can be decreased as long as it is not less than <xref:System.Text.StringBuilder.Length%2A>.  
  
 The <xref:System.Text.StringBuilder> dynamically allocates more space when required and increases <xref:System.Text.StringBuilder.Capacity%2A> accordingly. For performance reasons, a <xref:System.Text.StringBuilder> might allocate more memory than needed. The amount of memory allocated is implementation\-specific.  
  
   
  
## 例  
 The following example demonstrates the <xref:System.Text.StringBuilder.Capacity%2A> property.  
  
 [!code-cpp[stringbuilder.ensurecapacity\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作に指定された値は、このインスタンスの現在の長さより小さい値です。  
  
 または  
  
 設定操作に指定された値は、最大容量を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">文字の位置。</param>
        <summary>このインスタンス内の指定した文字位置の文字を取得または設定します。</summary>
        <value>
          <paramref name="index" /> 位置の Unicode 文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The **parameterReference tag is not supported!!!!**  
 parameter is the position of a character within the <xref:System.Text.StringBuilder>. The first character in the string is at index 0. The length of a string is the number of characters it contains. The last accessible character of a <xref:System.Text.StringBuilder> instance is at index <xref:System.Text.StringBuilder.Length%2A> \- 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> is the default property of the <xref:System.Text.StringBuilder> class. In C\#, it is an indexer. This means that individual characters can be retrieved from the <xref:System.Text.StringBuilder.Chars%2A> property as shown in the following example, which counts the number of alphabetic, white\-space, and punctuation characters in a string.  
  
 [!code-csharp[System.Text.StringBuilder.Chars\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">文字の設定において、<paramref name="index" /> がこのインスタンスの境界外です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">文字の取得において、<paramref name="index" /> がこのインスタンスの境界外です。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Text.StringBuilder" /> インスタンスからすべての文字を削除します。</summary>
        <returns>
          <see cref="P:System.Text.StringBuilder.Length" /> が 0 \(ゼロ\) であるオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.StringBuilder.Clear%2A> is a convenience method that is equivalent to setting the <xref:System.Text.StringBuilder.Length%2A> property of the current instance to 0 \(zero\).  
  
 Calling the <xref:System.Text.StringBuilder.Clear%2A> method does not modify the current instance's <xref:System.Text.StringBuilder.Capacity%2A> or <xref:System.Text.StringBuilder.MaxCapacity%2A> property.  
  
   
  
## 例  
 The following example instantiates a <xref:System.Text.StringBuilder> object with a string, calls the <xref:System.Text.StringBuilder.Clear%2A> method, and then appends a new string.  
  
 [!code-csharp[System.Text.StringBuilder.Clear\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">このインスタンスにおける文字のコピーの開始位置。 インデックスの値は、0 から始まります。</param>
        <param name="destination">文字のコピー先となる配列。</param>
        <param name="destinationIndex">
          <c>destination</c> における文字のコピーの開始位置。 インデックスの値は、0 から始まります。</param>
        <param name="count">コピーする文字数。</param>
        <summary>このインスタンスの指定したセグメントにある文字を、目的の <see cref="T:System.Char" /> 配列の指定したセグメントにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [CopyTo メソッド \(Int32, Char\<xref:System.Text.StringBuilder.CopyTo%2A> メソッドは、まれな状況での連続するセクションを効率的にコピーする必要がある場合に使用するものでは、 [CopyTo メソッド \(Int32, Char\<xref:System.Text.StringBuilder> オブジェクトを配列にします。 配列は固定サイズで事前に割り当てられた、再利用可能なおよび場合によってグローバルにアクセス可能である必要があります。  
  
 たとえば、アプリケーションを取り込むことができます、 [CopyTo メソッド \(Int32, Char\<xref:System.Text.StringBuilder> 大きな文字数が表示されたオブジェクトを使用して、 [CopyTo メソッド \(Int32, Char\<xref:System.Text.StringBuilder.CopyTo%2A> の小さな、連続する要素をコピーする方法、 [CopyTo メソッド \(Int32, Char\<xref:System.Text.StringBuilder> オブジェクトを配列に要素が処理されます。 内のすべてのデータ、 [CopyTo メソッド \(Int32, Char\<xref:System.Text.StringBuilder> オブジェクトの処理のサイズ、 [CopyTo メソッド \(Int32, Char\<xref:System.Text.StringBuilder> オブジェクトが 0 に設定され、サイクルが繰り返されます。  
  
   
  
## 例  
 次の例は、 [CopyTo メソッド \(Int32, Char\<xref:System.Text.StringBuilder.CopyTo%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.copyto2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />、<paramref name="destinationIndex" /> または <paramref name="count" /> が 0 より小さい値です。  
  
 \-または\-  
  
 <paramref name="sourceIndex" /> はこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> \+ <paramref name="count" /> がこのインスタンスの長さを超えています。  
  
 \-または\-  
  
 <paramref name="destinationIndex" /> に <paramref name="count" /> を加算した値が <paramref name="destination" /> の長さを超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">必要な最小容量。</param>
        <summary>このインスタンスの <see cref="T:System.Text.StringBuilder" /> の容量が、指定した値以上になるようにします。</summary>
        <returns>このインスタンスの新しい容量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the current capacity is less than the **parameterReference tag is not supported!!!!**  
 parameter, memory for this instance is reallocated to hold at least **parameterReference tag is not supported!!!!**  
 number of characters; otherwise, no memory is changed.  
  
   
  
## 例  
 The following example demonstrates the <xref:System.Text.StringBuilder.EnsureCapacity%2A> method.  
  
 [!code-cpp[stringbuilder.ensurecapacity\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。  
  
 \-または\-  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">このインスタンスと比較する対象のオブジェクト、または <see langword="null" />。</param>
        <summary>このインスタンスが指定されたオブジェクトに等しいかどうかを示す値を返します。</summary>
        <returns>このインスタンスと <paramref name="sb" /> が同じ文字列、<see cref="P:System.Text.StringBuilder.Capacity" /> 値、および <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 値を保持している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following code uses the <xref:System.Text.StringBuilder.Equals%2A> method to check whether two <xref:System.Text.StringBuilder> objects are equal. The method is called repeatedly after small changes are made to each object, and the results are displayed to the console.  
  
 [!code-cpp[stringbuilder.ensurecapacity\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>Boolean 値の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Boolean.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 8 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Byte.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した Unicode 文字の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Char.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が 0 未満か、またはこのインスタンスの長さを超えています。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する文字配列。</param>
        <summary>指定した Unicode 文字の配列の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
 場合 `value` は `null`, 、 <xref:System.Text.StringBuilder> は変更されません。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が 0 未満か、またはこのインスタンスの長さを超えています。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>10 進数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Decimal.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>倍精度浮動小数点数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 16 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Int16.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 32 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Int32.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>64 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Int64.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入するオブジェクト、または <see langword="null" />。</param>
        <summary>オブジェクトの文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Object.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
 場合 `value` は `null`, 、このインスタンスの値は変更されません。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 8 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.SByte.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>単精度浮動小数点数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Single.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する文字列。</param>
        <summary>文字列をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて容量が調整されます。  
  
 このインスタンスの <xref:System.Text.StringBuilder> 場合は変更されません `value` は `null`, 、または `value` は `null` が、その長さが 0 です。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの現在の長さより大きいです。  
  
 または  
  
 この <see cref="T:System.Text.StringBuilder" /> オブジェクトの現在の長さに <paramref name="value" /> の長さを加算した結果が、<see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えています。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>16 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.UInt16.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>32 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.UInt32.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>64 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.UInt64.ToString%2A?displayProperty=fullName> 文字列表現を取得するために使用 `value`します。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 より小さいか、このインスタンスの長さより大きいです。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する文字列。</param>
        <param name="count">
          <c>value</c> を挿入する回数。</param>
        <summary>指定した文字列の 1 つ以上のコピーをこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
 これは、 <xref:System.Text.StringBuilder> 場合、オブジェクトが変更されていない `value` は `null`, 、`value` は `null` が、その長さが 0、または `count` ゼロです。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの現在の長さを超えています。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.OutOfMemoryException">この <see cref="T:System.Text.StringBuilder" /> オブジェクトの現在の長さに <paramref name="value" /> の長さを <paramref name="count" /> 倍した値を加算した結果が、<see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えています。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">文字配列。</param>
        <param name="startIndex">
          <c>value</c> 内の開始インデックス。</param>
        <param name="charCount">挿入する文字数。</param>
        <summary>Unicode 文字の指定した部分配列の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## 例  
 次の例は、 [Insert メソッド \(Int32, Char\<xref:System.Text.StringBuilder.Insert%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.insert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> であり、<paramref name="startIndex" /> と <paramref name="charCount" /> は 0 ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />、<paramref name="startIndex" />、または <paramref name="charCount" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> はこのインスタンスの長さを超えています。  
  
 または  
  
 <paramref name="startIndex" /> に <paramref name="charCount" /> を加算した値が <paramref name="value" /> 内の位置にありません。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの長さを取得または設定します。</summary>
        <value>このインスタンスの長さ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 長さ、 <xref:System.Text.StringBuilder> の番号を使用してオブジェクトが定義されている <xref:System.Char> オブジェクトです。  
  
 ように、<xref:System.String.Length%2A?displayProperty=fullName> 、プロパティ、 <xref:System.Text.StringBuilder.Length%2A> プロパティは、現在の文字列の長さを示します。 異なり、 <xref:System.String.Length%2A?displayProperty=fullName> 読み取り専用では、プロパティ、 <xref:System.Text.StringBuilder.Length%2A> プロパティに格納されている文字列の長さを変更することができます、 <xref:System.Text.StringBuilder> オブジェクトです。  
  
 指定した長さは、現在の長さは現在よりも小さいかどうか <xref:System.Text.StringBuilder> オブジェクトが指定の長さに切り詰められます。 指定された長さが現在の長さは、現在の文字列値の末尾よりも大きいかどうか <xref:System.Text.StringBuilder> オブジェクトは、Unicode NULL 文字で埋められます \(u\+0000\)。  
  
 指定された長さが現在の容量を超える場合 <xref:System.Text.StringBuilder.Capacity%2A> されるように指定した長さ以上に増加します。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Length%2A> プロパティです。  
  
 [!code-cpp[stringbuilder.ensurecapacity\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作で指定された値は、0 より小さい値か、<see cref="P:System.Text.StringBuilder.MaxCapacity" /> より大きい値になります。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このインスタンスの最大容量を取得します。</summary>
        <value>このインスタンスが保持できる最大文字数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この実装の最大容量は <xref:System.Int32.MaxValue?displayProperty=fullName>です。 ただし、この値は実装固有で、またはそれ以降の実装では異なる場合があります。 最大容量を明示的に設定することができます、 <xref:System.Text.StringBuilder> オブジェクトを呼び出して、 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> コンス トラクターです。  
  
 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] と [!INCLUDE[net_v45](~/includes/net-v45-md.md)], をインスタンス化するときに、 <xref:System.Text.StringBuilder> オブジェクトを呼び出して、 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> コンス トラクター、長さと容量の両方、 <xref:System.Text.StringBuilder> インスタンスは、の値を超えることができます、 <xref:System.Text.StringBuilder.MaxCapacity%2A> プロパティです。 これは特にを呼び出したときに発生、 <xref:System.Text.StringBuilder.Append%2A> と <xref:System.Text.StringBuilder.AppendFormat%2A> 短い文字列を追加する方法です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンスにおける 0 から始まる削除の開始位置。</param>
        <param name="length">削除する文字数。</param>
        <summary>このインスタンスから、指定した範囲の文字を削除します。</summary>
        <returns>削除操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在のメソッドは、現在のインスタンスから指定された文字の範囲を削除します。 文字 \(`startIndex` \+ `length`\) に移動 `startIndex`, 、によって現在のインスタンスの文字列値が簡略化され、 `length`です。 現在のインスタンスの容量に影響はありません。  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A> メソッドは、現在の値を変更 <xref:System.Text.StringBuilder> をインスタンス化し、そのインスタンスを返します。 それを作成し、返す、新しいない <xref:System.Text.StringBuilder> オブジェクトです。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Remove%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.remove\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満か、<paramref name="startIndex" /> \+ <paramref name="length" /> がこのインスタンスの長さを超えています。</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">置換する文字。</param>
        <param name="newChar">
          <c>oldChar</c> を置換する文字。</param>
        <summary>このインスタンスに出現する指定文字をすべて、別に指定した文字に置換します。</summary>
        <returns>
          <paramref name="oldChar" /> が <paramref name="newChar" /> に置換されたこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの出現回数を識別するために序数に基づく小文字を区別する比較を実行する `oldChar` 現在のインスタンスに存在します。 現在のサイズ <xref:System.Text.StringBuilder> インスタンスには、交換した後は変更されません。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Replace%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.replace\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換する文字列。</param>
        <param name="newValue">
          <c>oldValue</c> を置換する文字列、または <see langword="null" />。</param>
        <summary>このインスタンスに出現するすべての指定した文字列を、別の指定した文字列に置換します。</summary>
        <returns>
          <paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> に置換されたこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの出現回数を識別するために序数に基づく小文字を区別する比較を実行する `oldValue` 現在のインスタンスに存在します。 場合 `newValue` は `null`または<xref:System.String.Empty?displayProperty=fullName>, 、出現するすべての `oldValue` が削除されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Replace%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.replace\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">置換する文字。</param>
        <param name="newChar">
          <c>oldChar</c> を置換する文字。</param>
        <param name="startIndex">このインスタンスにおける部分文字列の開始位置。</param>
        <param name="count">部分文字列の長さ。</param>
        <summary>このインスタンスの部分文字列に出現するすべての指定した文字を、別の指定した文字に置換します。</summary>
        <returns>
          <paramref name="oldChar" /> から <paramref name="newChar" /> \+ <paramref name="startIndex" /> \-1 までの範囲内で、<paramref name="startIndex" /> が <paramref name="count" /> に置換されたこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの出現回数を識別するために序数に基づく小文字を区別する比較を実行する `oldChar` 現在のインスタンスに存在します。 現在のサイズ <xref:System.Text.StringBuilder> オブジェクトには、交換した後は変更されません。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Replace%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.replace\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> に <paramref name="count" /> を加算した値がこのインスタンスの長さを超えています。  
  
 または  
  
 <paramref name="startIndex" /> または <paramref name="count" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換する文字列。</param>
        <param name="newValue">
          <c>oldValue</c> を置換する文字列、または <see langword="null" />。</param>
        <param name="startIndex">このインスタンスにおける部分文字列の開始位置。</param>
        <param name="count">部分文字列の長さ。</param>
        <summary>このインスタンスの部分文字列に出現するすべての指定した文字列を、別の指定した文字列に置換します。</summary>
        <returns>
          <paramref name="startIndex" /> から <paramref name="startIndex" /> \+ <paramref name="count" /> 1 までの範囲内で、<paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> に置換されたこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの出現回数を識別するために序数に基づく小文字を区別する比較を実行する `oldValue` で指定した部分文字列。 場合 `newValue` は `null`または<xref:System.String.Empty?displayProperty=fullName>, 、出現するすべての `oldValue` が削除されます。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.StringBuilder.Replace%2A> メソッドです。  
  
 [!code-cpp[stringbuilder.replace\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> に<paramref name="count" /> を加算した値はこのインスタンスの範囲外の文字位置を示します。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">シリアル化情報が設定されるオブジェクト。</param>
        <param name="context">シリアル化データを格納および取得する場所。 将来使用するために予約されています。</param>
        <summary>
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクトに、現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの逆シリアル化に必要なデータを入力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `context` パラメーターは将来使用するために予約されて、この操作に参加しません。  
  
 詳細については、<xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=fullName> メソッドを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの値を <see cref="T:System.String" /> に変換します。</summary>
        <returns>このインスタンスと同じ値の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す必要があります、 <xref:System.Text.StringBuilder.ToString%2A> に変換する方法、 <xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> オブジェクトで表される文字列を渡す前に、 <xref:System.Text.StringBuilder> オブジェクトを持つメソッドを <xref:System.String> パラメーターまたはユーザー インターフェイスで表示します。  
  
   
  
## 例  
 次の例では、<xref:System.Text.StringBuilder.ToString%2A> メソッドを呼び出す方法を示しています。 この例に示されている例の一部である、 <xref:System.Text.StringBuilder> クラスです。  
  
 [!code-cpp[StringBuilder\#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder\#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の開始位置。</param>
        <param name="length">部分文字列の長さ。</param>
        <summary>このインスタンスの部分文字列の値を <see cref="T:System.String" /> に変換します。</summary>
        <returns>このインスタンスの指定した部分文字列と同じ値の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す必要があります、 <xref:System.Text.StringBuilder.ToString%2A> に変換する方法、 <xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> オブジェクトで表される文字列を渡す前に、 <xref:System.Text.StringBuilder> オブジェクトを持つメソッドを <xref:System.String> パラメーターまたはユーザー インターフェイスで表示します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
 \-または\-  
  
 <paramref name="startIndex" /> と <paramref name="length" /> の合計が、現在のインスタンスの長さより大きくなっています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたオブジェクトの文字列表記をこのインスタンスの指定された文字位置に挿入します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスに出現する指定文字または指定文字列をすべて、別に指定した文字または文字列に置換します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したオブジェクトの文字列形式をこのインスタンスに追加します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既定の行終端記号、または指定した文字列のコピーと既定の行終端記号を、このインスタンスの末尾に追加します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Text.StringBuilder" /> の値を <see cref="T:System.String" /> に変換します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>