<Type Name="UTF8Encoding" FullName="System.Text.UTF8Encoding">
  <TypeSignature Language="C#" Value="public class UTF8Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF8Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF8Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Unicode 文字の UTF\-8 エンコードを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 エンコーディングは、Unicode 文字のセットをバイト シーケンスに変換するプロセスです。 デコードは、Unicode 文字のセットにエンコードされたバイト シーケンスを変換するプロセスです。  
  
 UTF 8 では、エンコードを Unicode では、各コード ポイントを表す 1 ~ 4 バイトのシーケンスとして。 Utf\-16、utf\-32 エンコーディングとは異なり、utf\-8 エンコードでは「エンディアン」です。エンコード方式は、プロセッサは、ビッグ エンディアンまたはリトル エンディアンかどうかに関係なく同じです。<xref:System.Text.UTF8Encoding> Windows コード ページ 65001 に対応します。 詳細については、UTFs とでサポートされているその他のエンコーディングの <xref:System.Text>, を参照してください [Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)します。  
  
 インスタンスを作成できる、 <xref:System.Text.UTF8Encoding> するかどうか、バイト順マーク \(BOM\) を提供して、エラーの検出を有効にするかどうかに応じて、複数の方法の数のオブジェクト。 次の表に、コンス トラクターは、および <xref:System.Text.Encoding> プロパティを返す、 <xref:System.Text.UTF8Encoding> オブジェクトです。  
  
|メンバー|BOM|エラーの検出|  
|----------|---------|------------|  
|<xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName>|はい|なし \(置換フォールバック\)|  
|<xref:System.Text.UTF8Encoding.%23ctor?displayProperty=fullName>|いいえ|なし \(置換フォールバック\)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29?displayProperty=fullName>|構成可能|なし \(置換フォールバック\)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName>|構成可能|構成可能|  
  
 <xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 <xref:System.Text.UTF8Encoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。  
  
 同様に、 <xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドは、バイト シーケンスをデコード中に発生する文字数を決定し、 <xref:System.Text.UTF8Encoding.GetChars%2A> と <xref:System.Text.UTF8Encoding.GetString%2A> メソッドは、実際のデコードを実行します。  
  
 エンコーダーまたはデコーダー エンコードまたはデコード \(100,000 文字セグメントでエンコードされている 100万文字の文字列\) などの複数のブロックにわたるデータと状態情報を保存、使用することであるため、 <xref:System.Text.UTF8Encoding.GetEncoder%2A> と <xref:System.Text.UTF8Encoding.GetDecoder%2A> プロパティそれぞれします。  
  
 必要に応じて、 <xref:System.Text.UTF8Encoding> オブジェクトは、この場合、配列の先頭には、エンコーディング プロセスによって生成されるバイト ストリームの先頭にバイトのバイト順マーク \(BOM\) を提供します。 Utf\-8 エンコードされたバイト ストリームを先頭バイト順マーク \(BOM\) をバイト順および変換形式または UTF デコーダーのに役立ちます。 ただし、Unicode 標準では、どちらもないエンコードされたストリームを utf\-8 で BOM を推奨することに注意してください。 バイト順とバイト順マークの詳細についてで Unicode 標準を参照してください、 [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123)します。  
  
 エンコーダーが BOM を提供する構成されている場合は、呼び出すことによって取得できる、 <xref:System.Text.UTF8Encoding.GetPreamble%2A> メソッドです。 それ以外の場合、メソッドが空の配列を返します。 なお、場合でも、 <xref:System.Text.UTF8Encoding> オブジェクトは、BOM サポートのために構成されている、必要に応じて、エンコードされたバイト ストリームの先頭に BOM を含める必要がありますのエンコード方法、 <xref:System.Text.UTF8Encoding> クラスしないで自動的にします。  
  
> [!NOTE]
>  エラーの検出を有効にして、クラスのインスタンスのセキュリティを強化するを呼び出す必要があります、 <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> コンス トラクターと、 `throwOnInvalidBytes` パラメーターを `true`します。 エラーの検出が有効になっている、無効な文字またはバイトのシーケンスを検出するメソッドがスローされます、 <xref:System.ArgumentException> 例外です。 エラー検出例外はスローされませんし、無効なシーケンスが通常は無視されます。  
  
> [!NOTE]
>  オブジェクトはシリアル化され、別の .NET Framework のバージョンを使用して逆シリアル化される場合は、utf\-8 でエンコードされたオブジェクトの状態は保持されません。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.UTF8Encoding> Unicode 文字の文字列をエンコードおよびバイト配列内に格納するオブジェクト。 Unicode 文字列には、Pi \(U \+ 03A0\) およびシグマ \(U \+ 03A3\)、ASCII 文字の範囲外にある 2 つの文字が含まれています。 エンコードされたバイト配列を文字列にデコード時 Pi およびシグマ文字がまだ存在します。  
  
 [!code-cpp[System.Text.UTF8Encoding Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF8Encoding Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/snippet.vb#1)]  
  
 次の例は、ファイルにエンコードされたバイトを書き込みます、バイト ストリームにバイト順マーク \(BOM\) をプレフィックスする点を除いて、前の例では、として同じ文字列を使用します。 これは、後、2 つの方法で、ファイルを読み取ります: を使用してテキスト ファイルとして、 <xref:System.IO.StreamReader> オブジェクトおよびバイナリ ファイルです。 想定されるように、どちらの場合には、BOM が含まれて新しく読み取られた文字列には。  
  
 [!code-csharp[System.Text.UTF8Encoding Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UTF8Encoding Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Text.UTF8Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは、Unicode バイト順マークを提供しないと、無効なエンコードが検出されると、例外をスローしませんが、インスタンスを作成します。  
  
> [!NOTE]
>  セキュリティ上の理由をお勧めのコンス トラクターを呼び出すことによって、エラーの検出を有効にすること、 `throwOnInvalidBytes` パラメーターその値を設定して `true`します。  
  
   
  
## 例  
 次の例が、新たに作成 <xref:System.Text.UTF8Encoding> をインスタンス化し、その名前が表示されます。  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> メソッドが Unicode バイト順マークを返すよう指定する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 詳細については、「解説」を参照してください。</param>
        <summary>
          <see cref="T:System.Text.UTF8Encoding" /> クラスの新しいインスタンスを初期化します。 Unicode バイト順マークを付加するかどうかを指定するパラメーター。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターでは、無効なエンコードが検出されると、例外をスローしないインスタンスを作成します。  
  
> [!NOTE]
>  セキュリティ上の理由を含むコンス トラクターを呼び出すことによってエラー検出を有効に.、 `throwOnInvalidBytes` パラメーターその値を設定して `true`します。  
  
 `encoderShouldEmitUTF8Identifier` パラメーターの動作を制御する、 <xref:System.Text.UTF8Encoding.GetPreamble%2A> メソッドです。 場合 `true`, 、utf\-8 形式で Unicode バイト順マーク \(BOM\) を格納するバイト配列を返します。  場合 `false`, 、長さ 0 バイトの配列を返します。 ただし、設定 `encoderShouldEmitUTF8Identifier` に `true` は伴いません、 <xref:System.Text.UTF8Encoding.GetBytes%2A> とプレフィックスのバイト配列の先頭に BOM メソッド発生しても、 <xref:System.Text.UTF8Encoding.GetByteCount%2A> をバイト数の BOM でバイト数を含める方法です。  
  
   
  
## 例  
 次の例が、新たに作成 <xref:System.Text.UTF8Encoding> をインスタンス化し Unicode バイト順マークのプリフィックスを出力するように指定、 <xref:System.Text.UTF8Encoding.GetPreamble%2A> メソッドです。<xref:System.Text.UTF8Encoding.GetPreamble%2A> メソッドは、Unicode バイト順マーク プリフィックスを返します。  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> メソッドが Unicode バイト順マークを返すよう指定する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 詳細については、「解説」を参照してください。</param>
        <param name="throwOnInvalidBytes">無効なエンコードが検出されたときに例外をスローする場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Text.UTF8Encoding" /> クラスの新しいインスタンスを初期化します。 パラメーターでは、Unicode バイト順マークを付加するかどうか、および無効なエンコードが検出されたときに例外をスローするかどうかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `encoderShouldEmitUTF8Identifier` パラメーターの動作を制御する、 <xref:System.Text.UTF8Encoding.GetPreamble%2A> メソッドです。 場合 `true`, 、utf\-8 形式で Unicode バイト順マーク \(BOM\) を格納するバイト配列を返します。  場合 `false`, 、長さ 0 バイトの配列を返します。 ただし、設定 `encoderShouldEmitUTF8Identifier` に `true` は伴いません、 <xref:System.Text.UTF8Encoding.GetBytes%2A> とプレフィックスのバイト配列の先頭に BOM メソッド発生しても、 <xref:System.Text.UTF8Encoding.GetByteCount%2A> をバイト数の BOM でバイト数を含める方法です。  
  
 場合 `throwOnInvalidBytes` は `true`, 、無効なバイト シーケンスを検出するメソッドがスロー、 <xref:System.ArgumentException?displayProperty=fullName> 例外です。 それ以外の場合、メソッドは、例外をスローしていないと、順序が無効ですが無視されます。  
  
> [!NOTE]
>  セキュリティ上の理由を含むコンス トラクターを呼び出すことによってエラー検出を有効に.、 `throwOnInvalidBytes` パラメーターとそのパラメーターを設定 `true`します。  
  
   
  
## 例  
 次の例が、新たに作成 <xref:System.Text.UTF8Encoding> ことを指定するインスタンス、 <xref:System.Text.UTF8Encoding.GetPreamble%2A> メソッドでは、Unicode バイト順マーク プリフィックスは生成されないようにし、無効なエンコードが検出されたときに例外がスローする必要があります。 このコンス トラクターの動作は、既定値と比較 <xref:System.Text.UTF8Encoding.%23ctor> コンス トラクターは、無効なエンコードが検出されると、例外をスローしません。 2 つ <xref:System.Text.UTF8Encoding> インスタンスが無効な文字シーケンスである行で 2 つの高サロゲート \(U \+ D801 と U \+ D802\) を格納した文字配列をエンコード; 上位サロゲートは、下位サロゲートで常に従ってください。  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor3 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor3 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のインスタンスと比較するオブジェクト。</param>
        <summary>指定したオブジェクトが、現在の <see cref="T:System.Text.UTF8Encoding" /> オブジェクトと等しいかどうかを判断します。</summary>
        <returns>
          <paramref name="value" /> が <see cref="T:System.Text.UTF8Encoding" /> のインスタンスで、現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 2 つ <xref:System.Text.UTF8Encoding> オブジェクトは、次の条件がすべて当てはまる場合に等価と見なされます。  
  
-   両方のオブジェクトのバイト順マークを提供するかどうか。  
  
-   両方のオブジェクトは、同じエンコーダー フォールバックを使用します。  
  
-   両方のオブジェクトは、同じデコーダーのフォールバックを使用します。  
  
   
  
## 例  
 次の例で、 <xref:System.Text.UTF8Encoding.Equals%2A> メソッドをテストするかどうか、現在 <xref:System.Text.UTF8Encoding> オブジェクトが別のサーバーに対する <xref:System.Text.UTF8Encoding> オブジェクトです。 次の 4 つ <xref:System.Text.UTF8Encoding> オブジェクトが作成され、比較し、比較の結果が表示されます。  
  
 [!code-cpp[System.Text.UTF8Encoding.Equals Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CPP/equals-object.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.Equals Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CS/equals-object.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.Equals Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/VB/equals-object.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している <see cref="T:System.String" />。</param>
        <summary>指定した <see cref="T:System.String" /> 内の文字をエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.UTF8Encoding.GetBytes%2A> 結果のバイトを格納するを呼び出す、 <xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 <xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など一連のファイルに書き込まれるバイト数の先頭にある\) は、開発者の責任であり、preamble のバイト数はによって返される値に反映されず、 <xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> と <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> 、文字列をエンコードするために必要なバイトの最大値と実際の数を計算する方法です。 また、実際のバイト ストリームにバイト オーダー マークの保存に必要なバイト数も表示されます。  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">結果のバイト数は、整数値として返すことができる最大数を超えています。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になっていると <paramref name="chars" /> 、無効な文字のシーケンスが含まれています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>指定した文字ポインターで始まる文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する、 <xref:System.Text.UTF8Encoding.GetBytes%2A> 結果のバイトを格納するメソッドを呼び出す、 <xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 <xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など一連のファイルに書き込まれるバイト数の先頭にある\) は、開発者の責任であり、preamble のバイト数はによって返される値に反映されず、 <xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="chars" /> に無効な文字のシーケンスが含まれています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(を参照してください [Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9) の詳しい説明について\)  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>指定した文字配列から文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetByteCount メソッド \(Char\<xref:System.Text.UTF8Encoding.GetBytes%2A> の使用を呼び出して結果のバイトを格納する [GetByteCount メソッド \(Char\<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 [GetByteCount メソッド \(Char\<xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドです。[GetByteCount メソッド \(Char\<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 [GetByteCount メソッド \(Char\<xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 [GetByteCount メソッド \(Char\<xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など一連のファイルに書き込まれるバイト数の先頭にある\) は、開発者の責任であり、preamble のバイト数はによって返される値に反映されず、 [GetByteCount メソッド \(Char\<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。  
  
   
  
## 例  
 ラテン文字の大文字を持つ配列と文字の小文字と呼び出しを設定する例を次の [GetByteCount メソッド \(Char\<xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ラテン文字の小文字の文字をエンコードするために必要なバイト数を決定する方法です。 バイト順マークが追加された場合に必要なバイトの合計数と共にこの情報が表示されます。 この番号によって返される値を比較して、 [GetByteCount メソッド \(Char\<xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドで、ラテン文字の小文字の文字をエンコードするために必要なバイトの最大数を示します。  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になっていると <paramref name="chars" /> 、無効な文字のシーケンスが含まれています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> プロパティが <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されている。</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスの書き込みを開始する位置へのポインター。</param>
        <param name="byteCount">書き込む最大バイト数。</param>
        <summary>指定した文字ポインターで始まる文字のセットを、指定したバイト ポインターを開始位置として格納されるバイト シーケンスにエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> によって示される位置に書き込まれる実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.UTF8Encoding.GetBytes%2A> 結果のバイトを格納するを呼び出す、 <xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 <xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合を使用して、 <xref:System.Text.Decoder> または <xref:System.Text.Encoder> によって返される、 <xref:System.Text.UTF8Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.UTF8Encoding.GetEncoder%2A> メソッドをそれぞれします。  
  
 ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など、一連のファイルに書き込まれるバイト数の先頭にある\) 開発者の責任です。<xref:System.Text.UTF8Encoding.GetBytes%2A> メソッドはエンコードされたバイト シーケンスの先頭に preamble を追加しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="chars" /> に無効な文字のシーケンスが含まれています。  
  
 または  
  
 <paramref name="byteCount" /> 結果のバイト数より少ない。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <summary>指定した文字配列に格納されている文字のセットを指定したバイト配列にエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetBytes%2A> 結果のバイトを格納するを呼び出す、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドです。[GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合を使用して、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Decoder> または [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder> によって提供される、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetDecoder%2A> メソッドまたは [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetEncoder%2A> メソッドをそれぞれします。  
  
 ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など、一連のファイルに書き込まれるバイト数の先頭にある\) 開発者の責任です。[GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetBytes%2A> メソッドはエンコードされたバイト シーケンスの先頭に preamble を追加しません。  
  
   
  
## 例  
 次の例では、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetBytes%2A> とストアのバイト配列の要素の範囲内でエンコードされたバイトの文字列から文字の範囲をエンコードする方法です。  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes3 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes3 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> または <paramref name="charCount" /> または <paramref name="byteIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
 または  
  
 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="chars" /> に無効な文字のシーケンスが含まれています。  
  
 または  
  
 <paramref name="bytes" /> 十分な容量がない <paramref name="byteIndex" /> に結果のバイトを合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">エンコード対象の文字のセットを格納している <see cref="T:System.String" />。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <summary>指定した <see cref="T:System.String" /> の文字セットを、指定したバイト配列にエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetBytes%2A> 結果のバイトを格納するを呼び出す、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドです。[GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合を使用して、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Decoder> または [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoder> によって提供される、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetDecoder%2A> メソッドまたは [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetEncoder%2A> メソッドをそれぞれします。  
  
 ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など、一連のファイルに書き込まれるバイト数の先頭にある\) 開発者の責任です。[GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetBytes%2A> メソッドはエンコードされたバイト シーケンスの先頭に preamble を追加しません。  
  
   
  
## 例  
 次の例では、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UTF8Encoding.GetBytes%2A> 一連の Unicode 文字配列から要素をエンコードおよびバイト配列の要素の範囲内でエンコードされたバイトを格納する方法です。  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> または <paramref name="charCount" /> または <paramref name="byteIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
 または  
  
 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="s" /> に無効な文字のシーケンスが含まれています。  
  
 または  
  
 <paramref name="bytes" /> 十分な容量がない <paramref name="byteIndex" /> に結果のバイトを合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>指定したバイト ポインターで始まるバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.UTF8Encoding.GetChars%2A> 結果の文字を格納する、 <xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> メソッドです。<xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 <xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="bytes" /> に無効なバイト シーケンスが含まれています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>指定したバイト配列からバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetCharCount メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetChars%2A> 結果の文字を格納する、 [GetCharCount メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 [GetCharCount メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> メソッドです。[GetCharCount メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 [GetCharCount メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 [GetCharCount メソッド \(Byte\<xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
   
  
## 例  
 次の例で、 [GetCharCount メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetCharCount%2A> バイト配列の要素の範囲をデコードして文字数を返すメソッドが発生しました。  
  
 [!code-cpp[System.Text.UTF8Encoding.GetCharCount Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetCharCount Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetCharCount Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="bytes" /> に無効なバイト シーケンスが含まれています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字セットの書き込みを開始する位置へのポインター。</param>
        <param name="charCount">書き込む文字の最大数。</param>
        <summary>指定したバイト ポインターで始まるバイト シーケンスを、指定した文字ポインターを開始位置として格納される文字のセットにデコードします。</summary>
        <returns>
          <paramref name="chars" /> によって示される位置に書き込まれる実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.UTF8Encoding.GetChars%2A> 結果の文字を格納する、 <xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> メソッドです。<xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 <xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 デコードするバイトの範囲には、バイト順マーク \(BOM\) が含まれているバイト配列が BOM で非対応型のメソッドによって返された場合は、このメソッドによって返される文字配列には文字 U \+ FFFE が含まれます。 これを削除するには呼び出すことによって、 <xref:System.String.TrimStart%2A?displayProperty=fullName> メソッドです。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合を使用して、 <xref:System.Text.Decoder> または <xref:System.Text.Encoder> オブジェクトによって提供される、 <xref:System.Text.UTF8Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.UTF8Encoding.GetEncoder%2A> メソッドをそれぞれします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> または <paramref name="charCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="bytes" /> に無効なバイト シーケンスが含まれています。  
  
 または  
  
 <paramref name="charCount" /> 結果の文字数より少ない。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="byteIndex">デコードする最初のバイトのインデックス。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字のセットを格納する文字配列。</param>
        <param name="charIndex">結果の文字のセットを書き込む開始位置のインデックス。</param>
        <summary>指定したバイト配列に格納されているバイト シーケンスを指定した文字配列にデコードします。</summary>
        <returns>
          <paramref name="chars" /> に書き込まれた実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UTF8Encoding.GetChars%2A> 結果の文字を格納する、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> メソッドです。[GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 デコードするバイトの範囲には、バイト順マーク \(BOM\) が含まれているバイト配列が BOM で非対応型のメソッドによって返された場合は、このメソッドによって返される文字配列には文字 U \+ FFFE が含まれます。 これを削除するには呼び出すことによって、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.String.TrimStart%2A?displayProperty=fullName> メソッドです。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合を使用して、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Decoder> または [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoder> によって提供される、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UTF8Encoding.GetDecoder%2A> メソッドまたは [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UTF8Encoding.GetEncoder%2A> メソッドをそれぞれします。  
  
   
  
## 例  
 次の例では、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UTF8Encoding.GetChars%2A> メソッドをバイト配列の要素の範囲をデコードし、結果を文字配列に格納します。  
  
 [!code-cpp[System.Text.UTF8Encoding.GetChars Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetChars Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetChars Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> または <paramref name="byteCount" /> または <paramref name="charIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="byteindex" /> <paramref name="byteCount" /> で有効な範囲を表していません <paramref name="bytes" />します。  
  
 または  
  
 <paramref name="charIndex" /> が <paramref name="chars" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="bytes" /> に無効なバイト シーケンスが含まれています。  
  
 または  
  
 <paramref name="chars" /> 十分な容量がない <paramref name="charIndex" /> に結果の文字を合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetDecoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>UTF\-8 でエンコードされたバイト シーケンスを Unicode 文字のシーケンスに変換するデコーダーを取得します。</summary>
        <returns>UTF\-8 でエンコードされたバイト シーケンスを Unicode 文字のシーケンスに変換するデコーダー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> メソッドと同様の方法での文字の連続ブロックにバイトの連続したブロックを変換する、 <xref:System.Text.UTF8Encoding.GetChars%2A> このクラスのメソッドです。 ただし、 <xref:System.Text.Decoder> ブロックにまたがるバイト シーケンスを正しくデコードすることができますので、呼び出しの間で状態情報を保持します。<xref:System.Text.Decoder> もデータ ブロックの末尾にある末尾のバイトを保持し、次のデコード操作で末尾のバイトを使用します。 したがって、 <xref:System.Text.UTF8Encoding.GetDecoder%2A> と <xref:System.Text.UTF8Encoding.GetEncoder%2A> の完全なデータ ストリームではなくデータ ブロックを頻繁にこれらの操作を処理するためには、ネットワーク転送とファイルの操作に便利です。  
  
 かどうかはエラー検出が有効な場合は、 `throwOnInvalidCharacters` にコンス トラクターのパラメーターが設定されている `true`, でエラーの検出が有効にも、 <xref:System.Text.Decoder> このメソッドによって返されます。 エラーの検出を有効にし、無効なシーケンスが発生した場合は、デコーダーの状態は未定義と処理を停止する必要があります。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.UTF8Encoding.GetDecoder%2A> を utf\-8 デコーダーを取得します。 デコーダーでは、文字のシーケンスにバイト シーケンスに変換します。  
  
 [!code-cpp[System.Text.UTF8Encoding.GetDecoder Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetDecoder Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetDecoder Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetEncoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unicode 文字のシーケンスを UTF\-8 でエンコードされたバイト シーケンスに変換するエンコーダーを取得します。</summary>
        <returns>Unicode 文字のシーケンスを UTF\-8 でエンコードされたバイト シーケンスに変換する <see cref="T:System.Text.Encoder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドと同様の方法のバイト数の連続ブロックに文字の連続したブロックを変換する、 <xref:System.Text.UTF8Encoding.GetBytes%2A> メソッドです。 ただし、 <xref:System.Text.Encoder> ブロックにまたがる文字のシーケンスを正しくエンコードすることができますので、呼び出しの間で状態情報を保持します。<xref:System.Text.Encoder> も保持末尾のデータ ブロックの末尾に文字を使用して末尾の文字の次のエンコード操作します。 たとえば、データ ブロックが上位サロゲートで終了し、一致する下位サロゲートが次のデータ ブロックしていることがあります。 したがって、 <xref:System.Text.UTF8Encoding.GetDecoder%2A> と <xref:System.Text.UTF8Encoding.GetEncoder%2A> の完全なデータ ストリームではなくデータ ブロックを頻繁にこれらの操作を処理するためには、ネットワーク転送とファイルの操作に便利です。  
  
 かどうかはエラー検出が有効な場合は、 `throwOnInvalidCharacters` にコンス トラクターのパラメーターが設定されている `true`, でエラーの検出が有効にも、 <xref:System.Text.Encoder> このメソッドによって返されます。 エラーの検出を有効にし、無効なシーケンスが発生した場合は、エンコーダーの状態は未定義と処理を停止する必要があります。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.UTF8Encoding.GetEncoder%2A> でエンコードされたバイト シーケンスを文字のシーケンスを utf\-8 に変換するエンコーダーを取得します。  
  
 [!code-cpp[System.Text.UTF8Encoding.GetEncoder Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetEncoder Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetEncoder Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスのハッシュ コードを返します。</summary>
        <returns>現在のインスタンスのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、 <xref:System.Text.UTF8Encoding.GetHashCode%2A> のハッシュ コードを返すメソッドを <xref:System.Text.UTF8Encoding> インスタンス。 このメソッドによって返されたハッシュ コードを作成に使用されるコンス トラクターに依存していることに注意してください、 <xref:System.Text.UTF8Encoding> オブジェクトです。  
  
 [!code-cpp[System.Text.UTF8Encoding.GetHashCode Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CPP/gethashcode-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetHashCode Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CS/gethashcode-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetHashCode Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/VB/gethashcode-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">エンコードする文字数。</param>
        <summary>指定した文字数をエンコードすることによって生成される最大バイト数を計算します。</summary>
        <returns>指定した文字数をエンコードすることによって生成される最大バイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.UTF8Encoding.GetBytes%2A> 結果のバイトを格納するを呼び出す、 <xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> 現在選択されている最悪のケースを含む、最悪のケースの数は、 <xref:System.Text.EncoderFallback>です。 フォールバックが大きくなる可能性の文字列で選択した場合 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> 大きな値を返すことができます。  
  
 ほとんどの場合は、このメソッドは、短い文字列では適切な数値を返します。 大きな文字列の場合に、非常に大きなバッファーを使用してより適切なバッファーを超えているというまれなケースでエラーの検出を選択する必要があります。 別のアプローチの使用を検討することも <xref:System.Text.UTF8Encoding.GetByteCount%2A> または <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>です。 たとえば、英語とその他の多くの言語でテキストには、文字を表現する utf\-8 バイトが 1 つだけ多くの場合、必要がありますがによって返される数 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> できる可能性がある文字列を変換できますの 4 バイトする必要のある文字だけで構成されることにします。  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> 関係を持たない <xref:System.Text.UTF8Encoding.GetChars%2A>します。 使用する類似の機能が、アプリケーションに必要なかどうかは <xref:System.Text.UTF8Encoding.GetChars%2A>, 、それを使用する必要があります <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>します。  
  
> [!NOTE]
>  `GetMaxByteCount(N)` 同じ値とは限りません `N* GetMaxByteCount(1)`します。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> メソッドを指定した文字数をエンコードするために必要なバイトの最大数を取得します。  
  
 [!code-cpp[System.Text.utf8encoding.getmaxbytecount example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.utf8encoding.getmaxbytecount example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.utf8encoding.getmaxbytecount example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> が 0 未満です。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">デコードするバイト数。</param>
        <summary>指定したバイト数をデコードすることによって生成される最大文字数を計算します。</summary>
        <returns>指定したバイト数をデコードすることによって生成される最大文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.UTF8Encoding.GetChars%2A> 結果の文字を格納するを呼び出す、 <xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> メソッドです。<xref:System.Text.UTF8Encoding.GetCharCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> 現在選択されている最悪のケースを含む、最悪のケースの数は、 <xref:System.Text.DecoderFallback>です。 フォールバックが大きくなる可能性の文字列で選択した場合 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> 大きな値を返すことができます。  
  
 ほとんどの場合は、このメソッドは、短い文字列では適切な数値を返します。 大きな文字列の場合に、非常に大きなバッファーを使用してより適切なバッファーを超えているというまれなケースでエラーの検出を選択する必要があります。  別のアプローチの使用を検討することも <xref:System.Text.UTF8Encoding.GetCharCount%2A> または <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>です。  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> 関係を持たない <xref:System.Text.UTF8Encoding.GetBytes%2A>します。 使用する類似の機能が、アプリケーションに必要なかどうかは <xref:System.Text.UTF8Encoding.GetBytes%2A>, 、それを使用する必要があります <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>します。  
  
> [!NOTE]
>  `GetMaxCharCount(N)` 同じ値とは限りません `N* GetMaxCharCount(1)`します。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> 最大文字数を返すメソッドが指定したバイト数をデコードして生成されました。  
  
 [!code-cpp[System.Text.UTF8Encoding.GetMaxCharCount Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetMaxCharCount Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetMaxCharCount Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> が 0 未満です。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetPreamble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Text.UTF8Encoding" /> エンコード オブジェクトが UTF\-8 形式でエンコードされた Unicode バイト順マークを提供するように構成されている場合、そのようなマークが返されます。</summary>
        <returns>
          <see cref="T:System.Text.UTF8Encoding" /> エンコード オブジェクトが Unicode バイト順マークを提供するように構成されている場合、そうしたマークが格納されているバイト配列。 それ以外の場合、このメソッドは長さがゼロのバイト配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.UTF8Encoding> オブジェクトが提供できる、preamble では、バイト配列の先頭には、エンコーディング プロセスに起因するバイト シーケンスです。 バイト順マーク \(コード ポイント U\+FEFF\) でエンコードされたバイト シーケンスの先頭には、バイト順および変換形式または UTF デコーダーことができます。 Unicode バイト順マーク \(BOM\) が 0xEF としてシリアル化 0xBB 0xBF します。 どちらが必要なありません BOM utf\-8 を使用することをお勧めの Unicode 標準にストリームがエンコードされていることに注意してください。  
  
 インスタンスを作成できる、 <xref:System.Text.UTF8Encoding> オブジェクト <xref:System.Text.UTF8Encoding.GetPreamble%2A> メソッドは、次の方法で有効な BOM を返します。  
  
-   取得することによって、 <xref:System.Text.UTF8Encoding> によって返されるオブジェクト、 <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> プロパティです。  
  
-   呼び出して、 <xref:System.Text.UTF8Encoding> を持つコンス トラクター、 `encoderShouldEmitUTF8Identifier` パラメーターとその値に設定を設定する `true`です。  
  
 他のすべての <xref:System.Text.UTF8Encoding> オブジェクトは有効な BOM ではなく、空の配列を返すようにします。  
  
 タグ付けされていないか、不適切なタグが付けられた web などデータまたはおランダムなテキスト ファイルがありませんでした国際的な懸念事項、BOM は、それ以外の場合、エンコードへの参照が失われているファイルのエンコーディングの特定の id にほぼを提供します。 データが一貫して適切なタグとは、多くの場合、ユーザーの問題を回避できる可能性があります。  
  
 エンコードの種類を定義した標準から、BOM は、少し冗長です。 ただし、適切なエンコードのヘッダーを送信するサーバーのヘルプを使用できます。 または、そのとして使用できます、フォールバック エンコーディングが失われたそれ以外の場合に備えてします。  
  
 BOM を使用するいくつかのデメリットがあります。 たとえば、BOM を使用するデータベース フィールドを制限する方法についての知識が難しくなります。 ファイルの連結問題になる場合も、たとえば、ファイルを結合するようにデータの途中で不要な文字は最終的にする方法です。 いくつかの短所にもかかわらずただし、部品表の使用強くお勧めします。  
  
 バイト順とバイト順マークの詳細についてで Unicode 標準を参照してください、 [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123)します。  
  
> [!CAUTION]
>  ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードするためには、プリアンブルでエンコードされたバイトのストリームの先頭を先頭に付加することができます。 なお、 <xref:System.Text.UTF8Encoding.GetBytes%2A> メソッドでエンコードされたバイト シーケンスに BOM が追加しません。 開発者の責任は、適切なバイト ストリームの先頭に BOM を指定することです。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.UTF8Encoding.GetPreamble%2A> Unicode のバイトを返すメソッドが utf\-8 形式でエンコードされたマークを注文します。 注意して、既定のコンス トラクター <xref:System.Text.UTF8Encoding> 、preamble を行いません。  
  
 [!code-cpp[System.Text.UTF8Encoding.GetPreamble Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 次の例では、2 つをインスタンス化 <xref:System.Text.UTF8Encoding> オブジェクト、最初のパラメーターなしで呼び出すことによって <xref:System.Text.UTF8Encoding.%23ctor> コンス トラクターは、呼び出すことによって、BOM や、2 つ目を提供しない、 <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29> を持つコンス トラクターの `encoderShouldEmitUTF8Identifier` 引数に設定されて `true`します。 呼び出して、 <xref:System.Text.UTF8Encoding.GetPreamble%2A> UF8 でエンコードされた文字列を書き込む前に、ファイルには BOM を書き込みます。 コンソール出力の例に示すように、2 つ目のエンコーダーからのバイトを保存するファイルは最初より多いバイト数の 3 つにあります。  
  
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/cs/getpreamble1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/vb/getpreamble1.vb#1)]  
  
 You can also compare the files by using the **languageKeyword tag is not supported!!!!**  
 command in a console window, or you can inspect the files in a text editor that includes a Hex View mode. Note that when the file is opened in an editor that supports UTF\-8, the BOM is not displayed.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>バイト配列に格納されているある範囲のバイトを文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている <see cref="T:System.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 [GetString メソッド \(Byte\<xref:System.ArgumentException> 例外です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 デコードするバイトの範囲には、バイト順マーク \(BOM\) が含まれているバイト配列が BOM で非対応型のメソッドによって返された場合は、このメソッドによって返される文字配列には文字 U \+ FFFE が含まれます。 これを削除するには呼び出すことによって、 [GetString メソッド \(Byte\<xref:System.String.TrimStart%2A?displayProperty=fullName> メソッドです。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合を使用して、 [GetString メソッド \(Byte\<xref:System.Text.Decoder> または [GetString メソッド \(Byte\<xref:System.Text.Encoder> によって提供される、 [GetString メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetDecoder%2A> メソッドまたは [GetString メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetEncoder%2A> メソッドをそれぞれします。  
  
   
  
## 例  
 次の例では、配列を初期化を呼び出して、 [GetString メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetByteCount%2A> バイト数をエンコードされた文字列とバイト順マーク \(BOM\) のサイズを追加するために必要な正確に決定する方法です。 次の [GetString メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetPreamble%2A> は BOM を呼び出す前に、配列を格納する方法、 [GetString メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetBytes%2A> 配列にエンコードされたバイトを格納するメソッドです。 次の [GetString メソッド \(Byte\<xref:System.Text.UTF8Encoding.GetString%2A> 文字列をデコードする方法です。  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Note that in this case the decoded string differs from the original string, since it begins with a 16\-bit byte order mark U\+FFFD. This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?". To remove the BOM at the beginning of the string, you can call the [GetString メソッド \(Byte\<xref:System.String.TrimStart%2A?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="bytes" /> に無効なバイト シーケンスが含まれています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Text.UTF8Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>文字のセットをバイト シーケンスにエンコードします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイト シーケンスを文字のセットにデコードします。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>