<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Unicode 文字の UTF\-16 エンコーディングを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 エンコーディングは、Unicode 文字のセットをバイト シーケンスに変換するプロセスです。 デコードは、Unicode 文字のセットにエンコードされたバイト シーケンスを変換するプロセスです。  
  
 [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) コード ポイント \(数値\) をすべてサポートされているスクリプト内の各文字に割り当てます。 Unicode 変換形式 \(UTF\) は、そのコード ポイントをエンコードする方法です。[Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) 次 UTFs を使用します。  
  
-   Utf\-8、各コード ポイントを 1 ~ 4 バイトのシーケンスとして表します。  
  
-   Utf\-16、各コード ポイントを 1 ~ 2 の 16 ビット整数のシーケンスとして表現します。  
  
-   Utf\-32、32 ビット整数として各コード ポイントを表します。  
  
 詳細については、UTFs とでサポートされているその他のエンコーディングの <xref:System.Text>, を参照してください [Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)します。  
  
 <xref:System.Text.UnicodeEncoding> クラスは、utf\-16 エンコーディングを表します。 エンコーダーは、ビッグ エンディアン バイト順を使用できます \(最上位バイト最初\) またはリトル エンディアン バイト順 \(最下位バイト最初\)。 たとえば、アルファベットの大文字 a \(コード ポイント u\+0041\) としてシリアル化された次のように 16 進数\)。  
  
-   ビッグ エンディアン バイト順: 00 00 00 41  
  
-   リトル エンディアン バイト順: 41 00 00 00  
  
 これは、特定のプラットフォームのネイティブなバイト順を使用する Unicode 文字を格納する方が効率的です。 たとえば、intel ベースのコンピューターなど、リトル エンディアンのプラットフォームでリトル エンディアン バイト順を使用することをお勧めします。<xref:System.Text.UnicodeEncoding> クラスは、Windows コード ページ 1200 \(リトル エンディアン バイト順\) と 1201 \(ビッグ エンディアン バイト順\) に対応します。 呼び出して、特定のアーキテクチャ「エンディアン」を指定できます、 <xref:System.BitConverter.IsLittleEndian?displayProperty=fullName> メソッドです。  
  
 必要に応じて、 <xref:System.Text.UnicodeEncoding> オブジェクトは、この場合、配列の先頭には、エンコーディング プロセスに起因するバイトのシーケンスをバイト数のバイト順マーク \(BOM\) を提供します。 プリアンブルにバイト順マーク \(BOM\) が含まれている場合、バイト順および変換形式または UTF デコーダーが役立ちます。  
  
 場合、 <xref:System.Text.UnicodeEncoding> BOM を提供するインスタンスが構成されているを呼び出して取得することができます、 <xref:System.Text.UnicodeEncoding.GetPreamble%2A> メソッドです。 それ以外の場合、メソッドが空の配列を返します。 なお、場合でも、 <xref:System.Text.UnicodeEncoding> オブジェクトは、BOM サポートのために構成されている、必要に応じて、エンコードされたバイト ストリームの先頭に BOM を含める必要がありますのエンコード方法、 <xref:System.Text.UnicodeEncoding> クラスしないで自動的にします。  
  
 エラーの検出を有効にして、クラスのインスタンスのセキュリティを強化するには、インスタンスを作成、 <xref:System.Text.UnicodeEncoding> オブジェクトを呼び出して、 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> コンス トラクターと設定、 `throwOnInvalidBytes` への引数 `true`します。 エラーの検出、無効な文字またはバイトのシーケンスを検出するメソッドがスローされます、 <xref:System.ArgumentException>です。 エラー検出例外はスローされませんし、無効なシーケンスが通常は無視されます。  
  
 インスタンスを作成できる、 <xref:System.Text.UnicodeEncoding> オブジェクトは、さまざまな方法でするかどうか、バイト順マーク \(BOM\) を提供する、ビッグ エンディアンまたはリトル エンディアン エンコーディングするかどうか、およびエラーの検出を有効にするかどうかによって異なります。 次の表に、 <xref:System.Text.UnicodeEncoding> コンス トラクターと <xref:System.Text.Encoding> を返すプロパティ、 <xref:System.Text.UnicodeEncoding> オブジェクトです。  
  
|メンバー|エンディアン|BOM|エラーの検出|  
|----------|------------|---------|------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|ビッグ エンディアン|はい|なし \(置換フォールバック\)|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=fullName>|リトル エンディアン|はい|なし \(置換フォールバック\)|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=fullName>|リトル エンディアン|はい|なし \(置換フォールバック\)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|構成可能|構成可能|なし \(置換フォールバック\)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName>|構成可能|構成可能|構成可能|  
  
 <xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 <xref:System.Text.UnicodeEncoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。  
  
 同様に、 <xref:System.Text.UnicodeEncoding.GetCharCount%2A> メソッドは、バイト シーケンスをデコード中に発生する文字数を決定し、 <xref:System.Text.UnicodeEncoding.GetChars%2A> と <xref:System.Text.UnicodeEncoding.GetString%2A> メソッドは、実際のデコードを実行します。  
  
 エンコーダーまたはデコーダー エンコードまたはデコード \(100,000 文字セグメントでエンコードされている 100万文字の文字列\) などの複数のブロックにわたるデータと状態情報を保存、使用することであるため、 <xref:System.Text.UnicodeEncoding.GetEncoder%2A> と <xref:System.Text.UnicodeEncoding.GetDecoder%2A> プロパティそれぞれします。  
  
   
  
## 例  
 次の例では、バイト配列を使用して Unicode 文字の文字列をエンコードする方法、 <xref:System.Text.UnicodeEncoding> オブジェクトです。 バイト配列は、データの損失がないことを示すために文字列にデコードされます。  
  
 [!code-cpp[System.Text.UnicodeEncoding Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 点を除いて、ファイルにエンコードされたバイトを書き込み、バイト順マーク \(BOM\) をバイト ストリームの前に、次の例は前の項目と同じ文字列を使用します。 これは、後、2 つの方法で、ファイルを読み取ります: を使用してテキスト ファイルとして、 <xref:System.IO.StreamReader> オブジェクトおよびバイナリ ファイルです。 想定されるように、どちらの場合には、BOM が含まれて新しく読み取られた文字列には。  
  
 [!code-csharp[System.Text.UnicodeEncoding Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Text.UnicodeEncoding" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターでは、リトル エンディアン バイト順を使用して、Unicode バイト順マークを提供し、無効なエンコードが検出されると、例外をスローしないインスタンスを作成します。  
  
> [!NOTE]
>  セキュリティ上の理由を呼び出してエラーの検出を有効に.、 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> コンス トラクターと設定、 `throwOnInvalidBytes` 引数 `true`します。  
  
   
  
## 例  
 次の例では、\[新しい <xref:System.Text.UnicodeEncoding> をインスタンス化し、エンコーディングの名前を表示します。  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">最上位バイトが先頭に配置されるビッグ エンディアン バイト順を使用する場合は <see langword="true" />。最下位バイトが先頭に配置されるリトル エンディアン バイト順を使用する場合は <see langword="false" />。</param>
        <param name="byteOrderMark">
          <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> メソッドが Unicode バイト順マークを返すよう指定する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 詳細については、「解説」を参照してください。</param>
        <summary>
          <see cref="T:System.Text.UnicodeEncoding" /> クラスの新しいインスタンスを初期化します。 パラメーターでは、ビッグ エンディアン バイト順を使用するかどうか、および <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> メソッドが Unicode バイト順マークを返すかどうかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターでは、無効なエンコードが検出されると、例外をスローしないインスタンスを作成します。  
  
> [!NOTE]
>  セキュリティ上の理由を呼び出してエラーの検出を有効に.、 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> コンス トラクターと設定、 `throwOnInvalidBytes` 引数 `true`します。  
  
 `byteOrderMark` パラメーターの動作を制御する、 <xref:System.Text.UnicodeEncoding.GetPreamble%2A> メソッドです。 場合 `true`, 、utf\-16 形式で Unicode バイト順マーク \(BOM\) を格納するバイト配列を返します。  場合 `false`, 、長さ 0 バイトの配列を返します。 ただし、設定 `byteOrderMark` に `true` は伴いません、 <xref:System.Text.UnicodeEncoding.GetBytes%2A> とプレフィックスのバイト配列の先頭に BOM メソッド発生しても、 <xref:System.Text.UnicodeEncoding.GetByteCount%2A> をバイト数の BOM でバイト数を含める方法です。  
  
   
  
## 例  
 次の例では、\[新しい <xref:System.Text.UnicodeEncoding> リトル エンディアンまたはビッグ エンディアン バイト順をサポートするかどうかを指定してインスタンスと Unicode バイト オーダー マークします。  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">最上位バイトが先頭に配置されるビッグ エンディアン バイト順を使用する場合は <see langword="true" />。最下位バイトが先頭に配置されるリトル エンディアン バイト順を使用する場合は <see langword="false" />。</param>
        <param name="byteOrderMark">
          <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> メソッドが Unicode バイト順マークを返すよう指定する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 詳細については、「解説」を参照してください。</param>
        <param name="throwOnInvalidBytes">無効なエンコーディングが検出されたときに例外をスローすることを指定する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Text.UnicodeEncoding" /> クラスの新しいインスタンスを初期化します。 パラメーターでは、ビッグ エンディアン バイト順を使用するかどうか、Unicode バイト順マークを付加するかどうか、および無効なエンコーディングを検出したときに例外をスローするかどうかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `byteOrderMark` パラメーターの動作を制御する、 <xref:System.Text.UnicodeEncoding.GetPreamble%2A> メソッドです。 場合 `true`, 、utf\-16 形式で Unicode バイト順マーク \(BOM\) を格納するバイト配列を返します。  場合 `false`, 、長さ 0 バイトの配列を返します。 ただし、設定 `byteOrderMark` に `true` は伴いません、 <xref:System.Text.UnicodeEncoding.GetBytes%2A> とプレフィックスのバイト配列の先頭に BOM メソッド発生しても、 <xref:System.Text.UnicodeEncoding.GetByteCount%2A> をバイト数の BOM でバイト数を含める方法です。  
  
 場合、 `throwOnInvalidBytes` パラメーターは `true`, 、無効なバイト シーケンスを検出するメソッドがスローされます <xref:System.ArgumentException?displayProperty=fullName>します。 それ以外の場合、メソッドは、例外をスローしていないと、順序が無効ですが無視されます。  
  
> [!NOTE]
>  このコンス トラクターを使用してのインスタンスを作成するセキュリティ上の理由から、アプリケーションの勧め、 <xref:System.Text.UnicodeEncoding> クラスし、設定して、エラーの検出を有効にする `throwOnInvalidBytes` に `true`します。  
  
   
  
## 例  
 次の例の動作を示します <xref:System.Text.UnicodeEncoding>, 、エラーの検出を有効になっているとなし。  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Unicode 文字サイズをバイト単位で表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The value of this field is a 32\-bit signed constant with a value of 2.  
  
   
  
## 例  
 The following example demonstrates how to return the value of <xref:System.Text.UnicodeEncoding.CharSize> and display it.  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のオブジェクトと比較するオブジェクト。</param>
        <summary>指定した <see cref="T:System.Object" /> が、現在の <see cref="T:System.Text.UnicodeEncoding" /> オブジェクトと等しいかどうかを判断します。</summary>
        <returns>
          <paramref name="value" /> が <see cref="T:System.Text.UnicodeEncoding" /> のインスタンスで、現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Two <xref:System.Text.UnicodeEncoding> objects are considered equal if all of the following conditions are true:  
  
-   Both objects use the same byte order \(little\-endian or big\-endian\).  
  
-   Both objects provide the byte order mark, or both do not.  
  
-   Both objects use the same encoder fallback.  
  
-   Both objects use the same decoder fallback.  
  
   
  
## 例  
 The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.Equals%2A> method to test whether the current <xref:System.Text.UnicodeEncoding> object is equal to a different <xref:System.Text.UnicodeEncoding> object. Five <xref:System.Text.UnicodeEncoding> objects are created and compared, and the results of the comparisons are displayed.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">エンコード対象の文字のセットを格納する文字列。</param>
        <summary>指定した文字列内の文字をエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.UnicodeEncoding.GetBytes%2A> 結果のバイトを格納するを呼び出す、 <xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 <xref:System.ArgumentException>です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
> [!NOTE]
>  ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など一連のファイルに書き込まれるバイト数の先頭にある\) は、開発者の責任であり、preamble のバイト数はによって返される値に反映されず、 <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> メソッドです。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> と <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> 、文字列をエンコードするために必要なバイトの最大値と実際の数を計算する方法です。 また、実際のバイト ストリームにバイト オーダー マークの保存に必要なバイト数も表示されます。  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null " /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">結果のバイト数は、整数値として返すことができる最大数を超えています。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になっていると <paramref name="s" /> 、無効な文字のシーケンスが含まれています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(を参照してください [Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9) 詳細については\)  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>指定した文字ポインターで始まる文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 計算する正確な配列のサイズを <xref:System.Text.UnicodeEncoding.GetBytes%2A> 必要と結果のバイトを格納するを呼び出す、 <xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 <xref:System.ArgumentException>です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
> [!NOTE]
>  ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など一連のファイルに書き込まれるバイト数の先頭にある\) は、開発者の責任であり、preamble のバイト数はによって返される値に反映されず、 <xref:System.Text.UTF8Encoding.GetByteCount%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null " /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になっていると <paramref name="chars" /> 、無効な文字のシーケンスが含まれています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>指定した文字配列から文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な厳密な配列のサイズを計算する[GetByteCount メソッド \(Char\<xref:System.Text.UnicodeEncoding.GetBytes%2A>結果のバイトを格納するアプリケーションを使用して[GetByteCount メソッド \(Char\<xref:System.Text.UnicodeEncoding.GetByteCount%2A>です。 最大配列サイズを計算するには、呼び出します、[GetByteCount メソッド \(Char\<xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>メソッドです。[GetByteCount メソッド \(Char\<xref:System.Text.UnicodeEncoding.GetByteCount%2A>メソッドでは、メモリが少なく、通常が割り当てるときに、[GetByteCount メソッド \(Char\<xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>メソッドは通常、速く実行します。  
  
 無効なシーケンスでエラーの検出が有効になっている、このメソッドをスローすると、[GetByteCount メソッド \(Char\<xref:System.ArgumentException>です。 エラーの検出、無効なシーケンスが無視され、例外はスローされません。  
  
 ファイルまたはストリームとして保存するときに、エンコード済みバイトが正しくデコードするためには、ストリーム、preamble でエンコードされたバイトのプレフィックスにすることができます。 バイト ストリームの先頭の preamble を挿入する \(など、一連のファイルに書き込まれるバイトの先頭\) 開発者の責任は、preamble のバイト数がによって返される値に反映されません、[GetByteCount メソッド \(Char\<xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>メソッドです。  
  
   
  
## 例  
 次の例は、配列ラテン文字の大文字と小文字および呼び出しは追加、[GetByteCount メソッド \(Char\<xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ラテン文字の小文字の文字をエンコードするために必要なバイト数を調べます。 バイト順マークが追加された場合に必要なバイトの合計数と共に、この情報が表示されます。 この番号によって返される値と比較してその、[GetByteCount メソッド \(Char\<xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>メソッドで、小文字のラテン文字をエンコードするために必要なバイトの最大数を示します。 次の例は、ギリシャ語 \(キリル\) の文字と呼び出しの組み合わせを含む配列を設定、[GetByteCount メソッド \(Char\<xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>キリル文字をエンコードするために必要なバイト数を調べます。 バイト順マークが追加された場合に必要なバイトの合計数と共に、この情報が表示されます。 この番号によって返される値と比較してその、[GetByteCount メソッド \(Char\<xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>メソッドで、キリル文字をエンコードするために必要なバイトの最大数を示します。  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="chars" /> に無効な文字のシーケンスが含まれています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスの書き込みを開始する位置へのポインター。</param>
        <param name="byteCount">書き込む最大バイト数。</param>
        <summary>指定した文字ポインターで始まる文字のセットを、指定したバイト ポインターを開始位置として格納されるバイト シーケンスにエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> パラメーターによって示される位置に書き込む実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 計算する正確な配列のサイズを <xref:System.Text.UnicodeEncoding.GetBytes%2A> 必要と結果のバイトを格納するを呼び出す、 <xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 <xref:System.ArgumentException>です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合は、アプリケーションが使用する必要があります、 <xref:System.Text.Decoder> または <xref:System.Text.Encoder> オブジェクトによって提供される、 <xref:System.Text.UnicodeEncoding.GetDecoder%2A> または <xref:System.Text.UnicodeEncoding.GetEncoder%2A> メソッドをそれぞれします。  
  
> [!NOTE]
>  ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など、一連のファイルに書き込まれるバイト数の先頭にある\) 開発者の責任です。<xref:System.Text.UnicodeEncoding.GetBytes%2A> メソッドはエンコードされたバイト シーケンスの先頭に preamble を追加しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> が <see langword="null " />\(<see langword="Nothing" />\) です。  
  
 または  
  
 <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="chars" /> に無効な文字のシーケンスが含まれています。  
  
 または  
  
 <paramref name="byteCount" /> 結果のバイト数より少ない。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <summary>指定した文字配列に格納されている文字のセットを指定したバイト配列にエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetBytes%2A> 結果のバイトを格納するを呼び出す、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドです。[GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.ArgumentException>です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合は、アプリケーションが使用する必要があります、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Decoder> または [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder> によって提供される、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetDecoder%2A> メソッドまたは [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetEncoder%2A> メソッドをそれぞれします。  
  
> [!NOTE]
>  ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など、一連のファイルに書き込まれるバイト数の先頭にある\) 開発者の責任です。[GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetBytes%2A> メソッドはエンコードされたバイト シーケンスの先頭に preamble を追加しません。  
  
   
  
## 例  
 次の例では、使用して、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetBytes%2A> から文字の範囲をエンコードする方法、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.String> し、バイト配列の要素の範囲内でエンコードされたバイトを格納します。  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> が <see langword="null " />\(<see langword="Nothing" />\) です。  
  
 または  
  
 <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> または <paramref name="charCount" /> または <paramref name="byteIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
 または  
  
 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="chars" /> に無効な文字のシーケンスが含まれています。  
  
 または  
  
 <paramref name="bytes" /> 十分な容量がない <paramref name="byteIndex" /> に結果のバイトを合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">エンコード対象の文字のセットを格納している文字列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <summary>指定した <see cref="T:System.String" /> の文字セットを、指定したバイト配列にエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetBytes%2A> 結果のバイトを格納するを呼び出す、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するを呼び出す、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドです。[GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.ArgumentException>です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合は、アプリケーションが使用する必要があります、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Decoder> または [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoder> によって提供される、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetDecoder%2A> メソッドまたは [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetEncoder%2A> メソッドをそれぞれします。  
  
> [!NOTE]
>  ファイルまたはストリームに保存されるときに、エンコード済みバイトが正しくデコードすることを確認するには、プリアンブルでエンコードされたバイトのストリームの先頭を付加することができます。 バイト ストリームの先頭にある preamble を挿入する \(など、一連のファイルに書き込まれるバイト数の先頭にある\) 開発者の責任です。[GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.UnicodeEncoding.GetBytes%2A> メソッドはエンコードされたバイト シーケンスの先頭に preamble を追加しません。  
  
   
  
## 例  
 次の例では、一連の Unicode 文字配列から要素をエンコードおよびバイト配列の要素の範囲内でエンコードされたバイトを格納する方法を示します。  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null " /> です。  
  
 または  
  
 <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> または <paramref name="charCount" /> または <paramref name="byteIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
 または  
  
 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="s" /> に無効な文字のシーケンスが含まれています。  
  
 または  
  
 <paramref name="bytes" /> 十分な容量がない <paramref name="byteIndex" /> に結果のバイトを合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>指定したバイト ポインターで始まるバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 計算する正確な配列のサイズを<xref:System.Text.UnicodeEncoding.GetChars%2A>アプリケーションは、結果として得られる文字を格納する必要があります<xref:System.Text.UnicodeEncoding.GetCharCount%2A>です。 配列の最大サイズを計算する、アプリケーションを使用する必要があります<xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>です。<xref:System.Text.UnicodeEncoding.GetCharCount%2A>メソッドでは、メモリが少なく、通常が割り当てるときに、<xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>メソッドは通常、速く実行します。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、<xref:System.ArgumentException>です。 エラーの検出、無効なシーケンスが無視され、例外はスローされません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="bytes" /> に無効なバイト シーケンスが含まれています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>指定したバイト配列からバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な厳密な配列のサイズを計算する[GetCharCount メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetChars%2A>結果の文字を格納するアプリケーションを使用して[GetCharCount メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetCharCount%2A>です。 配列の最大サイズを計算する、アプリケーションを使用する必要があります[GetCharCount メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>です。[GetCharCount メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetCharCount%2A>メソッドでは、メモリが少なく、通常が割り当てるときに、[GetCharCount メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>メソッドは通常、速く実行します。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、[GetCharCount メソッド \(Byte\<xref:System.ArgumentException>です。 エラーの検出、無効なシーケンスが無視され、例外はスローされません。  
  
   
  
## 例  
 次の例で使用する方法、[GetCharCount メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetCharCount%2A>範囲の要素を使用してバイト配列にデコードすることによって生成される文字数を返すメソッドを[GetCharCount メソッド \(Byte\<xref:System.Text.UnicodeEncoding>です。  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="bytes" /> に無効なバイト シーケンスが含まれています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字セットの書き込みを開始する位置へのポインター。</param>
        <param name="charCount">書き込む文字の最大数。</param>
        <summary>指定したバイト ポインターで始まるバイト シーケンスを、指定した文字ポインターを開始位置として格納される文字のセットにデコードします。</summary>
        <returns>
          <paramref name="chars" /> パラメーターによって示される位置に書き込む実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 計算する正確な配列のサイズを <xref:System.Text.UnicodeEncoding.GetChars%2A> 結果の文字列では、アプリケーションが使用を格納する必要があります <xref:System.Text.UnicodeEncoding.GetCharCount%2A>します。 配列の最大サイズを計算する、アプリケーションを使用する必要があります <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>します。<xref:System.Text.UnicodeEncoding.GetCharCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 <xref:System.ArgumentException>です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 デコードするバイトの範囲には、バイト順マーク \(BOM\) が含まれているバイト配列が BOM で非対応型のメソッドによって返された場合は、このメソッドによって返される文字配列には文字 U \+ FFFE が含まれます。 これを削除するには呼び出すことによって、 <xref:System.String.TrimStart%2A?displayProperty=fullName> メソッドです。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合は、アプリケーションが使用する必要があります、 <xref:System.Text.Decoder> または <xref:System.Text.Encoder> オブジェクトによって提供される、 <xref:System.Text.UnicodeEncoding.GetDecoder%2A> または <xref:System.Text.UnicodeEncoding.GetEncoder%2A> メソッドをそれぞれします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。  
  
 または  
  
 <paramref name="chars" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> または <paramref name="charCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="bytes" /> に無効なバイト シーケンスが含まれています。  
  
 または  
  
 <paramref name="charCount" /> 結果の文字数より少ない。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="byteIndex">デコードする最初のバイトのインデックス。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字のセットを格納する文字配列。</param>
        <param name="charIndex">結果の文字のセットを書き込む開始位置のインデックス。</param>
        <summary>指定したバイト配列に格納されているバイト シーケンスを指定した文字配列にデコードします。</summary>
        <returns>
          <paramref name="chars" /> に書き込まれた実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UnicodeEncoding.GetChars%2A> 結果の文字を格納するアプリケーションを使用して [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UnicodeEncoding.GetCharCount%2A>します。 配列の最大サイズを計算する、アプリケーションを使用する必要があります [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>します。[GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UnicodeEncoding.GetCharCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.ArgumentException>です。 エラー検出を無効なシーケンスは無視され、例外はスローされません。  
  
 デコードするバイトの範囲には、バイト順マーク \(BOM\) が含まれているバイト配列が BOM で非対応型のメソッドによって返された場合は、このメソッドによって返される文字配列には文字 U \+ FFFE が含まれます。 これを削除するには呼び出すことによって、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.String.TrimStart%2A?displayProperty=fullName> メソッドです。  
  
 ストリームから読み取ったデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量が小さなブロックに分割する必要があることが非常に大きい場合は、アプリケーションが使用する必要があります、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Decoder> または [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoder> によって提供される、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UnicodeEncoding.GetDecoder%2A> メソッドまたは [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UnicodeEncoding.GetEncoder%2A> メソッドをそれぞれします。  
  
   
  
## 例  
 次の例では、使用して、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.UnicodeEncoding.GetChars%2A> バイト配列の要素の範囲をデコードし、結果を文字配列に格納する方法です。  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。  
  
 または  
  
 <paramref name="chars" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> または <paramref name="byteCount" /> または <paramref name="charIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="byteindex" /> および <paramref name="byteCount" /> は <paramref name="bytes" /> において有効な範囲を表していません。  
  
 または  
  
 <paramref name="charIndex" /> が <paramref name="chars" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="bytes" /> に無効なバイト シーケンスが含まれています。  
  
 または  
  
 <paramref name="chars" /> 十分な容量がない <paramref name="charIndex" /> に結果の文字を合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>UTF\-16 でエンコードされたバイト シーケンスを Unicode 文字のシーケンスに変換するデコーダーを取得します。</summary>
        <returns>UTF\-16 でエンコードされたバイト シーケンスを Unicode 文字のシーケンスに変換する <see cref="T:System.Text.Decoder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> メソッドと同様の方法での文字の連続ブロックにバイトの連続したブロックを変換する、 <xref:System.Text.UnicodeEncoding.GetChars%2A>です。 ただし、 <xref:System.Text.Decoder> ブロックにまたがるバイト シーケンスを正しくデコードすることができますので、呼び出しの間で状態情報を保持します。<xref:System.Text.Decoder> もデータ ブロックの末尾にある末尾のバイトを保持し、次のデコード操作で末尾のバイトを使用します。 したがって、 <xref:System.Text.UnicodeEncoding.GetDecoder%2A> と <xref:System.Text.UnicodeEncoding.GetEncoder%2A> の完全なデータ ストリームではなくデータ ブロックを頻繁にこれらの操作を処理するためには、ネットワーク転送とファイルの操作に便利です。  
  
 かどうかはエラー検出が有効な場合は、 `throwOnInvalidBytes` にコンス トラクターのパラメーターが設定されている `true`, でエラーの検出が有効にも、 <xref:System.Text.Decoder> このメソッドによって返されます。 エラーの検出を有効にし、無効なシーケンスが発生した場合は、デコーダーの状態は未定義と処理を停止する必要があります。  
  
   
  
## 例  
 次の例は、エンコーダーとデコーダーを使用して、\(バイト単位\) の配列に文字列をエンコードして、文字の配列にバイトをデコードします。  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unicode 文字のシーケンスを UTF\-16 でエンコードされたバイト シーケンスに変換するエンコーダーを取得します。</summary>
        <returns>Unicode 文字のシーケンスを UTF\-16 でエンコードされたバイト シーケンスに変換する <see cref="T:System.Text.Encoder" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドと同様の方法のバイト数の連続ブロックに文字の連続したブロックを変換する、 <xref:System.Text.UnicodeEncoding.GetBytes%2A> このクラスのメソッドです。 ただし、 <xref:System.Text.Encoder> にブロックにまたがる文字のシーケンスを正しくエンコードできるように、オブジェクトが呼び出しの間で状態情報を保持します。<xref:System.Text.Encoder> オブジェクトもデータ ブロックの末尾にある末尾の文字を保持し、末尾の文字を次のエンコード操作に使用します。 たとえば、データ ブロックが上位サロゲートで終了し、一致する下位サロゲートが次のデータ ブロックしていることがあります。 したがって、 <xref:System.Text.UnicodeEncoding.GetDecoder%2A> と <xref:System.Text.UnicodeEncoding.GetEncoder%2A> の完全なデータ ストリームではなくデータ ブロックを頻繁にこれらの操作を処理するためには、ネットワーク転送とファイルの操作に便利です。  
  
 かどうかはエラー検出が有効な場合は、 `throwOnInvalidBytes` にコンス トラクターのパラメーターが設定されている `true`, でエラーの検出が有効にも、 <xref:System.Text.Encoder> このメソッドによって返されるオブジェクト。 エラーの検出を有効にし、無効なシーケンスが発生した場合は、エンコーダーの状態は未定義と処理を停止する必要があります。  
  
   
  
## 例  
 次の例は、エンコーダーとデコーダーを使用して、\(バイト単位\) の配列に文字列をエンコードして、文字の配列にバイトをデコードします。  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスのハッシュ コードを返します。</summary>
        <returns>現在の <see cref="T:System.Text.UnicodeEncoding" /> オブジェクトのハッシュ コード。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">エンコードする文字数。</param>
        <summary>指定した文字数をエンコードすることによって生成される最大バイト数を計算します。</summary>
        <returns>指定した文字数をエンコードすることによって生成される最大バイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.UnicodeEncoding.GetBytes%2A> 結果のバイトを格納するアプリケーションを使用して <xref:System.Text.UnicodeEncoding.GetByteCount%2A>します。 配列の最大サイズを計算する、アプリケーションを使用する必要があります <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>します。<xref:System.Text.UnicodeEncoding.GetByteCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> 現在選択されている最悪のケースを含む、最悪のケースの数を取得 <xref:System.Text.EncoderFallback>します。 フォールバックが大きくなる可能性の文字列で選択した場合 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> 大きな値を返すことができます。  
  
 ほとんどの場合は、このメソッドは、短い文字列では適切な数値を取得します。 大きな文字列の場合に、非常に大きなバッファーを使用してより適切なバッファーを超えているというまれなケースでエラーの検出を選択する必要があります。 別のアプローチの使用を検討することも <xref:System.Text.UnicodeEncoding.GetByteCount%2A> または <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>です。  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> 関係を持たない <xref:System.Text.UnicodeEncoding.GetChars%2A>します。 使用する類似の機能が、アプリケーションに必要なかどうかは <xref:System.Text.UnicodeEncoding.GetChars%2A>, 、それを使用する必要があります <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>します。  
  
> [!NOTE]
>  `GetMaxByteCount(N)` 同じ値とは限りません `N* GetMaxByteCount(1)`します。  
  
   
  
## 例  
 次の例では、使用して、 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> メソッドを指定した文字数をエンコードするために必要なバイトの最大数を取得します。  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> が 0 未満です。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">デコードするバイト数。</param>
        <summary>指定したバイト数をデコードすることによって生成される最大文字数を計算します。</summary>
        <returns>指定したバイト数をデコードすることによって生成される最大文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.UnicodeEncoding.GetChars%2A> 結果の文字を格納するアプリケーションを使用して <xref:System.Text.UnicodeEncoding.GetCharCount%2A>します。 配列の最大サイズを計算する、アプリケーションを使用する必要があります <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>します。<xref:System.Text.UnicodeEncoding.GetCharCount%2A> メソッドでは、メモリも減り、一般が割り当てるときに、 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> 現在選択されている最悪のケースを含む、最悪のケースの数を取得 <xref:System.Text.DecoderFallback>します。 フォールバックが大きくなる可能性の文字列で選択した場合 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> 大きな値を取得します。  
  
 ほとんどの場合は、このメソッドは、短い文字列では適切な数値を取得します。 大きな文字列の場合に、非常に大きなバッファーを使用してより適切なバッファーを超えているというまれなケースでエラーの検出を選択する必要があります。 別のアプローチの使用を検討することも <xref:System.Text.UnicodeEncoding.GetCharCount%2A> または <xref:System.Text.Decoder.Convert%2A>です。  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> 関係を持たない <xref:System.Text.UnicodeEncoding.GetBytes%2A>します。 使用する類似の機能が、アプリケーションに必要なかどうかは <xref:System.Text.UnicodeEncoding.GetBytes%2A>, 、それを使用する必要があります <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>します。  
  
> [!NOTE]
>  `GetMaxCharCount(N)` 同じ値とは限りません `N* GetMaxCharCount(1)`します。  
  
   
  
## 例  
 次の例では、使用して、 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> 最大文字数を返すメソッドが指定したバイト数をデコードして生成されました。  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> が 0 未満です。  
  
 または  
  
 結果のバイト数が、整数として返すことのできる最大数を超えています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのコンストラクターでバイト順マークを要求した場合は、UTF\-16 形式でエンコードされた Unicode バイト順マークを返します。</summary>
        <returns>Unicode のバイト順マークが格納されたバイト配列を提供するように <see cref="T:System.Text.UnicodeEncoding" /> オブジェクトが構成されている場合には、そうしたバイト配列。 それ以外の場合、このメソッドは長さがゼロのバイト配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.UnicodeEncoding> オブジェクトが提供できる、preamble では、バイト配列の先頭には、エンコーディング プロセスに起因バイト シーケンスです。 バイト順マーク \(コード ポイント U\+FEFF\) でエンコードされたバイト シーケンスの先頭には、バイト順および変換形式または UTF デコーダーことができます。 Unicode バイト順マーク \(BOM\) が \(16 進\) に次のようにシリアル化されます。  
  
-   ビッグ エンディアン バイト順: FE FF  
  
-   リトル エンディアン バイト順: FF FE  
  
 インスタンスを作成できる、 <xref:System.Text.UnicodeEncoding> オブジェクト <xref:System.Text.UnicodeEncoding.GetPreamble%2A> メソッドは、次の方法で有効な BOM を返します。  
  
-   取得することによって、 <xref:System.Text.UnicodeEncoding> によって返されるオブジェクト、 <xref:System.Text.Encoding.Unicode%2A?displayProperty=fullName> または <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=fullName> プロパティです。  
  
-   パラメーターなしで呼び出すことによって <xref:System.Text.UnicodeEncoding.%23ctor> インスタンスを作成するコンス トラクター、 <xref:System.Text.UnicodeEncoding> オブジェクトです。  
  
-   指定して `true` の値として、 `byteOrderMark` への引数、 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> または <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> コンス トラクターです。  
  
 失われた場合、参照、エンコード、または不適切なタグなしなどのファイルのエンコーディングの特定の id にほぼが用意されているので web データまたはおランダムなテキスト ファイルがありませんでした国際的な懸念事項を BOM を使用することをお勧めします。 データが一貫して適切なタグとは、多くの場合、ユーザーの問題を回避できる可能性があります。  
  
 エンコードの種類を定義した標準から、BOM は、少し冗長です。 ただし、適切なエンコードのヘッダーを送信するサーバーのヘルプを使用できます。 または、そのとして使用できます、フォールバック エンコーディングが失われたそれ以外の場合に備えてします。  
  
 BOM を使用するいくつかのデメリットがあります。 たとえば、BOM を使用するデータベース フィールドを制限する方法についての知識が難しくなります。 ファイルの連結問題になる場合も、たとえば、ファイルを結合するようにデータの途中で不要な文字は最終的にする方法です。 いくつかの短所にもかかわらずただし、部品表の使用強くお勧めします。  
  
> [!CAUTION]
>  エンコードされたバイトを正しくデコードするためには、プリアンブルでエンコードされたバイトのストリームの先頭プレフィックスにする必要があります。 なお、 <xref:System.Text.UnicodeEncoding.GetBytes%2A> メソッドでエンコードされたバイト シーケンスに BOM が追加しません。 開発者の責任は、適切なバイト ストリームの先頭に BOM を指定することです。  
  
   
  
## 例  
 次の例では、使用して、 <xref:System.Text.UnicodeEncoding.GetPreamble%2A> ビッグ エンディアンまたはのインスタンスに配置されるリトル エンディアンのバイト順で Unicode バイト順マークを取得するメソッドを <xref:System.Text.UnicodeEncoding>です。  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 次の例では、2 つをインスタンス化 <xref:System.Text.UnicodeEncoding> オブジェクトのうち 1 つ目は BOM とするは、2 番目は提供しません。 呼び出して、 <xref:System.Text.UnicodeEncoding.GetPreamble%2A> に Unicode でエンコードされた文字列を書き込む前に、BOM をファイルに書き込みます。 コンソール出力の例に示すように、2 つ目のエンコーダーからのバイトを保存するファイルは最初より多いバイト数の 3 つにあります。  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 You can also compare the files by using the **languageKeyword tag is not supported!!!!**  
 command in a console window, or you can inspect the files in a text editor that includes a Hex View mode. Note that when the file is opened in an editor that supports UTF\-16 encoding, the BOM is not displayed.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>バイト配列に格納されているある範囲のバイトを文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている <see cref="T:System.String" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 無効なシーケンス エラーの検出でこのメソッドをスローすると、[GetString メソッド \(Byte\<xref:System.ArgumentException>です。 エラーの検出、無効なシーケンスが無視され、例外はスローされません。  
  
 デコードするバイトの範囲には、バイト順マーク \(BOM\) が含まれています。 バイト配列が BOM で非対応型のメソッドによって返される場合は、文字 U \+ FFFE はこのメソッドによって返される文字配列に含まれています。 これを削除するには呼び出すことによって、[GetString メソッド \(Byte\<xref:System.String.TrimStart%2A?displayProperty=fullName>メソッドです。  
  
 ストリームから読み取られるデータなど、変換するデータは、シーケンシャル ブロック内でのみ使用可能な可能性があります。 この場合、またはデータの量がより小さなブロックに分割する必要があることが非常に大きい場合は、アプリケーションが使用する必要があります、[GetString メソッド \(Byte\<xref:System.Text.Decoder>または[GetString メソッド \(Byte\<xref:System.Text.Encoder>オブジェクトによって提供される、[GetString メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetDecoder%2A>または[GetString メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetEncoder%2A>メソッド、それぞれします。  
  
   
  
## 例  
 次の例では、配列を初期化を呼び出して、[GetString メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetByteCount%2A>バイト数がエンコードされた文字列とバイト順マーク \(BOM\) のサイズを追加するために必要なだけを調べます。 この例では、[GetString メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetPreamble%2A>は BOM を呼び出す前に、配列を格納する方法、[GetString メソッド \(Byte\<xref:System.Text.Encoding.GetBytes%2A>配列にエンコードされたバイトを格納するメソッド。 この例では、[GetString メソッド \(Byte\<xref:System.Text.UnicodeEncoding.GetString%2A>文字列をデコードします。  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Note that in this case the decoded string differs from the original string, since it begins with a 16\-bit byte order mark U\+FFFD. This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?". To remove the BOM at the beginning of the string, you can call the [GetString メソッド \(Byte\<xref:System.String.TrimStart%2A?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> が <see langword="null " />\(<see langword="Nothing" />\) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.ArgumentException">エラーの検出が有効になり、<paramref name="bytes" /> に無効なバイト シーケンスが含まれています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>文字のセットをバイト シーケンスにエンコードします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Text.UnicodeEncoding" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイト シーケンスを文字のセットにデコードします。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>