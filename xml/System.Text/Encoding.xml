<Type Name="Encoding" FullName="System.Text.Encoding">
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>文字エンコーディングを表します。  
  
 この型の .NET Framework ソース コードを参照するには、[参照ソース](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25)をご覧ください。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25). You can browse through the source code online, download the reference for offline viewing, and step through the sources \(including patches and updates\) during debugging; see [instructions](http://referencesource.microsoft.com/).  
  
 Encoding is the process of transforming a set of Unicode characters into a sequence of bytes. In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters. For information about the Unicode Transformation Formats \(UTFs\) and other encodings supported by <xref:System.Text.Encoding>, see [Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9).  
  
 Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays. If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>.  
  
 The .NET Framework provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:  
  
-   <xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7\-bit ASCII characters. This encoding only supports character values between U\+0000 and U\+007F. Code page 20127. Also available through the <xref:System.Text.Encoding.ASCII%2A> property.  
  
-   <xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF\-7 encoding. This encoding supports all Unicode character values. Code page 65000. Also available through the <xref:System.Text.Encoding.UTF7%2A> property.  
  
-   <xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF\-8 encoding. This encoding supports all Unicode character values. Code page 65001. Also available through the <xref:System.Text.Encoding.UTF8%2A> property.  
  
-   <xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF\-16 encoding. Both little endian and big endian byte orders are supported. Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.  
  
-   <xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF\-32 encoding. Both little endian \(code page 12000\) and big endian \(code page 12001\) byte orders are supported. Also available through the <xref:System.Text.Encoding.UTF32%2A> property.  
  
 The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode. Often one of the derived Unicode classes is the correct choice for your app.  
  
 Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings.  
  
 The following table lists the encodings supported by the .NET Framework. It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=fullName> properties. An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform. Note that code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> property corresponds to an international standard do not necessarily comply in full with that standard.  
  
|Code page|Name|Display name|.NET Framework support|  
|---------------|----------|------------------|----------------------------|  
|37|IBM037|IBM EBCDIC \(US\-Canada\)||  
|437|IBM437|OEM United States||  
|500|IBM500|IBM EBCDIC \(International\)||  
|708|ASMO\-708|Arabic \(ASMO 708\)||  
|720|DOS\-720|Arabic \(DOS\)||  
|737|ibm737|Greek \(DOS\)||  
|775|ibm775|Baltic \(DOS\)||  
|850|ibm850|Western European \(DOS\)||  
|852|ibm852|Central European \(DOS\)||  
|855|IBM855|OEM Cyrillic||  
|857|ibm857|Turkish \(DOS\)||  
|858|IBM00858|OEM Multilingual Latin I||  
|860|IBM860|Portuguese \(DOS\)||  
|861|ibm861|Icelandic \(DOS\)||  
|862|DOS\-862|Hebrew \(DOS\)||  
|863|IBM863|French Canadian \(DOS\)||  
|864|IBM864|Arabic \(864\)||  
|865|IBM865|Nordic \(DOS\)||  
|866|cp866|Cyrillic \(DOS\)||  
|869|ibm869|Greek, Modern \(DOS\)||  
|870|IBM870|IBM EBCDIC \(Multilingual Latin\-2\)||  
|874|windows\-874|Thai \(Windows\)||  
|875|cp875|IBM EBCDIC \(Greek Modern\)||  
|932|shift\_jis|Japanese \(Shift\-JIS\)||  
|936|gb2312|Chinese Simplified \(GB2312\)|✓|  
|949|ks\_c\_5601\-1987|Korean||  
|950|big5|Chinese Traditional \(Big5\)||  
|1026|IBM1026|IBM EBCDIC \(Turkish Latin\-5\)||  
|1047|IBM01047|IBM Latin\-1||  
|1140|IBM01140|IBM EBCDIC \(US\-Canada\-Euro\)||  
|1141|IBM01141|IBM EBCDIC \(Germany\-Euro\)||  
|1142|IBM01142|IBM EBCDIC \(Denmark\-Norway\-Euro\)||  
|1143|IBM01143|IBM EBCDIC \(Finland\-Sweden\-Euro\)||  
|1144|IBM01144|IBM EBCDIC \(Italy\-Euro\)||  
|1145|IBM01145|IBM EBCDIC \(Spain\-Euro\)||  
|1146|IBM01146|IBM EBCDIC \(UK\-Euro\)||  
|1147|IBM01147|IBM EBCDIC \(France\-Euro\)||  
|1148|IBM01148|IBM EBCDIC \(International\-Euro\)||  
|1149|IBM01149|IBM EBCDIC \(Icelandic\-Euro\)||  
|1200|utf\-16|Unicode|✓|  
|1201|unicodeFFFE|Unicode \(Big endian\)|✓|  
|1250|windows\-1250|Central European \(Windows\)||  
|1251|windows\-1251|Cyrillic \(Windows\)||  
|1252|Windows\-1252|Western European \(Windows\)|✓|  
|1253|windows\-1253|Greek \(Windows\)||  
|1254|windows\-1254|Turkish \(Windows\)||  
|1255|windows\-1255|Hebrew \(Windows\)||  
|1256|windows\-1256|Arabic \(Windows\)||  
|1257|windows\-1257|Baltic \(Windows\)||  
|1258|windows\-1258|Vietnamese \(Windows\)||  
|1361|Johab|Korean \(Johab\)||  
|10000|macintosh|Western European \(Mac\)||  
|10001|x\-mac\-japanese|Japanese \(Mac\)||  
|10002|x\-mac\-chinesetrad|Chinese Traditional \(Mac\)||  
|10003|x\-mac\-korean|Korean \(Mac\)|✓|  
|10004|x\-mac\-arabic|Arabic \(Mac\)||  
|10005|x\-mac\-hebrew|Hebrew \(Mac\)||  
|10006|x\-mac\-greek|Greek \(Mac\)||  
|10007|x\-mac\-cyrillic|Cyrillic \(Mac\)||  
|10008|x\-mac\-chinesesimp|Chinese Simplified \(Mac\)|✓|  
|10010|x\-mac\-romanian|Romanian \(Mac\)||  
|10017|x\-mac\-ukrainian|Ukrainian \(Mac\)||  
|10021|x\-mac\-thai|Thai \(Mac\)||  
|10029|x\-mac\-ce|Central European \(Mac\)||  
|10079|x\-mac\-icelandic|Icelandic \(Mac\)||  
|10081|x\-mac\-turkish|Turkish \(Mac\)||  
|10082|x\-mac\-croatian|Croatian \(Mac\)||  
|12000|utf\-32|Unicode \(UTF\-32\)|✓|  
|12001|utf\-32BE|Unicode \(UTF\-32 Big endian\)|✓|  
|20000|x\-Chinese\-CNS|Chinese Traditional \(CNS\)||  
|20001|x\-cp20001|TCA Taiwan||  
|20002|x\-Chinese\-Eten|Chinese Traditional \(Eten\)||  
|20003|x\-cp20003|IBM5550 Taiwan||  
|20004|x\-cp20004|TeleText Taiwan||  
|20005|x\-cp20005|Wang Taiwan||  
|20105|x\-IA5|Western European \(IA5\)||  
|20106|x\-IA5\-German|German \(IA5\)||  
|20107|x\-IA5\-Swedish|Swedish \(IA5\)||  
|20108|x\-IA5\-Norwegian|Norwegian \(IA5\)||  
|20127|us\-ascii|US\-ASCII|✓|  
|20261|x\-cp20261|T.61||  
|20269|x\-cp20269|ISO\-6937||  
|20273|IBM273|IBM EBCDIC \(Germany\)||  
|20277|IBM277|IBM EBCDIC \(Denmark\-Norway\)||  
|20278|IBM278|IBM EBCDIC \(Finland\-Sweden\)||  
|20280|IBM280|IBM EBCDIC \(Italy\)||  
|20284|IBM284|IBM EBCDIC \(Spain\)||  
|20285|IBM285|IBM EBCDIC \(UK\)||  
|20290|IBM290|IBM EBCDIC \(Japanese katakana\)||  
|20297|IBM297|IBM EBCDIC \(France\)||  
|20420|IBM420|IBM EBCDIC \(Arabic\)||  
|20423|IBM423|IBM EBCDIC \(Greek\)||  
|20424|IBM424|IBM EBCDIC \(Hebrew\)||  
|20833|x\-EBCDIC\-KoreanExtended|IBM EBCDIC \(Korean Extended\)||  
|20838|IBM\-Thai|IBM EBCDIC \(Thai\)||  
|20866|koi8\-r|Cyrillic \(KOI8\-R\)||  
|20871|IBM871|IBM EBCDIC \(Icelandic\)||  
|20880|IBM880|IBM EBCDIC \(Cyrillic Russian\)||  
|20905|IBM905|IBM EBCDIC \(Turkish\)||  
|20924|IBM00924|IBM Latin\-1||  
|20932|EUC\-JP|Japanese \(JIS 0208\-1990 and 0212\-1990\)||  
|20936|x\-cp20936|Chinese Simplified \(GB2312\-80\)|✓|  
|20949|x\-cp20949|Korean Wansung|✓|  
|21025|cp1025|IBM EBCDIC \(Cyrillic Serbian\-Bulgarian\)||  
|21866|koi8\-u|Cyrillic \(KOI8\-U\)||  
|28591|iso\-8859\-1|Western European \(ISO\)|✓|  
|28592|iso\-8859\-2|Central European \(ISO\)||  
|28593|iso\-8859\-3|Latin 3 \(ISO\)||  
|28594|iso\-8859\-4|Baltic \(ISO\)||  
|28595|iso\-8859\-5|Cyrillic \(ISO\)||  
|28596|iso\-8859\-6|Arabic \(ISO\)||  
|28597|iso\-8859\-7|Greek \(ISO\)||  
|28598|iso\-8859\-8|Hebrew \(ISO\-Visual\)|✓|  
|28599|iso\-8859\-9|Turkish \(ISO\)||  
|28603|iso\-8859\-13|Estonian \(ISO\)||  
|28605|iso\-8859\-15|Latin 9 \(ISO\)||  
|29001|x\-Europa|Europa||  
|38598|iso\-8859\-8\-i|Hebrew \(ISO\-Logical\)|✓|  
|50220|iso\-2022\-jp|Japanese \(JIS\)|✓|  
|50221|csISO2022JP|Japanese \(JIS\-Allow 1 byte Kana\)|✓|  
|50222|iso\-2022\-jp|Japanese \(JIS\-Allow 1 byte Kana \- SO\/SI\)|✓|  
|50225|iso\-2022\-kr|Korean \(ISO\)|✓|  
|50227|x\-cp50227|Chinese Simplified \(ISO\-2022\)|✓|  
|51932|euc\-jp|Japanese \(EUC\)|✓|  
|51936|EUC\-CN|Chinese Simplified \(EUC\)|✓|  
|51949|euc\-kr|Korean \(EUC\)|✓|  
|52936|hz\-gb\-2312|Chinese Simplified \(HZ\)|✓|  
|54936|GB18030|Chinese Simplified \(GB18030\)|✓|  
|57002|x\-iscii\-de|ISCII Devanagari|✓|  
|57003|x\-iscii\-be|ISCII Bengali|✓|  
|57004|x\-iscii\-ta|ISCII Tamil|✓|  
|57005|x\-iscii\-te|ISCII Telugu|✓|  
|57006|x\-iscii\-as|ISCII Assamese|✓|  
|57007|x\-iscii\-or|ISCII Oriya|✓|  
|57008|x\-iscii\-ka|ISCII Kannada|✓|  
|57009|x\-iscii\-ma|ISCII Malayalam|✓|  
|57010|x\-iscii\-gu|ISCII Gujarati|✓|  
|57011|x\-iscii\-pa|ISCII Punjabi|✓|  
|65000|utf\-7|Unicode \(UTF\-7\)|✓|  
|65001|utf\-8|Unicode \(UTF\-8\)|✓|  
  
 The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek \(Windows\) code page encoding. It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.  
  
 [!code-csharp[System.Text.Encoding\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 If the data to be converted is available only in sequential blocks \(such as data read from a stream\) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.  
  
 The UTF\-16 and the UTF\-32 encoders can use the big endian byte order \(most significant byte first\) or the little endian byte order \(least significant byte first\). For example, the Latin Capital Letter A \(U\+0041\) is serialized as follows \(in hexadecimal\):  
  
-   UTF\-16 big endian byte order: 00 41  
  
-   UTF\-16 little endian byte order: 41 00  
  
-   UTF\-32 big endian byte order: 00 00 00 41  
  
-   UTF\-32 little endian byte order: 41 00 00 00  
  
 It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.  
  
 The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark \(BOM\). If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.  
  
 For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Note that the encoding classes allow errors to:  
  
-   Silently change to a "?" character.  
  
-   Use a "best fit" character.  
  
-   Change to an application\-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U\+FFFD Unicode replacement character.  
  
 You should throw an exception on any data stream error. An app either uses a "throwonerror" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes. Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements. For ANSI encodings, the best fit behavior is the default.  
  
   
  
## 例  
 The following example converts a string from one encoding to another.  
  
> [!NOTE]
>  The byte\[\] array is the only type in this example that contains the encoded data. The .NET Char and String types are themselves Unicode, so the <xref:System.Text.Encoding.GetChars%2A> call decodes the data back to Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Derived classes override this constructor.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">使用するエンコーディングのコード ページ ID。  
  
 または  
  
 既定のエンコーディングを使用する場合は 0。</param>
        <summary>指定したコード ページに対応する <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Derived classes override this constructor.  
  
 Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best\-fit fallback for both encoding and decoding operations. Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read\-only and cannot be modified. To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> が 0 未満です。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">エンコーディングのコード ページ ID。</param>
        <param name="encoderFallback">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <param name="decoderFallback">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <summary>指定したコード ページに対応する <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを、指定したエンコーダーとデコーダーのフォールバック方法を使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This constructor is **languageKeyword tag is not supported!!!!**  
; derived classes override it.  
  
 You call this constructor from a derived class to control the fallback encoding and decoding strategies. The <xref:System.Text.Encoding> class constructors create read\-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.  
  
 If either **parameterReference tag is not supported!!!!**  
 or **parameterReference tag is not supported!!!!**  
 is null, best\-fit fallback is used as the corresponding fallback strategy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASCII \(7 ビット\) 文字セットのエンコーディングを取得します。</summary>
        <value>ASCII \(7 ビット\) 文字セットのエンコーディング。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASCII 文字は、u\+0000 ~ U \+ 007F から下位 128 Unicode 文字に制限されます。  
  
 アプリの ASCII エンコードを選択すると、次の操作を考慮してください。  
  
-   ASCII エンコーディングは ASCII が必要なプロトコルは大抵適切です。  
  
-   Ascii エンコーディングよりも utf\-8 エンコードが推奨するには、8 ビットのエンコーディング \(がされることがあると呼ばれていない"ASCII"\) が必要とする場合のエンコーディングします。 0 ~ 7 f の文字の場合、結果は同じですが utf\-8 の使用が表現可能なすべての Unicode 文字の表現を許可することでデータの損失を回避できます。 ASCII エンコーディングに第 8 ビット両義性を悪意のある使用を許可することができますが、8 番目のビットについて明確に utf\-8 エンコードことに注意してください。  
  
-   .NET Framework version 2.0 では、前に、.NET Framework は、8 番目のビットを無視してスプーフィングが許可されます。 .NET Framework 2.0 以降では、非 ASCII コード フォールバックを指すデコード中にします。  
  
 <xref:System.Text.ASCIIEncoding> このプロパティによって返されるオブジェクトは、アプリの適切な動作をいない可能性があります。 置換フォールバックを使用して各エンコードできない文字列とデコードできないバイトがごとを疑問符 \(\) に置き換えること \("?"\) 文字に置き換えらるからです。 代わりに、呼び出すことができます、 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> をインスタンス化するメソッド、 <xref:System.Text.ASCIIEncoding> のフォールバックは、いずれかのオブジェクト、 <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>, 次の例に示すようにします。  
  
 [!code-csharp[System.Text.Encoding.ASCII\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## 例  
 次の例では、ASCII ASCII の範囲外にある文字エンコーディングの効果を示します。  
  
 [!code-cpp[System.Text.Encoding.ASCII Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ビッグ エンディアンのバイト順を使用する UTF\-16 形式のエンコーディングを取得します。</summary>
        <value>ビッグ エンディアンのバイト順を使用する UTF\-16 形式のエンコーディング オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.UnicodeEncoding> このプロパティによって返されるオブジェクトで、アプリの適切な動作がない可能性があります。 置換フォールバックを使用して各エンコードできない文字列とデコードできないバイトがごとを疑問符 \(\) に置き換えること \("?"\) 文字に置き換えらるからです。 代わりに、呼び出すことができます、 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> ビッグ エンディアンのインスタンスを作成するコンス トラクター <xref:System.Text.UnicodeEncoding> のフォールバックは、いずれかのオブジェクト、 <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>, 次の例に示すようにします。  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 返された <xref:System.Text.UnicodeEncoding> オブジェクトには <xref:System.Text.Encoding.BodyName%2A>, 、<xref:System.Text.Encoding.HeaderName%2A>, 、および <xref:System.Text.Encoding.WebName%2A> プロパティは、"unicodeFFFE"という名前を生成します。 Utf\-16 ビッグ エンディアン バイト順マークは、16 進数の FEFF は、"unicodeFFFE"という名前は、リトル エンディアンの Windows コンピューターに FFFE を 16 進数とバイト順マークが表示されるために選択されました。  
  
   
  
## 例  
 次の例では、utf\-16 エンコーディングをビッグ エンディアン バイト順を使用してテキスト ファイルを読み取ります。  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 次の例は、文字配列をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール エージェントの Body タグと共に使用できる現在のエンコーディングの名前を取得します。</summary>
        <value>メール エージェントの Body タグと共に使用できる、現在の <see cref="T:System.Text.Encoding" /> の名前。  
  
 または  
  
 現在の <see cref="T:System.Text.Encoding" /> が使用できない場合は、空の文字列 \(""\)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e\-mail applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.  
  
 In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding. This doesn't mean that the implementation complies in full with that standard.  
  
   
  
## 例  
 The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName>. It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.  
  
 [!code-cpp[System.Text.Encoding.Names\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在の <see cref="T:System.Text.Encoding" /> オブジェクトの簡易コピーを作成します。</summary>
        <returns>現在の <see cref="T:System.Text.Encoding" /> オブジェクトのコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The clone is writable even if the original <xref:System.Text.Encoding> object is read\-only. Therefore, the properties of the clone can be modified.  
  
 A shallow copy of an object is a copy of the object only. If the object contains references to other objects, the shallow copy does not create copies of the referred objects. It refers to the original objects instead. In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在の <see cref="T:System.Text.Encoding" /> のコード ページ ID を取得します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> のコード ページ ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例は、エンコーディングごとに異なる名前を取得し、表示とは異なる 1 つまたは複数の名前を持つエンコーディング <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName>します。 表示 <xref:System.Text.Encoding.EncodingName%2A> に対しては比較されませんが、します。  
  
 [!code-cpp[System.Text.Encoding.Names\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">
          <c>bytes</c> のエンコーディング形式。</param>
        <param name="dstEncoding">変換後のエンコーディング形式。</param>
        <param name="bytes">変換対象のバイト。</param>
        <summary>バイト配列全体を、あるエンコーディングから別のエンコーディングに変換します。</summary>
        <returns>
          <see cref="T:System.Byte" /> を <paramref name="bytes" /> から <paramref name="srcEncoding" /> へ変換した結果を格納する <paramref name="dstEncoding" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、ASCII でエンコードされた文字列に Unicode でエンコードされた文字列に変換します。 ASCII エンコード オブジェクトが返されるため、 <xref:System.Text.Encoding.ASCII%2A> プロパティは、置換フォールバックを使用し、Pi 文字は、ASCII 文字セットの一部ではない、Pi の文字が、例から出力として疑問符 \(\) に置き換えられます。  
  
 [!code-cpp[System.Text.Encoding.Convert Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="dstEncoding" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 **srcEncoding。** <see cref="P:System.Text.Encoding.DecoderFallback" /> に設定されている <see cref="T:System.Text.DecoderExceptionFallback" />です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 **dstEncoding。** <see cref="P:System.Text.Encoding.EncoderFallback" /> に設定されている <see cref="T:System.Text.EncoderExceptionFallback" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">変換前の配列 <c>bytes</c> のエンコーディング。</param>
        <param name="dstEncoding">変換後の配列のエンコーディング。</param>
        <param name="bytes">変換対象のバイト配列。</param>
        <param name="index">変換対象の <c>bytes</c> の最初の要素を示すインデックス。</param>
        <param name="count">変換するバイト数。</param>
        <summary>バイト配列内のバイトの範囲を、あるエンコーディングから別のエンコーディングに変換します。</summary>
        <returns>
          <see cref="T:System.Byte" /> に含まれる特定の範囲のバイトを <paramref name="bytes" /> から <paramref name="srcEncoding" /> へ変換した結果が格納されている <paramref name="dstEncoding" /> 型の配列。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="dstEncoding" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> <paramref name="count" /> バイト配列内の有効な範囲を指定しません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 **srcEncoding。** <see cref="P:System.Text.Encoding.DecoderFallback" /> に設定されている <see cref="T:System.Text.DecoderExceptionFallback" />です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 **dstEncoding。** <see cref="P:System.Text.Encoding.EncoderFallback" /> に設定されている <see cref="T:System.Text.EncoderExceptionFallback" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.DecoderFallback" /> オブジェクトの <see cref="T:System.Text.Encoding" /> オブジェクトを取得または設定します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> オブジェクトのデコーダー フォールバック オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.DecoderFallback> オブジェクトは、文字にエンコード済みバイト シーケンスをデコードできないときに呼び出されるエラー ハンドラーを表します。 次のハンドラーの種類のいずれかがサポートされています。  
  
-   デコードできないバイトをいくつかの適切な代替文字に置き換え、最適フォールバックのハンドラー。  
  
-   置換フォールバック ハンドラー、いくつかの任意の置換文字をデコードできないバイトに置き換えられます。 .NET Framework には、1 つの置換フォールバック ハンドラーが含まれています <xref:System.Text.DecoderFallback>, 、疑問符 \(\) とデコードできないバイトを置き換える既定で \("?"\)。 文字に置き換えらるからです。  
  
-   例外フォールバック ハンドラーのバイトをデコードできないときに例外をスローします。 .NET Framework には、1 つの例外フォールバック ハンドラーが含まれています。 <xref:System.Text.DecoderExceptionFallback>, 、どのスロー、 <xref:System.Text.DecoderFallbackException> バイトをデコードできない場合にします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">設定操作の値が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">設定操作の値を割り当てることができません現在 <see cref="T:System.Text.Encoding" /> オブジェクトは読み取り専用です。</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オペレーティング システムの現在の ANSI コード ページのエンコーディングを取得します。</summary>
        <value>オペレーティング システムの現在の ANSI コード ページのエンコーディング。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!WARNING]
>  Different computers can use different encodings as the default, and the default encoding can even change on a single computer. Therefore, data streamed from one computer to another or even retrieved at different times on the same computer might be translated incorrectly. In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best\-fit fallback to map unsupported characters to characters supported by the code page. For these two reasons, using the default encoding is generally not recommended. To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>, with a preamble. Another option is to use a higher\-level protocol to ensure that the same format is used for encoding and decoding.  
  
 The system ANSI code page defined by <xref:System.Text.Encoding.Default%2A> covers the ASCII set of characters, but the encoding is different from the encoding for ASCII. Because all <xref:System.Text.Encoding.Default%2A> encodings lose data, you might use <xref:System.Text.Encoding.UTF8%2A> instead. UTF\-8 is often identical in the U\+00 to U\+7F range, but can encode other characters without loss.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.EncoderFallback" /> オブジェクトの <see cref="T:System.Text.Encoding" /> オブジェクトを取得または設定します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> オブジェクトのエンコーダー フォールバック オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.EncoderFallback> オブジェクトは、文字をエンコード済みバイト シーケンスに変換できないときに呼び出されるエラー ハンドラーを表します。 次のハンドラーの種類のいずれかがサポートされています。  
  
-   エンコードできない文字をいくつかの適切な代替文字に置き換え、最適フォールバックのハンドラー。  
  
-   置換フォールバック ハンドラー、いくつかの任意の置換文字をエンコードできない文字に置き換えられます。 .NET Framework には、1 つの置換フォールバック ハンドラーが含まれています <xref:System.Text.EncoderFallback>, 、疑問符 \(\) でエンコードできない文字を置換すると、既定で \("?"\)。 文字に置き換えらるからです。  
  
-   例外フォールバック ハンドラーの文字をエンコードできないときに例外をスローします。 .NET Framework には、1 つの例外フォールバック ハンドラーが含まれています。 <xref:System.Text.EncoderExceptionFallback>, 、どのスロー、 <xref:System.Text.EncoderFallbackException> 文字をデコードできない場合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">設定操作の値が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">設定操作の値を割り当てることができません現在 <see cref="T:System.Text.Encoding" /> オブジェクトは読み取り専用です。</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングについての記述を、ユーザーが判読できる形式で取得します。</summary>
        <value>ユーザーが判読できる形式の、現在の <see cref="T:System.Text.Encoding" /> の記述。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display. To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.  
  
   
  
## 例  
 The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName>. It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.  
  
 [!code-cpp[System.Text.Encoding.Names\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のインスタンスと比較する <see cref="T:System.Object" />。</param>
        <summary>指定した <see cref="T:System.Object" /> が、現在のインスタンスと等しいかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="value" /> のインスタンスで、現在のインスタンスと等しい場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their **languageKeyword tag is not supported!!!!**  
 and **languageKeyword tag is not supported!!!!**  
 objects are equal. In particular, derived code pages all have a code page of 0 and their fallbacks are normally **languageKeyword tag is not supported!!!!**  
\(**languageKeyword tag is not supported!!!!**  
in Visual Basic .NET\). Thus they are all considered equal to one another. One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.  
  
   
  
## 例  
 The following example gets two instances of the same encoding \(one by codepage and another by name\), and checks their equality.  
  
 [!code-cpp[System.Text.Encoding.Equals\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字を格納している文字配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されているすべての文字をエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字配列に格納されているすべての文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.Encoding.GetBytes%2A> 結果のバイトを格納する、 <xref:System.Text.Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 <xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.Encoding.GetByteCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 <xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。<xref:System.Text.Encoding.GetBytes%2A> メソッドのとは異なり、不連続の変換が必要ですが、 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数の変換を処理します。  
  
 複数のバージョンの <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードして、複数の呼び出しを使用して文字を処理する必要があります。 ここでは、おそらく必要によって保存された状態を考慮に入れて、呼び出し間で状態を維持するために、 <xref:System.Text.Encoder> 使用されているオブジェクトします。  
  
-   アプリでは、文字列入力を処理する場合は、文字列バージョンを使用する必要があります、 <xref:System.Text.Encoding.GetBytes%2A> メソッドです。  
  
-   Unicode 文字バッファー バージョン <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> により、特にサイズを使用して複数の呼び出しが、いくつかの高速なテクニック、 <xref:System.Text.Encoder> オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッドのバージョンがない場合があります安全である、ポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、に、出力バッファーが再利用する必要があります。 ここで、 <xref:System.Text.Encoding.GetBytes%2A> バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、 <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> メソッドの代わりに <xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、できるだけ多くのデータを変換し、出力バッファーが小さすぎる場合、例外がスローします。 連続的に、ストリームのエンコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例は、文字配列をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">エンコード対象の文字のセットを格納している文字列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列に含まれる文字をエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.Encoding.GetBytes%2A> 結果のバイトを格納する、 <xref:System.Text.Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 <xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.Encoding.GetByteCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 <xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。<xref:System.Text.Encoding.GetBytes%2A> メソッドのとは異なり、不連続の変換が必要ですが、 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数の変換を処理します。  
  
 複数のバージョンの <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードして、複数の呼び出しを使用して文字を処理する必要があります。 ここでは、おそらく必要によって保存された状態を考慮に入れて、呼び出し間で状態を維持するために、 <xref:System.Text.Encoder> 使用されているオブジェクトします。  
  
-   アプリは、文字列入力の文字列形式を処理する場合 <xref:System.Text.Encoding.GetBytes%2A> をお勧めします。  
  
-   Unicode 文字バッファー バージョン <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> により、特にサイズを使用して複数の呼び出しが、いくつかの高速なテクニック、 <xref:System.Text.Encoder> オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッドのバージョンがない場合があります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 <xref:System.Text.Encoding.GetBytes%2A> バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、 <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> メソッドの代わりに <xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、できるだけ多くのデータを変換し、出力バッファーが小さすぎる場合、例外がスローします。 連続的に、ストリームのエンコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例は、文字列または文字列の範囲をエンコードするために必要なバイト数を決定するの文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_String\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_String\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_String\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字ポインターから始まる文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 計算する正確な配列のサイズを <xref:System.Text.Encoding.GetBytes%2A> 必要と結果のバイトを格納するを呼び出す必要があります、 <xref:System.Text.Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 <xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.Encoding.GetByteCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 <xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> メソッドでは、実際のエンコードを実行します。<xref:System.Text.Encoding.GetBytes%2A> メソッドのとは異なり、不連続の変換が必要ですが、 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数の変換を処理します。  
  
 複数のバージョンの <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> はサポートされています。 これらのメソッドを使用するためのいくつか考慮事項を次に示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードして、複数の呼び出しを使用して文字を処理する必要があります。 ここでは、おそらく必要によって保存された状態を考慮に入れて、呼び出し間で状態を維持するために、 <xref:System.Text.Encoder> 使用されているオブジェクトします。  
  
-   文字列バージョンを使用するアプリでは、文字列入力を処理する場合、 <xref:System.Text.Encoding.GetBytes%2A> メソッドです。  
  
-   Unicode 文字バッファー バージョン <xref:System.Text.Encoding.GetBytes%2A> により、特にサイズを使用して複数の呼び出しが、いくつかの高速なテクニック、 <xref:System.Text.Encoder> オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッドのバージョンがない場合があります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 <xref:System.Text.Encoding.GetBytes%2A> バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、 <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> メソッドの代わりに <xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、できるだけ多くのデータを変換し、出力バッファーが小さすぎる場合、例外がスローします。 連続的に、ストリームのエンコード、このメソッドが多くの場合、最適な選択肢です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A> 結果のバイトを格納する、 [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドです。[GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetByteCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。[GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A> メソッドのとは異なり、不連続の変換が必要ですが、 [GetByteCount メソッド \(Char\<xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数の変換を処理します。  
  
 複数のバージョンの [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetByteCount%2A> と [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードして、複数の呼び出しを使用して文字を処理する必要があります。 ここでは、おそらく必要によって保存された状態を考慮に入れて、呼び出し間で状態を維持するために、 [GetByteCount メソッド \(Char\<xref:System.Text.Encoder> 使用されているオブジェクトします。  
  
-   アプリは、文字列入力の文字列形式を処理する場合 [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A> をお勧めします。  
  
-   Unicode 文字バッファー バージョン [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> により、特にサイズを使用して複数の呼び出しが、いくつかの高速なテクニック、 [GetByteCount メソッド \(Char\<xref:System.Text.Encoder> オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッドのバージョンがない場合があります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A> バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、 [GetByteCount メソッド \(Char\<xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> メソッドの代わりに [GetByteCount メソッド \(Char\<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、できるだけ多くのデータを変換し、出力バッファーが小さすぎる場合、例外がスローします。 連続的に、ストリームのエンコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例は、文字配列から次の 3 つの文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_CharArrIC\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_CharArrIC\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_CharArrIC\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字を格納している文字配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されているすべての文字をバイト シーケンスにエンコードします。</summary>
        <returns>指定した文字のセットをエンコードした結果を格納しているバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 <xref:System.Text.Decoder> または <xref:System.Text.Encoder> によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッド、派生クラスのそれぞれをします。  
  
 <xref:System.Text.Encoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。<xref:System.Text.Encoding.GetBytes%2A> メソッドのとは異なり、不連続の変換が必要ですが、 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数の変換を処理します。  
  
 複数のバージョンの <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードして、複数の呼び出しを使用して文字を処理する必要があります。 ここでは、おそらく必要によって保存された状態を考慮に入れて、呼び出し間で状態を維持するために、 <xref:System.Text.Encoder> 使用されているオブジェクトします。 \(たとえば、サロゲート ペアが格納されている文字シーケンスから上位サロゲートで終わる可能性があります。<xref:System.Text.Encoder> できるので、次の呼び出しの先頭にある下位サロゲートで組み合わせることができます、その上位サロゲートが記憶されます。<xref:System.Text.Encoding> 文字に送信されるように、状態を維持することはできません、 <xref:System.Text.EncoderFallback>.\)  
  
-   アプリでは、文字列入力を処理する場合は、文字列バージョンを呼び出す必要があります、 <xref:System.Text.Encoding.GetBytes%2A> メソッドです。  
  
-   Unicode 文字バッファー バージョン <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> により、特にサイズを使用して複数の呼び出しが、いくつかの高速なテクニック、 <xref:System.Text.Encoder> オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッドのバージョンがない場合があります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 <xref:System.Text.Encoding.GetBytes%2A> バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、 <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> メソッドの代わりに <xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、できるだけ多くのデータを変換し、出力バッファーが小さすぎる場合、例外がスローします。 連続的に、ストリームのエンコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例は、文字配列をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">エンコードする文字を含む文字列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列に含まれるすべての文字をバイト シーケンスにエンコードします。</summary>
        <returns>指定した文字のセットをエンコードした結果を格納しているバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 <xref:System.Text.Decoder> または <xref:System.Text.Encoder> によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッド、派生クラスのそれぞれをします。  
  
 <xref:System.Text.Encoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。<xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> メソッドのとは異なり、不連続の変換が必要ですが、 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数の変換を処理します。  
  
 複数のバージョンの <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードして、複数の呼び出しを使用して文字を処理する必要があります。 ここでは、おそらく必要によって保存された状態を考慮に入れて、呼び出し間で状態を維持するために、 <xref:System.Text.Encoder> 使用されているオブジェクトします。 \(たとえば、サロゲート ペアが格納されている文字シーケンスから上位サロゲートで終わる可能性があります。<xref:System.Text.Encoder> できるので、次の呼び出しの先頭にある下位サロゲートで組み合わせることができます、その上位サロゲートが記憶されます。<xref:System.Text.Encoding> 文字に送信されるように、状態を維持することはできません、 <xref:System.Text.EncoderFallback>.\)  
  
-   アプリでは、文字列入力を処理する場合は、文字列形式を使用する必要があります <xref:System.Text.Encoding.GetBytes%2A>します。  
  
-   Unicode 文字バッファー バージョン <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> により、特にサイズを使用して複数の呼び出しが、いくつかの高速なテクニック、 <xref:System.Text.Encoder> オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッドのバージョンがない場合があります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 <xref:System.Text.Encoding.GetBytes%2A> バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、 <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> メソッドの代わりに <xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、できるだけ多くのデータを変換し、出力バッファーが小さすぎる場合、例外がスローします。 連続的に、ストリームのエンコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例は、文字列または文字列の範囲をエンコードするために必要なバイト数を決定するの文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_String\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_String\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_String\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットをバイト シーケンスにエンコードします。</summary>
        <returns>指定した文字のセットをエンコードした結果を格納しているバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 [GetBytes メソッド \(Char\<xref:System.Text.Decoder> または [GetBytes メソッド \(Char\<xref:System.Text.Encoder> によって提供される、 [GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは [GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetEncoder%2A> メソッド、派生クラスのそれぞれをします。  
  
 [GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 [GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。[GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> メソッドのとは異なり、不連続の変換が必要ですが、 [GetBytes メソッド \(Char\<xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数の変換を処理します。  
  
 複数のバージョンの [GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetByteCount%2A> と [GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードして、複数の呼び出しを使用して文字を処理する必要があります。 ここでは、おそらく必要によって保存された状態を考慮に入れて、呼び出し間で状態を維持するために、 [GetBytes メソッド \(Char\<xref:System.Text.Encoder> 使用されているオブジェクトします。 \(たとえば、サロゲート ペアが格納されている文字シーケンスから上位サロゲートで終わる可能性があります。[GetBytes メソッド \(Char\<xref:System.Text.Encoder> できるので、次の呼び出しの先頭にある下位サロゲートで組み合わせることができます、その上位サロゲートが記憶されます。[GetBytes メソッド \(Char\<xref:System.Text.Encoding> 文字に送信されるように、状態を維持することはできません、 [GetBytes メソッド \(Char\<xref:System.Text.EncoderFallback>.\)  
  
-   アプリでは、文字列入力を処理する場合は、文字列形式を使用する必要があります [GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A>します。  
  
-   Unicode 文字バッファー バージョン [GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> により、特にサイズを使用して複数の呼び出しが、いくつかの高速なテクニック、 [GetBytes メソッド \(Char\<xref:System.Text.Encoder> オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッドのバージョンがない場合があります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 [GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetBytes%2A> バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、 [GetBytes メソッド \(Char\<xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> メソッドの代わりに [GetBytes メソッド \(Char\<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、できるだけ多くのデータを変換し、出力バッファーが小さすぎる場合、例外がスローします。 連続的に、ストリームのエンコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例は、文字配列から次の 3 つの文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_CharArrIC\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_CharArrIC\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_CharArrIC\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスの書き込みを開始する位置へのポインター。</param>
        <param name="byteCount">書き込む最大バイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字ポインターで始まる文字のセットを、指定したバイト ポインターを開始位置として格納されるバイト シーケンスにエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> パラメーターによって示される位置に書き込む実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 計算する正確な配列のサイズを <xref:System.Text.Encoding.GetBytes%2A> 必要と結果のバイトを格納する、 <xref:System.Text.Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 <xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.Encoding.GetByteCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 <xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 <xref:System.Text.Decoder> または <xref:System.Text.Encoder> オブジェクトによって提供される、 <xref:System.Text.Encoding.GetDecoder%2A> または <xref:System.Text.Encoding.GetEncoder%2A> メソッドを派生クラスのそれぞれに、します。  
  
 <xref:System.Text.Encoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。<xref:System.Text.Encoding.GetBytes%2A> メソッドのとは異なり、不連続の変換が必要ですが、 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数の変換を処理します。  
  
 複数のバージョンの <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードして、複数の呼び出しを使用して文字を処理する必要があります。 ここでは、おそらく必要によって保存された状態を考慮に入れて、呼び出し間で状態を維持するために、 <xref:System.Text.Encoder> 使用されているオブジェクトします。 \(たとえば、サロゲート ペアが格納されている文字シーケンスから上位サロゲートで終わる可能性があります。<xref:System.Text.Encoder> できるので、次の呼び出しの先頭にある下位サロゲートで組み合わせることができます、その上位サロゲートが記憶されます。<xref:System.Text.Encoding> 文字に送信されるように、状態を維持することはできません、 <xref:System.Text.EncoderFallback>.\)  
  
-   アプリでは、文字列入力を処理する場合は、文字列形式を使用する必要があります <xref:System.Text.Encoding.GetBytes%2A>します。  
  
-   Unicode 文字バッファー バージョン <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> により、特にサイズを使用して複数の呼び出しが、いくつかの高速なテクニック、 <xref:System.Text.Encoder> オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッドのバージョンがない場合があります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 <xref:System.Text.Encoding.GetBytes%2A> バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、 <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> メソッドの代わりに <xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、できるだけ多くのデータを変換し、出力バッファーが小さすぎる場合、例外がスローします。 連続的に、ストリームのエンコード、このメソッドが多くの場合、最適な選択肢です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> 結果のバイト数より少ない。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットを、指定したバイト配列にエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A> 呼び出す必要があります結果のバイトを格納する、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドです。[GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetByteCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Decoder> または [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder> によって提供される、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetEncoder%2A> メソッド、派生クラスのそれぞれをします。  
  
 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。[GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> メソッドのとは異なり、不連続の変換が必要ですが、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数の変換を処理します。  
  
 複数のバージョンの [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetByteCount%2A> と [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードして、複数の呼び出しを使用して文字を処理する必要があります。 ここでは、おそらく必要によって保存された状態を考慮に入れて、呼び出し間で状態を維持するために、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder> 使用されているオブジェクトします。 \(たとえば、サロゲート ペアが格納されている文字シーケンスから上位サロゲートで終わる可能性があります。[GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder> できるので、次の呼び出しの先頭にある下位サロゲートで組み合わせることができます、その上位サロゲートが記憶されます。[GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding> 文字に送信されるように、状態を維持することはできません、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.EncoderFallback>.\)  
  
-   アプリでは、文字列入力を処理する場合は、文字列形式を使用する必要があります [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A>します。  
  
-   Unicode 文字バッファー バージョン [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> により、特にサイズを使用して複数の呼び出しが、いくつかの高速なテクニック、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder> オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッドのバージョンがない場合があります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A> バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、 [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> メソッドの代わりに [GetBytes メソッド \(Char\[\], Int32, Int32, Byte\<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、できるだけ多くのデータを変換し、出力バッファーが小さすぎる場合、例外がスローします。 連続的に、ストリームのエンコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例は、文字配列から次の 3 つの文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_CharArrIC\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_CharArrIC\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_CharArrIC\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> または <paramref name="charCount" /> または <paramref name="byteIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
 または  
  
 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> 十分な容量がない <paramref name="byteIndex" /> に結果のバイトを合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">エンコード対象の文字のセットを格納している文字列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列に含まれる文字のセットを、指定したバイト配列にエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A> 呼び出す必要があります結果のバイトを格納する、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するには、呼び出し、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドです。[GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetByteCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Decoder> または [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoder> によって提供される、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetEncoder%2A> メソッド、派生クラスのそれぞれをします。  
  
 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetByteCount%2A> メソッドでは、Unicode 文字のセットをエンコードで発生するまでのバイト数を決定し、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A> メソッドでは、実際のエンコードを実行します。[GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A?displayProperty=fullName> メソッドのとは異なり、不連続の変換が必要ですが、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数の変換を処理します。  
  
 複数のバージョンの [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetByteCount%2A> と [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードして、複数の呼び出しを使用して文字を処理する必要があります。 ここでは、おそらく必要によって保存された状態を考慮に入れて、呼び出し間で状態を維持するために、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoder> 使用されているオブジェクトします。 \(たとえば、サロゲート ペアが格納されている文字シーケンスから上位サロゲートで終わる可能性があります。[GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoder> できるので、次の呼び出しの先頭にある下位サロゲートで組み合わせることができます、その上位サロゲートが記憶されます。[GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding> 文字に送信されるように、状態を維持することはできません、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.EncoderFallback>.\)  
  
-   アプリでは、文字列入力を処理する場合は、文字列形式を使用する必要があります [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A>します。  
  
-   Unicode 文字バッファー バージョン [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> により、特にサイズを使用して複数の呼び出しが、いくつかの高速なテクニック、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoder> オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッドのバージョンがない場合があります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetBytes%2A> バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、 [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoder.Convert%2A?displayProperty=fullName> メソッドの代わりに [GetBytes メソッド \(String, Int32, Int32, Byte\<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、できるだけ多くのデータを変換し、出力バッファーが小さすぎる場合、例外がスローします。 連続的に、ストリームのエンコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例は、文字列または文字列の範囲をエンコードするために必要なバイト数を決定するの文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_String\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_String\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_String\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> または <paramref name="charCount" /> または <paramref name="byteIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="charIndex" /> <paramref name="charCount" /> で有効な範囲を表していません <paramref name="chars" />します。  
  
 または  
  
 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> 十分な容量がない <paramref name="byteIndex" /> に結果のバイトを合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> 結果の文字を保存するには、使用する必要があります、 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> メソッドです。 配列の最大サイズを計算するには、使用する必要があります、 <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> メソッドです。<xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 一般的に、メソッドより少ないメモリの割り当て中に、 <xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> メソッドは、バイト シーケンスをデコード中に発生する文字数を決定し、  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> メソッドでは、実際のデコードを実行します。<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> メソッドのとは異なり、不連続の変換が必要ですが、 <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数のパスを処理します。  
  
 複数のバージョンの <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 この場合、おそらく、呼び出しの間で状態を維持する必要があります。  
  
-   使用する必要があります、アプリは、文字列の出力を処理する場合、 <xref:System.Text.Encoding.GetString%2A> メソッドです。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、その結果、 <xref:System.String> 型が優先されます。  
  
-   バイトのバージョンの <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッドのバージョンがない場合もあります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> サポートしていますが、文字バッファーを出力するバージョンをお勧めします。  
  
-   使用を検討して、 <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> メソッドの代わりに <xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例では、文字列、バイト配列にエンコードし、文字の配列にバイトをデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetChars\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト ポインターから始まるバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 計算する正確な配列のサイズを <xref:System.Text.Encoding.GetChars%2A> 必要と結果の文字を保存するには、使用する必要があります、 <xref:System.Text.Encoding.GetCharCount%2A> メソッドです。 配列の最大サイズを計算するには、使用、 <xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドです。<xref:System.Text.Encoding.GetCharCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 <xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイト シーケンスをデコード中に発生する文字数を決定し、 <xref:System.Text.Encoding.GetChars%2A> メソッドでは、実際のデコードを実行します。<xref:System.Text.Encoding.GetChars%2A> メソッドのとは異なり、不連続の変換が必要ですが、 <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数のパスを処理します。  
  
 複数のバージョンの <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 この場合、おそらく、呼び出しの間で状態を維持する必要があります。  
  
-   使用することが推奨アプリでは、文字列の出力を処理する場合、 <xref:System.Text.Encoding.GetString%2A> メソッドです。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、その結果、 <xref:System.String> 型が優先されます。  
  
-   バイトのバージョンの <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッドのバージョンがない場合もあります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> サポートしていますが、文字バッファーを出力するバージョンをお勧めします。  
  
-   使用を検討して、 <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> メソッドの代わりに <xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドが多くの場合、最適な選択肢です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A> 結果の文字を保存するには、使用する必要があります、 [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetCharCount%2A> メソッドです。 配列の最大サイズを計算するには、使用、 [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドです。[GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetCharCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイト シーケンスをデコード中に発生する文字数を決定し、 [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A> メソッドでは、実際のデコードを実行します。[GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A> メソッドのとは異なり、不連続の変換が必要ですが、 [GetCharCount メソッド \(Byte\<xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数のパスを処理します。  
  
 複数のバージョンの [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetCharCount%2A> と [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 この場合、おそらく、呼び出しの間で状態を維持する必要があります。  
  
-   使用することが推奨アプリでは、文字列の出力を処理する場合、 [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetString%2A> メソッドです。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、その結果、 [GetCharCount メソッド \(Byte\<xref:System.String> 型が優先されます。  
  
-   バイトのバージョンの [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッドのバージョンがない場合もあります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> サポートしていますが、文字バッファーを出力するバージョンをお勧めします。  
  
-   使用を検討して、 [GetCharCount メソッド \(Byte\<xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> メソッドの代わりに [GetCharCount メソッド \(Byte\<xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例では、あるエンコーディングから別のエンコーディング文字列に変換します。  
  
 [!code-cpp[System.Text.Encoding.Convert Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 次の例では、文字列、バイト配列にエンコードし、文字の配列にバイトの範囲をデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトを文字のセットにデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納された文字配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 入力バイト シーケンスから文字を取得します。<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 異なる <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> ため <xref:System.Text.Encoding> 、不連続の変換が必要ですが中に <xref:System.Text.Decoder> は単一の入力ストリームに複数のパスに設計されています。  
  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 <xref:System.Text.Decoder> または <xref:System.Text.Encoder> によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッド、派生クラスのそれぞれをします。  
  
 **注** このメソッドは、バイト配列などの任意のバイナリ データではなく、Unicode 文字に対して行うためのものです。 テキストに任意のバイナリ データをエンコードする必要がある場合などの方法で実装された uuencode などのプロトコルを使用する必要があります <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>します。  
  
 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイト シーケンスをデコード中に発生する文字数を決定し、 <xref:System.Text.Encoding.GetChars%2A> メソッドでは、実際のデコードを実行します。<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> メソッドのとは異なり、不連続の変換が必要ですが、 <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数のパスを処理します。  
  
 複数のバージョンの <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 この場合、可能性があります必要があります、呼び出し間で状態を維持するためにバッチ処理では、バイト シーケンスを中断することがあるためです。 \(たとえば、iso\-2022 シフト シーケンスの一部がなる可能性がありますいずれかの <xref:System.Text.Encoding.GetChars%2A> を呼び出すし、次の先頭から継続 <xref:System.Text.Encoding.GetChars%2A> を呼び出します。<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 不完全なシーケンスのフォールバックを呼び出しますが、 <xref:System.Text.Decoder> は次の呼び出しのシーケンスに注意してください\)。  
  
-   使用することが推奨アプリでは、文字列の出力を処理する場合、 <xref:System.Text.Encoding.GetString%2A> メソッドです。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、その結果、 <xref:System.String> 型が優先されます。  
  
-   バイトのバージョンの <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッドのバージョンがない場合もあります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> サポートしていますが、文字バッファーを出力するバージョンをお勧めします。  
  
-   使用を検討して、 <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> メソッドの代わりに <xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例では、文字列、バイト配列にエンコードし、文字の配列にバイトをデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetChars\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを文字のセットにデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納された文字配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 入力バイト シーケンスから文字を取得します。[GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 異なる [GetChars メソッド \(Byte\<xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> ため [GetChars メソッド \(Byte\<xref:System.Text.Encoding> 、不連続の変換が必要ですが中に [GetChars メソッド \(Byte\<xref:System.Text.Decoder> は単一の入力ストリームに複数のパスに設計されています。  
  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 [GetChars メソッド \(Byte\<xref:System.Text.Decoder> または [GetChars メソッド \(Byte\<xref:System.Text.Encoder> によって提供される、 [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetEncoder%2A> メソッド、派生クラスのそれぞれをします。  
  
 **注** このメソッドは、バイト配列などの任意のバイナリ データではなく、Unicode 文字に対して行うためのものです。 テキストに任意のバイナリ データをエンコードする必要がある場合などの方法で実装された uuencode などのプロトコルを使用する必要があります [GetChars メソッド \(Byte\<xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>します。  
  
 [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイト シーケンスをデコード中に発生する文字数を決定し、 [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A> メソッドでは、実際のデコードを実行します。[GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> メソッドのとは異なり、不連続の変換が必要ですが、 [GetChars メソッド \(Byte\<xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数のパスを処理します。  
  
 複数のバージョンの [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetCharCount%2A> と [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 この場合、可能性があります必要があります、呼び出し間で状態を維持するためにバッチ処理では、バイト シーケンスを中断することがあるためです。 \(たとえば、iso\-2022 シフト シーケンスの一部がなる可能性がありますいずれかの [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A> を呼び出すし、次の先頭から継続 [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A> を呼び出します。[GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 不完全なシーケンスのフォールバックを呼び出しますが、 [GetChars メソッド \(Byte\<xref:System.Text.Decoder> は次の呼び出しのシーケンスに注意してください\)。  
  
-   使用することが推奨アプリでは、文字列の出力を処理する場合、 [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetString%2A> メソッドです。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、その結果、 [GetChars メソッド \(Byte\<xref:System.String> 型が優先されます。  
  
-   バイトのバージョンの [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッドのバージョンがない場合もあります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> サポートしていますが、文字バッファーを出力するバージョンをお勧めします。  
  
-   使用を検討して、 [GetChars メソッド \(Byte\<xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> メソッドの代わりに [GetChars メソッド \(Byte\<xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例では、文字列、バイト配列にエンコードし、文字の配列にバイトの範囲をデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字セットの書き込みを開始する位置へのポインター。</param>
        <param name="charCount">書き込む文字の最大数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト ポインターで始まるバイト シーケンスを、指定した文字ポインターを開始位置として格納される文字のセットにデコードします。</summary>
        <returns>
          <paramref name="chars" /> パラメーターによって示される位置に書き込む実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 計算する正確な配列のサイズを <xref:System.Text.Encoding.GetChars%2A> 必要と結果の文字を保存するには、使用する必要があります、 <xref:System.Text.Encoding.GetCharCount%2A> メソッドです。 配列の最大サイズを計算するには、使用、 <xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドです。<xref:System.Text.Encoding.GetCharCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 <xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 入力バイト シーケンスから文字を取得します。<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 異なる <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> ため <xref:System.Text.Encoding> 、不連続の変換が必要ですが中に <xref:System.Text.Decoder> は単一の入力ストリームに複数のパスに設計されています。  
  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 <xref:System.Text.Decoder> または <xref:System.Text.Encoder> オブジェクトによって提供される、 <xref:System.Text.Encoding.GetDecoder%2A> または <xref:System.Text.Encoding.GetEncoder%2A> メソッドを派生クラスのそれぞれに、します。  
  
 **注** このメソッドは、バイト配列などの任意のバイナリ データではなく、Unicode 文字に対して行うためのものです。 テキストに任意のバイナリ データをエンコードする必要がある場合などの方法で実装された uuencode などのプロトコルを使用する必要があります <xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>します。  
  
 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイト シーケンスをデコード中に発生する文字数を決定し、 <xref:System.Text.Encoding.GetChars%2A> メソッドでは、実際のデコードを実行します。<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> メソッドのとは異なり、不連続の変換が必要ですが、 <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数のパスを処理します。  
  
 複数のバージョンの <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 この場合、可能性があります必要があります、呼び出し間で状態を維持するためにバッチ処理では、バイト シーケンスを中断することがあるためです。 \(たとえば、iso\-2022 シフト シーケンスの一部がなる可能性がありますいずれかの <xref:System.Text.Encoding.GetChars%2A> を呼び出すし、次の先頭から継続 <xref:System.Text.Encoding.GetChars%2A> を呼び出します。<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 不完全なシーケンスのフォールバックを呼び出しますが、 <xref:System.Text.Decoder> は次の呼び出しのシーケンスに注意してください\)。  
  
-   アプリは、文字列の出力を処理する場合、 <xref:System.Text.Encoding.GetString%2A> 方法はお勧めします。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、その結果、 <xref:System.String> 型が優先されます。  
  
-   バイトのバージョンの <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッドのバージョンがない場合もあります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> サポートしていますが、文字バッファーを出力するバージョンをお勧めします。  
  
-   使用を検討して、 <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> メソッドの代わりに <xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドが多くの場合、最適な選択肢です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> または <paramref name="charCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> 結果の文字数より少ない。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="byteIndex">デコードする最初のバイトのインデックス。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字のセットを格納する文字配列。</param>
        <param name="charIndex">結果の文字のセットを書き込む開始位置のインデックス。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを、指定した文字配列にデコードします。</summary>
        <returns>
          <paramref name="chars" /> に書き込まれた実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> 結果の文字を保存するには、使用する必要があります、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetCharCount%2A> メソッドです。 配列の最大サイズを計算するには、使用、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドです。[GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetCharCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 入力バイト シーケンスから文字を取得します。[GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 異なる [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> ため [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding> 、不連続の変換が必要ですが中に [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Decoder> は単一の入力ストリームに複数のパスに設計されています。  
  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Decoder> または [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoder> によって提供される、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetEncoder%2A> メソッド、派生クラスのそれぞれをします。  
  
 **注** このメソッドは、バイト配列などの任意のバイナリ データではなく、Unicode 文字に対して行うためのものです。 テキストに任意のバイナリ データをエンコードする必要がある場合などの方法で実装された uuencode などのプロトコルを使用する必要があります [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Convert.ToBase64CharArray%2A?displayProperty=fullName>します。  
  
 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイト シーケンスをデコード中に発生する文字数を決定し、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> メソッドでは、実際のデコードを実行します。[GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> メソッドのとは異なり、不連続の変換が必要ですが、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> メソッドで、1 つの入力ストリームに複数のパスを処理します。  
  
 複数のバージョンの [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetCharCount%2A> と [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> はサポートされています。 これらのメソッドの使用のプログラミング注意事項を次に示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 この場合、可能性があります必要があります、呼び出し間で状態を維持するためにバッチ処理では、バイト シーケンスを中断することがあるためです。 \(たとえば、iso\-2022 シフト シーケンスの一部がなる可能性がありますいずれかの [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> を呼び出すし、次の先頭から継続 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> を呼び出します。[GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> 不完全なシーケンスのフォールバックを呼び出しますが、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Decoder> は次の呼び出しのシーケンスに注意してください\)。  
  
-   アプリは、文字列の出力を処理する場合、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetString%2A> 方法はお勧めします。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、その結果、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.String> 型が優先されます。  
  
-   バイトのバージョンの [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッドのバージョンがない場合もあります安全である、ポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要がありますは、出力バッファーを再利用する必要があります。 ここで、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> サポートしていますが、文字バッファーを出力するバージョンをお勧めします。  
  
-   使用を検討して、 [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> メソッドの代わりに [GetChars メソッド \(Byte\[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドが多くの場合、最適な選択肢です。  
  
   
  
## 例  
 次の例では、あるエンコーディングから別のエンコーディング文字列に変換します。  
  
 [!code-cpp[System.Text.Encoding.Convert Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 次の例では、文字列、バイト配列にエンコードし、文字の配列にバイトの範囲をデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> または <paramref name="byteCount" /> または <paramref name="charIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="byteindex" /> <paramref name="byteCount" /> で有効な範囲を表していません <paramref name="bytes" />します。  
  
 または  
  
 <paramref name="charIndex" /> が <paramref name="chars" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> 十分な容量がない <paramref name="charIndex" /> に結果の文字を合わせて、配列の末尾にします。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、エンコード済みバイト シーケンスを文字シーケンスに変換するデコーダーを取得します。</summary>
        <returns>エンコード済みバイト シーケンスを文字シーケンスに変換する <see cref="T:System.Text.Decoder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> メソッドと同様の方法での文字の連続ブロックにバイトの連続したブロックを変換する、 <xref:System.Text.Encoding.GetChars%2A> このクラスのメソッドです。 ただし、 <xref:System.Text.Decoder> ブロックにまたがるバイト シーケンスを正しくデコードするための呼び出しの間で状態情報を保持します。<xref:System.Text.Decoder> もデータ ブロックの末尾にある末尾のバイトを保持し、次のデコード操作で末尾のバイトを使用します。 したがって、 <xref:System.Text.Encoding.GetDecoder%2A> と <xref:System.Text.Encoding.GetEncoder%2A> の完全なデータ ストリームではなくデータ ブロックを頻繁にこれらの操作を処理するためには、ネットワーク転送とファイルの操作に便利です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The default implementation returns a <see cref="T:System.Text.Decoder" /> that calls the <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> methods of the current <see cref="T:System.Text.Encoding" />. You must override this method to return a <see cref="T:System.Text.Decoder" /> that maintains its state between calls.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、Unicode 文字のシーケンスをエンコード済みバイト シーケンスに変換するエンコーダーを取得します。</summary>
        <returns>Unicode 文字のシーケンスをエンコード済みバイト シーケンスに変換する <see cref="T:System.Text.Encoder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> メソッドと同様の方法のバイト数の連続ブロックに文字の連続したブロックを変換する、 <xref:System.Text.Encoding.GetBytes%2A> このクラスのメソッドです。 ただし、 <xref:System.Text.Encoder> ブロックにまたがる文字のシーケンスを正しくエンコードするための呼び出しの間で状態情報を保持します。<xref:System.Text.Encoder> も保持末尾のデータ ブロックの末尾に文字を使用して末尾の文字の次のエンコード操作します。 たとえば、データ ブロックが上位サロゲートで終了し、一致する下位サロゲートが次のデータ ブロックしていることがあります。 したがって、 <xref:System.Text.Encoding.GetDecoder%2A> と <xref:System.Text.Encoding.GetEncoder%2A> の完全なデータ ストリームではなくデータ ブロックを頻繁にこれらの操作を処理するためには、ネットワーク転送とファイルの操作に便利です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The default implementation returns a <see cref="T:System.Text.Encoder" /> that calls the <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> methods of the current <see cref="T:System.Text.Encoding" />. You must override this method to return a <see cref="T:System.Text.Encoder" /> that maintains its state between calls.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">使用するエンコーディングのコード ページ ID。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、コード ページの列にリストされています。  
  
 または  
  
 既定のエンコーディングを使用する場合は 0。</param>
        <summary>指定したコード ページ ID に関連付けられたエンコーディングを返します。</summary>
        <returns>指定したコード ページに関連付けられたエンコーディング。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォールバックのハンドラーは、エンコードの種類によって異なります。 `codepage`します。 場合 `codepage` コード ページまたは 2 バイト文字セット \(DBCS\) エンコーディングを設定、最適フォールバック ハンドラーを使用します。 それ以外の場合、置換フォールバック ハンドラーが使用されます。 これらのフォールバック ハンドラーは、アプリが適さない場合があります。 指定したエンコーディングで使用されるフォールバック ハンドラーを指定する `codepage`, 、呼び出すことができます、 <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> オーバー ロードします。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> メソッドは、ほとんどのコード ページをサポートするために基になるプラットフォームに依存します。 ただし、.NET Framework では、一部のエンコーディングをネイティブにサポートします。 コード ページの一覧は、次を参照してください。、 <xref:System.Text.Encoding> クラスに関するトピック。 また、呼び出すことができます、 <xref:System.Text.Encoding.GetEncodings%2A> の配列を取得するメソッド <xref:System.Text.EncodingInfo> すべてのエンコーディングに関する情報を含むオブジェクト。  
  
 .NET Framework の特定のプラットフォームのバージョンで本質的にサポートされているエンコーディングだけでなく、 <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> メソッドを登録することによって利用できる追加のエンコーディングを返します、 <xref:System.Text.EncodingProvider> オブジェクトです。  
  
 オペレーティング システムの地域と言語の設定で既定の ANSI コード ページに関連付けられたエンコーディングを取得するの値 0 を指定することができますか、 `codepage` 引数または、Windows デスクトップで完全な .NET Framework、上の値を取得、 <xref:System.Text.Encoding.Default%2A> プロパティです。 システムで使用される既定のコード ページを確認するのには、Windows を使用して [GetSystemDefaultLangID](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx) 関数です。 現在の ANSI コード ページを確認するのに Windows を呼び出す [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) から Windows デスクトップで、完全な .NET Framework の関数です。  
  
> [!NOTE]
>  サポートされていないコード ページもあれば、例外が発生する <xref:System.ArgumentException> が発生する他のユーザーに対してスローされる <xref:System.NotSupportedException>します。 そのため、コードでキャッチする必要がありますすべて例外\] セクションに示される例外。  
  
> [!NOTE]
>  ANSI コード ページは、別のコンピューターに異なる場合がまたはデータの破損につながる 1 台のコンピューターに変更できます。 このため、エンコーディングと既定のコード ページを使用してデータをデコードすることによって返される `Encoding.GetEncoding(0)` はお勧めしません。 最も一貫性のある結果を得るには、特定のコード ページではなく utf\-8 \(コード ページ 65001\) や utf\-16 などの Unicode を使用してください。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 既定の設定でキャッシュされたインスタンスを返します。 派生クラスのコンス トラクターを使用して、設定が異なるインスタンスを取得する必要があります。 たとえば、 <xref:System.Text.UTF32Encoding> クラスには、エラーの検出を有効にできるコンス トラクターが用意されています。  
  
   
  
## 例  
 次の例では、\(コード ページで 1 つ\)、もう一方は名前をエンコードするには、同じ 2 つのインスタンスを取得し、等しいかどうかを確認します。  
  
 [!code-cpp[System.Text.Encoding.Equals\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> 0 以上 65535 以下未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> 基になるプラットフォームによってサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> 基になるプラットフォームによってサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">使用するエンコーディングのコード ページ名。<see cref="P:System.Text.Encoding.WebName" /> プロパティが返す値はすべて有効です。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、名前の列にリストされています。</param>
        <summary>指定したコード ページ名に関連付けられたエンコーディングを返します。</summary>
        <returns>指定したコード ページに関連付けられたエンコード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォールバックのハンドラーは、エンコードの種類によって異なります。 `name`します。 場合 `name` コード ページまたは 2 バイト文字セット \(DBCS\) エンコーディングを設定、最適フォールバック ハンドラーを使用します。 それ以外の場合、置換フォールバック ハンドラーが使用されます。 これらのフォールバック ハンドラーは、アプリが適さない場合があります。 指定したエンコーディングで使用されるフォールバック ハンドラーを指定する `name`, 、呼び出すことができます、 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> オーバー ロードします。  
  
 `GetEncoding` メソッドは、ほとんどのコード ページをサポートするために基になるプラットフォームに依存します。 ただし、.NET Framework では、一部のエンコーディングをネイティブにサポートします。  
  
 .NET Framework の特定のプラットフォームのバージョンで本質的にサポートされているエンコーディングだけでなく、 <xref:System.Text.Encoding.GetEncoding%28System.String%29> メソッドを登録することによって利用できる追加のエンコーディングを返します、 <xref:System.Text.EncodingProvider> オブジェクトです。  
  
> [!NOTE]
>  ANSI コード ページは、別のコンピューターに異なる場合がまたはデータの破損につながる 1 台のコンピューターに変更できます。 最も一貫性のある結果を得るには、特定のコード ページではなく utf\-8 \(コード ページ 65001\) や utf\-16 などの Unicode を使用してください。  
  
 コード ページの一覧は、次を参照してください。、 <xref:System.Text.Encoding> クラスに関するトピック。 呼び出すことができます、 <xref:System.Text.Encoding.GetEncodings%2A> すべてのエンコーディングの一覧を取得する Windows デスクトップで完全な .NET Framework のメソッドです。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 既定の設定でキャッシュされたインスタンスを返します。 派生クラスのコンス トラクターを使用して、設定が異なるインスタンスを取得する必要があります。 たとえば、 <xref:System.Text.UTF32Encoding> クラスには、エラーの検出を有効にできるコンス トラクターが用意されています。  
  
   
  
## 例  
 次の例では、\(コード ページで 1 つ\)、もう一方は名前をエンコードするには、同じ 2 つのインスタンスを取得し、等しいかどうかを確認します。  
  
 [!code-cpp[System.Text.Encoding.Equals\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 有効なコード ページ名ではありません。  
  
 または  
  
 コード ページがによって示される <paramref name="name" /> は基になるプラットフォームによってサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">使用するエンコーディングのコード ページ ID。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、コード ページの列にリストされています。  
  
 または  
  
 既定のエンコーディングを使用する場合は 0。</param>
        <param name="encoderFallback">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <param name="decoderFallback">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <summary>指定したコード ページ ID に関連付けられたエンコーディングを返します。 パラメーターには、エンコードできない文字とデコードできないバイト シーケンスのためのエラー ハンドラーを指定します。</summary>
        <returns>指定したコード ページに関連付けられたエンコーディング。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  サポートされていないコード ページもあれば、例外が発生する <xref:System.ArgumentException> が発生する他のユーザーに対してスローされる <xref:System.NotSupportedException>します。 そのため、コードでキャッチする必要がありますすべて例外\] セクションに示される例外。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> メソッドは、ほとんどのコード ページをサポートするために基になるプラットフォームに依存します。 ただし、.NET Framework では、一部のエンコーディングをネイティブにサポートします。  
  
 .NET Framework の特定のプラットフォームのバージョンで本質的にサポートされているエンコーディングだけでなく、 <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> メソッドを登録することによって利用できる追加のエンコーディングを返します、 <xref:System.Text.EncodingProvider> オブジェクトです。  
  
> [!NOTE]
>  ANSI コード ページは、別のコンピューターに異なる場合がまたはデータの破損につながる 1 台のコンピューターに変更できます。 このため、エンコーディングと既定のコード ページを使用してデータをデコードすることによって返される `Encoding.GetEncoding(0)` はお勧めしません。 最も一貫性のある結果を得るには、特定のコード ページではなく utf\-8 \(コード ページ 65001\) や utf\-16 などの Unicode を使用してください。  
  
 コード ページの一覧は、次を参照してください。、 <xref:System.Text.Encoding> クラスに関するトピック。 呼び出すことができます、 <xref:System.Text.Encoding.GetEncodings%2A> すべてのエンコーディングの一覧を取得する Windows デスクトップで完全な .NET Framework のメソッドです。  
  
 オペレーティング システムの地域と言語の設定で既定の ANSI コード ページに関連付けられたエンコーディングを取得する、0 に設定する値を指定することができますか、 `codepage` 引数または、コードが、完全な .NET Framework、Windows デスクトップ上で実行されている場合は、値を取得、 <xref:System.Text.Encoding.Default%2A?displayProperty=fullName> プロパティです。 システムで使用される既定のコード ページを確認するのには、Windows を使用して [GetSystemDefaultLangID](http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx) 関数です。 現在の ANSI コード ページを確認するのに Windows を呼び出す [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) から Windows デスクトップで、完全な .NET Framework の関数です。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 既定の設定でキャッシュされたインスタンスを返します。 派生クラスのコンス トラクターを使用して、設定が異なるインスタンスを取得する必要があります。 たとえば、 <xref:System.Text.UTF32Encoding> クラスには、エラーの検出を有効にできるコンス トラクターが用意されています。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=fullName> メソッドです。  
  
 [!code-cpp[sys.txt.fallbackEncRpl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> 0 以上 65535 以下未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> 基になるプラットフォームによってサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> 基になるプラットフォームによってサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">使用するエンコーディングのコード ページ名。<see cref="P:System.Text.Encoding.WebName" /> プロパティが返す値はすべて有効です。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、名前の列にリストされています。</param>
        <param name="encoderFallback">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <param name="decoderFallback">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <summary>指定したコード ページ名に関連付けられたエンコーディングを返します。 パラメーターには、エンコードできない文字とデコードできないバイト シーケンスのためのエラー ハンドラーを指定します。</summary>
        <returns>指定したコード ページに関連付けられたエンコーディング。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `GetEncoding` メソッドは、ほとんどのコード ページをサポートするために基になるプラットフォームに依存します。 ただし、.NET Framework では、一部のエンコーディングをネイティブにサポートします。  
  
 .NET Framework の特定のプラットフォームのバージョンで本質的にサポートされているエンコーディングだけでなく、 <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> メソッドを登録することによって利用できる追加のエンコーディングを返します、 <xref:System.Text.EncodingProvider> オブジェクトです。  
  
> [!NOTE]
>  ANSI コード ページは、別のコンピューターに異なる場合がまたはデータの破損につながる 1 台のコンピューターに変更できます。 最も一貫性のある結果を得るには、特定のコード ページではなく utf\-8 \(コード ページ 65001\) や utf\-16 などの Unicode を使用してください。  
  
 コード ページの一覧は、次を参照してください。、 <xref:System.Text.Encoding> クラスに関するトピック。 呼び出すことができます、 <xref:System.Text.Encoding.GetEncodings%2A> すべてのエンコーディングの一覧を取得する Windows デスクトップで完全な .NET Framework のメソッドです。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 既定の設定でキャッシュされたインスタンスを返します。 派生クラスのコンス トラクターを使用して、設定が異なるインスタンスを取得する必要があります。 たとえば、 <xref:System.Text.UTF32Encoding> クラスには、エラーの検出を有効にできるコンス トラクターが用意されています。  
  
   
  
## 例  
 次の例は、 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=fullName> メソッドです。  
  
 [!code-cpp[sys.txt.fallbackEncRpl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 有効なコード ページ名ではありません。  
  
 または  
  
 コード ページがによって示される <paramref name="name" /> は基になるプラットフォームによってサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのエンコーディングを格納した配列を返します。</summary>
        <returns>すべてのエンコーディングを格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、サポートされているエンコーディングでは、コード ページによって一意に区別の一覧を返します。 サポートされているエンコーディングを示す表を参照してください、 <xref:System.Text.Encoding> クラスに関するトピック。  
  
> [!NOTE]
>  によって返される、サポートされているエンコーディングの一覧、 <xref:System.Text.Encoding.GetEncodings%2A> メソッドがいずれかで使用できる追加のエンコーディングを含まない <xref:System.Text.EncodingProvider> 実装への呼び出しによって登録されている、 <xref:System.Text.Encoding.RegisterProvider%2A> メソッドです。  
  
 50220 と 50222 には、どちらも"iso\-2022年\-jp"、名前に関連付けられているが同一ではないがあります。 50220 のエンコード、カタカナの全角半角カタカナ文字を変換、50222 のエンコーディングは、半角カタカナ文字をエンコードする shift\/シフト アウト シーケンスを使用します。 50222 をエンコードするための表示名は、"日本語 \(Jis 1 バイト カタカナ可 \-、\/SI\)""日本語 \(JIS\)"という名前をディスプレイを持つ 50220 エンコーディングと区別します。  
  
 .NET Framework のエンコーディング 50220 戻り値をエンコード名"iso\-2022年\-jp"を要求するかどうか。 ただし、アプリに適したエンコーディングは、半角カタカナの推奨される処理方法によって決まります。  
  
 特定のエンコーディングを取得するには、使用する必要があります、 <xref:System.Text.Encoding.GetEncoding%2A> メソッドです。  
  
 <xref:System.Text.Encoding.GetEncodings%2A> ファイルのエンコーディングの一覧をユーザーに表示するため **名前を付けて** \] ダイアログ ボックス。 ただし、多くの Unicode 以外のエンコーディングは、いずれかの不完全な多くの文字と"?"、微妙に異なる動作をさまざまなプラットフォームであるか。 既定として utf\-8 または utf\-16 を使用してください。  
  
   
  
## 例  
 次の例では、各エンコーディングのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスのハッシュ コードを返します。</summary>
        <returns>現在のインスタンスのハッシュ コード。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字数をエンコードすることによって生成される最大バイト数を計算します。</summary>
        <returns>指定した文字数をエンコードすることによって生成される最大バイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `charCount` パラメーターの数を実際に指定する <xref:System.Char> を .NET Framework は内部的に Unicode 文字を表す utf\-16 を使用するためにエンコードする Unicode 文字を表すオブジェクト。 Unicode 文字のほとんどを表現して、いずれかでその結果、 <xref:System.Char> オブジェクトがサロゲート ペアで表される Unicode 文字が 2 つ必要です <xref:System.Char> オブジェクトです。  
  
 必要な正確な配列のサイズを計算する <xref:System.Text.Encoding.GetBytes%2A> 結果のバイトを保存するには、使用する必要があります、 <xref:System.Text.Encoding.GetByteCount%2A> メソッドです。 配列の最大サイズを計算するには、使用、 <xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドです。<xref:System.Text.Encoding.GetByteCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 <xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> 現在選択されている最悪のケースを含む、最悪のケースの数を取得 <xref:System.Text.EncoderFallback>します。 フォールバックが大きくなる可能性の文字列で選択した場合 <xref:System.Text.Encoding.GetMaxByteCount%2A> 場所のエンコーディングの最悪の場合は、すべての文字に対してモードの切り替えのケースでは特に、大きな値を取得します。 たとえば、これは ISO 2022\-JP の発生することができます。 詳細については、ブログ記事を参照してください。"[What's with Encoding.GetMaxByteCount\(\) and Encoding.GetMaxCharCount\(\)?](http://go.microsoft.com/fwlink/?LinkId=153702)"\(http:\/\/blogs.msdn.com\/shawnste\/archive\/2005\/03\/02\/383903.aspx\)。  
  
 ほとんどの場合は、このメソッドは、短い文字列で妥当な値を取得します。 大きな文字列の場合は、非常に大きなバッファーを使用してより適切なバッファーが小さすぎる場合は、まれなケースでエラーをキャッチから選択する必要があります。 別のアプローチの使用を検討することも <xref:System.Text.Encoding.GetByteCount%2A> または <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>です。  
  
 使用する場合 <xref:System.Text.Encoding.GetMaxByteCount%2A>, 、入力バッファーの最大サイズに基づいて出力バッファーを割り当てる必要があります。 出力バッファーが \[サイズに制約がある場合、使用、 <xref:System.Text.Encoding.Convert%2A> メソッドです。  
  
 なお <xref:System.Text.Encoding.GetMaxByteCount%2A> 前デコーダー操作から潜在的なサロゲートが残っていると見なします。 デコーダーが原因は、メソッドに値 1 を渡すと、1 バイト エンコーディングに対して、ASCII などの 2 が取得されます。 使用する必要があります、 <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> プロパティがこの情報が必要な場合です。  
  
> [!NOTE]
>  `GetMaxByteCount(N)` 同じ値とは限りません `N* GetMaxByteCount(1)`します。  
  
   
  
## 例  
 次の例は、文字配列をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <block subset="none" type="overrides">
          <para>All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト数をデコードすることによって生成される最大文字数を計算します。</summary>
        <returns>指定したバイト数をデコードすることによって生成される最大文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要な正確な配列のサイズを計算する <xref:System.Text.Encoding.GetChars%2A> 結果の文字を保存するには、使用する必要があります、 <xref:System.Text.Encoding.GetCharCount%2A> メソッドです。 配列の最大サイズを計算するには、使用、 <xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドです。<xref:System.Text.Encoding.GetCharCount%2A> 一般的に、メソッドより少ないメモリの割り当て中に、 <xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 現在選択されている最悪のケースを含む、最悪のケースの数を取得 <xref:System.Text.DecoderFallback>します。 フォールバックが大きくなる可能性の文字列で選択した場合 <xref:System.Text.Encoding.GetMaxCharCount%2A> 大きな値を取得します。  
  
 ほとんどの場合は、このメソッドは、短い文字列では適切な数値を取得します。 大きな文字列の場合に、非常に大きなバッファーを使用してより適切なバッファーが小さすぎることというまれなケースでエラーの検出を選択する必要があります。 別のアプローチの使用を検討することも <xref:System.Text.Encoding.GetCharCount%2A> または <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName>です。  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 関係を持たない <xref:System.Text.Encoding.GetBytes%2A>します。 同様の機能を使用する必要がある場合 <xref:System.Text.Encoding.GetBytes%2A>, 、使用する必要があります <xref:System.Text.Encoding.GetMaxByteCount%2A>します。  
  
 使用する場合 <xref:System.Text.Encoding.GetMaxCharCount%2A>, 、入力バッファーの最大サイズに基づいて出力バッファーを割り当てる必要があります。 出力バッファーが \[サイズに制約がある場合、使用、 <xref:System.Text.Decoder.Convert%2A?displayProperty=fullName> メソッドです。  
  
 なお <xref:System.Text.Encoding.GetMaxCharCount%2A> 最悪の場合、以前のエンコーダーの操作から残されたバイト数を考慮します。 ほとんどのコード ページに、このメソッドに値 0 を渡すと、1 以上の値を取得します。  
  
> [!NOTE]
>  `GetMaxCharCount(N)` 同じ値とは限りません `N* GetMaxCharCount(1)`します。  
  
   
  
## 例  
 次の例では、文字列、バイト配列にエンコードし、文字の配列にバイトをデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetChars\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <block subset="none" type="overrides">
          <para>All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、使用するエンコーディングを指定するバイト シーケンスを返します。</summary>
        <returns>使用するエンコーディングを指定するバイト シーケンスを格納するバイト配列。  
  
 または  
  
 プリアンブルが不要な場合は、長さ 0 のバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要に応じて、 <xref:System.Text.Encoding> オブジェクトは、エンコーディング プロセスに起因バイト シーケンスの先頭バイトの配列である preamble を提供します。 プリアンブルにバイト順マーク \(Unicode では、コード ポイント U\+FEFF\) が含まれている場合、バイト順および変換形式または UTF デコーダーが役立ちます。  
  
 Unicode バイト順マーク \(BOM\) が \(16 進\) に次のようにシリアル化されます。  
  
-   UTF 8: EF BB BF  
  
-   Utf\-16 ビッグ エンディアン バイト順: FE FF  
  
-   Utf\-16 リトル エンディアン バイト順: FF FE  
  
-   Utf\-32 ビッグ エンディアン バイト順: 00 00 FE FF  
  
-   Utf\-32 リトル エンディアン バイト順: FF FE 00 00  
  
 特定の id への参照を失っているファイルのエンコーディングのほとんどを提供しているため、BOM を使用する必要があります、 <xref:System.Text.Encoding> オブジェクト、たとえば、タグなし web データを不適切なタグまたはときビジネス保存されたランダムなテキスト ファイルは、国際的な関心やその他のデータがありませんでした。 データが一貫した方法で適切にタグ付け、可能であれば utf\-8 または utf\-16 と、多くの場合、ユーザーの問題を回避できる可能性があります。  
  
 エンコードの種類を定義した標準から、BOM は、少し冗長です。 ただし、適切なエンコードのヘッダーを送信するサーバーのヘルプを使用できます。 または、そのとして使用できます、フォールバック エンコーディングが失われたそれ以外の場合に備えてします。  
  
 BOM を使用するいくつかのデメリットがあります。 たとえば、BOM を使用するデータベース フィールドを制限する方法についての知識が難しくなります。 ファイルの連結問題になる場合も、たとえば、ファイルを結合するようにデータの途中で不要な文字は最終的にする方法です。 いくつかの短所にもかかわらずただし、部品表の使用強くお勧めします。  
  
 バイト順とバイト順マークの詳細についてで Unicode 標準を参照してください、 [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123)します。  
  
> [!CAUTION]
>  エンコードされたバイトを正しくデコードするためには、エンコード済みバイトのプリアンブルとプレフィックスにする必要があります。 ただし、ほとんどのエンコーディングでは、プリアンブルは提供されません。 ように、エンコード済みバイトが正常にデコードする必要があります、Unicode エンコーディングを使用する、つまり、 <xref:System.Text.UTF8Encoding>, 、<xref:System.Text.UnicodeEncoding>, 、または <xref:System.Text.UTF32Encoding>, 、プリアンブルとします。  
  
   
  
## 例  
 次の例では、プリアンブルに基づいてエンコーディングのバイト順を決定します。  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトを文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 <xref:System.Text.Decoder> によって返されるオブジェクト、 <xref:System.Text.Encoding.GetDecoder%2A> 派生クラスのメソッドです。  
  
 「解説」セクションを参照してください、 <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> デコード手法および考慮事項については、リファレンス トピックです。  
  
 正確な動作、 <xref:System.Text.Encoding.GetString%2A> 、特定のメソッド <xref:System.Text.Encoding> の実装が定義されているフォールバック ストラテジに依存 <xref:System.Text.Encoding> オブジェクトです。 詳細については、「フォールバック ストラテジを選択する」セクションを参照してください、 [Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9) トピックです。  
  
   
  
## 例  
 次の例では、utf\-8 でエンコードされた文字列を読み取りますによって表されるバイナリ ファイルから、 <xref:System.IO.FileStream> オブジェクトです。 2,048 バイトよりも小さいファイルの場合、バイト配列の呼び出しにファイル全体の内容を読み取りますが、 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> のデコードを実行するメソッドです。 大きいファイルの場合、2,048 バイトずつ読み込むを呼び出し、バイト配列に、 <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> 文字列の文字数を決定する方法は、配列に含まれを呼び出して、 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=fullName> のデコードを実行するメソッドです。  
  
 [!code-csharp[System.Text.Encoding.GetString\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 例は、Utf8Example.txt をという名前の utf\-8 でエンコードされたファイルに保存する必要がありますが、次のテキストを使用します。  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">バイト配列には、無効な Unicode コード ポイントが含まれています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">バイト配列へのポインター。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したアドレスで始まる指定したバイト数を文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Encoding.GetString%2A> メソッドがバイト配列へのネイティブ ポインターがある場合は、パフォーマンスを最適化するために設計されています。 マネージ バイト配列を作成して、それをデコードし、代わりに、中間のオブジェクトを作成しなくてもこのメソッドを代わりに呼び出すことができます。  
  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 <xref:System.Text.Decoder> によって返されるオブジェクト、 <xref:System.Text.Encoding.GetDecoder%2A> 派生クラスのメソッドです。  
  
 「解説」セクションを参照してください、 <xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> デコード手法および考慮事項については、リファレンス トピックです。  
  
 正確な動作、 <xref:System.Text.Encoding.GetString%2A> 、特定のメソッド <xref:System.Text.Encoding> の実装が定義されているフォールバック ストラテジに依存 <xref:System.Text.Encoding> オブジェクトです。 詳細については、「フォールバック ストラテジを選択する」セクションを参照してください、 [Character Encoding in the .NET Framework](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9) トピックです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> null のポインターです。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(を参照してください [Character Encoding in the .NET Framework](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9) の詳しい説明について\)  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 変換するデータが \(データのストリームからの読み取り\) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、 [GetString メソッド \(Byte\<xref:System.Text.Decoder> または [GetString メソッド \(Byte\<xref:System.Text.Encoder> によって提供される、 [GetString メソッド \(Byte\<xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは [GetString メソッド \(Byte\<xref:System.Text.Encoding.GetEncoder%2A> メソッド、派生クラスのそれぞれをします。  
  
 「解説」セクションを参照してください、 [GetString メソッド \(Byte\<xref:System.Text.Encoding.GetChars%2A?displayProperty=fullName> デコード手法および考慮事項については、リファレンス トピックです。  
  
   
  
## 例  
 次の例では、utf\-8 でエンコードされた文字列を読み取りますによって表されるバイナリ ファイルから、 [GetString メソッド \(Byte\<xref:System.IO.FileStream> オブジェクトです。 2,048 バイトよりも小さいファイルの場合、バイト配列の呼び出しにファイル全体の内容を読み取りますが、 [GetString メソッド \(Byte\<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> のデコードを実行するメソッドです。 大きいファイルの場合、2,048 バイトずつ読み込むを呼び出し、バイト配列に、 [GetString メソッド \(Byte\<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> 文字列の文字数を決定する方法は、配列に含まれを呼び出して、 [GetString メソッド \(Byte\<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=fullName> のデコードを実行するメソッドです。  
  
 [!code-csharp[System.Text.Encoding.GetString\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 例は、Utf8Example.txt をという名前の utf\-8 でエンコードされたファイルに保存する必要がありますが、次のテキストを使用します。  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">バイト配列には、無効な Unicode コード ポイントが含まれています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました \(詳細については、「[Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください\)。  
  
 および  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール エージェント ヘッダー タグと共に使用できる現在のエンコーディングの名前を取得します。</summary>
        <value>メール エージェント ヘッダー タグと共に使用する、現在の <see cref="T:System.Text.Encoding" /> の名前。  
  
 または  
  
 現在の <see cref="T:System.Text.Encoding" /> が使用できない場合は、空の文字列 \(""\)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ヘッダー名をエンコードする場合を呼び出す必要があります、 <xref:System.Text.Encoding.GetEncoding%2A> メソッドを <xref:System.Text.Encoding.HeaderName%2A> プロパティです。 多くの場合、メソッドの呼び出しで提供されるテスト エンコーディングから別のエンコーディングを取得します。 一般に電子メール アプリケーションだけでは、このようなエンコーディングを取得する必要があります。  
  
 場合によっては、値で、 <xref:System.Text.Encoding.BodyName%2A> プロパティは、そのエンコーディングを定義する国際標準に対応しています。 実装は、その標準に完全に準拠しているわけです。  
  
 なお <xref:System.Text.Encoding.WebName%2A> を使用して、エンコーディングの記述名を返します。<xref:System.Text.Encoding.HeaderName%2A> プロパティがよりよく機能する電子メール アプリケーションは、たとえば別のエンコードを定義します。 ただし、エンコーディングを定義するプロパティの使用は推奨されません。  
  
   
  
## 例  
 次の例は、エンコーディングごとに異なる名前を取得し、表示とは異なる 1 つまたは複数の名前を持つエンコーディング <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName>します。 表示 <xref:System.Text.Encoding.EncodingName%2A> に対しては比較されませんが、します。  
  
 [!code-cpp[System.Text.Encoding.Names\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のエンコーディングが、既定の正規形を使用して常に正規化されるかどうかを示す値。</summary>
        <returns>現在の <see langword="true" /> が常に正規化される場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の正規形は <xref:System.Text.NormalizationForm.FormC>, 、後は、シーケンスをプライマリ複合文字の置換可能な場合は、正式な分解を使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">
          <see cref="T:System.Text.NormalizationForm" /> 値のいずれか。</param>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングが、指定した正規形を使用して常に正規化されるかどうかを示す値を取得します。</summary>
        <returns>現在の <see langword="true" /> オブジェクトが、指定した <see cref="T:System.Text.Encoding" /> 値を使用して常に正規化される場合は <see cref="T:System.Text.NormalizationForm" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の正規形は <xref:System.Text.NormalizationForm.FormC>, 、後は、シーケンスをプライマリ複合文字の置換可能な場合は、正式な分解を使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、ブラウザー クライアントが現在のエンコーディングを使用してコンテンツを表示できるかどうかを示す値を取得します。</summary>
        <value>ブラウザー クライアントが現在の <see langword="true" /> を使用してコンテンツを表示できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、各エンコーディングのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、ブラウザー クライアントが現在のエンコーディングを使用してコンテンツを保存できるかどうかを示す値を取得します。</summary>
        <value>ブラウザー クライアントが現在の <see langword="true" /> を使用してコンテンツを保存できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、各エンコーディングのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール クライアントおよびニュース クライアントが現在のエンコーディングを使用してコンテンツを表示できるかどうかを示す値を取得します。</summary>
        <value>メール クライアントおよびニュース クライアントが現在の <see langword="true" /> を使用してコンテンツを表示できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、各エンコーディングのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール クライアントおよびニュース クライアントが現在のエンコーディングを使用してコンテンツを保存できるかどうかを示す値を取得します。</summary>
        <value>メール クライアントおよびニュース クライアントが現在の <see langword="true" /> を使用してコンテンツを保存できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、各エンコーディングのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングが読み取り専用かどうかを示す値を取得します。</summary>
        <value>現在の <see langword="true" /> が読み取り専用の場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングが 1 バイトのコード ポイントを使用するかどうかを示す値を取得します。</summary>
        <value>現在の <see langword="true" /> が 1 バイトのコード ポイントを使用する場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 1 バイトのエンコード、たとえば、 <xref:System.Text.ASCIIEncoding>, 、このプロパティは取得 `true`します。  
  
> [!CAUTION]
>  値を含む、アプリケーションが何で注意が必要 <xref:System.Text.Encoding.IsSingleByte%2A>します。 エンコード方式の進行方法であると仮定は、正しくない可能性があります。 たとえばの値には Windows 1252 `true` の <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=fullName>, 、Encoding.GetMaxByteCount\(1\) 2 が返されますが、します。 これは、メソッドにでは前のデコーダー操作から潜在的なサロゲートが残っているためです。  
  
   
  
## 例  
 次の例では、各エンコーディングのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">追加の文字エンコーディングへのアクセスを提供する <see cref="T:System.Text.EncodingProvider" /> のサブクラス。</param>
        <summary>エンコーディング プロバイダーを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Encoding.RegisterProvider%2A>メソッドから派生するクラスを登録できます。<xref:System.Text.EncodingProvider>文字の場合はそれらをサポートしないプラットフォームで利用可能なエンコーディングをによりします。 エンコーディング プロバイダーを登録すると、サポートしているエンコーディングは、いずれかを呼び出すことによって取得できる<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=fullName>オーバー ロードします。  
  
 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]1 つのエンコーディング プロバイダーを含む<xref:System.Text.CodePagesEncodingProvider>、により、利用可能なエンコーディングがあるが、完全な .NET Framework 内にあるでは使用できない[!INCLUDE[net_v46](~/includes/net-v46-md.md)]です。 既定では、 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] Unicode エンコーディング、ASCII、およびコード ページ 28591 のみをサポートします。  
  
 同じエンコーディング プロバイダーは複数の呼び出しで使用されているかどうか、<xref:System.Text.Encoding.RegisterProvider%2A>メソッド、最初のメソッドの呼び出しのみが、プロバイダーを登録します。 後続の呼び出しは無視されます。  
  
 場合、<xref:System.Text.Encoding.RegisterProvider%2A>でも同じエンコードを処理する複数のプロバイダーを登録するメソッドが呼び出すと、最後の登録済みのプロバイダーがすべてのエンコードとデコード操作で使用されます。 以前に登録されたすべてのプロバイダーは無視されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リトル エンディアン バイト順を使用する UTF\-16 形式のエンコーディングを取得します。</summary>
        <value>リトル エンディアンのバイト順を使用する UTF\-16 形式のエンコーディング。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework を使用するエンコード Unicode の詳細についてはサポートされているエンコーディングの詳細については、次を参照してください。 [Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)します。  
  
 <xref:System.Text.UnicodeEncoding> このプロパティによって返されるオブジェクトで、アプリの適切な動作がない可能性があります。 置換フォールバックを使用して各エンコードできない文字列とデコードできないバイトがごとを疑問符 \(\) に置き換えること \("?"\) 文字に置き換えらるからです。 代わりに、呼び出すことができます、 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> 、リトル エンディアンのインスタンスを作成するコンス トラクター <xref:System.Text.UnicodeEncoding> のフォールバックは、いずれかのオブジェクト、 <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>, 次の例に示すようにします。  
  
 [!code-csharp[System.Text.Encoding.Unicode\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## 例  
 次の例は、文字配列をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リトル エンディアン バイト順を使用する UTF\-32 形式のエンコーディングを取得します。</summary>
        <value>リトル エンディアンのバイト順を使用する UTF\-32 形式のエンコーディング オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.UTF32Encoding> このプロパティによって返されるオブジェクトで、アプリの適切な動作がない可能性があります。 置換フォールバックを使用し、各エンコードできない文字列とデコードできないバイトがごとに、Unicode REPLACEMENT CHARACTER \(U \+ fffe になります\) を置き換えます。 代わりに、呼び出すことができます、 <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> インスタンスを作成するコンス トラクター、 <xref:System.Text.UTF32Encoding> のフォールバックは、いずれかのオブジェクト、 <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>, 次の例に示すようにします。  
  
 [!code-csharp[System.Text.Encoding.UTF32\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 リトル エンディアン バイト順の詳細については、次を参照してください。、 <xref:System.Text.Encoding> クラスに関するトピック。  
  
 .NET Framework を使用するエンコード Unicode の詳細についてはサポートされているエンコーディングの詳細については、次を参照してください。 [Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)します。  
  
   
  
## 例  
 次の例は、文字配列をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UTF\-7 形式のエンコーディングを取得します。</summary>
        <value>UTF\-7 形式のエンコード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Utf\-7 エンコードは、NNTP などの 7 ビットや一部の電子メール アプリケーションにこれまでに制限されている環境で主に使用されます。 保全性とセキュリティの問題のためする必要がありますエンコードを使用しない UTF7 8 ビット環境で、utf\-8 エンコード代わりを使用できます。  
  
   
  
## 例  
 次の例は、文字配列をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes\_CharArr\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UTF\-8 形式のエンコーディングを取得します。</summary>
        <value>UTF\-8 形式のエンコード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返します、 <xref:System.Text.UTF8Encoding> \(UTF エンコード\) の Unicode 文字を 1 文字を 1 ~ 4 バイトのシーケンスにエンコードして、Unicode \(UTF エンコード\) 文字に UTF 8 エンコードされたバイト配列をデコードするオブジェクト。 .NET Framework を使用するエンコード Unicode の詳細についてはサポートされている文字エンコーディングの詳細については、次を参照してください。 [Understanding Encodings](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)します。  
  
 <xref:System.Text.UTF8Encoding> このプロパティによって返されるオブジェクトは、アプリの適切な動作をいない可能性があります。  
  
-   返す、 <xref:System.Text.UTF8Encoding> Unicode バイト順マーク \(BOM\) を提供するオブジェクト。 BOM が用意されていません UTF8 エンコードをインスタンス化するには、すべてのオーバー ロードを呼び出し、 <xref:System.Text.UTF8Encoding.%23ctor%2A> コンス トラクターです。  
  
-   返す、 <xref:System.Text.UTF8Encoding> に各エンコードできない文字列とデコードできないバイトがごとに疑問符 \(\) を置き換えて、置換フォールバックを使用するオブジェクト \("?"\) 文字に置き換えらるからです。 代わりに、呼び出すことができます、 <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName> インスタンスを作成するコンス トラクター、 <xref:System.Text.UTF8Encoding> のフォールバックは、いずれかのオブジェクト、 <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>, 次の例に示すようにします。  
  
     [!code-csharp[System.Text.Encoding.UTF8\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## 例  
 次の例では、次の文字で構成される配列を定義します。  
  
-   LATIN SMALL LETTER Z \(U \+ 007A\)  
  
-   LATIN SMALL LETTER、\(U \+ 0061\)  
  
-   結合 BREVE \(U \+ 0306\)  
  
-   鋭角 \(U \+ 01FD\) で LATIN SMALL LETTER AE  
  
-   ギリシャ文字 Β \(U \+ 03B2\)  
  
-   ギリシャ語 ACROPHONIC ATTIC 1 桁 STATERS \(U \+ 10154\) を形成するサロゲート ペア \(u\+d800 U \+ DD54\)。  
  
 各文字の utf\-16 コード単位を表示し、utf\-8 エンコーダーで文字配列をエンコードするために必要なバイト数を決定します。 文字をエンコードし、結果として得られる UTF で 8 でエンコードされたバイト数を表示します。  
  
 [!code-csharp[System.Text.Encoding.UTF8\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングの IANA \(Internet Assigned Numbers Authority\) に登録されている名前を取得します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> の IANA 名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Text.Encoding.WebName%2A> プロパティと同じ、 <xref:System.Text.EncodingInfo.Name%2A> プロパティです。  
  
 なお <xref:System.Text.Encoding.WebName%2A> のエンコーディングの IANA 登録の名前を返します。 その値が標準の名前である場合は、エンコーディングの実装がその標準に完全に準拠していません。<xref:System.Text.Encoding.HeaderName%2A> プロパティは、電子メールのヘッダーの方が適切なが別のエンコードを定義します。 ただし、ほとんどのアプリを使用する必要があります <xref:System.Text.Encoding.WebName%2A> 代わりにします。  
  
 IANA の詳細についてを参照してください [www.iana.org](http://www.iana.org/)します。  
  
 <xref:System.Text.Encoding.WebName%2A?displayProperty=fullName> と同じ、 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName> によって返される <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName>です。 Web の名前の一部が重複しています。「解説」を参照してください <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=fullName> の詳細。  
  
   
  
## 例  
 次の例では、 <xref:System.Text.Encoding.WebName%2A> HTML ヘッダーにします。  
  
 [!code-cpp[System.Text.Encoding.WebName\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 次の例は、エンコーディングごとに異なる名前を取得し、表示とは異なる 1 つまたは複数の名前を持つエンコーディング <xref:System.Text.EncodingInfo.Name%2A?displayProperty=fullName>します。 表示 <xref:System.Text.Encoding.EncodingName%2A> に対しては比較されませんが、します。  
  
 [!code-cpp[System.Text.Encoding.Names\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングに最も厳密に対応する Windows オペレーティング システムのコード ページを取得します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> に最も厳密に対応する、Windows オペレーティング システムのコード ページ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、フォント ファミリを決定するなど、Windows 多言語 \(MLang\) Api は、互換性のため提供されます。 グローバリゼーション、Unicode エンコーディングのいずれかを使用して勧め代わりにします。 使用をお勧めも<xref:System.Text.Encoding.WebName%2A>なく<xref:System.Text.Encoding.WindowsCodePage%2A>コード ページを識別します。  
  
   
  
## 例  
 次の例では、各エンコーディングに最も密接に対応する Windows コード ページを決定します。  
  
 [!code-cpp[System.Text.Encoding.CodePage\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスを文字列にデコードします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したコード ページのエンコーディングを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイト配列を、あるエンコーディングから別のエンコーディングに変換します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスを文字のセットにデコードします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、文字のセットをバイト シーケンスにエンコードします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のエンコーディングが常に正規化されるかどうかを示す値を取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>