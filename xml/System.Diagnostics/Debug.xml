<Type Name="Debug" FullName="System.Diagnostics.Debug">
  <TypeSignature Language="C#" Value="public static class Debug" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Debug extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Debug" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Debug</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>コードのデバッグを支援するメソッドとプロパティのセットを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 If you use methods in the <xref:System.Diagnostics.Debug> class to print debugging information and check your logic with assertions, you can make your code more robust without impacting the performance and code size of your shipping product.  
  
 This class provides methods to display an <xref:System.Diagnostics.Debug.Assert%2A> dialog box, and to emit an assertion that will always fail. This class provides write methods in the following variations: <xref:System.Diagnostics.Debug.Write%2A>, <xref:System.Diagnostics.Debug.WriteLine%2A>, <xref:System.Diagnostics.Debug.WriteIf%2A> and <xref:System.Diagnostics.Debug.WriteLineIf%2A>.  
  
 The <xref:System.Diagnostics.BooleanSwitch> and <xref:System.Diagnostics.TraceSwitch> classes provide means to dynamically control the tracing output. You can modify the values of these switches without recompiling your application. For information on using the configuration file to set a switch, see the <xref:System.Diagnostics.Switch> class and the [Trace Switches](http://msdn.microsoft.com/ja-jp/8ab913aa-f400-4406-9436-f45bc6e54fbe) topic.  
  
 You can customize the tracing output's target by adding <xref:System.Diagnostics.TraceListener> instances to or removing instances from the <xref:System.Diagnostics.Debug.Listeners%2A> collection. The <xref:System.Diagnostics.Debug.Listeners%2A> collection is shared by both the <xref:System.Diagnostics.Debug> and the <xref:System.Diagnostics.Trace> classes; adding a trace listener to either class adds the listener to both. By default, the <xref:System.Diagnostics.DefaultTraceListener> class emits trace output.  
  
> [!NOTE]
>  Adding a trace listener to the <xref:System.Diagnostics.Debug.Listeners%2A> collection can cause an exception to be thrown while tracing, if a resource used by the trace listener is not available. The conditions and the exception thrown depend on the trace listener and cannot be enumerated in this topic. It may be useful to place calls to the <xref:System.Diagnostics.Debug> methods in **languageKeyword tag is not supported!!!!**  
> \/**languageKeyword tag is not supported!!!!**  
>  blocks to detect and handle any exceptions from trace listeners.  
  
 You can modify the level of indentation using the <xref:System.Diagnostics.Debug.Indent%2A> method or the <xref:System.Diagnostics.Debug.IndentLevel%2A> property. To modify the indent spacing, use the <xref:System.Diagnostics.Debug.IndentSize%2A> property. You can specify whether to automatically flush the output buffer after each write by setting the <xref:System.Diagnostics.Debug.AutoFlush%2A> property to **languageKeyword tag is not supported!!!!**  
.  
  
 To set the <xref:System.Diagnostics.Debug.AutoFlush%2A> and <xref:System.Diagnostics.Debug.IndentSize%2A> for <xref:System.Diagnostics.Debug>, you can edit the configuration file corresponding to the name of your application. The configuration file should be formatted as shown in the following example.  
  
```  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 The <xref:System.Diagnostics.ConditionalAttribute> attribute is applied to the methods of <xref:System.Diagnostics.Debug>. Compilers that support <xref:System.Diagnostics.ConditionalAttribute> ignore calls to these methods unless "DEBUG" is defined as a conditional compilation symbol. Refer to a compiler's documentation to determine whether <xref:System.Diagnostics.ConditionalAttribute> is supported and the syntax for defining a conditional compilation symbol.  
  
> [!NOTE]
>  In Visual Studio C\# and Visual Basic projects, by default, the "DEBUG" conditional compilation symbol is defined for debug builds, and the "TRACE" symbol is defined for both debug and release builds. For information about how to disable this behavior, see the Visual Studio documentation. For information about conditional debugging in Visual C\+\+, see [Debug Class in Visual C\+\+](http://msdn.microsoft.com/ja-jp/076bd528-1b6f-4e8a-a372-eb5849cf969a).  
  
 To define the "DEBUG" conditional compilation symbol in C\#, add the **languageKeyword tag is not supported!!!!**  
 option to the compiler command line when you compile your code using a command line, or add **languageKeyword tag is not supported!!!!**  
 to the top of your file. In Visual Basic, add the **languageKeyword tag is not supported!!!!**  
 option to the compiler command line or add **languageKeyword tag is not supported!!!!**  
 to the file.  
  
   
  
## 例  
 The following example uses <xref:System.Diagnostics.Debug> to indicate the beginning and end of a program's execution. The example also uses <xref:System.Diagnostics.Debug.Indent%2A> and <xref:System.Diagnostics.Debug.Unindent%2A> to distinguish the tracing output.  
  
 [!code-cpp[Classic Debug Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug Example/CS/source.cs#1)]
 [!code-vb[Classic Debug Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
    <altmember cref="T:System.Diagnostics.Trace" />
    <altmember cref="T:System.Diagnostics.Switch" />
    <altmember cref="T:System.Diagnostics.BooleanSwitch" />
    <altmember cref="T:System.Diagnostics.TraceSwitch" />
    <altmember cref="T:System.Diagnostics.TraceListener" />
    <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
    <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
    <altmember cref="T:System.Diagnostics.EventLogTraceListener" />
    <altmember cref="T:System.Diagnostics.TraceListenerCollection" />
    <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件が <see langword="true" /> の場合、エラー メッセージは送信されず、メッセージ ボックスは表示されません。</param>
        <summary>条件をチェックします。条件が <see langword="false" /> の場合、呼び出し履歴を見せるメッセージ ボックスを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 By default, the <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=fullName> method works only in debug builds. Use the <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=fullName> method if you want to do assertions in release builds. For more information, see [Assertions in Managed Code](http://msdn.microsoft.com/ja-jp/70ab2522-6486-4076-a1a9-e0f11cd0f3a1).  
  
> [!IMPORTANT]
>  The **languageKeyword tag is not supported!!!!**  
>  methods are not available for [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps.  
  
 Typically, the <xref:System.Diagnostics.Debug.Assert%28System.Boolean%29> method is used to identify logic errors during program development. <xref:System.Diagnostics.Debug.Assert%2A> evaluates the condition. If the result is **languageKeyword tag is not supported!!!!**  
, it sends a failure message to the <xref:System.Diagnostics.Debug.Listeners%2A> collection. You can customize this behavior by adding a <xref:System.Diagnostics.TraceListener> to, or removing one from, the <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
 When the application runs in user interface mode, it displays a message box that shows the call stack with file and line numbers. The message box contains three buttons: **ui tag is not supported!!!!**  
, **ui tag is not supported!!!!**  
, and **ui tag is not supported!!!!**  
. Clicking the **ui tag is not supported!!!!**  
 button terminates the application. Clicking **ui tag is not supported!!!!**  
 sends you to the code in the debugger if your application is running in a debugger, or offers to open a debugger if it is not. Clicking **ui tag is not supported!!!!**  
 continues with the next instruction in the code.  
  
> [!NOTE]
>  [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps do not support modal dialog boxes, so they behave the same in user interface mode and non\-user interface mode. The message is written to the active trace listeners in debugging mode, or no message is written in release mode.  
  
> [!NOTE]
>  The display of the message box depends on the presence of the <xref:System.Diagnostics.DefaultTraceListener>. If the <xref:System.Diagnostics.DefaultTraceListener> is not in the <xref:System.Diagnostics.Trace.Listeners%2A> collection, the message box is not displayed. The <xref:System.Diagnostics.DefaultTraceListener> can be removed by the [\<clear\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/b44732a8-271f-4a06-ba9e-fe3298d6f192), the [\<remove\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/9a5cd1b5-be1a-485f-8f0c-2890ad3ef3e0), or by calling the <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> method on the <xref:System.Diagnostics.Trace.Listeners%2A> property \(`System.Diagnostics.Trace.Listeners.Clear()`\).  
  
 You can change the behavior of the <xref:System.Diagnostics.DefaultTraceListener> in the configuration file that corresponds to the name of your application. In this file, you can enable and disable the assert message box or set the <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=fullName> property. The configuration file should be formatted as follows:  
  
```  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## 例  
 The following example creates an index for an array, performs some action to set the value of the index, and then calls <xref:System.Diagnostics.Debug.Assert%2A> to confirm that the index value is valid. If it is not valid, <xref:System.Diagnostics.Debug.Assert%2A> outputs the call stack.  
  
 [!code-cpp[Classic Debug.Assert Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件が <see langword="true" /> の場合、指定したメッセージは送信されず、メッセージ ボックスは表示されません。</param>
        <param name="message">
          <see cref="P:System.Diagnostics.Trace.Listeners" /> コレクションに送信するメッセージ。</param>
        <summary>条件をチェックします。条件が <see langword="false" /> の場合、指定したメッセージを出力し、コール スタックを示すメッセージ ボックスを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 By default, the <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=fullName> method works only in debug builds. Use the <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=fullName> method if you want to do assertions in release builds. For more information, see [Assertions in Managed Code](http://msdn.microsoft.com/ja-jp/70ab2522-6486-4076-a1a9-e0f11cd0f3a1).  
  
 Typically, the <xref:System.Diagnostics.Debug.Assert%2A> method is used to identify logic errors during program development. <xref:System.Diagnostics.Debug.Assert%2A> evaluates the condition. If the result is **languageKeyword tag is not supported!!!!**  
, it sends the specified diagnostic message to the <xref:System.Diagnostics.Debug.Listeners%2A> collection. You can customize this behavior by adding a <xref:System.Diagnostics.TraceListener> to, or removing one from, the <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
 When the application runs in user interface mode, it displays a message box that shows the call stack with file and line numbers. The message box contains three buttons: **ui tag is not supported!!!!**  
, **ui tag is not supported!!!!**  
, and **ui tag is not supported!!!!**  
. Clicking the **ui tag is not supported!!!!**  
 button terminates the application. Clicking **ui tag is not supported!!!!**  
 sends you to the code in the debugger if your application is running in a debugger, or offers to open a debugger if it is not. Clicking **ui tag is not supported!!!!**  
 continues with the next instruction in the code.  
  
> [!NOTE]
>  The display of the message box depends on the presence of the <xref:System.Diagnostics.DefaultTraceListener>. If the <xref:System.Diagnostics.DefaultTraceListener> is not in the <xref:System.Diagnostics.Trace.Listeners%2A> collection, the message box is not displayed. The <xref:System.Diagnostics.DefaultTraceListener> can be removed by the [\<clear\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/b44732a8-271f-4a06-ba9e-fe3298d6f192), the [\<remove\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/9a5cd1b5-be1a-485f-8f0c-2890ad3ef3e0), or by calling the <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> method on the <xref:System.Diagnostics.Trace.Listeners%2A> property \(`System.Diagnostics.Trace.Listeners.Clear()`\).  
  
 You can change the behavior of the <xref:System.Diagnostics.DefaultTraceListener> in the configuration file that corresponds to the name of your application. In this file, you can enable and disable the assert message box or set the <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=fullName> property. The configuration file should be formatted as follows:  
  
```  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## 例  
 The following example checks whether the `type` parameter is valid. If `type` is **languageKeyword tag is not supported!!!!**  
, <xref:System.Diagnostics.Trace.Assert%2A> outputs a message.  
  
 [!code-cpp[Classic Debug.Assert1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件が <see langword="true" /> の場合、指定したメッセージは送信されず、メッセージ ボックスは表示されません。</param>
        <param name="message">
          <see cref="P:System.Diagnostics.Trace.Listeners" /> コレクションに送信するメッセージ。</param>
        <param name="detailMessage">
          <see cref="P:System.Diagnostics.Trace.Listeners" /> コレクションに送信する詳細なメッセージ。</param>
        <summary>条件をチェックします。条件が <see langword="false" /> の場合、指定した 2 つのメッセージを出力し、コール スタックを示すメッセージ ボックスを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 By default, the <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=fullName> method works only in debug builds. Use the <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=fullName> method if you want to do assertions in release builds. For more information, see [Assertions in Managed Code](http://msdn.microsoft.com/ja-jp/70ab2522-6486-4076-a1a9-e0f11cd0f3a1).  
  
 Typically, the <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%29> method is used to identify logic errors during program development. <xref:System.Diagnostics.Debug.Assert%2A> evaluates the condition. If the result is **languageKeyword tag is not supported!!!!**  
, it sends the specified diagnostic message and detailed message to the <xref:System.Diagnostics.Debug.Listeners%2A> collection. You can customize this behavior by adding a <xref:System.Diagnostics.TraceListener> to, or removing one from, the <xref:System.Diagnostics.Debug.Listeners%2A> collection.  
  
 When the application runs in user interface mode, it displays a message box that shows the call stack with file and line numbers. The message box contains three buttons: **ui tag is not supported!!!!**  
, **ui tag is not supported!!!!**  
, and **ui tag is not supported!!!!**  
. Clicking the **ui tag is not supported!!!!**  
 button terminates the application. Clicking **ui tag is not supported!!!!**  
 sends you to the code in the debugger if your application is running in a debugger, or offers to open a debugger if it is not. Clicking **ui tag is not supported!!!!**  
 continues with the next instruction in the code.  
  
> [!NOTE]
>  The display of the message box depends on the presence of the <xref:System.Diagnostics.DefaultTraceListener>. If the <xref:System.Diagnostics.DefaultTraceListener> is not in the <xref:System.Diagnostics.Trace.Listeners%2A> collection, the message box is not displayed. The <xref:System.Diagnostics.DefaultTraceListener> can be removed by the [\<clear\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/b44732a8-271f-4a06-ba9e-fe3298d6f192), the [\<remove\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/9a5cd1b5-be1a-485f-8f0c-2890ad3ef3e0), or by calling the <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> method on the <xref:System.Diagnostics.Trace.Listeners%2A> property \(`System.Diagnostics.Trace.Listeners.Clear()`\).  
  
 You can change the behavior of the <xref:System.Diagnostics.DefaultTraceListener> in the configuration file that corresponds to the name of your application. In this file, you can enable and disable the assert message box or set the <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=fullName> property. The configuration file should be formatted as follows:  
  
```  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## 例  
 The following example checks whether the `type` parameter is valid. If `type` is **languageKeyword tag is not supported!!!!**  
, <xref:System.Diagnostics.Trace.Assert%2A> outputs two messages.  
  
 [!code-cpp[Classic Debug.Assert2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message, string detailMessageFormat, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message, string detailMessageFormat, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessageFormat" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件が <see langword="true" /> の場合、指定したメッセージは送信されず、メッセージ ボックスは表示されません。</param>
        <param name="message">
          <see cref="P:System.Diagnostics.Trace.Listeners" /> コレクションに送信するメッセージ。</param>
        <param name="detailMessageFormat">複合書式指定文字列 \(「解説」を参照してください\) を送信する、 <see cref="P:System.Diagnostics.Trace.Listeners" /> コレクションです。 このメッセージには、テキストが含まれています。 0 個以上の書式指定項目内のオブジェクトが混合、 <c>args</c> 配列。</param>
        <param name="args">0 個以上の書式設定対象オブジェクトを含んだオブジェクト配列。</param>
        <summary>条件をチェックします。条件の場合 <see langword="false" />, \(単純なおよび書式設定された\) 2 つのメッセージが出力、および呼び出し履歴を示すメッセージ ボックスを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、.NET Framework オブジェクトの値をそのテキスト表現に変換し、その表現を文字列に埋め込むのです。 結果の文字列に送信される、 <xref:System.Diagnostics.Trace.Listeners%2A> コレクションです。  
  
 既定では、 <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=fullName> メソッドはデバッグ ビルドでのみ機能します。 使用して、 <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=fullName> アサーションのリリースでの操作を実行する場合、メソッドが作成されます。 詳細については、「[Assertions in Managed Code](http://msdn.microsoft.com/ja-jp/70ab2522-6486-4076-a1a9-e0f11cd0f3a1)」を参照してください。  
  
 通常、 <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%2CSystem.Object%5B%5D%29> プログラムの開発中に論理エラーを識別するメソッドを使用します。<xref:System.Diagnostics.Debug.Assert%2A> 条件を評価します。 結果の場合 `false`, 、 <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29?displayProperty=fullName> メソッドが呼び出されると、 `detailMessageFormat` 文字列と `args` 配列パラメーターとして渡されます。<xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%2CSystem.Object%5B%5D%29> 指定したテキスト メッセージと、書式設定されたテキスト メッセージを送信、 <xref:System.Diagnostics.Debug.Listeners%2A> コレクションです。 この動作をカスタマイズするには、追加することで、 <xref:System.Diagnostics.TraceListener> から、1 つを削除または、 <xref:System.Diagnostics.Debug.Listeners%2A> コレクションです。  
  
 アプリケーションがユーザー インターフェイス モードで実行されているときは、ファイル番号と行番号を含む呼び出し履歴を示すメッセージ ボックスが表示されます。 メッセージ ボックスには、3 つのボタンが含まれています: **中止**, 、**再試行**, 、および **を無視する**します。 クリックすると、 **中止** ボタンがアプリケーションを終了します。 クリックすると **再試行** 、アプリケーションが、デバッガーで実行されているがない場合は、デバッガーを開くである場合に、デバッガーでコードを送信します。 クリックすると **無視** コード内の次の命令を続行します。  
  
> [!NOTE]
>  メッセージ ボックスの表示がの存在に依存している、 <xref:System.Diagnostics.DefaultTraceListener>です。 場合、 <xref:System.Diagnostics.DefaultTraceListener> に含まれていない、 <xref:System.Diagnostics.Trace.Listeners%2A> コレクション、メッセージ ボックスは表示されません。<xref:System.Diagnostics.DefaultTraceListener> は、 [\<clear\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/b44732a8-271f-4a06-ba9e-fe3298d6f192), 、 [\<remove\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/9a5cd1b5-be1a-485f-8f0c-2890ad3ef3e0), 、またはを呼び出して、 <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> メソッドを <xref:System.Diagnostics.Trace.Listeners%2A> プロパティ \(`System.Diagnostics.Trace.Listeners.Clear()`\)。  
  
 動作を変更することができます、 <xref:System.Diagnostics.DefaultTraceListener> アプリケーションの名前に対応する構成ファイルにします。 このファイルを有効にしてアサート メッセージ ボックスを無効にしたり設定、 <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=fullName> プロパティです。 構成ファイルは、次のようにフォーマットされている必要があります。  
  
```  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public static bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.AutoFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうか <see cref="M:System.Diagnostics.Debug.Flush" /> で呼び出す必要があります、 <see cref="P:System.Diagnostics.Debug.Listeners" /> たび。</summary>
        <value>
          <see langword="true" /> 場合 <see cref="M:System.Diagnostics.Debug.Flush" /> で呼び出される、 <see cref="P:System.Diagnostics.Debug.Listeners" /> すべての書き込み後にそれ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定値は、`false` です。  
  
 明示的に呼び出す場合を除きは、ストリームのフラッシュに基になる、エンコーダーはフラッシュされません <xref:System.Diagnostics.Debug.Flush%2A> または <xref:System.Diagnostics.Debug.Close%2A>です。 設定 <xref:System.Diagnostics.Debug.AutoFlush%2A> に `true` に、ストリーム バッファーからデータがフラッシュされますが、エンコーダーの状態はフラッシュされないことを意味します。 これにより、次の文字のブロックを正常にエンコードできるように、\(一部の文字\) の状態を保持するエンコーダーです。 このシナリオでは、UTF8、UTF7、特定の文字をエンコードするため、エンコーダーは、隣接する文字または文字列を受信した後に影響します。  
  
 設定する、 <xref:System.Diagnostics.Debug.AutoFlush%2A> と <xref:System.Diagnostics.Debug.IndentSize%2A> の <xref:System.Diagnostics.Debug>, 、アプリケーションの名前に対応する構成ファイルを編集することもできます。 構成ファイルは、次の例で示すようにフォーマットされている必要があります。  
  
```  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for operating with unmanaged code. Demand value <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public static void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>出力バッファーをフラッシュしを呼び出して、 <see langword="Close" /> それぞれのメソッド、 <see cref="P:System.Diagnostics.Debug.Listeners" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用するときに、出力ファイルになど、 <xref:System.Diagnostics.TextWriterTraceListener>です。  
  
 明示的に呼び出さない限りは、ストリームのフラッシュにその基になるエンコーダーはフラッシュされません <xref:System.Diagnostics.Debug.Flush%2A> または <xref:System.Diagnostics.Debug.Close%2A>です。 設定 <xref:System.Diagnostics.Debug.AutoFlush%2A> に `true` に、ストリーム バッファーからデータがフラッシュされますが、エンコーダーの状態はフラッシュされないことを意味します。 これにより、次の文字のブロックを正常にエンコードできるように、\(一部の文字\) の状態を保持するエンコーダーです。 このシナリオでは、UTF8、UTF7、特定の文字をエンコードするため、エンコーダーは、隣接する文字または文字列を受信した後に影響します。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TextWriterTraceListener> という `myTextListener`します。`myTextListener` 使用して、 <xref:System.IO.StreamWriter> と呼ばれる `myOutputWriter` という名前のファイルに書き込む `TestFile.txt`します。 例は、ファイル、ストリーム、およびテキスト ライターを作成、1 行のテキストをファイルに書き込みをフラッシュしたうえで、出力を閉じます。  
  
 [!code-cpp[Classic Debug.Close Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Close Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Close Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for operating with unmanaged code. Demand value <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Fail(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">出力するメッセージ。</param>
        <summary>指定されたエラー メッセージを出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の動作は、 <xref:System.Diagnostics.DefaultTraceListener> ユーザー インターフェイス モードにされ、アプリケーションが実行中に、メッセージ ボックスにメッセージを出力、 <xref:System.Diagnostics.TraceListener> のインスタンス、 <xref:System.Diagnostics.Debug.Listeners%2A> コレクションです。  
  
> [!NOTE]
>  メッセージ ボックスの表示がの存在に依存している、 <xref:System.Diagnostics.DefaultTraceListener>です。 場合、 <xref:System.Diagnostics.DefaultTraceListener> に含まれていない、 <xref:System.Diagnostics.Trace.Listeners%2A> コレクション、メッセージ ボックスは表示されません。<xref:System.Diagnostics.DefaultTraceListener> は、 [\<clear\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/b44732a8-271f-4a06-ba9e-fe3298d6f192), 、 [\<remove\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/9a5cd1b5-be1a-485f-8f0c-2890ad3ef3e0), 、またはを呼び出して、 <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> メソッドを <xref:System.Diagnostics.Trace.Listeners%2A> プロパティ \(`System.Diagnostics.Trace.Listeners.Clear()`\)。  
  
 この動作をカスタマイズするには、追加することで、 <xref:System.Diagnostics.TraceListener> から、1 つを削除または、 <xref:System.Diagnostics.Debug.Listeners%2A> コレクションです。  
  
   
  
## 例  
 次の例では、 <xref:System.Diagnostics.Debug.Fail%2A> 例外処理中にメッセージを印刷する方法です。  
  
 [!code-cpp[Classic Debug.Fail Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Fail Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Fail Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail Example/VB/source.vb#1)]  
  
 使用することも、 <xref:System.Diagnostics.Debug.Fail%2A> switch ステートメント内のメソッドです。  
  
 [!code-cpp[Classic Debug.Fail Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Debug.Fail Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CS/source.cs#2)]
 [!code-vb[Classic Debug.Fail Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Fail(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">出力するメッセージ。</param>
        <param name="detailMessage">出力する詳細メッセージ。</param>
        <summary>エラー メッセージと詳細なエラー メッセージを出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の動作は、 <xref:System.Diagnostics.DefaultTraceListener> ユーザー インターフェイス モードにされ、アプリケーションが実行中に、メッセージ ボックスにメッセージを出力、 <xref:System.Diagnostics.TraceListener> のインスタンス、 <xref:System.Diagnostics.Debug.Listeners%2A> コレクションです。  
  
> [!NOTE]
>  メッセージ ボックスの表示がの存在に依存している、 <xref:System.Diagnostics.DefaultTraceListener>です。 場合、 <xref:System.Diagnostics.DefaultTraceListener> に含まれていない、 <xref:System.Diagnostics.Trace.Listeners%2A> コレクション、メッセージ ボックスは表示されません。<xref:System.Diagnostics.DefaultTraceListener> は、 [\<clear\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/b44732a8-271f-4a06-ba9e-fe3298d6f192), 、 [\<remove\> Element for \<listeners\> for \<trace\>](http://msdn.microsoft.com/ja-jp/9a5cd1b5-be1a-485f-8f0c-2890ad3ef3e0), 、またはを呼び出して、 <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> メソッドを <xref:System.Diagnostics.Trace.Listeners%2A> プロパティ \(`System.Diagnostics.Trace.Listeners.Clear()`\)。  
  
 この動作をカスタマイズするには、追加することで、 <xref:System.Diagnostics.TraceListener> から、1 つを削除または、 <xref:System.Diagnostics.Debug.Listeners%2A> コレクションです。  
  
   
  
## 例  
 次の例では、 <xref:System.Diagnostics.Debug.Fail%2A> 例外処理中にメッセージを印刷する方法です。  
  
 [!code-cpp[Classic Debug.Fail1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Fail1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Fail1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/VB/source.vb#1)]  
  
 使用することも、 <xref:System.Diagnostics.Debug.Fail%2A> switch ステートメント内のメソッドです。  
  
 [!code-cpp[Classic Debug.Fail1 Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Debug.Fail1 Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CS/source.cs#2)]
 [!code-vb[Classic Debug.Fail1 Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public static void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>出力バッファーをフラッシュし、バッファー内のデータを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 明示的に呼び出さない限りは、ストリームのフラッシュにその基になるエンコーダーはフラッシュされません <xref:System.Diagnostics.Debug.Flush%2A> または <xref:System.Diagnostics.Debug.Close%2A>です。 設定 <xref:System.Diagnostics.Debug.AutoFlush%2A> に `true` に、ストリーム バッファーからデータがフラッシュされますが、エンコーダーの状態はフラッシュされないことを意味します。 これにより、次の文字のブロックを正常にエンコードできるように、\(一部の文字\) の状態を保持するエンコーダーです。 このシナリオでは、UTF8、UTF7、特定の文字をエンコードするため、エンコーダーは、隣接する文字または文字列を受信した後に影響します。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TextWriterTraceListener> という `myTextListener`します。`myTextListener` 使用して、 <xref:System.IO.FileStream> と呼ばれる `myFileStream` という名前のファイルに書き込む `TestFile.txt`します。 例は、ストリームを作成、ファイルを開きますが存在するかを新規作成、ファイルを 1 行のテキストを書き込みますとフラッシュし、出力を閉じます。  
  
 [!code-cpp[Classic Debug.Close Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Close Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Close Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Indent">
      <MemberSignature Language="C#" Value="public static void Indent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Indent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Indent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="P:System.Diagnostics.Debug.IndentLevel" /> を 1 だけ増やします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、インデント レベルを設定し、デバッグ メッセージを出力します。  
  
 [!code-cpp[Classic Debug.IndentLevel Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Debug.Unindent" />
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
      </Docs>
    </Member>
    <Member MemberName="IndentLevel">
      <MemberSignature Language="C#" Value="public static int IndentLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.IndentLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデント レベルを取得または設定します。</summary>
        <value>インデント レベル。 既定値は 0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.Debug.IndentLevel%2A> プロパティを表す回数の合計サイズのインデント <xref:System.Diagnostics.Debug.IndentSize%2A> を適用します。  
  
   
  
## 例  
 次の例では、インデント レベルを設定し、デバッグ メッセージを出力します。  
  
 [!code-cpp[Classic Debug.IndentLevel Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IndentSize">
      <MemberSignature Language="C#" Value="public static int IndentSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentSize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.IndentSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>1 つのインデントに含まれるスペースの数を取得または設定します。</summary>
        <value>インデントに含まれるスペースの数。 既定値は 4 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Diagnostics.TextWriterTraceListener> スペースとしてこの数値を解釈します。<xref:System.Diagnostics.EventLogTraceListener> この値は無視されます。  
  
 設定する、 <xref:System.Diagnostics.Debug.AutoFlush%2A> と <xref:System.Diagnostics.Debug.IndentSize%2A> の <xref:System.Diagnostics.Debug>, 、アプリケーションの名前に対応する構成ファイルを編集することもできます。 構成ファイルは、次の例で示すようにフォーマットされている必要があります。  
  
```  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Listeners">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.TraceListenerCollection Listeners { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Diagnostics.TraceListenerCollection Listeners" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.Listeners" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.TraceListenerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デバッグ出力を監視するリスナーのコレクションを取得します。</summary>
        <value>A <see cref="T:System.Diagnostics.TraceListenerCollection" /> 型のコレクションを表す <see cref="T:System.Diagnostics.TraceListener" /> デバッグ出力を監視します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 リスナーは、デバッグ出力から書式付き出力を生成します。 既定では、コレクションには、インスタンスが含まれる、 <xref:System.Diagnostics.DefaultTraceListener> クラスです。 既定のリスナーを削除するには、呼び出し、 <xref:System.Diagnostics.TraceListenerCollection.Remove%2A> メソッドのインスタンスを渡すと、 <xref:System.Diagnostics.DefaultTraceListener>です。 出力をコンソール ウィンドウにリダイレクトするには、インスタンスを追加、 <xref:System.Diagnostics.ConsoleTraceListener>です。 インスタンスを追加、ファイルまたはストリームに出力をリダイレクトする、 <xref:System.Diagnostics.TextWriterTraceListener>です。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Debug.Listeners%2A> 両方でコレクションを共有、 <xref:System.Diagnostics.Debug> と <xref:System.Diagnostics.Trace> クラスはどちらかのクラスをトレース リスナーはリスナーを両方を追加します。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TextWriterTraceListener> コンソール画面に出力します。 コードは、新しいリスナーを追加、 <xref:System.Diagnostics.Debug.Listeners%2A>です。  
  
 [!code-cpp[Classic Debug.Listeners Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Listeners Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Listeners Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for operating with unmanaged code. Demand value <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Print(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">書き込むメッセージ。</param>
        <summary>メッセージ内のトレース リスナーに書き込み、続けて行終端記号、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の行終端記号は、キャリッジ リターンとライン フィードです。 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Print(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">0 個以上の書式項目が混在したテキストを含む複合書式指定文字列 \(「解説」を参照\)。各書式項目は、<c>args</c> 配列内のオブジェクトに対応します。</param>
        <param name="args">書式指定する 0 個以上のオブジェクトを含むオブジェクト配列。</param>
        <summary>書式指定文字列内のトレース リスナーに書き込み、続けて行終端記号を書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、.NET Framework オブジェクトの値をそのテキスト表現に変換し、その表現を文字列に埋め込むのです。 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式設定する引数は、0 より大きいか小さいか、数の指定された書式設定対象オブジェクトを示す数値。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unindent">
      <MemberSignature Language="C#" Value="public static void Unindent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unindent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Unindent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="P:System.Diagnostics.Debug.IndentLevel" /> を 1 だけ減らします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、インデント レベルを設定し、デバッグ メッセージを出力します。  
  
 [!code-cpp[Classic Debug.IndentLevel Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Debug.Indent" />
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">宛ての名前を持つオブジェクト、 <see cref="P:System.Diagnostics.Debug.Listeners" />です。</param>
        <summary>オブジェクトの値を書き込みます <see cref="M:System.Object.ToString" /> メソッド内のトレース リスナーを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.Write%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行に 2 番目のエラー メッセージを出力します。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.Write Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">書き込むメッセージ。</param>
        <summary>内のトレース リスナーにメッセージを書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.Write%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行に 2 番目のエラー メッセージを出力します。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.Write Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.Object,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">宛ての名前を持つオブジェクト、 <see cref="P:System.Diagnostics.Debug.Listeners" />です。</param>
        <param name="category">出力を編成するために使用するカテゴリ名。</param>
        <summary>カテゴリ名とオブジェクトの値を書き込みます <see cref="M:System.Object.ToString" /> メソッド内のトレース リスナーを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 使用して、 `category` グループへのパラメーターは、メッセージを出力します。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.Write%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行に 2 番目のエラー メッセージを出力します。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.Write Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">書き込むメッセージ。</param>
        <param name="category">出力を編成するために使用するカテゴリ名。</param>
        <summary>カテゴリ名とメッセージを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションのトレース リスナーに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 使用して、 `category` グループへのパラメーターは、メッセージを出力します。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.Write%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行に 2 番目のエラー メッセージを出力します。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.Write Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件の場合 <see langword="true" />, 、値は、コレクション内のトレース リスナーに書き込まれます。</param>
        <param name="value">宛ての名前を持つオブジェクト、 <see cref="P:System.Diagnostics.Debug.Listeners" />です。</param>
        <summary>オブジェクトの値を書き込みます <see cref="M:System.Object.ToString" /> メソッド内のトレース リスナーを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションの場合は、条件が <see langword="true" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.Write%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` または以上の場合、value パラメーターの名の出力例では、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行にメッセージが出力されます。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteIf1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can minimize the performance penalty of instrumenting your application by using <see langword="If...Then" /> statements instead of using <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> statements. The following two code examples send the same debugging message. However, the first example is much faster when tracing is off, because if <c>mySwitch.TraceError</c> evaluates to <see langword="false" />, you do not call <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. The second example always calls <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, even when <c>mySwitch.TraceError</c> is <see langword="false" /> and no tracing output is produced. This can result in unnecessary execution of arbitrarily complex code.  
  
 First example:  
  
```  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Second example:  
  
```  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件の場合 <see langword="true" />, 、コレクション内のトレース リスナーにメッセージが書き込まれます。</param>
        <param name="message">書き込むメッセージ。</param>
        <summary>内のトレース リスナーにメッセージを書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションの場合は、条件が <see langword="true" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.Write%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行に 2 番目のエラー メッセージを出力します。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteIf Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can minimize the performance penalty of instrumenting your application by using <see langword="If...Then" /> statements instead of using <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> statements. The following two code examples send the same debugging message. However, the first example is much faster when tracing is off, because if <c>mySwitch.TraceError</c> evaluates to <see langword="false" />, you do not call <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. The second example always calls <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, even when <c>mySwitch.TraceError</c> is <see langword="false" /> and no tracing output is produced. This can result in unnecessary execution of arbitrarily complex code.  
  
 First example:  
  
```  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Second example:  
  
```  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.Object,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件の場合 <see langword="true" />, 、カテゴリの名前と値がコレクション内のトレース リスナーに書き込まれます。</param>
        <param name="value">宛ての名前を持つオブジェクト、 <see cref="P:System.Diagnostics.Debug.Listeners" />です。</param>
        <param name="category">出力を編成するために使用するカテゴリ名。</param>
        <summary>カテゴリ名とオブジェクトの値を書き込みます <see cref="M:System.Object.ToString" /> メソッド内のトレース リスナーを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションの場合は、条件が <see langword="true" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 `category` パラメーターは、出力メッセージをグループ化を使用することができます。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.Write%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Verbose`, 、例では、出力の名前、 `myObject` と `category` に、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Error` または以上の場合、最初のメッセージと同じ行に 2 番目のエラー メッセージの出力例では、です。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteIf3 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf3 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can minimize the performance penalty of instrumenting your application by using <see langword="If...Then" /> statements instead of using <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> statements. The following two code examples send the same debugging message. However, the first example is much faster when tracing is off, because if <c>mySwitch.TraceError</c> evaluates to <see langword="false" />, you do not call <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. The second example always calls <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, even when <c>mySwitch.TraceError</c> is <see langword="false" /> and no tracing output is produced. This can result in unnecessary execution of arbitrarily complex code.  
  
 First example:  
  
```  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Second example:  
  
```  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件の場合 <see langword="true" />, 、コレクション内のトレース リスナーにカテゴリ名とメッセージが書き込まれます。</param>
        <param name="message">書き込むメッセージ。</param>
        <param name="category">出力を編成するために使用するカテゴリ名。</param>
        <summary>内のトレース リスナーにカテゴリ名とメッセージを書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションの場合は、条件が <see langword="true" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 `category` パラメーターは、出力メッセージをグループ化を使用することができます。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.Write%2A?displayProperty=fullName> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Verbose`, 、例では、最初のエラー メッセージが出力、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Error` または以上の場合、最初のメッセージと同じ行に 2 番目のエラー メッセージの出力例では、です。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteIf2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can minimize the performance penalty of instrumenting your application by using <see langword="If...Then" /> statements instead of using <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> statements. The following two code examples send the same debugging message. However, the first example is much faster when tracing is off, because if <c>mySwitch.TraceError</c> evaluates to <see langword="false" />, you do not call <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. The second example always calls <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, even when <c>mySwitch.TraceError</c> is <see langword="false" /> and no tracing output is produced. This can result in unnecessary execution of arbitrarily complex code.  
  
 First example:  
  
```  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Second example:  
  
```  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">宛ての名前を持つオブジェクト、 <see cref="P:System.Diagnostics.Debug.Listeners" />です。</param>
        <summary>オブジェクトの値を書き込みます <see cref="M:System.Object.ToString" /> メソッド内のトレース リスナーを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.WriteLine%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行にオブジェクトの名前を出力します。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteLine1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">書き込むメッセージ。</param>
        <summary>メッセージ内のトレース リスナーに書き込み、続けて行終端記号、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.WriteLine%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行に 2 番目のエラー メッセージを出力します。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteLine Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.Object,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">宛ての名前を持つオブジェクト、 <see cref="P:System.Diagnostics.Debug.Listeners" />です。</param>
        <param name="category">出力を編成するために使用するカテゴリ名。</param>
        <summary>カテゴリ名とオブジェクトの値を書き込みます <see cref="M:System.Object.ToString" /> メソッド内のトレース リスナーを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 `category` パラメーターは、出力メッセージをグループ化を使用することができます。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.WriteLine%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行に 2 番目のエラー メッセージを出力します。 2 番目のメッセージには、行終端記号が続きます。  
  
 [!code-cpp[Classic Debug.WriteLine3 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine3 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">0 個以上の書式項目が混在したテキストを含む複合書式指定文字列 \(「解説」を参照\)。各書式項目は、<c>args</c> 配列内のオブジェクトに対応します。</param>
        <param name="args">0 個以上の書式設定対象オブジェクトを含んだオブジェクト配列。</param>
        <summary>形式のメッセージ内のトレース リスナーに書き込み、続けて行終端記号を書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、.NET Framework オブジェクトの値をそのテキスト表現に変換し、その表現を文字列に埋め込むのです。  
  
 このメソッドの構文のキーワードは、オブジェクトの配列が 1 つの値にできることを意味します。 この例外は、 <xref:System.String> オブジェクトです。 明示的なオーバー ロードが優先ので、 `arg` 単一の文字列の値は既定値、 <xref:System.Diagnostics.Debug.WriteLine%28System.String%2CSystem.String%29?displayProperty=fullName> オーバー ロードします。  
  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=fullName> トレース リスナーのメソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">書き込むメッセージ。</param>
        <param name="category">出力を編成するために使用するカテゴリ名。</param>
        <summary>カテゴリ名とメッセージを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションのトレース リスナーに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 `category` パラメーターは、出力メッセージをグループ化を使用することができます。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.WriteLine%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 場合にその後、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、2 番目のエラー メッセージが出力され、 `category` 最初のメッセージと同じ行にします。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteLine2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件の場合 <see langword="true" />, 、値は、コレクション内のトレース リスナーに書き込まれます。</param>
        <param name="value">宛ての名前を持つオブジェクト、 <see cref="P:System.Diagnostics.Debug.Listeners" />です。</param>
        <summary>オブジェクトの値を書き込みます <see cref="M:System.Object.ToString" /> メソッド内のトレース リスナーを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションの場合は、条件が <see langword="true" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.WriteLine%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行にオブジェクトの名前を出力します。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteLineIf1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can minimize the performance penalty of instrumenting your application by using <see langword="If...Then" /> statements instead of using <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> statements. The following two code examples send the same debugging message. However, the first example is much faster when tracing is off, because if <c>mySwitch.TraceError</c> evaluates to <see langword="false" />, you do not call <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. The second example always calls <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, even when <c>mySwitch.TraceError</c> is <see langword="false" /> and no tracing output is produced. This can result in unnecessary execution of arbitrarily complex code.  
  
 First example:  
  
```  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Second example:  
  
```  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件の場合 <see langword="true" />, 、コレクション内のトレース リスナーにメッセージが書き込まれます。</param>
        <param name="message">書き込むメッセージ。</param>
        <summary>内のトレース リスナーにメッセージを書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションの場合は、条件が <see langword="true" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=fullName> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行に 2 番目のエラー メッセージを出力します。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteLineIf Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can minimize the performance penalty of instrumenting your application by using <see langword="If...Then" /> statements instead of using <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> statements. The following two code examples send the same debugging message. However, the first example is much faster when tracing is off, because if <c>mySwitch.TraceError</c> evaluates to <see langword="false" />, you do not call <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. The second example always calls <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, even when <c>mySwitch.TraceError</c> is <see langword="false" /> and no tracing output is produced. This can result in unnecessary execution of arbitrarily complex code.  
  
 First example:  
  
```  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Second example:  
  
```  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.Object,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">評価する条件式。 条件の場合 <see langword="true" />, 、カテゴリの名前と値がコレクション内のトレース リスナーに書き込まれます。</param>
        <param name="value">宛ての名前を持つオブジェクト、 <see cref="P:System.Diagnostics.Debug.Listeners" />です。</param>
        <param name="category">出力を編成するために使用するカテゴリ名。</param>
        <summary>カテゴリ名とオブジェクトの値を書き込みます <see cref="M:System.Object.ToString" /> メソッド内のトレース リスナーを <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションの場合は、条件が <see langword="true" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 `category` パラメーターは、出力メッセージをグループ化を使用することができます。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.WriteLine%2A> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 その後、if、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、最初のメッセージと同じ行に 2 番目のエラー メッセージを出力します。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteLineIf3 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf3 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can minimize the performance penalty of instrumenting your application by using <see langword="If...Then" /> statements instead of using <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> statements. The following two code examples send the same debugging message. However, the first example is much faster when tracing is off, because if <c>mySwitch.TraceError</c> evaluates to <see langword="false" />, you do not call <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. The second example always calls <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, even when <c>mySwitch.TraceError</c> is <see langword="false" /> and no tracing output is produced. This can result in unnecessary execution of arbitrarily complex code.  
  
 First example:  
  
```  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Second example:  
  
```  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">メッセージが書き込まれるようにするには <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="message">書き込むメッセージ。</param>
        <param name="category">出力を編成するために使用するカテゴリ名。</param>
        <summary>内のトレース リスナーにカテゴリ名とメッセージを書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションの場合は、条件が <see langword="true" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスに既定では、出力が書き込まれる <xref:System.Diagnostics.DefaultTraceListener>です。  
  
 `category` パラメーターは、出力メッセージをグループ化を使用することができます。  
  
 このメソッドは、 <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=fullName> トレース リスナーのメソッドです。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Diagnostics.TraceSwitch> という `generalSwitch`します。 このスイッチは、サンプル コードの外部で設定されています。  
  
 スイッチが設定されている場合、 <xref:System.Diagnostics.TraceLevel>`Error` 以降では、最初のエラー メッセージの出力例では、または、 <xref:System.Diagnostics.Debug.Listeners%2A>です。 リスナーを追加する方法について、 <xref:System.Diagnostics.Debug.Listeners%2A> 、コレクションを参照してください、 <xref:System.Diagnostics.TraceListenerCollection> クラスです。  
  
 場合にその後、 <xref:System.Diagnostics.TraceLevel> に設定されている `Verbose`, 、例では、2 番目のエラー メッセージが出力され、 `category` 最初のメッセージと同じ行にします。 行終端記号は、2 番目のメッセージを次に示します。  
  
 [!code-cpp[Classic Debug.WriteLineIf2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can minimize the performance penalty of instrumenting your application by using <see langword="If...Then" /> statements instead of using <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> statements. The following two code examples send the same debugging message. However, the first example is much faster when tracing is off, because if <c>mySwitch.TraceError</c> evaluates to <see langword="false" />, you do not call <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. The second example always calls <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, even when <c>mySwitch.TraceError</c> is <see langword="false" /> and no tracing output is produced. This can result in unnecessary execution of arbitrarily complex code.  
  
 First example:  
  
```  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Second example:  
  
```  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Print">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メッセージ内のトレース リスナーに書き込み、続けて行終端記号、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WriteLineIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>デバッグに関する情報内のトレース リスナーに書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションの場合は、条件が <see langword="true" />です。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Fail">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>エラー メッセージを出力します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>条件をチェックします。条件が <see langword="false" /> の場合、メッセージを出力し、コール スタックを示すメッセージ ボックスを表示します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>デバッグに関する情報内のトレース リスナーに書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WriteIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>デバッグに関する情報内のトレース リスナーに書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションの場合は、条件が <see langword="true" />です。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>デバッグに関する情報内のトレース リスナーに書き込みます、 <see cref="P:System.Diagnostics.Debug.Listeners" /> コレクションです。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>