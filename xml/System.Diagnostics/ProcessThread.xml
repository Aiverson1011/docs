<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>オペレーティング システムのプロセス スレッドを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用する <xref:System.Diagnostics.ProcessThread> システムで現在実行されているスレッドに関する情報を取得します。 これにより、たとえば、スレッドのパフォーマンス特性を監視します。  
  
> [!IMPORTANT]
>  この型は、 <xref:System.IDisposable> インターフェイスです。 型の使用が完了したらを直接または間接的にその破棄する必要があります。 型の直接 dispose を呼び出してその <xref:System.IDisposable.Dispose%2A> メソッドで、 `try`\/`catch` ブロックします。 直接ことのない破棄する場合など言語構成要素を使用して `using` \(c\#\) のまたは `Using` \(Visual Basic で\)。 詳細については、"を使用して、オブジェクトを実装して IDisposable"」セクションを参照してください、 <xref:System.IDisposable> インターフェイスに関するトピック。  
  
 スレッドは、プログラムの実行パスです。 Win32 のスケジュール実行の最小単位になります。 スタック、CPU レジスタとシステムのスケジューラの実行のリスト内のエントリの状態で構成されます。  
  
 プロセスは、1 つまたは複数のスレッドと、コード、データ、およびメモリ内のプログラムの他のリソースで構成されます。 一般的なプログラム リソースは開いているファイル、セマフォ、および動的に割り当てられたメモリです。 プロセスの各リソースは、すべてのプロセスのスレッドによって共有されます。  
  
 プログラムは、システムのスケジューラでは、実行制御をプログラムのスレッドの 1 つにときに実行されます。 どのスレッドを実行する必要があります、スケジューラが決定とします。 優先順位の低いスレッドは、優先度が高いスレッドは、各自のタスクを完了するまで待機が強制される場合があります。 マルチプロセッサ コンピューターで、スケジューラに移動できますの個別のスレッド異なるプロセッサを CPU の負荷を分散します。  
  
 各プロセスは、プライマリ スレッドと呼ばれる 1 つのスレッドで起動します。 どのスレッドでも新しいスレッドを作成できます。 プロセス内のすべてのスレッドは、そのプロセスのアドレス空間を共有します。  
  
 プライマリ スレッドは、コレクション内の最初のインデックスを必ずしも参照ではありません。  
  
> [!NOTE]
>  以降、.NET Framework version 2.0 では、他のコンピューターのパフォーマンス カウンター データを参照する機能は、.NET Framework のメソッドとプロパティの多くに削除されました。 パフォーマンスを向上させるために、非管理者による使用を有効にして、この変更が行われた、 <xref:System.Diagnostics.ProcessThread> クラスです。 .NET Framework の以前のバージョンでの例外を取得できなかった一部のアプリケーションが今すぐに入手可能性があります結果として、 <xref:System.NotSupportedException>です。 メソッドとプロパティの影響を受けるが多すぎてここでは、ボックスの一覧は、影響を受けるメンバーのトピックを例外情報が追加されています。  
  
 プロセスのスレッドは、個別に実行しにしない限り、それらを他の表示には互いに対応していません。 ただし、共通のリソースを共有しているスレッドは、セマフォ、またはプロセス間通信の別のメソッドを使用して作業を調整する必要があります。  
  
 すべてのコレクションを取得する、 <xref:System.Diagnostics.ProcessThread> 、現在のプロセスに関連付けられているオブジェクトを取得、 <xref:System.Diagnostics.Process.Threads%2A> のプロパティ、 <xref:System.Diagnostics.Process> インスタンス。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドの基本優先順位を取得します。</summary>
        <value>関連付けられたスレッドの優先度レベルとプロセスの優先度クラスを組み合わせることによって、オペレーティング システムを計算すると、スレッドの基本優先順位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.ProcessThread.BasePriority%2A> プロセスのスレッドの優先順位が開始します。 システム モニターの優先度ベース カウンターを通じて基本優先順位に関する情報を表示できます。  
  
 オペレーティング システムでは、プロセスの優先順位クラスと、スレッドの優先度レベルの範囲を組み合わせることによってスレッドの基本優先順位を計算します。 プロセスを設定することができます <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=fullName> プロパティの値のいずれかを <xref:System.Diagnostics.ProcessPriorityClass> は列挙体は、 <xref:System.Diagnostics.ProcessPriorityClass.Idle>, 、<xref:System.Diagnostics.ProcessPriorityClass.Normal>, 、<xref:System.Diagnostics.ProcessPriorityClass.High>, 、<xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, 、<xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, 、または <xref:System.Diagnostics.ProcessPriorityClass.RealTime>です。 スレッドを設定する <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> プロパティ値の範囲をスレッドの基本優先順位をします。 Win32 では、クラスごとに 7 つの基本優先度レベルと 4 つの優先度クラスを使用します。  
  
 スレッドの現在の優先順位は、基本の優先順位と異なる場合があります。 たとえば、オペレーティング システムを変更、 <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> 時間に基づいたプロパティが経過したか、プロセス時に、他の要因を元に並べアクセスのプロセッサにします。 さらに、設定、 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> プロパティをシステムにプロセスが待機状態から実行されるたびに、スレッドの優先順位を一時的に上げる可能性があります。 優先順位は、プロセスが待機状態に戻った時点でリセットされます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドの現在の優先順位を取得します。</summary>
        <value>オペレーティング システムがスレッドをスケジュールする方法に基づく基本優先順位と異なる場合がありますスレッドの現在の優先順位。 アクティブなスレッドの優先順位を一時的に上げることがあります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッドの現在の優先順位は、基本の優先順位と異なる場合があります。 たとえば、オペレーティング システムを変更、 <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> 時間に基づいたプロパティ経過すると、またはプロセス時にその他の要因を元に並べアクセスのプロセッサにします。 さらに、設定、 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> プロパティをシステムにプロセスが待機状態から実行されるたびに、スレッドの優先順位を一時的に上げる可能性があります。 優先順位は、プロセスが待機状態に戻った時点でリセットされます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドの一意の識別子を取得します。</summary>
        <value>特定のスレッドに関連付けられている一意の識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オペレーティング システムでは、有効期間中にのみ、スレッドを識別するためのスレッド id 番号が再利用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>上で実行するには、このスレッドの優先プロセッサを設定します。</summary>
        <value>システム スレッドの実行にプロセッサを決定する、スレッドをスケジュールするときに使用される、スレッドの優先プロセッサ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> 値は 0 から始まる。  つまり、最初のプロセッサのスレッドの関係を設定するには、0 に、プロパティを設定します。  
  
 システムでは、可能な限り、推奨されるプロセッサでスレッドをスケジュールします。  
  
 プロセスのスレッドは、プロセッサごとの移行に、プロセッサーを移行できます。 スレッドのプロセッサを指定すると、プロセッサのキャッシュが再読み込みされる回数を減らすことによって重い負荷のパフォーマンスが向上します。  
  
   
  
## 例  
 次の例では、設定、 <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> を最初のプロセッサには、メモ帳のインスタンスのプロパティです。  
  
 [!code-csharp[ProcessThreadIdealProcessor\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">システムは、指定されたプロセッサ上で開始するスレッドを設定できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはかどうか、オペレーティング システムが一時的に上げる関連付けられているスレッドの優先度、スレッドのプロセスのメイン ウィンドウがフォーカスを受け取ったときを示す値を設定します。</summary>
        <value>
          <see langword="true" /> スレッドの優先順位を上げるプロセスと、ユーザーが対話するときのインターフェイスです。それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> は `true`, 、システムは、関連するプロセスは待機状態から取得されるたびに一時的にスレッドの優先順位をブーストします。 この操作は、他のプロセスが現在のスレッドの処理を中断することを防ぎます。<xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> 設定は、既存のすべてのスレッドだけでなく、その後、プロセスによって作成されたすべてのスレッドに影響します。 通常の動作を復元するには、設定、 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> プロパティを `false`します。  
  
 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> 必要のあるプロセスでスレッドが実行されている場合にのみ有効な <xref:System.Diagnostics.Process.PriorityClass%2A> 動的な優先順位の列挙値のいずれかに設定 \(<xref:System.Diagnostics.ProcessPriorityClass.Normal>, 、<xref:System.Diagnostics.ProcessPriorityClass.High>, 、または <xref:System.Diagnostics.ProcessPriorityClass.RealTime>\)。  
  
> [!NOTE]
>  優先順位が高すぎるとやネットワーク機能の重要なオペレーティング システムからのリソースにドレインを実行できます。 これにより、他のオペレーティング システム タスクと問題が発生する可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">優先順位の上昇情報を取得できませんでした。  
  
 または  
  
 優先順位の上昇情報を設定できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはスレッドの優先度レベルを設定します。</summary>
        <value>いずれか、 <see cref="T:System.Diagnostics.ThreadPriorityLevel" /> スレッドの優先順位の境界となる範囲を指定する値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 優先度レベルはなく単一の値を値の範囲ではなくなります。 オペレーティング システム、プロセスを使用して、スレッドの基本優先順位を計算する <xref:System.Diagnostics.Process.PriorityClass%2A> で指定された範囲から値を選択する、 <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">スレッドの優先度レベルの情報を取得できませんでした。  
  
 または  
  
 スレッドの優先順位を設定できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドが、オペレーティング システム コア内のコードの実行に費やした時間を取得します。</summary>
        <value>A <see cref="T:System.TimeSpan" /> のスレッドが、オペレーティング システム コア内のコードの実行に費やした時間を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Windows では、いくつかの異なる保護メカニズムを使用し、ユーザー モードと特権モードの違いは、すべてのルートにします。<xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> オペレーティング システム コア内の特権モードで実行されているアプリケーションが費やした時間に対応します。<xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> プロパティのアプリケーションがシステムのコアの外部のユーザー モードでコードの実行に費やした時間の量を示します。  
  
 ユーザー モードでは、2 つの重要な点で、アプリケーションを制限します。 最初に、このアプリケーションは、周辺機器に直接アクセスすることはできませんが、代わりに、周辺機器のデータを取得または設定、オペレーティング システムのコアを呼び出す必要があります。 オペレーティング システムは、1 つのアプリケーションが別の作業で必要な周辺機器のデータを破棄しませんのでしたがってようにできます。 次に、アプリケーションでは、読み取りまたはオペレーティング システム自体を保持するデータを変更することはできません。 この制限は、偶然または意図的に破損では、コア アプリケーションをできないようにします。 アプリケーションでは、操作を実行するオペレーティング システムを必要とする場合、システムのルーチンの 1 つを呼び出します。 特権モードは、これらの移行の多くは、操作の実行し、スムーズにユーザー モードに戻ります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">スレッドの時間を取得できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたスレッドを実行できるプロセッサを設定します。</summary>
        <value>
          <see cref="T:System.IntPtr" /> スレッドで実行できるプロセッサを表すビット単位のセットを指します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッドのプロセッサのアフィニティは、プロセッサの関係のセットです。 つまり、それらで実行するようにスケジュールできます。  
  
 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> ビットで、各プロセッサを表します。 ビット 0 がいずれかのプロセッサを表し、ビット 1 は 2 つのプロセッサを表します。 次の表は、考えられるのサブセット <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> システムの 4 つのプロセッサ。  
  
|プロパティ値 \(16 進数\)|有効なプロセッサ|  
|----------------------|--------------|  
|0x0001|1|  
|0x0002|2|  
|0x0003|1 または 2|  
|0x0004|3|  
|0x0005|1 または 3|  
|0x0007|1、2、または 3|  
|0x000F|1、2、3、または 4|  
  
 設定して、スレッドの優先、1 つのプロセッサを指定することも、 <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> プロパティです。 プロセスのスレッドは、プロセッサごとの移行に、プロセッサーを移行できます。 スレッドのプロセッサを指定すると、プロセッサのキャッシュが再読み込みされる回数を減らすことによって重い負荷のパフォーマンスが向上します。  
  
   
  
## 例  
 次の例では、設定する方法、 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> を最初のプロセッサには、メモ帳のインスタンスのプロパティです。  
  
 [!code-csharp[ProcessThreadIdealProcessor\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">プロセッサのアフィニティを設定できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>単一の最適なプロセッサがないことを示すためには、このスレッドの最適なプロセッサをリセットします。 つまり、すべてのプロセッサが理想的なようにします。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">最適なプロセッサをリセットできませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドを起動するオペレーティング システムと呼ばれる関数のメモリ アドレスを取得します。</summary>
        <value>スレッドの開始アドレス、スレッドが実行するアプリケーション定義関数を指し示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各プロセスは、プライマリ スレッドと呼ばれる 1 つのスレッドで起動します。 どのスレッドでも新しいスレッドを作成できます。  
  
 仮想アドレス空間、実行可能コード、データ、オブジェクト ハンドル、環境変数、基本優先度、および最小値および最大ワーキング セット サイズを含むプロセスには。 プロセスのすべてのスレッドは、その仮想アドレス空間とシステム リソースを共有します。 さらに、各スレッドは、例外ハンドラー、スケジューリング優先順位、およびスケジュールされているスレッドが待機している間、システム スレッド コンテキストを保存する構造体のセットを保持します。 スレッドのコンテキストには、スレッドのプロセスのアドレス空間には中にマシン レジスタ、カーネル スタック、スレッド環境ブロック、およびユーザー スタックのスレッドのセットが含まれます。  
  
 すべての Windows スレッドは、実際には、アプリケーションによって提供される機能しないシステム提供の関数の実行を開始します。 プライマリ スレッドの開始アドレス、そのためと同じです \(システム指定の関数のアドレスを表します\)、システム内のすべての Windows プロセスのです。 ただし、 <xref:System.Diagnostics.ProcessThread.StartAddress%2A> プロパティでは、アプリケーションに固有である関数の開始アドレスを取得できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オペレーティング システムがスレッドを開始する時刻を取得します。</summary>
        <value>A <see cref="T:System.DateTime" /> オペレーティング システムのスレッドを開始するときに、システム上の時刻を表します。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">スレッドの時間を取得できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドの現在の状態を取得します。</summary>
        <value>A <see cref="T:System.Diagnostics.ThreadState" /> 、スレッドの実行、たとえば、実行中、待機中、または終了を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> プロパティの値が有効な場合にのみ、 <xref:System.Diagnostics.ProcessThread.ThreadState%2A> 値は <xref:System.Diagnostics.ThreadState.Wait>です。 そのため、確認、 <xref:System.Diagnostics.ProcessThread.ThreadState%2A> 値に達する前に、 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドがプロセッサを使用するのに費やした時間の合計を取得します。</summary>
        <value>A <see cref="T:System.TimeSpan" /> 時間、スレッドがプロセッサの制御がいることを示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> プロパティは、システム待機状態からスレッドが取得され、すべてのプロセッサ上の優先順位を指定する時間の合計を示します。 複数のプロセッサ システムで、スレッドが 1 つ以上のプロセッサを使用する場合、この値は各プロセッサで費やされた時間を指定すると。  
  
 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> プロパティの合計は、 <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> と <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">スレッドの時間を取得できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたスレッドが、アプリケーション コードを実行する時刻を取得します。</summary>
        <value>A <see cref="T:System.TimeSpan" /> をせずに、オペレーティング システム コア内のスレッドが、アプリケーション コードを実行に費やした時間を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Windows NT では、いくつかの異なる保護メカニズムを使用および、それらのすべてのルートには、ユーザー モードと特権モードの相違。<xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> オペレーティング システム コアの外部のユーザー モードで実行されているアプリケーションが費やした時間に対応します。<xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> のアプリケーションがシステム コア内の特権モードでコードの実行に費やした時間に対応しています。  
  
 ユーザー モードでは、2 つの重要な点で、アプリケーションを制限します。 最初に、このアプリケーションは、周辺機器に直接アクセスすることはできませんが、代わりに、周辺機器のデータを取得または設定、オペレーティング システムのコアを呼び出す必要があります。 オペレーティング システムは、1 つのアプリケーションが別の作業で必要な周辺機器のデータを破棄しませんのでしたがってようにできます。 次に、アプリケーションでは、読み取りまたはオペレーティング システム自体を保持するデータを変更することはできません。 この制限は、偶然または意図的に破損では、コア アプリケーションをできないようにします。 アプリケーションでは、操作を実行するオペレーティング システムを必要とする場合、システムのルーチンの 1 つを呼び出します。 特権モードは、これらの移行の多くは、操作の実行し、スムーズにユーザー モードに戻ります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">スレッドの時間を取得できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドが待機している理由を取得します。</summary>
        <value>A <see cref="T:System.Diagnostics.ThreadWaitReason" /> 、スレッドが待機状態にある理由を表します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> プロパティが有効な場合にのみ、 <xref:System.Diagnostics.ProcessThread.ThreadState%2A> は <xref:System.Diagnostics.ThreadState.Wait>です。 そのため、確認、 <xref:System.Diagnostics.ProcessThread.ThreadState%2A> 値に達する前に、 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">スレッドは、待機状態ではありません。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このプラットフォームは、Windows 98 または Windows Millennium Edition には。</exception>
        <exception cref="T:System.NotSupportedException">プロセスは、リモート コンピューター上です。</exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>