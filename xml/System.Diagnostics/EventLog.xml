<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows イベント ログとの相互作用を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.EventLog> lets you access or customize Windows event logs, which record information about important software or hardware events. Using <xref:System.Diagnostics.EventLog>, you can read from existing logs, write entries to logs, create or delete event sources, delete logs, and respond to log entries. You can also create new logs when creating an event source.  
  
> [!IMPORTANT]
>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a **languageKeyword tag is not supported!!!!**  
> \/**languageKeyword tag is not supported!!!!**  
>  block. To dispose of it indirectly, use a language construct such as **languageKeyword tag is not supported!!!!**  
>  \(in C\#\) or **languageKeyword tag is not supported!!!!**  
>  \(in Visual Basic\). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  
  
 In addition to providing access to individual event logs and their entries, the <xref:System.Diagnostics.EventLog> class lets you access the collection of all event logs. You can use the **languageKeyword tag is not supported!!!!**  
 members of <xref:System.Diagnostics.EventLog> to delete logs, get log lists, create or delete a source, or determine if a computer already contains a particular source.  
  
 There are three default event logs: Application, System, and Security. A Security log is read\-only. Other applications and services you install, such as Active Directory, might have additional event logs.  
  
 There are security considerations when using the <xref:System.Diagnostics.EventLog> class. <xref:System.Diagnostics.EventLog> requires <xref:System.Diagnostics.EventLogPermission> permissions for specific actions in the .NET Framework 2.0 and later versions, or full trust in the .NET Framework 1.0 and 1.1. We recommend that <xref:System.Diagnostics.EventLogPermission> not be granted to partially trusted code.  You should never pass any event log object, including <xref:System.Diagnostics.EventLogEntryCollection> and <xref:System.Diagnostics.EventLogEntry> objects, to less trusted code. For example, creating an <xref:System.Diagnostics.EventLog> object, writing an entry, and then passing the <xref:System.Diagnostics.EventLog> object to partially trusted code can create a security issue, because the ability to read and write to the event log allows code to perform actions such as issuing event log messages in the name of another application.  
  
 Starting with Windows Vista, User Account Control \(UAC\) determines the credentials of a user. If you are a member of the Built\-in Administrators group, you are assigned two run\-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To run the code that accesses the Security log, you must first elevate your credentials from standard user to administrator. You can do this when you start an application by opening the shortcut menu for the application \(if you're using a mouse, right\-click the application icon\) and indicating that you want to run as an administrator.  
  
 You can use <xref:System.Diagnostics.EventLog> to create custom event logs that you can view through the server's Event Viewer. Use the <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> method to display a localized name for your event log in the Event Viewer. Use the <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> method to configure the behavior of your event log when it reaches its maximum log size.  
  
 To read from an event log, specify the log name \(<xref:System.Diagnostics.EventLog.Log%2A> property\) and server computer name \(<xref:System.Diagnostics.EventLog.MachineName%2A> property for the event log. If you don't specify the server computer name, the local computer, ".", is assumed. It's not necessary to specify the event source \(<xref:System.Diagnostics.EventLog.Source%2A> property\), because a source is required only for writing to logs. The  <xref:System.Diagnostics.EventLog.Entries%2A> property is automatically populated with the event log's list of entries.  
  
 To write to an event log, specify or create an event source \(<xref:System.Diagnostics.EventLog.Source%2A> property\). You must have administrative credentials on the computer to create a new event source. The event source registers your application with the event log as a valid source of entries. You can use the event source  to write to only one log at a time. The <xref:System.Diagnostics.EventLog.Source%2A> property can be any random string, but the name must be distinct from other sources on the computer. The event source is typically the name of the application or another identifying string. Trying to create a duplicate <xref:System.Diagnostics.EventLog.Source%2A> value throws an exception. However, a single event log can be associated with multiple sources.  
  
 If the event source for the event log associated with the <xref:System.Diagnostics.EventLog> instance doesn't exist, a new event source is created. To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative credentials.  
  
 This requirement is because all event logs, including Security logs, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the Security log; therefore, a <xref:System.Security.SecurityException> is thrown.  
  
> [!IMPORTANT]
>  Creating or deleting an event source requires synchronization of the underlying code by using a named mutex. If a highly privileged application locks the named mutex, trying to create or delete an event source causes the application to stop responding until the lock is released. To help prevent this problem, never grant <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> permission to untrusted code. In addition, <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> permission potentially allows other permissions to be bypassed and should only be granted to highly trusted code.  
  
 Applications and services should write to the Application log or to a custom log. Device drivers should write to the System log. If you do not explicitly set the <xref:System.Diagnostics.EventLog.Log%2A> property, the event log defaults to the Application log.  
  
> [!NOTE]
>  There is nothing to protect an application from writing as any registered source.  If an application is granted <xref:System.Diagnostics.EventLogPermissionAccess.Write> permission, it can write events for any valid source registered on the computer.  
  
 Use the <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> methods to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  
  
 Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system hasn't refreshed its list of event sources, and you try to write an event with the new source, the write operation will fail. You can configure a new source by using an <xref:System.Diagnostics.EventLogInstaller> object or the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative credentials on the computer to create a new event source.  
  
 Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files. To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration instead of deleting the existing source.  
  
 You can register the event source with localized resources for your event category and message strings. Your application can write event log entries by using resource identifiers instead of specifying the actual string values. Refer to the <xref:System.Diagnostics.EventLogInstaller> and <xref:System.Diagnostics.EventSourceCreationData> classes for more information about configuring your source with resource files.  
  
 If your application writes string values directly to the event log, you do not have to set the resource file properties for the source. The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  
  
 When writing events, you must at least specify either a message string or the resource identifier for a message string. Other event properties are optional. Examples of optional event settings include the following:  
  
-   You can set the <xref:System.Diagnostics.EventLogEntryType> to specify the icon that the Event Viewer displays for the entry.  
  
-   You can specify a category identifier for the event, if your application uses categories for filtering the events.  
  
-   You can attach binary data to your event entry if you want to associate additional information with a given event.  
  
> [!IMPORTANT]
>  Event logging consumes disk space, processor time, and other system resources. It is important to log only essential information. We recommend that you place event log calls in an error path, rather than in the main code path, so they don't adversely affect performance.  
  
 For a list of initial property values for an instance of <xref:System.Diagnostics.EventLog>, see the <xref:System.Diagnostics.EventLog.%23ctor%2A> constructor.  
  
   
  
## 例  
 The following example creates the event source `MySource` if it doesn't already exist, and writes an entry to the event log `MyNewLog`.  
  
> [!NOTE]
>  Starting with Windows Vista, you must run this application as an administrator.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 このインスタンスは、ログとは関連付けられません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Before calling <xref:System.Diagnostics.EventLog.WriteEntry%2A>, specify the <xref:System.Diagnostics.EventLog.Source%2A> property of the <xref:System.Diagnostics.EventLog> instance. If you are only reading <xref:System.Diagnostics.EventLog.Entries%2A> from the log, you can alternatively specify only the <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A> properties.  
  
> [!NOTE]
>  If you do not specify a <xref:System.Diagnostics.EventLog.MachineName%2A>, the local computer \("."\) is assumed.  
  
 The following table shows initial property values for an instance of <xref:System.Diagnostics.EventLog>.  
  
|Property|Initial Value|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|An empty string \(""\).|  
|<xref:System.Diagnostics.EventLog.Log%2A>|An empty string \(""\).|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|The local computer \("."\).|  
  
   
  
## 例  
 The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">ローカル コンピューター上のログの名前。</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 ローカル コンピューター上のログにインスタンスを関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを設定、 <xref:System.Diagnostics.EventLog.Log%2A> プロパティを `logName` パラメーター。 呼び出しの前に <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 、指定、 <xref:System.Diagnostics.EventLog.Source%2A> のプロパティ、 <xref:System.Diagnostics.EventLog> インスタンス。 のみを読み込む場合 <xref:System.Diagnostics.EventLog.Entries%2A> 、ログからを指定できますのみ、 <xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティです。  
  
> [!NOTE]
>  指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>, 、ローカル コンピューター \("です"\)。 見なされます。 このオーバー ロード コンス トラクターの指定、 <xref:System.Diagnostics.EventLog.Log%2A> プロパティが変更できますこれを読み取る前に、 <xref:System.Diagnostics.EventLog.Entries%2A> プロパティです。  
  
 ソースを指定する場合、 <xref:System.Diagnostics.EventLog.Source%2A> プロパティは、後続の呼び出しに、コンピューター上の他のソースから一意 <xref:System.Diagnostics.EventLog.WriteEntry%2A> が既に存在しない場合は、指定した名前のログを作成します。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。 <xref:System.Diagnostics.EventLog>します。  
  
|プロパティ|初期値|  
|-----------|---------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 \(""\)。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|ローカル コンピューター \("です。"\) です。|  
  
   
  
## 例  
 次の例では、ローカル コンピューターの"myNewLog"、イベント ログにエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.EventLog1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">ログ名が正しくありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定したコンピューター上のログの名前。</param>
        <param name="machineName">ログが存在するコンピューター。</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 指定したコンピューター上のログにインスタンスを関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを設定、 <xref:System.Diagnostics.EventLog.Log%2A> プロパティを `logName` パラメーターおよび <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティを `machineName` パラメーター。 呼び出しの前に <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 、指定、 <xref:System.Diagnostics.EventLog.Source%2A> のプロパティ、 <xref:System.Diagnostics.EventLog>です。 のみを読み込む場合 <xref:System.Diagnostics.EventLog.Entries%2A> 、ログからを指定できますのみ、 <xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティです。  
  
> [!NOTE]
>  このコンス トラクターのオーバー ロードを指定、 <xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A> が、プロパティは読み取り前にいずれかで変更できます、 <xref:System.Diagnostics.EventLog.Entries%2A> プロパティです。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。 <xref:System.Diagnostics.EventLog>します。  
  
|プロパティ|初期値|  
|-----------|---------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 \(""\)。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` パラメーター。|  
  
   
  
## 例  
 次の例では、コンピューター"myServer"上"myNewLog"、イベント ログにエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.EventLog2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">ログ名が正しくありません。  
  
 または  
  
 コンピューター名が正しくありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定したコンピューター上のログの名前。</param>
        <param name="machineName">ログが存在するコンピューター。</param>
        <param name="source">イベント ログ エントリのソース。</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 指定したコンピューター上のログにインスタンスを関連付け、指定したソースを作成するか、または <see cref="T:System.Diagnostics.EventLog" /> に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターの設定、 <xref:System.Diagnostics.EventLog.Log%2A> プロパティを `logName` 、パラメーター、 <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティを `machineName` パラメーター、および <xref:System.Diagnostics.EventLog.Source%2A> プロパティを `source` パラメーター。<xref:System.Diagnostics.EventLog.Source%2A> プロパティは、イベント ログに書き込む際に必要です。 ただし、イベント ログ、のみからの読み取りのみ行う場合、 <xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A> である限り、サーバー上のイベント ログには、既に関連付けられているソースがある\) のプロパティが必要です。 イベント ログから読み取るだけの場合は、コンス トラクターの別のオーバー ロードするだけで十分です。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。 <xref:System.Diagnostics.EventLog>します。  
  
|プロパティ|初期値|  
|-----------|---------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` パラメーター。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` パラメーター。|  
  
   
  
## 例  
 次の例では、ソース""を使用して、ローカル コンピュータで"MyNewLog"イベント ログにエントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.EventLog3 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">ログ名が正しくありません。  
  
 または  
  
 コンピューター名が正しくありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用される <see cref="T:System.Diagnostics.EventLog" /> の初期化を開始します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントを使用するコンポーネントの初期化を開始します。<xref:System.Diagnostics.EventLog.EndInit%2A>メソッドが初期化を終了します。 使用して、<xref:System.Diagnostics.EventLog.BeginInit%2A>と<xref:System.Diagnostics.EventLog.EndInit%2A>メソッドのコントロールが完全に初期化される前に使用を禁止します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" />既に初期化されています。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>イベント ログからすべてのエントリを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント ログには、格納できるエントリの数を決定する最大サイズが設定されます。 イベント ログがいっぱいの場合、新しいイベント情報を記録を停止するか、古いエントリが上書きを開始します。 イベントの記録を停止する場合は、既存のエントリのログを消去し、イベントの記録を再開できるようにするこのメソッドを使用できます。 ログのイベント ログ エントリの消去が存在するコンピュータに対する管理者権限が必要です。  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> イベント ログを閉じ、新しい取得の読み取りし、書き込みハンドルをイベント ハンドルを解放およびイベント ログが再度開かれます。 既存のイベントと共に、メソッドの呼び出し後に受信したイベントはオフにします。  
  
   
  
## 例  
 次の例では、イベント ログを消去します。  
  
> [!CAUTION]
>  アプリケーション、システム、セキュリティ、およびその他の非カスタム ログは、重要な情報を含むことがこのコード例を実行する前に、カスタム ログを指定することを確認します。 この例は、カスタム ログを削除 `myNewLog`します。  
  
 [!code-cpp[Classic EventLog.Clear Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログは消去されませんでした。  
  
 または  
  
 ログを開くことができません。 Windows エラー コードは使用できません。</exception>
        <exception cref="T:System.ArgumentException">値が指定されていない、 <see cref="P:System.Diagnostics.EventLog.Log" /> プロパティです。 ログ名が空の文字列でないことを確認してください。</exception>
        <exception cref="T:System.InvalidOperationException">ログが存在しません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>イベント ログを閉じ、読み取りハンドルと書き込みハンドルを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.EventLog.Close%2A> メソッドが呼び出されるプロテクトによって <xref:System.ComponentModel.Component.Dispose%2A> メソッドです。 呼び出す必要はありません <xref:System.Diagnostics.EventLog.Close%2A> 呼び出す前に <xref:System.ComponentModel.Component.Dispose%2A>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログの読み取りハンドルまたは書き込みハンドルが正常に解放されませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">イベント ソースおよび対象のイベント ログの構成プロパティ。</param>
        <summary>イベント ソースおよび対応するイベント ログに指定された構成プロパティを使用して、ローカライズされたイベント メッセージを書き込むための有効なイベント ソースを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用すると、ローカル コンピューターまたはリモート コンピューター上のイベント ログにエントリを書き込むための新しいソースを構成できます。 このメソッドを使用すると、イベント ログから読み込む必要はありません。  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドは、入力を使用して `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>, 、<xref:System.Diagnostics.EventSourceCreationData.LogName%2A> と <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> 新しいソースとその関連のイベント ログのターゲット コンピューター上のレジストリ値を作成するプロパティです。 新しいソース名には、既存のソース名またはターゲット コンピューター上の既存のイベント ログ名を一致ことはできません。 場合、 <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> プロパティが設定されていない、アプリケーション イベント ログのソースが登録されています。 場合、 <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> 設定、ソースがローカル コンピューターに登録されています。  
  
> [!NOTE]
>  Windows Vista 以降のイベント ソースまたは Windows Server 2003 を作成するには、管理者特権が必要です。  
>   
>  この要件の理由では、セキュリティを含むすべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降では、ユーザー権限がない、セキュリティ ログにアクセスするにはしたがって、 <xref:System.Security.SecurityException> がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 \(UAC\) は、ユーザーの権限を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 使用する <xref:System.Diagnostics.EventLog.WriteEvent%2A> と <xref:System.Diagnostics.EventLog.WriteEntry%2A> イベント ログにイベントを書き込めません。 イベントを書き込むイベント ソースを指定する必要があります。作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログの新しいソースを作成するときにそのログのソースが登録されますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 オペレーティング システムは、イベント ログをファイルとして保存されます。 使用すると <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 指定したコンピューター上の %SystemRoot%\\System32\\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を追加することにより、ファイル名を設定、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 同時に、各ソースは 1 つだけのイベント ログに書き込むだけことができます。ただし、アプリケーションでは、複数のソースを使用して、複数のイベント ログに書き込みます。 たとえば、アプリケーションでは、別のイベント ログまたは別のリソース ファイル用に構成された複数のソースを必要があります。  
  
 イベント ソースは、イベント カテゴリおよびメッセージ文字列のローカライズされたリソース ファイルを登録できます。 アプリケーションでは、実際の文字列を指定するのではなく、リソース識別子を使用してイベント ログ エントリを書き込むことができます。 イベント ビューアーでは、リソース識別子を使用して、検索し、現在の言語設定に基づくローカライズされたリソース ファイルから対応する文字列を表示します。 イベントのカテゴリ、メッセージ、およびパラメーターの挿入文字列の個別のファイルを登録するまたはすべての 3 種類の文字列に同じリソース ファイルを登録することができます。 使用して、 <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, 、<xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, 、<xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, 、および <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> ローカライズされたエントリをイベント ログに書き込むにソースを構成するプロパティです。 アプリケーションがイベント ログに直接文字列値を書き込む場合は、これらのプロパティを設定する必要はありません。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成します。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  イベント ログのソースが構成され、別のイベント ログを再構成する場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## 例  
 次の例では、イベント ソースが名前付きかどうかを決定 `SampleApplicationSource` をローカル コンピューターに登録します。 イベント ソースが存在しない場合の例は、ソースのメッセージ リソース ファイルを設定し、新しいイベント ソースを作成します。 例にリソースの識別子の値を使用して、イベント ログのローカライズされた表示名を設定する最後に、 `DisplayNameMsgId` とリソース ファイルのパスに `messageFile`します。  
  
 [!code-cpp[EventLog\_WriteEvent\#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog\_WriteEvent\#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog\_WriteEvent\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージは、パラメーターの挿入文字列のテキストを定義します。 具体的には、リソース識別子 5001 イベント ログのローカライズされた名前が定義されます。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定されるコンピュータ名 <paramref name="sourceData" /> が無効です。  
  
 または  
  
 指定されたソース名 <paramref name="sourceData" /> は <see langword="null" />です。  
  
 または  
  
 指定されたログ名 <paramref name="sourceData" /> が無効です。 イベント ログ名が印刷可能な文字で構成する必要があり、文字を含めることはできません '\* ','?'、または' \\' です。  
  
 または  
  
 指定されたログ名 <paramref name="sourceData" /> ログの作成をユーザーに対して無効です。 システムで使用するには、AppEvent、SysEvent、および SecEvent のイベント ログ名が予約されています。  
  
 または  
  
 ログの名前では、既存のイベント ソース名と一致します。  
  
 または  
  
 指定されたソース名 <paramref name="sourceData" /> 254 文字を超えるレジストリ キー パスになります。  
  
 または  
  
 指定されたログ名の最初の 8 文字 <paramref name="sourceData" /> 固有ではありません。  
  
 または  
  
 指定されたソース名 <paramref name="sourceData" /> は既に登録されています。  
  
 または  
  
 指定されたソース名 <paramref name="sourceData" /> 既存のイベント ログ名に一致します。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションをローカル コンピューター上に登録するときに使用するソース名。</param>
        <param name="logName">ソースのエントリが書き込まれるログの名前。 指定できる値は、"Application"、"System"、またはカスタム イベント ログです。</param>
        <summary>ローカル コンピューター上のログにエントリを書き込むための有効なイベント ソースとして指定したソース名を設定します。 また、このメソッドによってローカル コンピューター上に新しいカスタム ログを作成することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して、カスタム ログを作成またはを作成し、登録、 <xref:System.Diagnostics.EventLog.Source%2A> 、ローカル コンピューター上の既存のログ。  
  
 場合 `logName` は `null` または空の文字列 \(""\) を呼び出すと <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, 、ログの既定値は、アプリケーション ログ。 システムがカスタム ログを作成して、として、アプリケーションの登録、ローカル コンピューター上にログが存在しない場合、 <xref:System.Diagnostics.EventLog.Source%2A> そのログにします。  
  
> [!NOTE]
>  Windows Vista 以降のイベント ソースまたは Windows Server 2003 を作成するには、管理者特権が必要です。  
>   
>  この要件の理由では、セキュリティを含むすべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降では、ユーザー権限がない、セキュリティ ログにアクセスするにはしたがって、 <xref:System.Security.SecurityException> がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 \(UAC: User Account Control\) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 のみ、イベント ログに書き込んでいる場合は、イベント ソースを作成する必要があります。 イベント ログにエントリを書き込む前に有効なイベント ソースとして、イベント ログでイベント ソースを登録する必要があります。 ログ エントリを記述するとき、システムは、 <xref:System.Diagnostics.EventLog.Source%2A> にエントリを配置するための適切なログを検索します。 かどうかは、イベント ログが表示されて、いずれかを指定できます、 <xref:System.Diagnostics.EventLog.Source%2A>, 、または <xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A>です。  
  
> [!NOTE]
>  指定する必要はありません、 <xref:System.Diagnostics.EventLog.MachineName%2A> 、ローカル コンピューター上のログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A> を表示する場合、ログから、ローカル コンピューター \("です"\)。 見なされます。  
  
 使用する <xref:System.Diagnostics.EventLog.WriteEvent%2A> と <xref:System.Diagnostics.EventLog.WriteEntry%2A> イベント ログにイベントを書き込めません。 イベントを書き込むイベント ソースを指定する必要があります。作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログの新しいソースを作成するときにそのログのソースが登録されますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 オペレーティング システムは、イベント ログをファイルとして保存されます。 使用すると <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 指定したコンピューター上の %SystemRoot%\\System32\\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を追加することにより、ファイル名を設定、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 ソースは、ローカル コンピューター上で一意である必要があります。新しいソース名には、既存のソース名または既存のイベント ログ名を一致ことはできません。 各ソースは、一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のソースを使用して、複数のイベント ログに書き込みます。 たとえば、アプリケーションでは、別のイベント ログまたは別のリソース ファイル用に構成された複数のソースを必要があります。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成します。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## 例  
 次の例では、ソース `MySource` ことが既に存在しないと、イベント ログにエントリを書き込むかどうか `MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 空の文字列 \(""\) または <see langword="null" />です。  
  
 または  
  
 <paramref name="logName" /> 有効なイベント ログ名がありません。 イベント ログ名が印刷可能な文字で構成されている必要があり、文字を含めることはできません '\* ','?'、または' \\' です。  
  
 または  
  
 <paramref name="logName" /> ログの作成をユーザーに対して無効です。 システムで使用するには、AppEvent、SysEvent、および SecEvent のイベント ログ名が予約されています。  
  
 または  
  
 ログの名前では、既存のイベント ソース名と一致します。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。  
  
 または  
  
 最初の 8 文字 <paramref name="logName" /> 既存のイベント ログ名の最初の 8 文字に一致します。  
  
 または  
  
 ローカル コンピューターに既に存在するため、ソースを登録することはできません。  
  
 または  
  
 ソース名では、既存のイベント ログ名と一致します。</exception>
        <exception cref="T:System.InvalidOperationException">ローカル コンピューターで、イベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="logName">ソースのエントリが書き込まれるログの名前。 指定できる値は、"Application"、"System"、またはカスタム イベント ログです。 値を指定しなかった場合、<c>logName</c> は既定によりアプリケーションに設定されます。</param>
        <param name="machineName">このイベント ソースを登録するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューター上のログにエントリを書き込むための有効なイベント ソースとして指定したソース名を設定します。 このメソッドを使用して、指定したコンピューター上に新しいカスタム ログを作成することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して、カスタム ログを作成またはを作成し、登録、 <xref:System.Diagnostics.EventLog.Source%2A> 指定したコンピューター上の既存のログ。  
  
 場合 `logName` は `null` または空の文字列 \(""\) を呼び出すと <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, 、ログの既定値は、アプリケーション ログ。 指定したコンピューター上にログが存在しない場合、システムはカスタム ログを作成し、として、アプリケーションを登録、 <xref:System.Diagnostics.EventLog.Source%2A> そのログにします。  
  
 のみ、イベント ログに書き込んでいる場合は、イベント ソースを作成する必要があります。 イベント ログにエントリを書き込む前に有効なイベント ソースとして、イベント ログでイベント ソースを登録する必要があります。 ログ エントリを記述するとき、システムは、 <xref:System.Diagnostics.EventLog.Source%2A> にエントリを配置するための適切なログを検索します。 かどうかは、イベント ログが表示されて、いずれかを指定できます、 <xref:System.Diagnostics.EventLog.Source%2A>, 、または <xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A>です。  
  
> [!NOTE]
>  Windows Vista 以降のイベント ソースまたは Windows Server 2003 を作成するには、管理者特権が必要です。  
>   
>  この要件の理由では、セキュリティを含むすべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降では、ユーザーが、セキュリティ ログにアクセスする権限を持たないしたがって、 <xref:System.Security.SecurityException> がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 \(UAC: User Account Control\) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 使用する <xref:System.Diagnostics.EventLog.WriteEvent%2A> と <xref:System.Diagnostics.EventLog.WriteEntry%2A> イベント ログにイベントを書き込めません。 イベントを書き込むイベント ソースを指定する必要があります。作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログの新しいソースを作成するときにそのログのソースが登録されますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 オペレーティング システムは、イベント ログをファイルとして保存されます。 使用すると <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 指定したコンピューター上の %SystemRoot%\\System32\\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を追加することにより、ファイル名を設定、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 ソースは、ローカル コンピューター上で一意である必要があります。新しいソース名には、既存のソース名または既存のイベント ログ名を一致ことはできません。 各ソースは、一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のソースを使用して、複数のイベント ログに書き込みます。 たとえば、アプリケーションでは、別のイベント ログまたは別のリソース ファイル用に構成された複数のソースを必要があります。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成します。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## 例  
 次の例では、ソース `MySource` コンピューターで `MyServer`, 、イベント ログにエントリを書き込むと `MyNewLog`です。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 有効なコンピューター名ではありません。  
  
 または  
  
 <paramref name="source" /> 空の文字列 \(""\) または <see langword="null" />です。  
  
 または  
  
 <paramref name="logName" /> 有効なイベント ログ名がありません。 イベント ログ名が印刷可能な文字で構成されている必要があり、文字を含めることはできません '\* ','?'、または' \\' です。  
  
 または  
  
 <paramref name="logName" /> ログの作成をユーザーに対して無効です。 システムで使用するには、AppEvent、SysEvent、および SecEvent のイベント ログ名が予約されています。  
  
 または  
  
 ログの名前では、既存のイベント ソース名と一致します。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。  
  
 または  
  
 最初の 8 文字 <paramref name="logName" /> 指定したコンピューター上の名前を既存のイベント ログの最初の 8 文字と一致します。  
  
 または  
  
 指定したコンピューターに既に存在するため、ソースを登録することはできません。  
  
 または  
  
 ソース名では、既存のイベント ソース名と一致します。</exception>
        <exception cref="T:System.InvalidOperationException">指定したコンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">削除するログの名前。 指定できる値は、アプリケーション、セキュリティ、システム、およびコンピューター上の任意のカスタム イベント ログです。</param>
        <summary>ローカル コンピューターからイベント ログを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 削除するログがローカル コンピューター上にある場合は、このメソッドを使用します。 適切なレジストリ権限が与えられていれば、コンピューター上のすべてのログを削除できます。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 指定されたログを削除 `logName` 、ローカル コンピューターからです。 ログに登録されているソースのみを削除する場合を呼び出す <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>します。 ログ エントリを削除する場合は、呼び出す <xref:System.Diagnostics.EventLog.Clear%2A>します。<xref:System.Diagnostics.EventLog.Delete%2A><xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は `static` メソッド、クラス自体を呼び出すことができるようにします。 新しいインスタンスを作成する必要はありません <xref:System.Diagnostics.EventLog> をいずれかのメソッドを呼び出します。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> メソッドが最初に、ログの内容を保持するファイルを削除します。 レジストリにアクセスし、そのログに登録されているすべてのイベント ソースを削除します。 後の時点でログを再作成する場合、再利用する場合は、ここでも、イベント ソースを登録してください。 イベント ソースを登録しないし、ログ名を指定せず、他のユーザーがイベント ソースに書き込むはアプリケーション イベント ログにイベント ソースが作成されます。 そのため、削除および再作成するログにエントリを書き込むことであったアプリケーションは、アプリケーション ログに書き込む代わりに、これで、イベント ソースを含んでいるためです。  
  
> [!NOTE]
>  イベント ログを再作成すると、困難なプロセスを指定できます。 システムで作成されたイベント ログで、アプリケーション ログなどのいずれかを削除しないでください。  
  
 呼び出すことによって、ログを削除する <xref:System.Diagnostics.EventLog.Delete%2A> ログに登録されているソースが自動的に削除します。 そのログ機能を使用して他のアプリケーションがあることがあります。  
  
   
  
## 例  
 次の例では、ローカル コンピューターからログを削除します。 この例では、ソースからログを決定します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込むことがあります。 カスタム ログを削除する前に、そのログに書き込んでいるその他のソースがないことを確認してください。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> 空の文字列 \(""\) または <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">ローカル コンピューターで、イベント ログのレジストリ キーを開けませんでした。  
  
 または  
  
 ログは、ローカル コンピューターではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログは消去されませんでした。  
  
 または  
  
 ログを開くことができません。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">削除するログの名前。 指定できる値は、アプリケーション、セキュリティ、システム、および指定したコンピューター上の任意のカスタム イベント ログです。</param>
        <param name="machineName">ログを削除するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターからイベント ログを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 削除するログがリモート コンピューター上にある場合は、このメソッドを使用します。 適切なレジストリ権限が与えられていれば、コンピューター上のすべてのログを削除できます。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 指定されたログを削除 `logName` で指定されたコンピューターから `machineName`します。 ログに登録されているソースのみを削除する場合を呼び出す <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>します。 ログ エントリを削除する場合は、呼び出す <xref:System.Diagnostics.EventLog.Clear%2A>します。<xref:System.Diagnostics.EventLog.Delete%2A><xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は `static` メソッド、クラス自体を呼び出すことができるようにします。 インスタンスを作成する必要はありません <xref:System.Diagnostics.EventLog> をいずれかのメソッドを呼び出します。  
  
 このメソッドは、まず、ログの内容を保持するファイルを削除します。 レジストリにアクセスし、そのログに登録されているすべてのイベント ソースを削除します。 後の時点でログを再作成する場合、再利用する場合は、ここでも、イベント ソースを登録してください。 イベント ソースを登録しないし、ログ名を指定せず、他のユーザーがイベント ソースに書き込むはアプリケーション イベント ログにイベント ソースが作成されます。 そのため、削除および再作成するログにエントリを書き込むことであったアプリケーションは、アプリケーション ログに書き込む代わりに、これで、イベント ソースを含んでいるためです。  
  
> [!NOTE]
>  イベント ログを再作成すると、困難なプロセスを指定できます。 システムで作成されたイベント ログで、アプリケーション ログなどのいずれかを削除しないでください。  
  
 呼び出すことによって、ログを削除する <xref:System.Diagnostics.EventLog.Delete%2A> ログに登録されているソースが自動的に削除します。 そのログ機能を使用して他のアプリケーションがあることがあります。  
  
   
  
## 例  
 次の例では、指定したコンピューターからログを削除します。 この例では、ソースからログを決定します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込むことがあります。 カスタム ログを削除する前に、そのログに書き込んでいるその他のソースがないことを確認してください。  
  
 [!code-cpp[Classic EventLog.Delete1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> 空の文字列 \(""\) または <see langword="null" />です。  
  
 または  
  
 <paramref name="machineName" /> 有効なコンピューター名ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したコンピューター上のイベント ログのレジストリ キーを開けませんでした。  
  
 または  
  
 指定したコンピューター上にログがありませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログは消去されませんでした。  
  
 または  
  
 ログを開くことができません。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ログ システムにアプリケーションを登録するときに使用する名前。</param>
        <summary>ローカル コンピューターのイベント ログからイベント ソースの登録を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 登録を削除するには、このメソッドを使用して、 <xref:System.Diagnostics.EventLog.Source%2A> 、ローカル コンピューターからです。<xref:System.Diagnostics.EventLog.DeleteEventSource%2A> ローカル コンピューター上のレジストリにアクセスし、有効なイベント ソースとして、アプリケーションの登録を解除します。  
  
 そのログにエントリを書き込むことが不要になった場合は、有効なイベント ソースとして、コンポーネントを削除できます。 たとえば、1 つのログを別のコンポーネントを変更する必要がある場合これを行うしてあります。 ソースは、一度に 1 つのログにしか登録できない、ためログを変更する必要がありますを現在の登録を削除します。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> ログに登録されているソースのみを削除します。 ログ自体を削除する場合は、呼び出す <xref:System.Diagnostics.EventLog.Delete%2A>します。 ログ エントリを削除する場合は、呼び出す <xref:System.Diagnostics.EventLog.Clear%2A>します。<xref:System.Diagnostics.EventLog.Delete%2A><xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は `static` メソッド、クラス自体を呼び出すことができるようにします。 インスタンスを作成する必要はありません <xref:System.Diagnostics.EventLog> をいずれかのメソッドを呼び出します。  
  
 呼び出すことによって、ログを削除する <xref:System.Diagnostics.EventLog.Delete%2A> ログに登録されているソースが自動的に削除します。 そのログ機能を使用して他のアプリケーションがあることがあります。  
  
> [!NOTE]
>  ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## 例  
 次の例では、ローカル コンピューターから、ソースを削除します。 例では、そのソースからログを特定し、ログが削除されます。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込むことがあります。 カスタム ログを削除する前に、そのログに書き込んでいるその他のソースがないことを確認してください。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> パラメーターは、ローカル コンピューターのレジストリに存在しません。  
  
 または  
  
 イベント ログのレジストリ キーに書き込みアクセス権がありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ログ システムにアプリケーションを登録するときに使用する名前。</param>
        <param name="machineName">登録を削除するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターからアプリケーションのイベント ソース登録を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 登録を削除するこのオーバー ロードを使用して、 <xref:System.Diagnostics.EventLog.Source%2A> リモート コンピューターからです。<xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 指定されたコンピューターのレジストリにアクセスする `machineName` し、有効なイベント ソースとして、アプリケーションの登録を解除します。  
  
 そのログにエントリを書き込むことが不要になった場合は、有効なイベント ソースとして、コンポーネントを削除できます。 たとえば、1 つのログを別のコンポーネントを変更する必要がある場合これを行うしてあります。 ソースは、一度に 1 つのログにしか登録できない、ためログを変更する必要がありますを現在の登録を削除します。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> ログに登録されているソースのみを削除します。 ログ自体を削除する場合は、呼び出す <xref:System.Diagnostics.EventLog.Delete%2A>します。 ログ エントリを削除する場合は、呼び出す <xref:System.Diagnostics.EventLog.Clear%2A>します。<xref:System.Diagnostics.EventLog.Delete%2A><xref:System.Diagnostics.EventLog.DeleteEventSource%2A> は `static` メソッド、クラス自体を呼び出すことができるようにします。 インスタンスを作成する必要はありません <xref:System.Diagnostics.EventLog> をいずれかのメソッドを呼び出します。  
  
 呼び出すことによって、ログを削除する <xref:System.Diagnostics.EventLog.Delete%2A> ログに登録されているソースが自動的に削除します。 そのログ機能を使用して他のアプリケーションがあることがあります。  
  
> [!NOTE]
>  ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## 例  
 次の例では、指定したコンピューターから、ソースを削除します。 例では、そのソースからログを特定し、ログが削除されます。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込むことがあります。 カスタム ログを削除する前に、そのログに書き込んでいるその他のソースがないことを確認してください。  
  
 [!code-cpp[Classic EventLog.Delete1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> パラメーターが無効です。  
  
 または  
  
 <paramref name="source" /> パラメーターが指定したコンピューターのレジストリに存在しません。  
  
 または  
  
 イベント ログのレジストリ キーに書き込みアクセス権がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 削除できませんレジストリの親のレジストリ キーに <paramref name="source" /> と同じ名前のサブキーが含まれていません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> が使用しているアンマネージ リソースを解放します。オプションとして、マネージ リソースを解放することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is called by the public **languageKeyword tag is not supported!!!!**  
**legacyBold tag is not supported!!!!**  
method and the <xref:System.Object.Finalize%2A> method. **languageKeyword tag is not supported!!!!**  
 invokes the protected **languageKeyword tag is not supported!!!!**  
 method with the **parameterReference tag is not supported!!!!**  
 parameter set to **languageKeyword tag is not supported!!!!**  
. <xref:System.Object.Finalize%2A> invokes **languageKeyword tag is not supported!!!!**  
 with **parameterReference tag is not supported!!!!**  
 set to **languageKeyword tag is not supported!!!!**  
.  
  
 When the **parameterReference tag is not supported!!!!**  
 parameter is true, this method releases all resources held by any managed objects that this <xref:System.Diagnostics.EventLog> references. This method invokes the **languageKeyword tag is not supported!!!!**  
 method of each referenced object.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> can be called multiple times by other objects. When overriding <see langword="Dispose(Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />. For more information about how to implement <see langword="Dispose(Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> が <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> イベント通知を受信するかどうかを示す値を取得または設定します。</summary>
        <value>エントリがログに書き込まれたときに <see cref="T:System.Diagnostics.EventLog" /> が通知を受信する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> プロパティを決定するかどうか、 <xref:System.Diagnostics.EventLog> エントリがログに書き込まれるときにイベントを発生させます。 プロパティが `true`, 、表示されるコンポーネント、 <xref:System.Diagnostics.EventLog.EntryWritten> イベントで指定されているログ エントリが書き込まれたれるたびに通知を受け取ります。、 <xref:System.Diagnostics.EventLog.Log%2A> プロパティです。 場合 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> は `false`, 、イベントは発生しません。  
  
> [!NOTE]
>  ローカル コンピューターのエントリが書き込まれる場合にのみ、イベント通知を受け取ることができます。 リモート コンピューターに書き込まれたエントリに対する通知を受け取ることはできません。  
  
   
  
## 例  
 次の例のハンドル、 <xref:System.Diagnostics.EventLog.EntryWritten> イベントです。  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">イベント ログは、リモート コンピューターでです。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用される <see cref="T:System.Diagnostics.EventLog" /> の初期化を終了します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] design environment uses this method to end the initialization of a component used on a form or by another component. The <xref:System.Diagnostics.EventLog.BeginInit%2A> method starts the initialization. Using the <xref:System.Diagnostics.EventLog.BeginInit%2A> and <xref:System.Diagnostics.EventLog.EndInit%2A> methods prevents the control from being used before it is fully initialized.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの内容を取得します。</summary>
        <value>イベント ログのエントリを保持している <see cref="T:System.Diagnostics.EventLogEntryCollection" />。 1 つのエントリが <see cref="T:System.Diagnostics.EventLogEntry" /> クラスの 1 つのインスタンスに関連付けられます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use the <xref:System.Diagnostics.EventLog.Entries%2A> member when reading from the event log.  
  
 Because the property is read\-only, you cannot modify an entry or write to the log using <xref:System.Diagnostics.EventLog.Entries%2A>. Instead, specify a <xref:System.Diagnostics.EventLog.Source%2A> and call <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write a new log entry. You can use <xref:System.Diagnostics.EventLog.Entries%2A> to count the number of entries in the event log, and view each <xref:System.Diagnostics.EventLogEntry> in the collection. Use the indexed <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> member to retrieve information about a specific entry, such as <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, or <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 It is not necessary to specify a <xref:System.Diagnostics.EventLog.Source%2A> when only reading from a log. You can specify only the <xref:System.Diagnostics.EventLog.Log%2A> name and <xref:System.Diagnostics.EventLog.MachineName%2A> \(server computer name\) properties for the <xref:System.Diagnostics.EventLog> instance. In either case, the <xref:System.Diagnostics.EventLog.Entries%2A> member is automatically populated with the event log's list of entries. You can select the appropriate index for an item in this list to read individual entries.  
  
 An important distinction between reading and writing log entries is that it is not necessary to explicitly call a read method. After the <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A> are specified, the <xref:System.Diagnostics.EventLog.Entries%2A> property is automatically populated. If you change the value of the <xref:System.Diagnostics.EventLog.Log%2A> or <xref:System.Diagnostics.EventLog.MachineName%2A> property, the <xref:System.Diagnostics.EventLog.Entries%2A> property is repopulated the next time you read it.  
  
> [!NOTE]
>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A>, the local computer, ".", is assumed.  
  
   
  
## 例  
 The following example reads entries in the event log, "MyNewLog", on the local computer.  
  
 [!code-cpp[Classic EventLog.Entries Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル コンピューター上のイベント ログにエントリが書き込まれたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 To get event notifications, you must set <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> to **languageKeyword tag is not supported!!!!**  
. You can only receive event notifications when entries are written on the local computer. You cannot receive notifications for entries written on remote computers.  
  
 When you create an <xref:System.Diagnostics.EventLog.EntryWritten> delegate, you identify the method that will handle the event. To associate the event with your event handler, add an instance of the delegate to the event. The event handler is called whenever the event occurs, until you remove the delegate. For more information about handling events with delegates, see [Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 The system responds to <xref:System.Diagnostics.EventLog.WriteEntry%2A> only if the last write event occurred at least six seconds previously. This implies you will only receive one <xref:System.Diagnostics.EventLog.EntryWritten> event notification within a six\-second interval, even if more than one event log change occurs. If you insert a sufficiently long sleep interval \(around 10 seconds\) between calls to <xref:System.Diagnostics.EventLog.WriteEntry%2A>, you are less likely to miss an event. However, if write events occur more frequently, you might not recieve the event notification until the next interval. Typically, missed event notifications are not lost, but delayed.  
  
   
  
## 例  
 The following example handles an entry written event.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">検索するログの名前。 指定できる値は、アプリケーション、セキュリティ、システム、アプリケーション固有のその他のログ \(Active Directory に関連するログなど\)、またはコンピューター上の任意のカスタム ログです。</param>
        <summary>ローカル コンピューター上にログが存在するかどうかを確認します。</summary>
        <returns>ローカル コンピューター上にログが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ローカル コンピューター上のログが存在するかどうかを調べるには、このメソッドを使用します。 使用して、ローカル コンピューターで、ソースが存在するかどうかを判断する <xref:System.Diagnostics.EventLog.SourceExists%2A>です。  
  
 このメソッドがレジストリにアクセスするため、ローカル コンピューターに適切なレジストリ権限がある必要があります。それ以外の場合、クエリが返す `false`します。  
  
 同じコンピューターには、既存のログの名前で新しいログを付与できない、ために、新しいログを作成する前にこのメソッドを使用して、かどうかを指定した `logName` 、ローカル コンピューターに既に存在します。`logName` パラメーターは大文字小文字を区別します。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> `static` メソッド、クラス自体を呼び出すことができます。 インスタンスを作成する必要はありません <xref:System.Diagnostics.EventLog> を呼び出す <xref:System.Diagnostics.EventLog.Exists%2A>します。  
  
   
  
## 例  
 [!code-cpp[EventLog\_Exists\_1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog\_Exists\_1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog\_Exists\_1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">LogName が <see langword="null" /> または値が空です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">検索するログ。 指定できる値は、アプリケーション、セキュリティ、システム、アプリケーション固有のその他のログ \(Active Directory に関連するログなど\)、またはコンピューター上の任意のカスタム ログです。</param>
        <param name="machineName">ログ検索の対象となるコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューター上にログが存在するかどうかを確認します。</summary>
        <returns>指定したコンピューター上にログが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 リモート コンピューター上のログが存在するかどうかを調べるには、このメソッドを使用します。 リモート コンピューターで、ソースが存在するかどうかを判断する <xref:System.Diagnostics.EventLog.SourceExists%2A>です。  
  
 このメソッドがレジストリにアクセスするため、指定したコンピューターに適切なレジストリ権限がある必要があります。それ以外の場合、クエリが返す `false`します。  
  
 同じコンピューターには、既存のログの名前で新しいログを付けることはできませんは、新しいログを作成する前にこのメソッドを 1 つを使用して、指定した `logName` で指定されたサーバーに既に存在する、 `machineName` パラメーター。`logName` と `machineName` パラメーターは大文字小文字が区別されません。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> `static` メソッド、クラス自体を呼び出すことができます。 新しいインスタンスを作成する必要はありません <xref:System.Diagnostics.EventLog> を呼び出す <xref:System.Diagnostics.EventLog.Exists%2A>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> パラメーターは、形式が無効です。 検索しているコンピューターに適切な構文を使用したことを確認します。  
  
 または  
  
 <paramref name="logName" /> は <see langword="null" /> または値が空です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ローカル コンピューター上のすべてのイベント ログを検索し、リストを格納する <see cref="T:System.Diagnostics.EventLog" /> オブジェクトの配列を作成します。</summary>
        <returns>ローカル コンピューター上のログを表す <see cref="T:System.Diagnostics.EventLog" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 配列 <xref:System.Diagnostics.EventLog> オブジェクトは、ローカル コンピューター上のすべてのイベント ログのスナップショットとへの呼び出し <xref:System.Diagnostics.EventLog.GetEventLogs%2A> されます。 ログをリアルタイムの作成または削除は反映されませんのででもこれは動的なコレクションではありません。 読み取りまたは書き込みをする前に、配列内のログが存在することを確認する必要があります。 配列には、通常、少なくとも 3 つのログが含まれます。 アプリケーション、システム、およびセキュリティです。 ローカル コンピューター上のカスタム ログを作成した場合も配列で表示されます。  
  
 イベント ログの一覧を取得するには、適切なレジストリのアクセス許可が必要です。 これらのアクセス許可は呼び出しに必要なものと同じ <xref:System.Diagnostics.EventLog.Exists%2A> と <xref:System.Diagnostics.EventLog.SourceExists%2A>です。  
  
   
  
## 例  
 次の例では、ローカル コンピューターで定義されたイベント ログを列挙し、各イベント ログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties\#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties\#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">レジストリへの読み取りアクセス権がありません。  
  
 または  
  
 コンピューター上では、イベント ログ サービスはありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">イベント ログの検索対象となるコンピューター。</param>
        <summary>指定したコンピューター上のすべてのイベント ログを検索し、リストを格納する <see cref="T:System.Diagnostics.EventLog" /> オブジェクトの配列を作成します。</summary>
        <returns>指定したコンピューター上のログを表す <see cref="T:System.Diagnostics.EventLog" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 配列 <xref:System.Diagnostics.EventLog> オブジェクトで指定されたコンピューター上のすべてのイベント ログのスナップショット、 `machineName` パラメーターとへの呼び出し <xref:System.Diagnostics.EventLog.GetEventLogs%2A> されます。 ログをリアルタイムの作成または削除は反映されませんのででもこれは動的なコレクションではありません。 読み取りまたは書き込みをする前に、配列内のログが存在することを確認する必要があります。 配列には、通常、少なくとも 3 つのログが含まれます。 アプリケーション、システム、およびセキュリティです。 指定したコンピューター上のカスタム ログを作成した場合も配列で表示されます。  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> `static` メソッドで呼び出すことができますので、 <xref:System.Diagnostics.EventLog> クラス自身です。 インスタンスを作成する必要はありません、 <xref:System.Diagnostics.EventLog> メソッドに呼び出しを行うオブジェクト。  
  
 イベント ログの一覧を取得するには、適切なレジストリのアクセス許可が必要です。 これらのアクセス許可は呼び出しに必要なものと同じ <xref:System.Diagnostics.EventLog.Exists%2A> と <xref:System.Diagnostics.EventLog.SourceExists%2A>です。  
  
   
  
## 例  
 次の例では、"myServer"のコンピューターでログの一覧を取得します。 各ログの名前を出力します。  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> パラメーターは、コンピューター名は無効です。</exception>
        <exception cref="T:System.InvalidOperationException">レジストリへの読み取りアクセス権がありません。  
  
 または  
  
 コンピューター上では、イベント ログ サービスはありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み取るログまたは書き込むログの名前を取得または設定します。</summary>
        <value>ログの名前。 ログ名には、アプリケーション ログ名、システム ログ名、セキュリティ ログ名、またはカスタム ログ名を指定できます。 既定値は、空の文字列 \(""\) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、サーバーで次の 3 つのログ ファイルが存在します。 アプリケーション、システム、およびセキュリティです。 アプリケーションとサービスは、アプリケーションのログ ファイルを使用します。 デバイス ドライバーは、システム ログ ファイルを使用します。 監査をオンにすると、セキュリティ ログの成功と失敗の監査イベントが生成されます。 その他のアプリケーションを Windows サーバー上の Active Directory のように、インストールした場合、その他の既定のログ ファイルがあります。 さらに、ローカルまたはリモート コンピューター上のカスタム ログ ファイルを作成することができます。 カスタム ログは、コンポーネントが既定のアプリケーション ログにイベントを書き込めない場合に許可されているより詳細な方法で入力内容を整理します。  
  
> [!NOTE]
>  ログ名は 8 文字に制限されます。 システムに従って MyLogSample1 と MyLogSample2 は、同じログです。  
  
 イベント ログに書き込む場合は指定するのに十分な <xref:System.Diagnostics.EventLog.Log%2A> プロパティです。 関連付ける必要があります、 <xref:System.Diagnostics.EventLog.Source%2A> 特定のログに接続するようにイベント ログ リソースを持つプロパティです。 指定する必要はありません、 <xref:System.Diagnostics.EventLog.Source%2A> ときに、ログ、イベント ソースからの読み取りのみがあります、サーバーのレジストリのイベント ログのリソースに関連付けられています。 だけを指定することができます、 <xref:System.Diagnostics.EventLog.Log%2A> 名および <xref:System.Diagnostics.EventLog.MachineName%2A> \(サーバーのコンピューター名\) からの読み取りにします。  
  
> [!NOTE]
>  指定する必要はありません、 <xref:System.Diagnostics.EventLog.MachineName%2A> をログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>, 、ローカル コンピューター \("です"\)。 見なされます。  
  
 場合、 <xref:System.Diagnostics.EventLog.Source%2A> プロパティが指定されていないへの呼び出し <xref:System.Diagnostics.EventLog.Log%2A> 場合は、空の文字列を返します <xref:System.Diagnostics.EventLog.Log%2A> 明示的に設定されていない \(を設定して、 <xref:System.Diagnostics.EventLog.Log%2A> プロパティ、またはコンス トラクター\)。 場合、 <xref:System.Diagnostics.EventLog.Source%2A> が指定されている <xref:System.Diagnostics.EventLog.Log%2A> そのソースが登録されているログの名前を返します。  
  
 ソースは、一度に 1 つのログのみ登録できます。 場合、 <xref:System.Diagnostics.EventLog.Source%2A> のインスタンスのプロパティが設定された <xref:System.Diagnostics.EventLog>, 、変更することはできません、 <xref:System.Diagnostics.EventLog.Log%2A> プロパティを <xref:System.Diagnostics.EventLog> の値を変更することがなく <xref:System.Diagnostics.EventLog.Source%2A> またはを呼び出して <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 最初です。 変更した場合、 <xref:System.Diagnostics.EventLog.Log%2A> 後プロパティ、 <xref:System.Diagnostics.EventLog.Source%2A> プロパティが設定されて、例外をスローするログ エントリを作成します。  
  
 オペレーティング システムは、イベント ログをファイルとして保存されます。 使用すると <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 指定したコンピューター上の %SystemRoot%\\System32\\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を追加することにより、ファイル名を設定、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 使用して新しいログを作成することはできません、 <xref:System.Diagnostics.EventLog.Log%2A> プロパティ \(なし、ログのソースを指定する\) だけです。 呼び出すことができます <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, で新しいログ名をパラメーターとして渡すこと、および物書き <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>します。 ただし、意図される通常の作成 \(およびエントリを書き込む\) にアプリケーション固有の新しいログや、既存のログからの読み取り。  
  
 場合、 <xref:System.Diagnostics.EventLog.Log%2A> 値の変更は、イベント ログは閉じられ、すべてのイベント ハンドルを解放します。  
  
> [!CAUTION]
>  設定した場合、 <xref:System.Diagnostics.EventLog.Log%2A> プロパティが存在しないログ ファイルの名前に、システムのアタッチ、 <xref:System.Diagnostics.EventLog> アプリケーション ログには、警告が使用されているいずれかの指定した以外のログができます。  
  
   
  
## 例  
 次の例では、ローカル コンピューター上のイベント ログ"NewEventLog"内のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.Log Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの表示名を取得します。</summary>
        <value>システムのイベント ビューアーのイベント ログを表す名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  Windows Vista 以降では、ユーザーには、セキュリティ ログにアクセスする権限がありません。 Windows Vista を実行している場合、get は、ユーザーは、後で、 <xref:System.Security.SecurityException> セキュリティ ログのイベントの表示名にアクセスしようとします。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 \(UAC: User Account Control\) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
   
  
## 例  
 次の例は、ローカル コンピューターで定義されたイベント ログを列挙し、表示、 <xref:System.Diagnostics.EventLog.LogDisplayName%2A> 各イベント ログのです。  
  
 [!code-cpp[EventLogProperties\#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties\#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定した <see cref="P:System.Diagnostics.EventLog.Log" /> このコンピューターのレジストリに存在しません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">for the ability to read the specified registry key. Associated enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to access the specified registry key if it is a remote key. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <param name="machineName">検索対象のコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したソースが登録されているログの名前を取得します。</summary>
        <returns>レジストリ内で指定したソースに関連付けられているログの名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント ソースは、どのようなイベントをログに記録を示します。 アプリケーションが大きい場合は、多くの場合、アプリケーションの名前や、アプリケーションのサブコンポーネントの名前です。 アプリケーションとサービスは、アプリケーション ログまたはカスタムのログに書き込む必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。  
  
 同時に 1 つのログに書き込むだけことができます、新しいソースを作成するときに、システムでは、イベント ログを含むアプリケーションをエントリの有効なソースとして登録します。<xref:System.Diagnostics.EventLog.Source%2A> プロパティは、任意の文字列を指定できますが、名前は、コンピューター上の他のソースでは使用できません。 作成、複製されたしよう <xref:System.Diagnostics.EventLog.Source%2A> 値は、例外をスローします。 ただし、単一のイベント ログを書き込むのさまざまなソースことができます。  
  
   
  
## 例  
 次の例では、ローカル コンピューターから、ソースを削除します。 例では、そのソースからログを特定し、ログが削除されます。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込むことがあります。 カスタム ログを削除する前に、そのログに書き込んでいるその他のソースがないことを確認してください。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベントを読み取るコンピューターまたは書き込むコンピューターの名前を取得または設定します。</summary>
        <value>イベント ログが存在するサーバーの名前。 既定値はローカル コンピューター \("."\) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント ログに書き込む場合に関連付ける必要があります、 <xref:System.Diagnostics.EventLog.Source%2A> オブジェクトを使用してイベント ログに特定のログに接続します。 指定する必要はありません、 <xref:System.Diagnostics.EventLog.Source%2A> プロパティのみをログから読み取るときにします。 だけを指定することができます、 <xref:System.Diagnostics.EventLog.Log%2A> 名および <xref:System.Diagnostics.EventLog.MachineName%2A> \(サーバーのコンピューター名\)。  
  
> [!NOTE]
>  指定する必要はありません、 <xref:System.Diagnostics.EventLog.MachineName%2A> をログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>, 、ローカル コンピューター \("です"\)。 見なされます。  
  
 ソースは、一度に 1 つのログのみ登録できます。 場合、 <xref:System.Diagnostics.EventLog.Source%2A> のインスタンスのプロパティが設定された <xref:System.Diagnostics.EventLog>, 、変更することはできません、 <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティを <xref:System.Diagnostics.EventLog> の値を変更することがなく <xref:System.Diagnostics.EventLog.Source%2A> またはを呼び出して <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 最初です。 変更した場合、 <xref:System.Diagnostics.EventLog.MachineName%2A> プロパティには、 <xref:System.Diagnostics.EventLog> すべてのハンドルを閉じ、ログと、新しいコンピューター上のソースに再アタッチします。  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A> 値が空の文字列にすることはできません。 これが明示的に設定されていない場合は、既定によりローカル コンピューター \("です。"\) です。  
  
   
  
## 例  
 次の例では、指定したコンピューター上のイベント ログ"NewEventLog"内のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.MachineName Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">コンピューター名が正しくありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの最大サイズを KB 単位で取得または設定します。</summary>
        <value>イベント ログの最大サイズ。単位は KB です。 既定値は、512 KB の最大ファイル サイズを示す 512 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> プロパティは、イベント ログ ファイルのサイズ制限を表します。 イベント ログが、構成されているサイズ制限に達したとき <xref:System.Diagnostics.EventLog.OverflowAction%2A> 値は、新しいエントリが破棄されたかどうかや、新しいエントリが古いエントリを上書きするかどうかを決定します。  
  
> [!NOTE]
>  このプロパティは、このインスタンスで表されるイベント ログの構成設定を表します。 イベント ログには、最大サイズに達すると、このプロパティは、オペレーティング システムがイベント ログに対して登録されているすべてのイベント ソースによって書き込まれる新しいエントリを処理する方法を指定します。  
  
   
  
## 例  
 次の例では、ローカル コンピューターで定義されたイベント ログを列挙し、各イベント ログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties\#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties\#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定した値は、64、4194240、または 64 の倍数いないより大きいか小さいです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 値が有効なログ名ではありません。  
  
 または  
  
 ターゲット コンピューターで、イベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログ内のエントリを保持する日数を取得します。</summary>
        <value>イベント ログ内のエントリが保持される日数。 既定値は 7 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> プロパティをイベント ログの現在の設定を確認します。 使用 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> イベント ログ内の各エントリを保持する日数の最小数を変更します。  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 値は、イベント ログのオーバーフロー動作に依存します。 場合、 <xref:System.Diagnostics.OverflowAction> にイベント ログのプロパティが設定されている <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, 、 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 値は 0 です。 場合、 <xref:System.Diagnostics.OverflowAction> にイベント ログのプロパティが設定されている <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, 、 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 値は\-1。 場合、 <xref:System.Diagnostics.OverflowAction> にイベント ログのプロパティが設定されている <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, 、 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 値が 0 より大きいと、イベント ログがいっぱいになったときに、イベント ログ エントリを保持する日数を表します。  
  
 オーバーフロー動作は、イベント ログがそのサイズ制限に達したときにのみ発生します。 ときに、 <xref:System.Diagnostics.EventLog> がその <xref:System.Diagnostics.EventLog.OverflowAction%2A> に設定 <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, 、し、イベント ログがその最大サイズに達すると、新しいエントリが書き込まれるだけの経過期間を超えたエントリが置き換えられたりかどうか、 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 期間。 最低限の期間のイベント エントリの保持は、イベント ログを定期的にアーカイブする場合に適しています。 それ以外の場合、イベント ログが、上限に達するときに、新しいエントリを損失する可能性があります。 新しいイベント情報を失うことを回避するには、特定のイベント ログのアーカイブ スケジュールに基づいてイベントの最小の保持日数を設定します。  
  
   
  
## 例  
 次の例では、ローカル コンピューターで定義されたイベント ログを列挙し、各イベント ログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties\#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties\#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">イベント ログに新しいエントリを書き込むためのオーバーフロー動作。</param>
        <param name="retentionDays">イベント ログの各エントリが保持される最小日数。 このパラメーターは、<c>action</c> が <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> に設定されている場合にのみ使用されます。</param>
        <summary>イベント ログが最大ファイル サイズに達した場合に、新しいエントリを書き込むように構成された動作を変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント ログのオーバーフロー動作では、新しいエントリが最大ファイル サイズに達したログに書き込まれるときの動作を指定します。  
  
> [!NOTE]
>  オーバーフロー動作は、イベント ログが最大ファイル サイズに達した場合にのみ有効です。 オーバーフロー動作は、新しいエントリの追加のイベント ログ エントリに対応するログに書き込むには影響しません。  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> メソッドは、イベント ログのオーバーフロー動作を構成します。<xref:System.Diagnostics.EventLog> インスタンス。 によって指定されたイベント ログにこのメソッドを呼び出した後、 <xref:System.Diagnostics.EventLog.Log%2A> 、プロパティ、 <xref:System.Diagnostics.EventLog.OverflowAction%2A> と <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> プロパティ値が新しく構成されたオーバーフロー動作を反映します。  
  
> [!NOTE]
>  このプロパティは、このインスタンスで表されるイベント ログの構成設定を表します。 イベント ログには、最大サイズに達すると、このプロパティは、オペレーティング システムがイベント ログに対して登録されているすべてのイベント ソースによって書き込まれる新しいエントリを処理する方法を指定します。  
  
 設定、 `action` パラメーターを <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> 新しいエントリが最も古いエントリを上書きすることを示すときに、 <xref:System.Diagnostics.EventLog> 最大サイズに達した。 場合、 `action` にパラメーターが設定されている <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, 、 `retentionDays` パラメーターの値は無視されます。  
  
 設定、 `action` パラメーターを <xref:System.Diagnostics.OverflowAction.OverwriteOlder> 新しいエントリが古いエントリを上書きすることを示すときに、 <xref:System.Diagnostics.EventLog> 最大サイズに達した。 使用して、ログでイベントを保持する日数を指定、 `retentionDays` パラメーター。 保有期間の範囲内のイベントは、新しいエントリでは上書きされません。  
  
 設定、 `action` パラメーターを <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> 最大ログ サイズに達したときに新しいイベントを破棄します。 場合、 `action` にパラメーターが設定されている <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, 、 `retentionDays` パラメーターの値は無視されます。  
  
> [!CAUTION]
>  オーバーフロー ポリシーを設定 <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> イベント ログがいっぱいになったときに、新しいエントリを破棄するように指定します。 この設定を使用する場合は、イベント ログが定期的にアーカイブし、最大サイズ制限に達しないようにするために消去を確認します。  
  
   
  
## 例  
 次の例では、指定のイベント ログに対して構成されているオーバーフロー ポリシーを表示し、イベント ログの新しいオーバーフロー ポリシー設定を選択することができます。  
  
 [!code-cpp[EventLogProperties\#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties\#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> が有効な <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> 小さい 365 よりも大きいかそれよりも、1 つです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 値が有効なログ名ではありません。  
  
 または  
  
 ターゲット コンピューターで、イベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログが最大ファイル サイズに達した場合に、新しいエントリを格納するように構成された動作を取得します。</summary>
        <value>イベント ログが最大サイズに達した場合に、新しいエントリを格納するために構成された動作を指定する <see cref="T:System.Diagnostics.OverflowAction" /> 値。 既定値は、<see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント ログ サイズが大きくなったりに新しいイベントが書き込まれるとします。 各イベント ログが構成されているサイズの上限です。 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> プロパティが許可されているイベントのログ ファイルのサイズをキロバイト単位の最大数を定義します。  
  
 使用して、 <xref:System.Diagnostics.EventLog.OverflowAction%2A> プロパティの値をその最大サイズでは、イベント ログのオーバーフロー動作を確認します。 使用して、 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> メソッド、イベント ログのオーバーフロー動作を変更します。  
  
> [!NOTE]
>  オーバーフロー動作は、イベント ログが最大ファイル サイズに達した場合にのみ有効です。 オーバーフロー動作は、新しいエントリの追加のイベント ログ エントリに対応するログに書き込むには影響しません。  
  
   
  
## 例  
 次の例では、ローカル コンピューターで定義されたイベント ログを列挙し、各イベント ログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties\#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties\#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">ローカライズされたリソース ファイルの完全指定パス。</param>
        <param name="resourceId">リソース ファイル内のローカライズされた文字列のインデックスを示すリソース識別子。</param>
        <summary>イベント ログのローカライズされた名前を指定します。これは、サーバーのイベント ビューアーに表示されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用 <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> を登録し、カスタム イベント ログのイベント ビューアーでローカライズされた名前を表示します。  
  
 指定したリソース識別子は、リソース ファイルで定義されているローカライズされた文字列に対応する必要があります。 イベント ビューアーには、ローカライズされた文字列と現在のカルチャ設定を使用してカスタム イベント ログ名が表示されます。 たとえば、リソース ファイル内のさまざまなカルチャ用にローカライズされた複数のイベント ログ名を定義できます。 イベント ビューアーには、現在のユーザーのカルチャ設定に対応するローカライズされた文字列が表示されます。  
  
 イベント ビューアーは、リソース ファイルからローカライズされた文字列を読み込むことができませんか、イベント ログの表示名が登録されていない場合、イベント ビューアーを表示で定義されているイベント ログ名 <xref:System.Diagnostics.EventLog.Log%2A>します。  
  
> [!NOTE]
>  定義済みのイベント ログの表示名を登録する必要はありません。 オペレーティング システムでは、アプリケーション、システム、およびセキュリティ イベント ログのローカライズされた表示名を登録します。  
  
   
  
## 例  
 次の例では、イベント ソースが名前付きかどうかを決定 `SampleApplicationSource` をローカル コンピューターに登録します。 イベント ソースが存在しない場合の例は、ソースのメッセージ リソース ファイルを設定し、新しいイベント ソースを作成します。 例にリソースの識別子の値を使用して、イベント ログのローカライズされた表示名を設定する最後に、 `DisplayNameMsgId` とリソース ファイルのパスに `messageFile`します。  
  
 [!code-cpp[EventLog\_WriteEvent\#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog\_WriteEvent\#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog\_WriteEvent\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージは、パラメーターの挿入文字列のテキストを定義します。 具体的には、リソース識別子 5001 イベント ログのローカライズされた名前が定義されます。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 値が有効なログ名ではありません。  
  
 または  
  
 ターゲット コンピューターで、イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile " /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for administering event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログを書き込むときに登録して使用するソース名を取得または設定します。</summary>
        <value>エントリのソースとしてイベント ログに登録される名前。 既定値は、空の文字列 \(""\) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント ソースは、どのようなイベントをログに記録を示します。 アプリケーションが大きい場合は、多くの場合、アプリケーションの名前や、アプリケーションのサブコンポーネントの名前です。 アプリケーションとサービスは、アプリケーション ログまたはカスタムのログに書き込む必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。  
  
 のみ、イベント ログに書き込んでいる場合は、イベント ソースを指定する必要があります。 イベント ログにエントリを書き込む前に有効なイベント ソースとして、イベント ログでイベント ソースを登録する必要があります。 ログ エントリを記述するとき、システムは、 <xref:System.Diagnostics.EventLog.Source%2A> エントリを配置するための適切なログを検索するプロパティです。 かどうかは、イベント ログが表示されて、いずれかを指定できます、 <xref:System.Diagnostics.EventLog.Source%2A>, 、または <xref:System.Diagnostics.EventLog.Log%2A> と <xref:System.Diagnostics.EventLog.MachineName%2A>です。  
  
> [!NOTE]
>  指定する必要はありません、 <xref:System.Diagnostics.EventLog.MachineName%2A> 、ローカル コンピューター上のログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>, 、ローカル コンピューター \("です"\)。 見なされます。  
  
 使用する <xref:System.Diagnostics.EventLog.WriteEvent%2A> と <xref:System.Diagnostics.EventLog.WriteEntry%2A> イベント ログにイベントを書き込めません。 イベントを書き込むイベント ソースを指定する必要があります。作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログの新しいソースを作成するときにそのログのソースが登録されますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 ソースは、ローカル コンピューター上で一意である必要があります。新しいソース名には、既存のソース名または既存のイベント ログ名を一致ことはできません。 各ソースは、一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のソースを使用して、複数のイベント ログに書き込みます。 たとえば、アプリケーションでは、別のイベント ログまたは別のリソース ファイル用に構成された複数のソースを必要があります。  
  
 変更した場合、 <xref:System.Diagnostics.EventLog.Source%2A> 値、 <xref:System.Diagnostics.EventLog> には、登録されているが閉じられ、すべてのイベント ハンドルを解放します。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成します。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするためにコンピューターを再起動する必要があります。  
  
   
  
## 例  
 次の例では、ソース `MySource` ことが既に存在しないと、イベント ログにエントリを書き込むかどうか `MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.Source Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <summary>ローカル コンピューターにイベント ソースが登録されているかどうかを確認します。</summary>
        <returns>イベント ソースがローカル コンピューターに登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用すると、イベント ソースがローカル コンピューター上に存在するかどうかを確認します。 使用して、ローカル コンピューター上にログが存在するかどうかを決定するかどうかは <xref:System.Diagnostics.EventLog.Exists%2A>です。  
  
 このメソッドがレジストリにアクセスするため、ローカル コンピューターに適切なレジストリ権限がある必要があります。それ以外の場合、 <xref:System.Security.SecurityException> がスローされます。  
  
> [!NOTE]
>  Windows Vista 以降のイベント ソースまたは Windows Server 2003 を検索するには、管理者特権が必要です。  
>   
>  この要件の理由では、セキュリティを含むすべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降では、ユーザー権限がない、セキュリティ ログにアクセスするにはしたがって、 <xref:System.Security.SecurityException> がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 \(UAC\) は、ユーザーの権限を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 パフォーマンス カウンターにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
> [!NOTE]
>  下で実行するサービス、 <xref:System.ServiceProcess.ServiceAccount.LocalSystem> アカウントには、このメソッドの実行に必要な権限はありません。 解決にイベント ソースが存在するかどうか確認するには、 <xref:System.ServiceProcess.ServiceInstaller>, 、それが存在しない場合、インストーラーのソースを作成するとします。  
  
 新しいソースには、同じコンピューター上の既存のソースの名前を付けることはできません、ので、試行する前にこのメソッドを使用して、呼び出す <xref:System.Diagnostics.EventLog.CreateEventSource%2A> で指定された名前のソースを確実に `source` 、ローカル コンピューターに既に存在しません。`source` パラメーターは、大文字小文字を区別することはありません。  
  
   
  
## 例  
 次の例では、ソース `MySource` ことが既に存在しないと、イベント ログにエントリを書き込むかどうか `MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.Source Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> 見つかりませんでしたが、一部またはすべてのイベント ログを検索できませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <param name="machineName">検索対象のコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターにイベント ソースが登録されているかどうかを確認します。</summary>
        <returns>指定したコンピューターにイベント ソースが登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定されたコンピューターでイベント ソースが存在するかどうかを確認するには、このメソッドを使用して、 `machineName` パラメーター。 使用して、指定したコンピューター上にログが存在するかどうかを決定するかどうかは <xref:System.Diagnostics.EventLog.Exists%2A>です。  
  
 このメソッドがレジストリにアクセスするため、特定のサーバーに適切なレジストリ権限がある必要があります。それ以外の場合、 <xref:System.Security.SecurityException> がスローされます。  
  
> [!NOTE]
>  Windows Vista 以降のイベント ソースまたは Windows Server 2003 を検索するには、管理者特権が必要です。  
>   
>  この要件の理由では、セキュリティを含むすべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降では、ユーザー権限がない、セキュリティ ログにアクセスするにはしたがって、 <xref:System.Security.SecurityException> がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 \(UAC\) は、ユーザーの権限を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 パフォーマンス カウンターにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
> [!NOTE]
>  下で実行するサービス、 <xref:System.ServiceProcess.ServiceAccount.LocalSystem> アカウントには、このメソッドの実行に必要な権限はありません。 解決にイベント ソースが存在するかどうか確認するには、 <xref:System.ServiceProcess.ServiceInstaller>, 、それが存在しない場合、インストーラーのソースを作成するとします。  
  
 新しいソースには、同じコンピューター上の既存のソースの名前を付けることはできません、ので、試行する前にこのメソッドを使用して、呼び出す <xref:System.Diagnostics.EventLog.CreateEventSource%2A> で指定された名前のソースを確実に `source` コンピューターに既に存在しません。`source` と `machineName` パラメーターは大文字小文字が区別されません。  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> `static` メソッド、クラス自体を呼び出すことができます。 インスタンスを作成する必要はありません <xref:System.Diagnostics.EventLog> を呼び出す <xref:System.Diagnostics.EventLog.SourceExists%2A>します。  
  
   
  
## 例  
 次の例では、ソース `MySource` コンピューターで `MyServer`, 、イベント ログにエントリを書き込むと `MyNewLog`です。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 無効なコンピューター名です。</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> 見つかりませんでしたが、一部またはすべてのイベント ログを検索できませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> エントリ書き込みイベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</summary>
        <value>イベント ログの <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用する <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> は `null`, 、処理の方法、 <xref:System.Diagnostics.EventLog.EntryWritten> イベントがシステム スレッド プールのスレッドで呼び出されます。 システム スレッド プールの詳細については、次を参照してください。 <xref:System.Threading.ThreadPool>します。  
  
 ときに、 <xref:System.Diagnostics.EventLog.EntryWritten> イベントはビジュアルの Windows フォーム コンポーネントにアクセスするシステム スレッド プールを介した、ボタンなどのコンポーネントが機能しないか、例外が発生する可能性があります。 この問題を回避するには <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Windows フォームのコンポーネントでは、それが原因の処理方法、 <xref:System.Diagnostics.EventLog.EntryWritten> コンポーネントが作成された同じスレッドで呼び出されるイベントをします。  
  
 場合、 <xref:System.Diagnostics.EventLog> 内で使用される [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Windows フォーム デザイナーで <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> を含むコントロールに自動的に設定されている、 <xref:System.Diagnostics.EventLog>です。 配置する場合など、 <xref:System.Diagnostics.EventLog> Form1 のデザイナー上 \(から継承される <xref:System.Windows.Forms.Form>\)、 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> の <xref:System.Diagnostics.EventLog> Form1 のインスタンスに設定されています。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <summary>種類が Information のエントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、これに関連付けられているイベント ログが information のエントリを書き込む <xref:System.Diagnostics.EventLog> インスタンス。 その他の指定する場合 <xref:System.Diagnostics.EventLogEntryType>, の別のオーバー ロードを使用して <xref:System.Diagnostics.EventLog.WriteEntry%2A>します。  
  
> [!NOTE]
>  `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
 設定する必要があります、 <xref:System.Diagnostics.EventLog.Source%2A> プロパティを <xref:System.Diagnostics.EventLog> コンポーネントがログにエントリを記述する前にします。 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ソースが指定されている場合、 <xref:System.Diagnostics.EventLog.Source%2A> このプロパティ <xref:System.Diagnostics.EventLog> インスタンスが、コンポーネントは、書き込みに使用されるコンピューターに登録されていない <xref:System.Diagnostics.EventLog.WriteEntry%2A> 呼び出し <xref:System.Diagnostics.EventLog.CreateEventSource%2A> され、ソースを登録します。  
  
> [!NOTE]
>  指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A> の <xref:System.Diagnostics.EventLog> インスタンスを呼び出す前に <xref:System.Diagnostics.EventLog.CreateEventSource%2A> または <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 、ローカル コンピューター \("です"\)。 見なされます。  
  
 システムを登録する必要がある場合、 <xref:System.Diagnostics.EventLog.Source%2A> を呼び出すことによって <xref:System.Diagnostics.EventLog.WriteEntry%2A> と <xref:System.Diagnostics.EventLog.Log%2A> にプロパティが設定されていない、 <xref:System.Diagnostics.EventLog> インスタンス、アプリケーション ログに、ログの既定値です。  
  
> [!NOTE]
>  登録処理中に発生したエラーによって生成される多くの上に示した例外、 <xref:System.Diagnostics.EventLog.Source%2A>です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、イベント ログを直接指定した文字列を書き込む場合、ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> にローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合メッセージ \(文字列\) の値があります、リモート コンピューターに .NET Framework が実行されていない場合に期待ではないです。  
  
> [!NOTE]
>  場合、 `message` パラメーターには、NUL 文字が含まれ、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## 例  
 次の例では、ソース `MySource` ことが既に存在しないと、イベント ログにエントリを書き込むかどうか `MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> のプロパティ、 <see cref="T:System.Diagnostics.EventLog" /> が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースがコンピューター名を登録しようとしています。 <see cref="P:System.Diagnostics.EventLog.MachineName" /> が無効です。  
  
 または  
  
 別のイベント ログのソースが既に登録されています。  
  
 または  
  
 メッセージ文字列は、31,839 バイト \(Windows Vista より前に、の Windows オペレーティング システムで 32,766 バイト\) を超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <summary>エラー、警告、情報、監査正常終了、または監査エラー エントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、指定したエントリを書き込む <xref:System.Diagnostics.EventLogEntryType> イベント ログにします。`type` アイコンとログのイベント ビューアーで型の列内のテキストで示されます。  
  
> [!NOTE]
>  `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
 設定する必要があります、 <xref:System.Diagnostics.EventLog.Source%2A> プロパティを <xref:System.Diagnostics.EventLog> コンポーネントがログにエントリを記述する前にします。 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ソースが指定されている場合、 <xref:System.Diagnostics.EventLog.Source%2A> このプロパティ <xref:System.Diagnostics.EventLog> インスタンスが、コンポーネントは、書き込みに使用されるコンピューターに登録されていない <xref:System.Diagnostics.EventLog.WriteEntry%2A> 呼び出し <xref:System.Diagnostics.EventLog.CreateEventSource%2A> され、ソースを登録します。  
  
> [!NOTE]
>  指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A> の <xref:System.Diagnostics.EventLog> インスタンスを呼び出す前に <xref:System.Diagnostics.EventLog.CreateEventSource%2A> または <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 、ローカル コンピューター \("です"\)。 見なされます。  
  
 システムを登録する必要がある場合、 <xref:System.Diagnostics.EventLog.Source%2A> を呼び出すことによって <xref:System.Diagnostics.EventLog.WriteEntry%2A> と <xref:System.Diagnostics.EventLog.Log%2A> にプロパティが設定されていない、 <xref:System.Diagnostics.EventLog> インスタンス、アプリケーション ログに、ログの既定値です。  
  
> [!NOTE]
>  上に示した多くの例外は、登録処理中に発生したエラーによって生成される、 <xref:System.Diagnostics.EventLog.Source%2A>です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、イベント ログを直接指定した文字列を書き込む場合、ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> にローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合メッセージ \(文字列\) の値があります、リモート コンピューターに .NET Framework が実行されていない場合に期待ではないです。  
  
> [!NOTE]
>  場合、 `message` パラメーターには、NUL 文字が含まれ、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## 例  
 次の例では、ローカル コンピューターの"MyNewLog"イベント ログに警告エントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> のプロパティ、 <see cref="T:System.Diagnostics.EventLog" /> が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースがコンピューター名を登録しようとしています。 <see cref="P:System.Diagnostics.EventLog.MachineName" /> が無効です。  
  
 または  
  
 別のイベント ログのソースが既に登録されています。  
  
 または  
  
 メッセージ文字列は、31,839 バイト \(Windows Vista より前に、の Windows オペレーティング システムで 32,766 バイト\) を超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <summary>指定した登録イベント ソースを使用して、種類が Information のエントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用すると、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログが information のエントリを記述できます。 その他の指定する場合 <xref:System.Diagnostics.EventLogEntryType>, の別のオーバー ロードを使用して <xref:System.Diagnostics.EventLog.WriteEntry%2A>します。  
  
 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、イベント ログを直接指定した文字列を書き込む場合、ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> にローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、 `message` パラメーターには、NUL 文字が含まれ、イベント ログにメッセージが NUL 文字で終了します。  
>   
>  `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
   
  
## 例  
 次の例では、ソース `MySource` ことが既に存在しないと、イベント ログにエントリを書き込むかどうか `MyNewLog`します。  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値は空の文字列 \(""\) です。  
  
 または  
  
 <paramref name="source" /> 値は <see langword="null" />です。  
  
 または  
  
 メッセージ文字列は、31,839 バイト \(Windows Vista より前に、の Windows オペレーティング システムで 32,766 バイト\) を超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <summary>エントリを、指定したメッセージ テキストおよびアプリケーション定義のイベント識別子と共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、アプリケーション定義を持つエントリを書き込む `eventID` イベント ログにします。`eventID` ソースと共に、イベントを一意に識別します。 各アプリケーションには、番号付きのイベントおよびそれらに対応する説明の文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
> [!NOTE]
>  `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
 他のイベント識別子を指定できます、 <xref:System.Diagnostics.EventLogEntryType> イベント ログに書き込まれるイベントです。`type` アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 設定する必要があります、 <xref:System.Diagnostics.EventLog.Source%2A> プロパティを <xref:System.Diagnostics.EventLog> コンポーネントがログにエントリを記述する前にします。 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ソースが指定されている場合、 <xref:System.Diagnostics.EventLog.Source%2A> このプロパティ <xref:System.Diagnostics.EventLog> インスタンスが、コンポーネントは、書き込みに使用されるコンピューターに登録されていない <xref:System.Diagnostics.EventLog.WriteEntry%2A> 呼び出し <xref:System.Diagnostics.EventLog.CreateEventSource%2A> され、ソースを登録します。  
  
> [!NOTE]
>  指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A> の <xref:System.Diagnostics.EventLog> インスタンスを呼び出す前に <xref:System.Diagnostics.EventLog.CreateEventSource%2A> または <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 、ローカル コンピューター \("です"\)。 見なされます。  
  
 システムを登録する必要がある場合、 <xref:System.Diagnostics.EventLog.Source%2A> を呼び出すことによって <xref:System.Diagnostics.EventLog.WriteEntry%2A> と <xref:System.Diagnostics.EventLog.Log%2A> にプロパティが設定されていない、 <xref:System.Diagnostics.EventLog> インスタンス、アプリケーション ログに、ログの既定値です。  
  
> [!NOTE]
>  上に示した多くの例外は、登録処理中に発生したエラーによって生成される、 <xref:System.Diagnostics.EventLog.Source%2A>です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、イベント ログを直接指定した文字列を書き込む場合、ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> にローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合メッセージ \(文字列\) の値があります、リモート コンピューターに .NET Framework が実行されていない場合に期待ではないです。  
  
> [!NOTE]
>  場合、 `message` パラメーターには、NUL 文字が含まれ、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## 例  
 [!code-cpp[EventLog\_WriteEntry\_1\_3\#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog\_WriteEntry\_1\_3\#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog\_WriteEntry\_1\_3\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> のプロパティ、 <see cref="T:System.Diagnostics.EventLog" /> が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースがコンピューター名を登録しようとしています。 <see cref="P:System.Diagnostics.EventLog.MachineName" /> が無効です。  
  
 または  
  
 別のイベント ログのソースが既に登録されています。  
  
 または  
  
 <paramref name="eventID" /> 0 より大きいか小さい <see cref="F:System.UInt16.MaxValue" />します。  
  
 または  
  
 メッセージ文字列は、31,839 バイト \(Windows Vista より前に、の Windows オペレーティング システムで 32,766 バイト\) を超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <summary>指定した登録イベント ソースを使用して、エラー、警告、情報、監査正常終了、または監査エラー エントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、指定したエントリを書き込む <xref:System.Diagnostics.EventLogEntryType> イベント ログにソースを既に使用して、適切なログのイベントのソースとして登録されています。`type` アイコンとログのイベント ビューアーで型の列内のテキストで示されます。  
  
> [!NOTE]
>  `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、イベント ログを直接指定した文字列を書き込む場合、ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> にローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、 `message` パラメーターには、NUL 文字が含まれ、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## 例  
 次の例では、ローカル コンピューターの"MyNewLog"イベント ログに警告エントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値は空の文字列 \(""\) です。  
  
 または  
  
 <paramref name="source" /> 値は <see langword="null" />です。  
  
 または  
  
 メッセージ文字列は、31,839 バイト \(Windows Vista より前に、の Windows オペレーティング システムで 32,766 バイト\) を超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <summary>指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、アプリケーション定義を持つエントリを書き込む `category` イベント ログにします。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントをフィルター処理するカテゴリを使用します。 イベント ビューアーが値は数値として、カテゴリを表示したり、ローカライズされたカテゴリ文字列を表示するリソース識別子とカテゴリを使用してそのことができます。  
  
> [!NOTE]
>  `category` パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、65,526 と 65,535 – 1 – 10 が表示されます。  
  
> [!NOTE]
>  `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
 イベント ビューアーでローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、 `category` カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定された `category` イベント ビューアーは、そのエントリの数値カテゴリの値を表示し、カテゴリのリソース ファイル内の文字列のインデックスはされません。 リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルの構成を使用して、 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventSourceCreationData> クラスです。  
  
 カテゴリには、だけでなく、イベント ログに書き込まれるイベントのイベント識別子を指定できます。 イベント ソースと共に、イベント識別子は、イベントを一意に識別します。 各アプリケーションには、番号付きのイベントおよびそれらに対応する説明の文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定、 <xref:System.Diagnostics.EventLogEntryType> イベントがイベント ログに書き込まれているのです。`type` アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 設定する必要があります、 <xref:System.Diagnostics.EventLog.Source%2A> プロパティを <xref:System.Diagnostics.EventLog> コンポーネントがログにエントリを記述する前にします。 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ソースが指定されている場合、 <xref:System.Diagnostics.EventLog.Source%2A> このプロパティ <xref:System.Diagnostics.EventLog> インスタンスが、コンポーネントは、書き込みに使用されるコンピューターに登録されていない <xref:System.Diagnostics.EventLog.WriteEntry%2A> 呼び出し <xref:System.Diagnostics.EventLog.CreateEventSource%2A> され、ソースを登録します。  
  
> [!NOTE]
>  指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A> の <xref:System.Diagnostics.EventLog> インスタンスを呼び出す前に <xref:System.Diagnostics.EventLog.CreateEventSource%2A> または <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 、ローカル コンピューター \("です"\)。 見なされます。  
  
 システムを登録する必要がある場合、 <xref:System.Diagnostics.EventLog.Source%2A> を呼び出すことによって <xref:System.Diagnostics.EventLog.WriteEntry%2A> と <xref:System.Diagnostics.EventLog.Log%2A> にプロパティが設定されていない、 <xref:System.Diagnostics.EventLog> インスタンス、アプリケーション ログに、ログの既定値です。  
  
> [!NOTE]
>  上に示した多くの例外は、登録処理中に発生したエラーによって生成される、 <xref:System.Diagnostics.EventLog.Source%2A>です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、イベント ログを直接指定した文字列を書き込む場合、ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> にローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合メッセージ \(文字列\) の値があります、リモート コンピューターに .NET Framework が実行されていない場合に期待ではないです。  
  
> [!NOTE]
>  場合、 `message` パラメーターには、NUL 文字が含まれ、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## 例  
 [!code-cpp[EventLog\_WriteEntry\_1\_3\#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog\_WriteEntry\_1\_3\#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog\_WriteEntry\_1\_3\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> のプロパティ、 <see cref="T:System.Diagnostics.EventLog" /> が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースがコンピューター名を登録しようとしています。 <see cref="P:System.Diagnostics.EventLog.MachineName" /> が無効です。  
  
 または  
  
 別のイベント ログのソースが既に登録されています。  
  
 または  
  
 <paramref name="eventID" /> 0 より大きいか小さい <see cref="F:System.UInt16.MaxValue" />します。  
  
 または  
  
 メッセージ文字列は、31,839 バイト \(Windows Vista より前に、の Windows オペレーティング システムで 32,766 バイト\) を超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <summary>指定した登録イベント ソースを使用して、指定したメッセージ テキストおよびアプリケーション定義のイベント識別子と共にエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、アプリケーション定義を持つエントリを書き込む `eventID` イベント ログにソースを既に使用して、適切なログのイベントのソースとして登録されています。`eventID`, 、ソースとイベントを一意に識別します。 各アプリケーションには、番号付きのイベントおよびそれらに対応する説明の文字列を定義できます。 イベント ビューアーでは、これらの文字列をユーザーの問題点を理解し、実行するアクションを提案するためにユーザーに表示します。  
  
> [!NOTE]
>  `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
 このオーバー ロードのイベント識別子だけでなく <xref:System.Diagnostics.EventLog.WriteEntry%2A> を指定することができます、 <xref:System.Diagnostics.EventLogEntryType> イベントがイベント ログに書き込まれているのです。`type` アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、イベント ログを直接指定した文字列を書き込む場合、ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> にローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、 `message` パラメーターには、NUL 文字が含まれ、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## 例  
 [!code-cpp[EventLog\_WriteEntry\_4\#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog\_WriteEntry\_4\#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog\_WriteEntry\_4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値は空の文字列 \(""\) です。  
  
 または  
  
 <paramref name="source" /> 値は <see langword="null" />です。  
  
 または  
  
 <paramref name="eventID" /> 0 より大きいか小さい <see cref="F:System.UInt16.MaxValue" />します。  
  
 または  
  
 メッセージ文字列は、31,839 バイト \(Windows Vista より前に、の Windows オペレーティング システムで 32,766 バイト\) を超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <param name="rawData">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <summary>指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込み、メッセージにバイナリ データを付加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用すると、イベント ログにイベント固有のデータをアプリケーション定義を記述できます。 イベント ビューアーがこのデータを解釈しています。結合の 16 進数およびテキスト形式でのみ、生データを表示します。 だれかが問題のデバッグに役に立つことを確認する場合にだけ、ほんのイベントに固有のデータを使用します。 また、アプリケーションは、イベント ビューアーとは無関係に処理できる情報を格納するのにイベントに固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述したり、ログ ファイルをスキャンし、イベントに固有のデータから情報を含むレポートを作成するプログラムを記述できます。  
  
 バイナリ データだけでなく、アプリケーション定義のカテゴリおよびアプリケーション定義のイベント識別子を指定できます。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントをフィルター処理するカテゴリを使用します。 イベント ビューアーが値は数値として、カテゴリを表示したり、ローカライズされたカテゴリ文字列を表示するリソース識別子とカテゴリを使用してそのことができます。  
  
> [!NOTE]
>  `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
> [!NOTE]
>  `category` パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、65,526 と 65,535 – 1 – 10 が表示されます。  
  
 イベント ビューアーでローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、 `category` カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定された `category` イベント ビューアーは、そのエントリの数値カテゴリの値を表示し、カテゴリのリソース ファイル内の文字列のインデックスはされません。 リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルの構成を使用して、 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventSourceCreationData> クラスです。  
  
 イベント ソースと共に、イベント識別子は、イベントを一意に識別します。 各アプリケーションには、番号付きのイベントおよびそれらに対応する説明の文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定、 <xref:System.Diagnostics.EventLogEntryType> イベントがイベント ログに書き込まれているのです。`type` アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 設定する必要があります、 <xref:System.Diagnostics.EventLog.Source%2A> プロパティを <xref:System.Diagnostics.EventLog> コンポーネントがログにエントリを記述する前にします。 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ソースが指定されている場合、 <xref:System.Diagnostics.EventLog.Source%2A> このプロパティ <xref:System.Diagnostics.EventLog> インスタンスが、コンポーネントは、書き込みに使用されるコンピューターに登録されていない <xref:System.Diagnostics.EventLog.WriteEntry%2A> 呼び出し <xref:System.Diagnostics.EventLog.CreateEventSource%2A> され、ソースを登録します。  
  
> [!NOTE]
>  指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A> の <xref:System.Diagnostics.EventLog> インスタンスを呼び出す前に <xref:System.Diagnostics.EventLog.CreateEventSource%2A> または <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 、ローカル コンピューター \("です"\)。 見なされます。  
  
 システムを登録する必要がある場合、 <xref:System.Diagnostics.EventLog.Source%2A> を呼び出すことによって <xref:System.Diagnostics.EventLog.WriteEntry%2A> と <xref:System.Diagnostics.EventLog.Log%2A> にプロパティが設定されていない、 <xref:System.Diagnostics.EventLog> インスタンス、アプリケーション ログに、ログの既定値です。  
  
> [!NOTE]
>  上に示した多くの例外は登録処理中に発生したエラーによって生成される、 <xref:System.Diagnostics.EventLog.Source%2A>です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、イベント ログを直接指定した文字列を書き込む場合、ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> にローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合メッセージ \(文字列\) の値があります、リモート コンピューターに .NET Framework が実行されていない場合に期待ではないです。  
  
> [!NOTE]
>  場合、 `message` パラメーターには、NUL 文字が含まれ、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## 例  
 [!code-cpp[EventLog\_WriteEntry\_5\#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog\_WriteEntry\_5\#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog\_WriteEntry\_5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> のプロパティ、 <see cref="T:System.Diagnostics.EventLog" /> が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースがコンピューター名を登録しようとしています。 <see cref="P:System.Diagnostics.EventLog.MachineName" /> が無効です。  
  
 または  
  
 別のイベント ログのソースが既に登録されています。  
  
 または  
  
 <paramref name="eventID" /> 0 より大きいか小さい <see cref="F:System.UInt16.MaxValue" />します。  
  
 または  
  
 メッセージ文字列は、31,839 バイト \(Windows Vista より前に、の Windows オペレーティング システムで 32,766 バイト\) を超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか 1 つ。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <summary>指定した登録イベント ソースを使用して、メッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込みます。<paramref name="category" /> は、イベント ビューアーでログ内のイベントをフィルター処理するときに使用できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、アプリケーション定義を持つエントリを書き込む `category` イベント ログに適切なログのイベント ソースとして既に登録されているソースを使用します。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントをフィルター処理するカテゴリを使用します。 イベント ビューアーが値は数値として、カテゴリを表示したり、ローカライズされたカテゴリ文字列を表示するリソース識別子とカテゴリを使用してそのことができます。  
  
> [!NOTE]
>  `category` パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、65,526 と 65,535 – 1 – 10 が表示されます。  
  
 イベント ビューアーでローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、 `category` カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定された `category` イベント ビューアーは、そのエントリの数値カテゴリの値を表示し、カテゴリのリソース ファイル内の文字列のインデックスはされません。 リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルの構成を使用して、 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventSourceCreationData> クラスです。  
  
 カテゴリには、だけでなく、イベント ログに書き込まれるイベントのイベント識別子を指定できます。 イベント ソースと共に、イベント識別子は、イベントを一意に識別します。 各アプリケーションには、番号付きのイベントおよびそれらに対応する説明の文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定、 <xref:System.Diagnostics.EventLogEntryType> イベントがイベント ログに書き込まれているのです。`type` アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、イベント ログを直接指定した文字列を書き込む場合、ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> にローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、 `message` パラメーターには、NUL 文字が含まれ、イベント ログにメッセージが NUL 文字で終了します。  
>   
>  `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
   
  
## 例  
 [!code-cpp[EventLog\_WriteEntry\_1\_3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog\_WriteEntry\_1\_3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog\_WriteEntry\_1\_3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値は空の文字列 \(""\) です。  
  
 または  
  
 <paramref name="source" /> 値は <see langword="null" />です。  
  
 または  
  
 <paramref name="eventID" /> 0 より大きいか小さい <see cref="F:System.UInt16.MaxValue" />します。  
  
 または  
  
 メッセージ文字列は、31,839 バイト \(Windows Vista より前に、の Windows オペレーティング システムで 32,766 バイト\) を超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <param name="rawData">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込み、メッセージにバイナリ データを付加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用すると、アプリケーションで定義されたイベントに固有のデータを適切なログのイベントのソースとして既に登録されているソースを使用して、イベント ログに記述できます。 イベント ビューアーがこのデータを解釈しています。結合の 16 進数およびテキスト形式でのみ、生データを表示します。 イベントに固有のデータを多用します。役に立つことを確認している場合にのみ含めます。 また、アプリケーションは、イベント ビューアーとは無関係に処理できる情報を格納するのにイベントに固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述したり、ログ ファイルをスキャンし、イベントに固有のデータから情報を含むレポートを作成するプログラムを記述できます。  
  
 バイナリ データだけでなく、アプリケーション定義のカテゴリおよびアプリケーション定義のイベント識別子を指定できます。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントをフィルター処理するカテゴリを使用します。 イベント ビューアーが値は数値として、カテゴリを表示したり、ローカライズされたカテゴリ文字列を表示するリソース識別子とカテゴリを使用してそのことができます。  
  
> [!NOTE]
>  `category` パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、– 10 は、65,526 と 65,535 – 1 として表示されます。  
  
 イベント ビューアーでローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、 `category` カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定された `category` イベント ビューアーは、そのエントリの数値カテゴリの値を表示し、カテゴリのリソース ファイル内の文字列のインデックスはされません。 リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルの構成を使用して、 <xref:System.Diagnostics.EventLogInstaller> または <xref:System.Diagnostics.EventSourceCreationData> クラスです。  
  
 イベント ソースと共に、イベント識別子は、イベントを一意に識別します。 各アプリケーションには、番号付きのイベントおよびそれらに対応する説明の文字列を定義できます。 イベント ビューアーでは、ユーザーの問題点を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定、 <xref:System.Diagnostics.EventLogEntryType> イベントがイベント ログに書き込まれているのです。`type` アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドは、イベント ログを直接指定した文字列を書き込む場合、ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> にローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、 `message` パラメーターには、NUL 文字が含まれ、イベント ログにメッセージが NUL 文字で終了します。  
>   
>  `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
   
  
## 例  
 [!code-cpp[EventLog\_WriteEntry\_1\_3\#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog\_WriteEntry\_1\_3\#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog\_WriteEntry\_1\_3\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値は空の文字列 \(""\) です。  
  
 または  
  
 <paramref name="source" /> 値は <see langword="null" />です。  
  
 または  
  
 <paramref name="eventID" /> 0 より大きいか小さい <see cref="F:System.UInt16.MaxValue" />します。  
  
 または  
  
 メッセージ文字列は、31,839 バイト \(Windows Vista より前に、の Windows オペレーティング システムで 32,766 バイト\) を超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>ローカライズされたエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用すると、イベント ログにローカライズされたエントリを記述できます。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソース識別子を使用して、表示用のローカライズされたリソース ファイルから対応する文字列、 <xref:System.Diagnostics.EventLog.Source%2A>です。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力 `instance` インスタンスは、イベント メッセージとプロパティを指定します。 設定、 <xref:System.Diagnostics.EventInstance.InstanceId%2A> の `instance` メッセージ リソース ファイルのソースで定義されたメッセージを入力します。 設定すると、 <xref:System.Diagnostics.EventInstance.CategoryId%2A> と <xref:System.Diagnostics.EventInstance.EntryType%2A> の `instance` イベント エントリのカテゴリとイベントの種類を定義する入力。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定 `values` に `null` イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 設定する必要があります、 <xref:System.Diagnostics.EventLog.Source%2A> プロパティを <xref:System.Diagnostics.EventLog> コンポーネントを使用する前に <xref:System.Diagnostics.EventLog.WriteEvent%2A>します。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドの場合は、アプリケーションは、イベント ログに直接文字列の値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモートのコンピューターの値にエントリを書き込むかどうか、 `message` となる場合がないリモート コンピューターに .NET Framework が実行されていない場合に期待します。 また、 `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
   
  
## 例  
 次の例は、2 つの監査イベント ログにエントリを書き込みます `myNewLog`します。 ローカル コンピューターに存在しない場合は、例では、新しいイベント ソースおよび新しいイベント ログを作成します。 イベントのメッセージ テキストは、リソース ファイル内のリソース識別子を使用して指定します。  
  
 [!code-cpp[EventLog\_WriteEvent\#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog\_WriteEvent\#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog\_WriteEvent\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージは、パラメーターの挿入文字列のテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> のプロパティ、 <see cref="T:System.Diagnostics.EventLog" /> が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースがコンピューター名を登録しようとしています。 <see cref="P:System.Diagnostics.EventLog.MachineName" /> が無効です。  
  
 または  
  
 別のイベント ログのソースが既に登録されています。  
  
 または  
  
 <paramref name="instance.InstanceId" /> 0 より大きいか小さい <see cref="F:System.UInt16.MaxValue" />します。  
  
 または  
  
 <paramref name="values" /> 256 個以上の要素があります。  
  
 または  
  
 いずれか、 <paramref name="values" /> 要素は 32766 バイトを超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="data">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定したイベント データ、メッセージ置換文字列、および関連するバイナリ データと共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用すると、イベント ログに追加のイベントに固有のデータのローカライズされたエントリを記述できます。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソース識別子を使用して、表示用のローカライズされたリソース ファイルから対応する文字列、 [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog.Source%2A>です。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力 `instance` インスタンスは、イベント メッセージとプロパティを指定します。 設定、 [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventInstance.InstanceId%2A> の `instance` メッセージ リソース ファイルのソースで定義されたメッセージを入力します。 設定すると、 [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventInstance.CategoryId%2A> と [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventInstance.EntryType%2A> の `instance` イベント エントリのカテゴリとイベントの種類を定義する入力。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定 `values` に `null` イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 イベントの詳しい情報を提供する必要があるときにイベントをバイナリ データを指定します。 たとえば、使用して、 `data` パラメーターは、特定のエラーに関する情報を含めます。 イベント ビューアーは、関連付けられたイベント データを解釈しています。16 進数およびテキストを組み合わせた形式でデータを表示します。 イベントに固有のデータを多用します。役に立つことを確認している場合にのみ含めます。 また、アプリケーションは、イベント ビューアーとは無関係に処理できる情報を格納するのにイベントに固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述したり、イベント ログをスキャンし、イベントに固有のデータから情報を含むレポートを作成するプログラムを記述できます。  
  
 設定する必要があります、 [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog.Source%2A> プロパティを [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog> コンポーネントを使用する前にコンポーネントの前に [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog.WriteEvent%2A>します。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
> [!NOTE]
>  指定しない場合、 [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog.MachineName%2A> の [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog> インスタンスを呼び出す前に [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog.WriteEvent%2A>, 、ローカル コンピューター \("です"\)。 見なされます。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 使用して、 [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドの場合は、アプリケーションは、イベント ログに直接文字列の値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 [WriteEvent メソッド \(EventInstance, Byte\<xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモートのコンピューターの値にエントリを書き込むかどうか、 `message` となる場合がないリモート コンピューターに .NET Framework が実行されていない場合に期待します。 また、 `message` % を含めることはできません*n*, ここで、 *n* 整数値 \(たとえば、%1\) は、イベント ビューアーは挿入文字列として処理するためです。 文字シーケンスのインターネット プロトコル バージョン 6 \(IPv6\) アドレスは、これを含めることができますので、IPv6 アドレスを含むイベント メッセージをログオンできません。  
  
   
  
## 例  
 次の例は、2 つの監査イベント ログにエントリを書き込みます `myNewLog`します。 ローカル コンピューターに存在しない場合は、例では、新しいイベント ソースおよび新しいイベント ログを作成します。 イベントのメッセージ テキストは、リソース ファイル内のリソース識別子を使用して指定します。  
  
 [!code-cpp[EventLog\_WriteEvent\#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog\_WriteEvent\#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog\_WriteEvent\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージは、パラメーターの挿入文字列のテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> のプロパティ、 <see cref="T:System.Diagnostics.EventLog" /> が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースがコンピューター名を登録しようとしています。 <see cref="P:System.Diagnostics.EventLog.MachineName" /> が無効です。  
  
 または  
  
 別のイベント ログのソースが既に登録されています。  
  
 または  
  
 <paramref name="instance.InstanceId" /> 0 より大きいか小さい <see cref="F:System.UInt16.MaxValue" />します。  
  
 または  
  
 <paramref name="values" /> 256 個以上の要素があります。  
  
 または  
  
 いずれか、 <paramref name="values" /> 要素は 32766 バイトを超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">指定したコンピューター上のアプリケーションに登録されるイベント ソースの名前。</param>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したイベント データとメッセージ置換文字列と共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用すると、ローカライズされたエントリを適切なログのイベントのソースとして既に登録されているソースを使用して、イベント ログに記述できます。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソース識別子を使用して、ソースのローカライズされたリソース ファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力 `instance` インスタンスは、イベント メッセージとプロパティを指定します。 設定、 <xref:System.Diagnostics.EventInstance.InstanceId%2A> の `instance` メッセージ リソース ファイルのソースで定義されたメッセージを入力します。 設定すると、 <xref:System.Diagnostics.EventInstance.CategoryId%2A> と <xref:System.Diagnostics.EventInstance.EntryType%2A> の `instance` イベント エントリのカテゴリとイベントの種類を定義する入力。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定 `values` に `null` イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 使用する前に、イベント ログの指定したソースを登録する必要があります <xref:System.Diagnostics.EventLog.WriteEvent%2A>します。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 <xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドの場合は、アプリケーションは、イベント ログに直接文字列の値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 <xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
   
  
## 例  
 次の例では、既存のイベント ログに情報イベント エントリおよび警告イベントのエントリを書き込みます。 イベントのメッセージ テキストは、リソース ファイル内のリソース識別子を使用して指定します。 この例では、ソースの対応するリソース ファイルが登録されています。  
  
 [!code-cpp[EventLog\_WriteEvent\#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog\_WriteEvent\#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog\_WriteEvent\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージは、パラメーターの挿入文字列のテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値は空の文字列 \(""\) です。  
  
 または  
  
 <paramref name="source" /> 値は <see langword="null" />です。  
  
 または  
  
 <paramref name="instance.InstanceId" /> 0 より大きいか小さい <see cref="F:System.UInt16.MaxValue" />します。  
  
 または  
  
 <paramref name="values" /> 256 個以上の要素があります。  
  
 または  
  
 いずれか、 <paramref name="values" /> 要素は 32766 バイトを超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">指定したコンピューター上のアプリケーションに登録されるイベント ソースの名前。</param>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="data">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したイベント データ、メッセージ置換文字列、および関連するバイナリ データと共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用すると、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログに追加のイベントに固有のデータのローカライズされたエントリを記述できます。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソース識別子を使用して、ソースのローカライズされたリソース ファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力 `instance` インスタンスは、イベント メッセージとプロパティを指定します。 設定、 [WriteEvent メソッド \(String, EventInstance, Byte\<xref:System.Diagnostics.EventInstance.InstanceId%2A> の `instance` メッセージ リソース ファイルのソースで定義されたメッセージを入力します。 設定すると、 [WriteEvent メソッド \(String, EventInstance, Byte\<xref:System.Diagnostics.EventInstance.CategoryId%2A> と [WriteEvent メソッド \(String, EventInstance, Byte\<xref:System.Diagnostics.EventInstance.EntryType%2A> の `instance` イベント エントリのカテゴリとイベントの種類を定義する入力。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定 `values` に `null` イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 イベントの詳しい情報を提供する必要があるときにイベントをバイナリ データを指定します。 たとえば、使用して、 `data` パラメーターは、特定のエラーに関する情報を含めます。 イベント ビューアーは、関連付けられたイベント データを解釈しています。16 進数およびテキストを組み合わせた形式でデータを表示します。 イベントに固有のデータを多用します。役に立つことを確認している場合にのみ含めます。 また、アプリケーションは、イベント ビューアーとは無関係に処理できる情報を格納するのにイベントに固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述したり、イベント ログをスキャンし、イベントに固有のデータから情報を含むレポートを作成するプログラムを記述できます。  
  
 使用する前に、イベント ログの指定したソースを登録する必要があります [WriteEvent メソッド \(String, EventInstance, Byte\<xref:System.Diagnostics.EventLog.WriteEvent%2A>します。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成および、ソースとの最初のエントリを書き込む前にイベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新するいないと書き込もうとした新しいソースを持つイベントの書き込み操作は失敗します。 使用して新しいソースを構成することができます、 [WriteEvent メソッド \(String, EventInstance, Byte\<xref:System.Diagnostics.EventLogInstaller>, 、またはを使用して、 [WriteEvent メソッド \(String, EventInstance, Byte\<xref:System.Diagnostics.EventLog.CreateEventSource%2A> メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 使用して、 [WriteEvent メソッド \(String, EventInstance, Byte\<xref:System.Diagnostics.EventLog.WriteEntry%2A> メソッドの場合は、アプリケーションは、イベント ログに直接文字列の値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列の値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、 [WriteEvent メソッド \(String, EventInstance, Byte\<xref:System.Diagnostics.EventLog.WriteEvent%2A> リソース id、イベント ログを使用してエントリを書き込みます。 リソース ファイルがない場合、別のソースを作成しでそのソースを使用して、 [WriteEvent メソッド \(String, EventInstance, Byte\<xref:System.Diagnostics.EventLog.WriteEntry%2A> そのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
   
  
## 例  
 次の例では、既存のイベント ログに情報イベント エントリおよび警告イベントのエントリを書き込みます。 イベントのメッセージ テキストは、リソース ファイル内のリソース識別子を使用して指定します。 この例では、ソースの対応するリソース ファイルが登録されています。  
  
 [!code-cpp[EventLog\_WriteEvent\#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog\_WriteEvent\#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog\_WriteEvent\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージは、パラメーターの挿入文字列のテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 値は空の文字列 \(""\) です。  
  
 または  
  
 <paramref name="source" /> 値は <see langword="null" />です。  
  
 または  
  
 <paramref name="instance.InstanceId" /> 0 より大きいか小さい <see cref="F:System.UInt16.MaxValue" />します。  
  
 または  
  
 <paramref name="values" /> 256 個以上の要素があります。  
  
 または  
  
 いずれか、 <paramref name="values" /> 要素は 32766 バイトを超えています。  
  
 または  
  
 ソース名は 254 文字を超えるレジストリ キー パスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときにエラーが報告されます。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">for writing the event log information on the computer. Associated enumeration: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ローカライズされたイベント エントリをイベント ログに書き込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>イベント ログにエントリを書き込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コンピューターのレジストリ内で、指定したイベント ソースを検索します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>イベント ログからアプリケーションのイベント ソース登録を削除します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>イベント ログの配列を作成します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したログが存在するかどうかを確認します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>システム上の特定のログにイベント情報を書き込むことができるようにアプリケーションを設定します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ログ リソースを削除します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>