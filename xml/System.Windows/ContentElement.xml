<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>コンテンツ要素に WPF コア レベルの基底クラスを提供します。 コンテンツ要素は、直感的なマークアップ指向レイアウト モデルと、意図的に単純なオブジェクト モデルを使用し、フロー スタイル プレゼンテーション用に設計されています。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement> defines the following common content characteristics:  
  
-   Input: All <xref:System.Windows.ContentElement> derived classes provide support for basic input capture from keyboard, mouse, drag\-and\-drop operations, stylus controls, and accelerators.  
  
-   Focus: All <xref:System.Windows.ContentElement> derived classes are potentially focusable. \(However, the default focusable state for the <xref:System.Windows.ContentElement> base class is **languageKeyword tag is not supported!!!!**  
    . For details on how to make a <xref:System.Windows.ContentElement> focusable, see <xref:System.Windows.ContentElement.Focusable%2A>.\) In addition, this class contains [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that you can use for traversing the focus across related elements.  
  
-   Events: <xref:System.Windows.ContentElement> includes events that are related to input and focus; it also includes events for changes in state. In many cases, the <xref:System.Windows.ContentElement> events are routed events. In some cases, routed events have both tunneling and bubbling routing strategies, raised as separate events in response to the same state or condition. Also, <xref:System.Windows.ContentElement> defines [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] that can raise routed events and that can add or remove handlers to events.  
  
 <xref:System.Windows.ContentElement> shares many common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] with <xref:System.Windows.UIElement>. These common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] do not come from a shared class inheritance. But they do share common naming, similar behavior, and similar internal implementation of [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] in each class. The similarity is because <xref:System.Windows.ContentElement> and <xref:System.Windows.UIElement> are each classes that are an element base, although each has different intentions for its markup object model behavior.  
  
 In particular, <xref:System.Windows.UIElement> descends from <xref:System.Windows.Media.Visual>, which provides the lower\-level graphics support for rendering a <xref:System.Windows.ContentElement> to a rectangular region within a composited window, whereas <xref:System.Windows.ContentElement> defers rendering so that concepts more common to document scenarios, such as flow and wrapping, are more easily supported. These two related classes also implement the common interfaces <xref:System.Windows.IInputElement> and <xref:System.Windows.Media.Animation.IAnimatable>.  
  
   
  
## 例  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>The <see cref="T:System.Windows.ContentElement" /> class does not yet define all aspects of a complete content element for flow-style presentation. <see cref="T:System.Windows.FrameworkContentElement" /> is an immediately derived class of <see cref="T:System.Windows.ContentElement" />. <see cref="T:System.Windows.FrameworkContentElement" /> includes a more complete set of additional members that support rendering a <see cref="T:System.Windows.FrameworkContentElement" /> within a content host and using the WPF framework-level layout system.</para>
    </block>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.ContentElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">処理されるルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <summary>指定したルーティング イベントにルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 例外を発生させずは、同じイベントに対して同じハンドラーを複数回追加できます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装において考慮する必要があります副作用がある可能性がありますを検討してください。  
  
 通常の"add"アクセサーの実装を提供するこのメソッドを使用する、 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] カスタム ルーティング イベントのイベントのアクセス パターンです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドルするルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <param name="handledEventsToo">イベント データ内でルーティング イベントがハンドル済みとしてマークされている場合でも呼び出されるようにハンドラーを登録するには <see langword="true" />。ルーティング イベントが既にハンドル済みとしてマークされている場合はハンドラーを呼び出ないという既定の条件を使用してハンドラーを登録する場合は <see langword="false" />。  
  
 既定値は、<see langword="false" /> です。  
  
 ルーティング イベントの再処理を機械的に要求しないでください。 詳細については、「解説」を参照してください。</param>
        <summary>指定したルーティング イベントのためのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。 イベント ルート上の別の要素により既にハンドル済みとしてマークされているルーティング イベントに対し、指定したハンドラーが呼び出されるようにするには、<paramref name="handledEventsToo" /> を <see langword="true" /> に指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複雑な作業は、実用的な方法で低レベルの入力イベントを処理します。 多くのコントロールと、特定のイベントが処理され、マーク、他のより直観的なイベントで交換の動作を実装します。 一般に、そのための設計上の意図がある場合を処理済みとして、コントロールはプラットフォームの入力イベントをマークだけです。 特定のシナリオで、設計上の意図、特定の入力イベントの処理が必要とは限りません。 そのを登録するようなシナリオはハンドラー `handledEventsToo` として `true` が適切です。 日常的に行いますされません。 処理される場合でも、すべてのイベントに応答ハンドラーを呼び出すと、独自のアプリケーション イベント処理ロジックが複雑になります。 ハンドラーのロジックが大きな場合は、パフォーマンスの低下を参照してください可能性があります。 既にいくつかのコントロールは、アプリケーション ロジックで処理するイベントを処理は開発プロセス中に発見した場所の場合の処理済みのイベントのハンドラーのアタッチの使用を予約する必要があります。  
  
 クラスの処理を特定のイベントとコントロールの組み合わせの動作を回避するためのもう 1 つの方法では、そのイベントのプレビューを代わりに使用します。 たとえば場合、 <xref:System.Windows.ContentElement.MouseLeftButtonDown> 処理済みとしてマークは、クラスの処理によってこともできますのハンドラーを追加する <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> 代わりにします。  
  
 例外を発生させずは、同じイベントに対して同じハンドラーを複数回追加できます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装において考慮する必要があります副作用がある可能性がありますを検討してください。  
  
 通常の"add"アクセサーの実装を提供するこのメソッドを使用する、 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] カスタム ルーティング イベントのイベントのアクセス パターンです。  
  
   
  
## 例  
 次の例で呼び出されるハンドラーを実装する、 <xref:System.Windows.FrameworkElement.Initialized> を使用して、ページ上の名前付きの要素のいずれかに定義されたハンドラーをアタッチするページ上のイベント `handledEventsToo` `true`します。  このハンドラーは、経路上の別の要素が共有イベント データ、ルートの処理中の要素に到達する前に処理済みとしてマークされている場合でも呼び出されるとします。  
  
 [!code-csharp[EventOvwSupport\#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport\#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">ハンドラーに追加されるイベントのルートです。</param>
        <param name="e">ハンドラーの追加に使用されるイベントのデータ。 このメソッドを使用して、 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> ハンドラーを作成する引数のプロパティです。</param>
        <summary>指定したハンドラーを追加する <see cref="T:System.Windows.EventRoute" /> 現在の <see cref="T:System.Windows.ContentElement" /> イベント ハンドラーのコレクション。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、コンテンツ ホスト要素の \(実装しているかどうかに関係なく <xref:System.Windows.IContentHost>\) ホストへのコンテンツのホストの子要素のハンドラーを追加するために <xref:System.Windows.EventRoute>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグアンドドロップ操作の対象として使用できるかどうかを示す値を取得または設定します。</summary>
        <value>この要素をドラッグアンドドロップ操作の対象として使用できる場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ドラッグ アンド ドロップ操作が既定では、有効でないと、設定して意図的に有効にする必要があります <xref:System.Windows.ContentElement.AllowDrop%2A> に  `true`します。 この基本的な設定を超えるドラッグ アンド ドロップの動作は完全に特定の実装とによって定義されていない <xref:System.Windows.ContentElement> またはその他の要素の基本クラスです。 たとえば、特定のコントロール <xref:System.Windows.Controls.RichTextBox>, は既定の動作はありませんが <xref:System.Windows.ContentElement> 派生クラスであるこのような動作です。 ドラッグ アンド ドロップの詳細については、次を参照してください。 [ドラッグ アンド ドロップの概要](http://msdn.microsoft.com/ja-jp/1a5b27b0-0ac5-4cdf-86c0-86ac0271fa64)します。  
  
 <xref:System.Windows.FrameworkContentElement> その実装では、この依存関係プロパティのメタデータを上書きします。 具体的には、 <xref:System.Windows.FrameworkContentElement> 指定で、このプロパティは、プロパティ値の継承を許可する \(<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> は `true` メタデータで\)。 このコンテキストでプロパティ値の継承ことを意味のないその他の値を含む子要素がある場合 <xref:System.Windows.ContentElement.AllowDrop%2A> ローカル値またはスタイル、割り当てられている \(ここでものいずれかで、既定値、またはローカルの値のスタイル\)、この値を持つ最も近い親要素の値を割り当てられた、プロパティ システムでのすべての未使用の子要素をその親要素から値が割り当てられます。 つまり、ルート要素でドロップ操作を許可し、すべての値を反映するかどうかを指定できる <xref:System.Windows.FrameworkContentElement> が具体的には割り当てられていない値の子要素 `false`します。  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 設定を次に例 <xref:System.Windows.ContentElement.AllowDrop%2A> で [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 [!code-xml[ContentElementsSmorgasbord\#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.AllowDrop" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">アニメーション化するプロパティの識別子。</param>
        <param name="clock">アニメーションをコントロールして宣言するアニメーション クロック。</param>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用します。 既存のアニメーションは停止され、新しいアニメーションに置き換えられます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 To remove an animation from a property, specify the identifier for that property as **parameterReference tag is not supported!!!!**  
 and specify **parameterReference tag is not supported!!!!**  
 as **languageKeyword tag is not supported!!!!**  
. This removes the animation and the animated property is set to its base value. However, the originally associated animation clock is not stopped. Any other animations assigned to that clock will continue to run.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">アニメーション化するプロパティ。</param>
        <param name="clock">アニメーションをコントロールして宣言するアニメーション クロック。</param>
        <param name="handoffBehavior">列挙体の値。 既定値は <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> で、既存のアニメーションを停止して新しいアニメーションに置き換えます。</param>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用し、プロパティでアニメーションが既に適用されているときに行われる処理を指定する機能も提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アニメーションのプロパティを削除すると、そのプロパティの識別子を指定する `dp` 指定 `clock` として `null`します。 これにより、アニメーション、削除し、アニメーションのプロパティをベース値に設定します。 ただし、最初に関連付けられているアニメーション クロックは停止されません。 クロックに割り当てられているその他のアニメーションは引き続き実行します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、少なくとも 1 つのタッチをキャプチャするかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 少なくとも 1 つのタッチの場合はこの要素にキャプチャします。それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のすべての子要素には、少なくとも 1 つのタッチがキャプチャされているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素またはそのビジュアル ツリー内のすべての子要素にキャプチャされる場合は、少なくとも 1 つのタッチそれ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上に少なくとも 1 つのタッチが押されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素上には、少なくとも 1 つのタッチが押された場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のすべての子要素の上に少なくとも 1 つのタッチが押されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素またはそのビジュアル ツリー内のすべての子要素の上には、少なくとも 1 つのタッチが押された場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">依存関係プロパティの識別子として指定されている、アニメーション化するプロパティです。</param>
        <param name="animation">開始するアニメーションのタイムラインになります。</param>
        <summary>この要素で指定したプロパティのアニメーションを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティがアニメーション化するかどうかをチェックするときに注意してください、アニメーションが開始されと見なされるアニメーション化されていない基を超える最初のフレームがレンダリングされるときにアニメーション化します。  
  
 場合、 <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> の `animation` は `null`, 、し、現在のアニメーションが削除され、プロパティの現在の値が保持されています。  
  
 場合全体 `animation` 値は `null`, 、すべてのアニメーションがプロパティから削除され、プロパティ値の基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 そのタイムラインに割り当てられているその他のアニメーションは引き続き実行します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">依存関係プロパティの識別子として指定されている、アニメーション化するプロパティです。</param>
        <param name="animation">適用されるアニメーションのタイムラインになります。</param>
        <param name="handoffBehavior">プロパティの値が既に影響を受けている現在の \(実行中\) のアニメーションと新しいアニメーションが対話する方法を指定する列挙型の値。</param>
        <summary>特定の内容を指定するオプションを使用して、この要素に指定されたアニメーション プロパティ アニメーションの場合は、プロパティには既に実行中のアニメーションを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティがアニメーション化するかどうかをチェックするときに注意してください、アニメーションが開始されと見なされるアニメーション化されていない基を超える最初のフレームがレンダリングされるときにアニメーション化します。  
  
 場合、 <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> の `animation` は `null`, 、し、現在のアニメーションが削除され、プロパティの現在の値が保持されています。  
  
 場合全体 `animation` 値は `null`, 、すべてのアニメーションがプロパティから削除され、プロパティ値の基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 そのタイムラインに割り当てられているその他のアニメーションは引き続き実行します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にマウスのキャプチャを強制しようとします。</summary>
        <returns>
          <see langword="true" /> マウスが正常にキャプチャされた場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャプチャされる要素を有効にする必要があります。 確認するかどうか <xref:System.Windows.ContentElement.IsEnabled%2A> は `true` を呼び出す前に <xref:System.Windows.ContentElement.CaptureMouse%2A>します。  
  
 呼び出す場合 <xref:System.Windows.ContentElement.CaptureMouse%2A> 返します `true`, 、し <xref:System.Windows.ContentElement.IsMouseCaptured%2A> も `true`です。  
  
 呼び出す場合 <xref:System.Windows.ContentElement.CaptureMouse%2A> を返します `true`, 、 <xref:System.Windows.ContentElement.GotMouseCapture> と <xref:System.Windows.ContentElement.IsMouseCapturedChanged> イベントが発生すると <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=fullName> 要素としてデータを報告するイベントの場所、 <xref:System.Windows.ContentElement.CaptureMouse%2A> メソッドが呼び出されます。 キャプチャを強制する場合は、既存のキャプチャを妨げることがあります: 特にのマウスでドラッグ アンド ドロップに関連するキャプチャします。  
  
 すべての要素からマウスのキャプチャをクリアするを呼び出す <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=fullName> で、 `element` として指定されたパラメーター `null`します。  
  
   
  
## 例  
 次の例では、マウスをキャプチャすると、要素によって、マウスが既にキャプチャされているかどうかに基づいてキャプチャの解放します。 この例では、見込み客に対してキャプチャ対象の要素はキャストに注意してください、 <xref:System.Windows.IInputElement> インターフェイス、および最初に呼び出したため、 <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=fullName> メソッドです。 キャストは <xref:System.Windows.IInputElement> 手法がわからないことを確認するかどうかにキャプチャする場合、要素、マウスの場合に便利ですが、 <xref:System.Windows.UIElement> または <xref:System.Windows.ContentElement>です。 インターフェイスにキャストしてインターフェイス メソッド実装を呼び出す、呼び出し、適切な型固有ことで内部的に、評価版のいずれかにキャストを必要とせず <xref:System.Windows.UIElement> または <xref:System.Windows.ContentElement>です。 これと同じキャスト方法が他のメンバーの動作を <xref:System.Windows.IInputElement> 、たとえば多数定義、入力に関連するイベント、およびその他の入力に関連するメソッドです。  
  
 [!code-csharp[ContentElementsSmorgasbord\#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord\#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>強制的にこの要素にスタイラスをキャプチャしようとします。</summary>
        <returns>
          <see langword="true" /> スタイラスが正常にキャプチャされた場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装を常に基になる既定のスタイラス デバイスに基づいて `true`します。 ただし、入力システムのデバイスの実装を提供する入力デバイスを拡張する場合は、異なる結果を返す可能性のある代替のスタイラス デバイスの実装を含む、システムを作成することです。  
  
 スタイラスをキャプチャする要素は、スタイラスがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このメソッドを呼び出す、基になる静的 <xref:System.Windows.Input.Stylus> メソッド <xref:System.Windows.Input.Stylus.Capture%2A>します。 実際のキャプチャの動作は、アクティブなスタイラス デバイスの実装によって実装されます。  
  
 キャプチャされる要素を有効にする必要があります。 確認するかどうか <xref:System.Windows.ContentElement.IsEnabled%2A> は `true` を呼び出す前に返す <xref:System.Windows.ContentElement.CaptureStylus%2A>します。  
  
 呼び出す場合 <xref:System.Windows.ContentElement.CaptureStylus%2A> 返します `true`, 、<xref:System.Windows.ContentElement.IsStylusCaptured%2A> も `true`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">キャプチャするデバイスです。</param>
        <summary>この要素に強制的にタッチをキャプチャしようとします。</summary>
        <returns>
          <see langword="true" /> この要素に指定したタッチがキャプチャされている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.CaptureTouch%2A> 戻ります `false` 場合、 <xref:System.Windows.Input.TouchDevice> 別の要素にキャプチャされています。  
  
 場合 <xref:System.Windows.ContentElement.CaptureTouch%2A> 返します `true`, 、 <xref:System.Windows.ContentElement.GotTouchCapture> イベントが発生します。  
  
 解放するにはこの要素から 1 つのタッチのキャプチャを使用して、 <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> メソッドを解放する、タッチ デバイスを指定します。 解放するにはこの要素からすべてのタッチを使用して、 <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コレクションを取得 <see cref="T:System.Windows.Input.CommandBinding" /> この要素に関連付けられているオブジェクト。</summary>
        <value>すべてのコレクション <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Windows.Input.CommandBinding> この要素の特定のコマンドのコマンドの処理を有効にし、コマンド、そのイベントでは、この要素にアタッチされているハンドラー間のリンケージを宣言します。  
  
 別の一般的な方法を設定する、 <xref:System.Windows.ContentElement.CommandBindings%2A> コレクションは、使用する <xref:System.Windows.Input.CommandManager> メソッド プログラムを使用しています。  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## XAML プロパティ要素の使用  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## XAML 値  
 *oneOrMoreCommandBindings*  
 1 つまたは複数 <xref:System.Windows.Input.CommandBinding> 要素。 これらの各、 <xref:System.Windows.Input.CommandBinding.Command%2A> 属性既知のコマンドに設定され、に対して属性が設定、 <xref:System.Windows.Input.CommandBinding.CanExecute> と <xref:System.Windows.Input.CommandBinding.Executed> ハンドラーの実装です。 詳細については、「<xref:System.Windows.Input.CommandBinding>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName> attached event for this class, so that <xref:System.Windows.ContentElement.DragEnter?displayProperty=fullName> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.ContentElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName> attached event and receive the same event data instance.  
  
<a name="routedEventInfo_DragEnter"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDragEnter>.  
  
-   Override <xref:System.Windows.ContentElement.OnDragEnter%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.DragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName> attached event for this class so that <xref:System.Windows.ContentElement.DragLeave?displayProperty=fullName> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.ContentElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName> attached event and receive the same event data instance.  
  
<a name="routedEventInfo_DragLeave"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.  
  
-   Override <xref:System.Windows.ContentElement.OnDragLeave%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.DragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event occurs even if the drag originates in the element bounds. If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.ContentElement.DragEnter> and related preview events.  
  
 This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=fullName> attached event for this class so that <xref:System.Windows.ContentElement.DragOver?displayProperty=fullName> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.ContentElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=fullName> attached event and receive the same event data instance.  
  
<a name="routedEventInfo_DragOver"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.ContentElement.DragOverEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.  
  
-   Override <xref:System.Windows.ContentElement.OnDragOver%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.DragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=fullName> attached event for this class so that <xref:System.Windows.ContentElement.Drop?displayProperty=fullName> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.ContentElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=fullName> attached event and receive the same event data instance.  
  
<a name="routedEventInfo_Drop"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.ContentElement.DropEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDrop>.  
  
-   Override <xref:System.Windows.ContentElement.OnDrop%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.Drop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にフォーカスを設定しようとします。</summary>
        <returns>
          <see langword="true" /> この要素にキーボード フォーカスを設定できる場合 <see langword="false" /> 場合、このメソッドの呼び出しは、フォーカスを設定できませんでした。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスを <xref:System.Windows.ContentElement.Focusable%2A> と <xref:System.Windows.ContentElement.IsEnabled%2A> 両方 `true`します。 ほぼすべて <xref:System.Windows.ContentElement> 派生するクラスは <xref:System.Windows.ContentElement.Focusable%2A> 既定では。  
  
 要素は、特定のツリー内でのフォーカスを取得できる、有効な場合は、イベントの処理が、たとえプレビュー フォーカス イベントにフォーカスがある、許可しないことによって応答 \(複合コントロールなど\) ためこのメソッドは `false`です。  
  
 一般にフォーカスが 2 つの異なる概念によって制御されます。 キーボード フォーカスと論理フォーカスは、常に同じではありません。 このメソッドは、論理フォーカスを設定します。 プログラム キーボード フォーカスを明示的に設定する手段はありません。キーボード フォーカスは、ユーザー入力によって決まります。 詳細については、次を参照してください。 [フォーカス概要](http://msdn.microsoft.com/ja-jp/0230c4eb-0c8a-462b-ac4b-ae3e511659f4) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 呼び出す場合 <xref:System.Windows.ContentElement.Focus%2A> 返します `true`, 、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A> と <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> も `true`です。  
  
 関連するプロパティがない場合 `true`, を呼び出したときに、 <xref:System.Windows.ContentElement.Focus%2A>, 、1 つ以上の次のイベントが次の順序で発生します: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, 、<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> \(ソースは新しいフォーカス ターゲット\)、 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, 、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, 、<xref:System.Windows.ContentElement.LostKeyboardFocus>, 、<xref:System.Windows.ContentElement.GotKeyboardFocus> \(ソースは新しいフォーカス ターゲット\)。  
  
   
  
## 例  
 次の例では、指定した文書の段落をという名前を検索するページ読み込みイベント ハンドラーは、し、フォーカスを設定します。 段落は、既定でフォーカスを設定できません。この特定の段落が適用されるスタイルのスタイルを使用する \(非表示\) <xref:System.Windows.Setter> フォーカスを取得できるようにします。  
  
 [!code-csharp[ContentElementsSmorgasbord\#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord\#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素がフォーカスを得ることができるかどうかを示す値を取得または設定します。</summary>
        <value>要素がフォーカス可能な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> ですが、「解説」をご覧ください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスがある要素だけでは、キーボード入力を受け取ります。  
  
 特定の派生クラスは、派生クラスを既定でフォーカスを取得できるように、この依存関係プロパティのメタデータをオーバーライド可能性があります。  
  
 によって継承される <xref:System.Windows.Documents.Hyperlink> またはその派生クラスでは、 <xref:System.Windows.Documents.Hyperlink> この依存関係プロパティのメタデータをオーバーライドし、このプロパティの既定値を再定義 `true`します。  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.FocusableProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、スタイルを <xref:System.Windows.Documents.Paragraph> 既定でフォーカスを取得できるが、フォーカスを受け取ったときに、視覚的な動作を付け、します。  
  
 [!code-xml[ContentElementsSmorgasbord\#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you derive from <see cref="T:System.Windows.ContentElement" />, consider whether you want your element to be focusable, because by default it will not be focusable. If you want your element to be focusable, override the metadata for this property in your derived class static constructor as follows:  
  
 [!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
 [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
 where <paramref name="myElement" /> is the class name of the type that you are overriding the metadata value on.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.Focusable" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.Focusable" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">確認する依存関係プロパティ。</param>
        <summary>この要素の、指定したプロパティの基本プロパティ値を返します。実行中または停止済みのアニメーションでアニメーション化される値は無視されます。</summary>
        <returns>指定した依存関係プロパティにアニメーションが添付されていないような場合のプロパティ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティのアニメーションが添付されていない場合、 <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> に戻り値は常に、 <xref:System.Windows.DependencyObject.GetValue%2A> の値を返します。 添付されたアニメーションがある場合は、可能なすべてのアニメーションが開始などの値を派生し、停止の値は無視され、プロパティ値が他のすべての可能な入力に基づいて決定します。 詳細については、次を参照してください。 [依存関係プロパティの値の優先順位](http://msdn.microsoft.com/ja-jp/1fbada8e-4867-4ed1-8d97-62c07dad7ebc)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、別の方法を返す ユーザー インターフェイス (UI) ビジュアル親が存在しない場合、この要素の親です。</summary>
        <returns>派生クラスの実装が代替親レポートに接続している場合のオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの既定の仮想実装 `null`します。<xref:System.Windows.FrameworkContentElement> 実用的な実装を提供します。  
  
 別の親は、要素が別の親の構造体を作成することで、そのイベントは、標準の親にビジュアル ツリーをルーティングの標準的なパターンから逸脱した方法でルーティングまたはプレビュー ルーティング戦略の下位方向へ場所の場合、イベントのルーティングに使用されます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素を対象とするドラッグ アンド ドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.GiveFeedback> イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。 視覚的なフィードバックは、ドラッグ アンド ドロップ操作が、プロセスを強化します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.ContentElement.GiveFeedback> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.GiveFeedback> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewGiveFeedback>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnGiveFeedback%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.GiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスがメソッド呼び出しを使用して強制的に意図的に直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 ここでは、要素にキーボード フォーカスが残り、このシナリオで、 <xref:System.Windows.ContentElement.Focus%2A> メソッドはまだ論理フォーカスを取得します。  
  
 このイベントのより正確な解釈がその it 発生する状況の値、 <xref:System.Windows.ContentElement.IsFocused%2A> からルート内の要素のプロパティが変更された `false` に `true`します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを受け取る要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを得られる実際の要素を特定のイベント データ。  
  
<a name="routedEventInfo_GotFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnGotFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.GotFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> 要素のフォーカスの状態を保持するプロパティの状態の変更を追跡するようなイベント <xref:System.Windows.ContentElement.GotKeyboardFocus> イベントは、多くの同じ状況で発生します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際にアタッチされている要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスがある実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.ContentElement.GotKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.GotKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウスをキャプチャする要素は、境界外にマウス ポインターがあって、マウス入力を受け取ります。 マウスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャしは、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャされたします。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> 、イベントをマウスを持つ実際の要素を特定のデータをキャプチャします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.ContentElement.GotMouseCapture> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.GotMouseCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスをキャプチャする要素は、ポインターがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスでは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャを保持します。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> 、イベント データがキャプチャを持つ実際の要素を特定します。  
  
 このイベントは、このクラスにアタッチされるイベントのエイリアスを作成できるように <xref:System.Windows.ContentElement.GotStylusCapture> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.GotStylusCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、タッチがキャプチャされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、アニメーション化されたプロパティが含まれるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素は、アニメーションのプロパティのいずれかに接続されている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返します `true` \(ロック、常に実行されている\) の永続的なアニメーションに対して、または特定のタイムラインのアニメーションです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関連付けられている入力のバインディングのコレクションを取得します。</summary>
        <value>入力バインディングのコレクションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 入力バインディングは、コマンドを入力デバイスのバインディングをサポートします。 たとえば、 <xref:System.Windows.Input.MouseBinding> マウス デバイスに固有のプロパティを含むバインドの入力を実装します。  
  
 入力バインディングのコレクションには、型に関連する両方と、インスタンス上で宣言される入力のバインディングが含まれています。  
  
 関連するプロパティ、 <xref:System.Windows.ContentElement.CommandBindings%2A>, 、コマンドのショートカット キーのコレクションを保持します。 これらのバインディングは、入力バインディングとは異なり、コマンド処理に既知のコマンドとクラス固有のハンドラーに関連付けられているアクションの下のレベルアップを表しています。  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## XAML プロパティ要素の使用  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## XAML 値  
 *oneOrMoreInputBindings*  
 1 つまたは複数 <xref:System.Windows.Input.InputBinding> 要素 \(通常、 <xref:System.Windows.Input.KeyBinding> または <xref:System.Windows.Input.MouseBinding> 派生クラス\)。 これらの各が予期、 <xref:System.Windows.Input.InputBinding.Command%2A> と <xref:System.Windows.Input.InputBinding.Gesture%2A> 属性が設定されます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定でこの要素が有効になっているかどうかを示す値、 ユーザー インターフェイス (UI)です。</summary>
        <value>コンポーネントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例を視覚的な代替動作を示すプロパティ setter を含むスタイルを作成するときに、 <xref:System.Windows.Documents.Hyperlink> に設定されている <xref:System.Windows.ContentElement.IsEnabled%2A> `false`します。  
  
 [!code-xml[ContentElementsSmorgasbord\#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.ContentElement.IsEnabled" /> プロパティでこの要素を変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>戻り値になる値を取得 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 派生クラスです。</summary>
        <value>コンポーネントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled. (If the parent is not enabled, the child element cannot be effectively enabled in practical [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsEnabled" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に論理フォーカスがあるかどうかを判断する値を取得します。</summary>
        <value>この要素に論理フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーションは、複数のフォーカス区分をなど\] メニューの内容と、アプリケーションの残りの部分の間に、論理フォーカスはキーボード フォーカスと異なる場合があります。 このシナリオでは、アプリケーションの UI の 1 つの要素にキーボード フォーカスが設定できるだけ、ただし、他のフォーカス区分の特定の要素がありますも保持する論理フォーカスします。 論理フォーカスの詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef) と [フォーカス概要](http://msdn.microsoft.com/ja-jp/0230c4eb-0c8a-462b-ac4b-ae3e511659f4)します。  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、スタイルを <xref:System.Windows.Documents.Paragraph> 既定でフォーカスを取得できるが、フォーカスを受け取ったときに、視覚的な動作を付け、します。  
  
 [!code-xml[ContentElementsSmorgasbord\#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Input Method Editor \(IME\) などの入力方式システムで、この要素への入力処理が有効になっているかどうかを示す値を取得します。</summary>
        <value>入力方式がアクティブである場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 基になる添付プロパティの既定値は <see langword="true" /> ですが、この値は実行時に入力方式の状態の影響を受けます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 添付プロパティによって返される値を返します <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=fullName> 現在有効な入力方法 \(キーボード、音声、およびその他の入力デバイス\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがあるかどうかを示す値を取得します。</summary>
        <value>この要素にキーボード フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キーボード フォーカスを要素または子要素内で任意の場所がかどうかを示す値を取得します。</summary>
        <value>キーボード フォーカスがその要素またはその子要素にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの値に対する変更で通常発生、 <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> イベント、派生クラスがオーバーライドされない限り、 <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> を抑制する状況、イベントです。  
  
 このプロパティを直接設定しないが、要素にフォーカスを設定するにを呼び出して <xref:System.Windows.ContentElement.Focus%2A>, を作成したりして、 <xref:System.Windows.ContentElement.MoveFocus%2A> 要求します。 このプロパティの値を変更するこれらのメソッド呼び出しのいずれかの可能性があります。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素によって、マウスをキャプチャするかどうかを示す値を取得します。</summary>
        <value>要素にマウス キャプチャがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウスの状態のキャプチャ プロセスでのドラッグ アンド ドロップの操作に関連しています。  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、マウスのキャプチャの状態を切り替えます要素によって、マウスが既にキャプチャされているかどうかに基づいてします。  
  
 [!code-csharp[ContentElementsSmorgasbord\#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord\#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素または要素ツリー内の子要素がマウス キャプチャを保持するかどうかを決定する値を取得します。</summary>
        <value>この要素または格納されている要素がマウス キャプチャを持つ場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> この要素に変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。</summary>
        <value>マウス ポインターがヒット テストと同じ要素の結果上にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり <xref:System.Windows.ContentElement.IsMouseOver%2A>, 、のみ、このプロパティは `true` マウス ポインターがリテラルの要素の上にある場合などは、ヒット テストとして。 マウス ポインターが代わりに子要素にある場合は、具体的には要素のより深いテンプレートおよび複合の一部である要素をこのプロパティはなります `false`します。 コントロールは複合方法がわかっていない限り、\(たとえば、このプロパティを使用したカスタム コントロール テンプレートで定義したコントロールの\) このプロパティは、予期しない結果を返す場合があります。 コントロールをいないオーサリングするほとんどのシナリオを使用して <xref:System.Windows.ContentElement.IsMouseOver%2A> 代わりにします。  
  
 この要素によって、マウスがキャプチャされていて、このプロパティは、 `true` のキャプチャ時に、このプロパティを返し続けます `true` マウスのキャプチャが失われ、ポインターはその境界から出るまでです。  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素 \(visual の子要素、またはそのコントロールの複合を含む\) 上にあるかどうかを示す値を取得します。</summary>
        <value>マウス ポインターが要素またはその子要素の上にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 類似しています"IsMouseOverChanged"イベントが存在しないがいくつかのようなイベントを行います。 たとえば、使用 <xref:System.Windows.ContentElement.MouseEnter>, 、<xref:System.Windows.ContentElement.MouseMove>, 、および <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>です。  
  
 この要素がマウスをキャプチャする場合に、このプロパティが残ります `true` マウスのキャプチャが失われ、マウス ポインターが要素の境界を離れるまでです。  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例を視覚的な代替動作を示すプロパティ setter を含むスタイルを作成するときに、 <xref:System.Windows.Documents.Hyperlink> レポート <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`します。  
  
 [!code-xml[ContentElementsSmorgasbord\#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsMouseOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にスタイラスがキャプチャされるかどうかを示す値を取得します。</summary>
        <value>要素にスタイラスのキャプチャがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素は、子要素およびコントロールの複合を含むでスタイラスをキャプチャが保持されているかどうかを決定する値を取得します。</summary>
        <value>
          <see langword="true" /> この要素にスタイラスをキャプチャが保持されている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。</summary>
        <value>スタイラスがヒット テストと同じ要素の上にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり <xref:System.Windows.ContentElement.IsStylusOver%2A>, 、このプロパティはのみ `true` スタイラスが要素上にある場合。 スタイラスの代わりに、子要素または要素のより深い複合の一部である要素を場合、このプロパティになります `false`します。  
  
 コントロールは複合方法がわかっていない限り、\(たとえば、このプロパティを使用したカスタム コントロール テンプレートで定義したコントロールの\) このプロパティは、予期しない結果を返す場合があります。 コントロールをいないオーサリングするほとんどのシナリオを使用して <xref:System.Windows.ContentElement.IsStylusOver%2A> 代わりにします。  
  
 この要素は、スタイラスをキャプチャすると、このプロパティは、 `true` のキャプチャ時に、このプロパティの値 `true` スタイラスをキャプチャが失われ、スタイラスがその境界から出るまでです。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素 \(visual の子要素を含む\) 上にあるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> スタイラスが、要素またはその子要素の上にある場合それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この要素にスタイラスをキャプチャがある場合は、このプロパティの値 `true` スタイラスをキャプチャは失われ、ポインターがその範囲外になるまでです。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.ContentElement.IsStylusOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがある状態でキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーの処理は、コマンドの実行とテキストの合成などの他のプラットフォーム機能と対話します。<xref:System.Windows.ContentElement.KeyDown> イベントは、下位レベルのテキストの入力イベントの特定のコントロールで期待どおりに動作しません。 これは、一部のコントロールがコントロールの複合か、テキストの高レベルのバージョンを提供するクラスの処理が入力処理および関連するイベントです。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.ContentElement.KeyDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.KeyDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_KeyDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewKeyDown>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnKeyDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.KeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがあるときにキーが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName> 添付このクラスでイベントように  <xref:System.Windows.ContentElement.KeyUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.KeyUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_KeyUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewKeyUp>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnKeyUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.KeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッド呼び出しを使用して意図的にフォーカスを外しているにもかかわらず、直前のキーボード フォーカスが異なるスコープ内に存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 シナリオではこのことがキーボード フォーカスは、要素を <xref:System.Windows.ContentElement.Focus%2A> メソッドはまだ論理フォーカスを取得します。  
  
 このイベントのより正確な解釈がその it 発生する状況の値、 <xref:System.Windows.ContentElement.IsFocused%2A> からルート内の要素のプロパティが変更される `true` に `false`します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを得られる実際の要素を特定のイベント データ。  
  
<a name="routedEventInfo_LostFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnLostFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.LostFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.LostKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.LostKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素がマウスをキャプチャは、境界外のポインターがあってもマウス入力を受け取ります。 マウスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> キャプチャを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.LostMouseCapture> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.LostMouseCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスをキャプチャする要素は、ポインターがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.LostStylusCapture> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.LostStylusCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素は、タッチのキャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.MouseDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.MouseDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.ContentElement.MouseDown> イベントは、多くの場合、いずれかと共に <xref:System.Windows.ContentElement.MouseLeftButtonDown> または <xref:System.Windows.ContentElement.MouseRightButtonDown>, 、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。<xref:System.Windows.ContentElement.MouseLeftButtonDown><xref:System.Windows.ContentElement.MouseRightButtonDown> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.ContentElement.MouseLeftButtonDown> または <xref:System.Windows.ContentElement.MouseRightButtonDown>です。  
  
> [!IMPORTANT]
>  いくつか <xref:System.Windows.ContentElement> などのコントロールと同様の動作のあるクラスを派生 <xref:System.Windows.Documents.Hyperlink>, 、対処するためのマウス ボタンのイベント固有のクラスがあります。 イベントをマウスの左ボタンは、クラス、コントロールの処理が最も可能性の高いイベントです。 クラスの多くの場合、処理が、基になるをマーク <xref:System.Windows.Input.Mouse> クラス イベントを処理します。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンスのハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。  
  
 前の「重要」に説明されている問題を解決し、それでも <xref:System.Windows.ContentElement.MouseDown> クラスによるこれらソリューションのいずれかの処理を含む派生クラスでイベントをマウスの左ボタンのイベント。  
  
-   ハンドラーのアタッチ、 <xref:System.Windows.ContentElement.PreviewMouseDown> コントロールによって処理済みとマークされていないイベント。 これはプレビュー イベントであるため、ルート ルートから始まり、コントロールまでトンネルに注意してください。  
  
-   呼び出して、コントロールのハンドラーを手続き的登録 <xref:System.Windows.ContentElement.AddHandler%2A> ハンドラーにルーティングされたイベント データの処理としてマークされている場合でも、イベントをリッスンできる署名オプションを選択します。  
  
<a name="routedEventInfo_MouseDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewMouseDown>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnMouseDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.MouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.MouseEnter> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 直接イベント ルーティング方法の処理を使用します。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、ルーティング イベントの動作のスタイルでイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.ContentElement.MouseEnter> マウス ポインターがこのイベントをさらに、要素の境界に入った時点を追跡するレポート文字どおり、 <xref:System.Windows.ContentElement.IsMouseOver%2A> からプロパティ値が変更 `false` に `true` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.MouseEnter> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.MouseEnter> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnMouseEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.MouseEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.MouseLeave> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 直接イベント ルーティング方法の処理を使用します。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、ルーティング イベントの動作のスタイルでイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.ContentElement.MouseLeave> マウスが離れると、要素にある場合、このイベントは、複数のトラックが文字どおり報告された、 <xref:System.Windows.ContentElement.IsMouseOver%2A> からプロパティ値が変更 `true` に `false` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.MouseLeave> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.MouseLeave> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnMouseLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.MouseLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてバブルのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.ContentElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントの引数を公開、基になる引数 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.ContentElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.ContentElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.ContentElement>します。  
  
> [!IMPORTANT]
>  いくつか <xref:System.Windows.ContentElement> などのコントロールと同様の動作のあるクラスを派生 <xref:System.Windows.Documents.Hyperlink>, 、対処するためのマウス ボタンのイベント固有のクラスがあります。 イベントをマウスの左ボタンは、クラス、コントロールの処理が最も可能性の高いイベントです。 クラスの多くの場合、処理が、基になるをマーク <xref:System.Windows.Input.Mouse> クラス イベントを処理します。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンスのハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。  
  
 前の「重要」に説明されている問題を解決し、それでも <xref:System.Windows.ContentElement.MouseLeftButtonDown> クラスによるこれらソリューションのいずれかの処理を含む派生クラスでイベントをマウスの左ボタンのイベント。  
  
-   ハンドラーのアタッチ、 <xref:System.Windows.ContentElement.PreviewMouseDown> コントロールによって処理済みとマークされていないイベント。 これはプレビュー イベントであるため、ルート ルートから始まり、コントロールまでトンネルに注意してください。  
  
-   呼び出して、コントロールのハンドラーを手続き的登録 <xref:System.Windows.ContentElement.AddHandler%2A> ハンドラーにルーティングされたイベント データの処理としてマークされている場合でも、イベントをリッスンできる署名オプションを選択します。  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてバブルのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.ContentElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントの引数を公開、基になる引数 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.ContentElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.ContentElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.ContentElement>します。  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.MouseMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.MouseMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewMouseMove>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnMouseMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.MouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてバブルのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.ContentElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントの引数を公開、基になる引数 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.ContentElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.ContentElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.ContentElement>します。  
  
 右側のボタンのマウス イベントは、アプリケーション シナリオでネイティブ処理を頻繁にあります。 たとえば、マウスの右ボタンを押すがコンテキスト メニューを表示します。 参照してください [ContextMenu の概要](http://msdn.microsoft.com/ja-jp/16909c42-799a-4561-91e0-7d69dcfeea91)します。  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてバブルのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.ContentElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントの引数を公開、基になる引数 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.ContentElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.ContentElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.ContentElement>します。  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.MouseUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.MouseUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.ContentElement.MouseUp> イベントは、多くの場合、いずれかと共に <xref:System.Windows.ContentElement.MouseLeftButtonUp> または <xref:System.Windows.ContentElement.MouseRightButtonUp>, 、2 つの標準のマウス ボタンのいずれかのリリースに対応します。<xref:System.Windows.ContentElement.MouseLeftButtonUp><xref:System.Windows.ContentElement.MouseRightButtonUp> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.ContentElement.MouseLeftButtonUp> または <xref:System.Windows.ContentElement.MouseRightButtonUp>です。  
  
<a name="routedEventInfo_MouseUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewMouseUp>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnMouseUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.MouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。そのため、表示された場合、 <xref:System.Windows.ContentElement.MouseWheel> フォーカスがあるか、キャプチャした要素からのイベント、マウス ポインターのほう別の要素上です。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.MouseWheel> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.MouseWheel> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewMouseWheel>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnMouseWheel%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.MouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">走査の各要求を視覚的に移動するには、既存のタブ オーダーまたは、方向を走査するモードにはいずれかを示すプロパティが含まれています。</param>
        <summary>この要素から別の要素にフォーカスを移動しようとします。 フォーカスを移動する方向は、この要素のビジュアルの親の組織内で解釈されますが、ガイダンスの方向を指定します。</summary>
        <returns>
          <see langword="true" /> 要求の検査が実行された場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの戻り値を確認してください。 戻り値 `false` 走査の各要求はラップする要求していないと、走査は、コントロールの構成で定義されているタブ ストップが実行されて、返される可能性があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>特定のクラスを返す <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> の実装、 Windows Presentation Foundation (WPF) インフラストラクチャです。</summary>
        <returns>型固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The implementation of this method is typically to call the constructor of a specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.  
  
 All <see cref="T:System.Windows.ContentElement" /> derived classes should implement this method in order to provide their own specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations to the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure. For details on implementing this pattern, see <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragLeave" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragOver" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.RoutedEventArgs" />。 このイベント データには、<see cref="E:System.Windows.ContentElement.GotFocus" /> イベントの識別子が含まれている必要があります。</param>
        <summary>渡されたイベント データを使用して、<see cref="E:System.Windows.ContentElement.GotFocus" /> ルーティングされたイベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、仮想がイベントを発生させる既定の実装です。  
  
 これを \* メソッドの実装の目的は、イベントが発生して、この同じメソッドの実装が内部的に呼び出され、イベントを発生させるときに、 <xref:System.Windows.ContentElement.IsFocused%2A> プロパティ値が変更されます。<xref:System.Windows.ContentElement.OnGotFocus%2A> 実装が異なるその他の [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] に \* のみそのイベントのクラス処理を追加する便利な手段を提供の実装です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation. Otherwise, the <see cref="E:System.Windows.ContentElement.GotFocus" /> event is not raised during typical user operations that ordinarily set focus to this element. If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />. Note that by default a <see cref="P:System.Windows.ContentElement.Focusable" /> is not focusable, therefore setting <see cref="P:System.Windows.ContentElement.Focusable" /> deliberately might not be necessary.</para>
        </block>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> タッチがこの要素にキャプチャされるときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> を処理する派生クラスで、 <xref:System.Windows.ContentElement.GotTouchCapture> イベントです。 必ず、基本クラスの <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> 依存関係プロパティが変更されました。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素によって <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> イベントが発生する直前に呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、 <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.ContentElement.IsMouseCaptured%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.ContentElement.IsMouseCapturedChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、 <xref:System.Windows.ContentElement.IsMouseCapturedChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This virtual method is raised when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property changes its value. The virtual method is raised first and can manipulate the event data as necessary. Then the <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance. Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.  
  
 This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation. You may call base either before or after your special handling, depending on your requirements.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、 <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.ContentElement.IsStylusCaptured%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.ContentElement.IsStylusCapturedChanged> 同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティングされたイベントではないことを確認します。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> 同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティングされたイベントではないことを確認します。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> 同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティングされたイベントではないことを確認します。 したがってクラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーボード操作は、専用の入力マネージャーによって処理されます。 たとえば、入力とコマンド バインドのキー入力に依存しているその他のプログラミング機能は、一般的なキーストロークとして公開される前にキーストロークを処理することがあります。 これらの入力システムの機能、イベントを処理し、としてマークする場合は、 <xref:System.Windows.ContentElement.OnKeyDown%2A> は呼び出されません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーボード操作は、専用の入力マネージャーによって処理されます。 たとえば、入力とコマンド バインドのキー入力に依存しているその他のプログラミング機能は、一般的なキーストロークとして公開される前にキーストロークを処理することがあります。 これらの入力システムの機能、イベントを処理し、としてマークする場合は、 <xref:System.Windows.ContentElement.OnKeyUp%2A> は呼び出されません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。 このイベント データには、<see cref="E:System.Windows.ContentElement.LostFocus" /> イベントの識別子が含まれている必要があります。</param>
        <summary>提供されたイベント データを使って、<see cref="E:System.Windows.ContentElement.LostFocus" /> ルーティング イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、仮想がイベントを発生させる既定の実装です。  
  
 これを \* メソッドの実装の目的は、イベントが発生して、この同じメソッドの実装が内部的に呼び出され、イベントを発生させるときに、 <xref:System.Windows.ContentElement.IsFocused%2A> プロパティ値が変更されます。 この実装が異なるその他の [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] に \* のみそのイベントのクラス処理を追加する便利な手段を提供の実装です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation. Otherwise, the <see cref="E:System.Windows.ContentElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element. If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> タッチのキャプチャを失ったときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> を処理する派生クラスで、 <xref:System.Windows.ContentElement.LostTouchCapture> イベントです。 必ず、基本クラスの <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、押されたマウス ボタンおよび処理済み状態に関する詳細を報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.ContentElement.OnMouseDown%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.ContentElement.MouseLeftButtonDown> と <xref:System.Windows.ContentElement.MouseRightButtonDown>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.ContentElement.OnMouseDown%2A>, 、下にはアクションのすべての可能なマウス ボタンのクラス処理を考慮できるという意味です。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、直接ルーティング方法と、ルーティングされたイベント。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 添付イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、直接ルーティング方法と、ルーティングされたイベント。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> ルーティング イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.MouseLeftButtonDown> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.ContentElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.ContentElement.MouseLeftButtonDown>します。 マークすることができますが、 <xref:System.Windows.ContentElement.MouseLeftButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.ContentElement> リッスン <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.ContentElement> をオーバーライドして <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Button> させ <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> 、派生クラスで基本クラスの実装を呼び出さずにただし、このオーバーライドを無効に、 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.MouseLeftButtonUp> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.ContentElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.ContentElement.MouseLeftButtonUp>します。 マークすることができますが、 <xref:System.Windows.ContentElement.MouseLeftButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.ContentElement> リッスン <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.ContentElement> をオーバーライドして <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.MouseRightButtonDown> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.ContentElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.ContentElement.MouseRightButtonDown>します。 マークすることができますが、 <xref:System.Windows.ContentElement.MouseRightButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.ContentElement> リッスン <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.ContentElement> をオーバーライドして <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Control> させ <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> 呼び出しベースにしていることがなく、派生クラスで、このオーバーライドを無効に含まれている、管理上のコンテキスト\] メニューの \[サービスの <xref:System.Windows.Controls.Control> の既定の動作です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.MouseRightButtonUp> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.ContentElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.ContentElement.MouseRightButtonUp>します。 マークすることができますが、 <xref:System.Windows.ContentElement.MouseRightButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.ContentElement> リッスン <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.ContentElement> をオーバーライドして <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウス ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.ContentElement.OnMouseUp%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.ContentElement.MouseLeftButtonUp> と <xref:System.Windows.ContentElement.MouseRightButtonUp>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.ContentElement.OnMouseUp%2A>, 、クラス処理をすべての可能なマウスのボタンの操作を考慮できることが示すされます。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>未処理の<see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 添付ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> と <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, 、下にはアクションのすべての可能なマウス ボタンのクラス処理を考慮できるという意味です。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.ContentElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>します。 マークすることができますが、 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.ContentElement> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.ContentElement> をオーバーライドして <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Button> させ <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> 、派生クラスで基本クラスの実装を呼び出さずにただし、このオーバーライドを無効に、 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.ContentElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>します。 マークすることができますが、 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.ContentElement> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.ContentElement> をオーバーライドして <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.ContentElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.ContentElement.MouseRightButtonDown>します。 マークすることができますが、 <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.ContentElement> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.ContentElement> をオーバーライドして <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Control> させ <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> 呼び出しベースにしていることがなく、派生クラスで、このオーバーライドを無効に含まれている、管理上のコンテキスト\] メニューの \[サービスの <xref:System.Windows.Controls.Control> の既定の動作です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.ContentElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>します。 マークすることができますが、 <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.ContentElement> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.ContentElement> をオーバーライドして <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> と <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, 、クラス処理をすべての可能なマウスのボタンの操作を考慮できることが示すされます。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> タッチがこの要素を押したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> を処理する派生クラスで、 <xref:System.Windows.ContentElement.PreviewTouchDown> イベントです。 必ず、基本クラスの <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> タッチがこの要素内に移動したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> を処理する派生クラスで、 <xref:System.Windows.ContentElement.PreviewTouchMove> イベントです。 必ず、基本クラスの <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> を処理する派生クラスで、 <xref:System.Windows.ContentElement.PreviewTouchUp> イベントです。 必ず、基本クラスの <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的は、のような [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的は、のような [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.ContentElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.ContentElement.TouchDown" /> タッチがこの要素の内部を押したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.OnTouchDown%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.ContentElement.OnTouchDown%2A> を処理する派生クラスで、 <xref:System.Windows.ContentElement.TouchDown> イベントです。 必ず、基本クラスの <xref:System.Windows.ContentElement.OnTouchDown%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.ContentElement.TouchEnter" /> ルーティングされたイベントから、タッチに移動したときに発生するこの要素の境界内に外部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.OnTouchEnter%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.ContentElement.OnTouchEnter%2A> を処理する派生クラスで、 <xref:System.Windows.ContentElement.TouchEnter> イベントです。 必ず、基本クラスの <xref:System.Windows.ContentElement.OnTouchEnter%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.ContentElement.TouchLeave" /> からタッチを移動するときに発生するルーティングされたイベントにこの要素の範囲外の内部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.OnTouchLeave%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.ContentElement.OnTouchLeave%2A> を処理する派生クラスで、 <xref:System.Windows.ContentElement.TouchLeave> イベントです。 必ず、基本クラスの <xref:System.Windows.ContentElement.OnTouchLeave%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.ContentElement.TouchMove" /> タッチがこの要素内に移動したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.OnTouchMove%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.ContentElement.OnTouchMove%2A> を処理する派生クラスで、 <xref:System.Windows.ContentElement.TouchMove> イベントです。 必ず、基本クラスの <xref:System.Windows.ContentElement.OnTouchMove%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.ContentElement.TouchUp" /> タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.OnTouchUp%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.ContentElement.OnTouchUp%2A> を処理する派生クラスで、 <xref:System.Windows.ContentElement.TouchUp> イベントです。 必ず、基本クラスの <xref:System.Windows.ContentElement.OnTouchUp%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">要求されたフォーカスの移動の方向です。</param>
        <summary>派生クラスでオーバーライドされた場合は、実際にその要素にフォーカスを移動せず指定したフォーカスの移動の方向のフォーカスを受け取る要素を返します。</summary>
        <returns>要素がフォーカスを受け取った場合 <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> が実際に呼び出されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このクラスでは、このメソッドの既定の実装は完了せず、常に返します `null`します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewDragEnter> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewDragEnter> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.DragEnter>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewDragLeave> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewDragLeave> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.DragLeave>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewDragOver> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewDragOver> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.DragOver>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewDrop> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewDrop> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.Drop>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewDrop%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewDrop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作が開始されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.PreviewGiveFeedback> イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewGiveFeedback> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewGiveFeedback> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.GiveFeedback>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、ルーティングのトンネリングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際にアタッチされている要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスがある実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.GotKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがある状態でいずれかのキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーの処理は、コマンドの実行とテキストの合成などの他のプラットフォーム機能と対話します。<xref:System.Windows.ContentElement.KeyDown> イベントは、下位レベルのテキストの入力イベントの特定のコントロールで期待どおりに動作しません。 これは、一部のコントロールがコントロールの複合か、テキストの高レベルのバージョンを提供するクラスの処理が入力処理および関連するイベントです。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewKeyDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewKeyDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.KeyDown>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがある状態でキーが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーの処理は、コマンドの実行とテキストの合成などの他のプラットフォーム機能と対話します。<xref:System.Windows.ContentElement.KeyUp> イベントは、下位レベルのテキストの入力イベントの特定のコントロールで期待どおりに動作しません。 これは、一部のコントロールがコントロールの複合か、テキストの高レベルのバージョンを提供するクラスの処理が入力処理および関連するイベントです。 詳細については、個々 のコントロールのマニュアルを確認します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewKeyUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewKeyUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.KeyUp>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、ルーティングのトンネリングを使用しているために、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.LostKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewMouseDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewMouseDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.ContentElement.PreviewMouseDown> イベントは、多くの場合、いずれかと共に <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> または <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, 、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> または <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>です。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.MouseDown>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.ContentElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントの引数を公開、基になる引数 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.ContentElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.ContentElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.ContentElement>します。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.ContentElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントの引数を公開、基になる引数 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.ContentElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.ContentElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.ContentElement>します。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントが発生した両方要素境界内にマウス ポインターが最初に入ると、マウス ポインターが要素の境界内に残っているときに移動するともとします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewMouseMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewMouseMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.MouseMove>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.ContentElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントの引数を公開、基になる引数 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.ContentElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.ContentElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.ContentElement>します。  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.ContentElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントの引数を公開、基になる引数 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.ContentElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.ContentElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.ContentElement>します。  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewMouseUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewMouseUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.ContentElement.PreviewMouseUp> イベントは、多くの場合、いずれかと共に <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> または <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, 、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> または <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>です。  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.MouseUp>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。そのため、フォーカスがあるか、キャプチャした要素からこのイベントを受信する場合、マウス ポインターのほう別の要素上です。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewMouseMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewMouseMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.MouseWheel>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作をキャンセルする必要があるかどうかを宣言します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.QueryContinueDrag>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewStylusButtonDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewStylusButtonDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.StylusButtonDown>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewStylusButtonUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewStylusButtonUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.StylusButtonUp>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewStylusDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewStylusDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.StylusDown>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewStylusInAirMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewStylusInAirMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.StylusInAirMove>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewStylusInRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewStylusInRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.StylusInRange>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスが要素上にあるときにスタイラスが移動すると発生します。 このイベントを発生させるためには、スタイラスがデジタイザーによって検出されているときにスタイラスが移動する必要があります。移動しない場合は、代わりに <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> が発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewStylusMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewStylusMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.StylusMove>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがデジタイザーから離れすぎているために検出されないときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.StylusOutOfRange>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスのジェスチャについては、次を参照してください。 <xref:System.Windows.Input.SystemGesture>します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.StylusSystemGesture>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewStylusDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewStylusDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.StylusUp>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.PreviewTextInput> イベントは、コンポーネントまたはデバイスに依存しない方法でテキストの入力を待機するアプリケーションを使用します。 キーボードの主要な手段は、 <xref:System.Windows.ContentElement.PreviewTextInput>; が、音声認識、手書き認識、およびその他の入力デバイスも <xref:System.Windows.ContentElement.PreviewTextInput>です。  
  
 キーの組み合わせのため、既定のキーボードまたは入力方式エディターを通じて\-複数のキー イベントが 1 つだけのテキスト入力イベントを発生させる可能性があります。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.PreviewTextInput> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.PreviewTextInput> イベントは、基になるに関連付けられている <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.TextInput>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、 <xref:System.Windows.ContentElement.PreviewTouchDown> と <xref:System.Windows.ContentElement.TouchDown> 指が画面をタッチし、移動するまでのイベントが発生しません。 画面に指を押すと、により、キーを押して移動せず保持しているとの動作を保持する <xref:System.Windows.Input.Stylus>です。 プレス アンド ホールド動作では、マウスの右クリックに相当します。  
  
 発生する、 <xref:System.Windows.ContentElement.PreviewTouchDown> と <xref:System.Windows.ContentElement.TouchDown> 指が、画面をタッチするとすぐに発生するイベントの設定、 <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName> 添付プロパティを `false` この要素のです。  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.TouchDown>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.TouchMove>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するバブル イベントが <xref:System.Windows.ContentElement.TouchUp>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.QueryContinueDrag> イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作をキャンセルする必要があるかどうかを決定します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.QueryContinueDrag> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.QueryContinueDrag> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カーソルの表示が要求されると発生します。 このイベントは、マウス ポインターが別の位置へ移動するたびに要素上で発生します。したがって、場合によってはカーソル オブジェクトを移動先の位置に基づいて変更する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.QueryCursor> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.QueryCursor> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 このイベントの名前によって参照されているカーソルは、必ずしも \(挿入ポイントとも呼ばれ\) テキストのカーソルではありません。 代わりに、いくつかの可能な入力に関連するデバイスまたはの概念に関連する画面に表示されるグラフィカルな表示を宣言するオブジェクトは、このコンテキストでのカーソル [!INCLUDE[TLA2#tla_win](~/includes/tla2sharptla-win-md.md)] プログラミングします。 そのオブジェクトがによって表される、 <xref:System.Windows.Input.Cursor> クラス [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]します。[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 入力システムでは、マウス ポインターの画面上の位置を表す場合は、このカーソルを変更することができます。 定義済みの値を使用して、 <xref:System.Windows.Input.Cursors> 列挙型、またはするには、画像ファイルとしてカスタムのカーソルを宣言できます。  
  
 リッスン、 <xref:System.Windows.ContentElement.QueryCursor> イベントは、カーソルの管理のための効率的な手法ではありません。 各要素がで独自のカーソル動作を定義する代わりに、 <xref:System.Windows.FrameworkContentElement.Cursor%2A> と <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>です。 ブラウザー リダイレクトにのみ依存 <xref:System.Windows.ContentElement.QueryCursor> WPF フレームワーク レベルの基本要素を使用していないかで異常な場合に、カーソルの動作を定義する要素ごとの単位ではニーズに合わないかどうか。 応答でのカーソルの動作の実装の詳細については <xref:System.Windows.ContentElement.QueryCursor>, を参照してください <xref:System.Windows.Input.QueryCursorEventHandler>します。  
  
<a name="routedEventInfo_QueryCursor"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnQueryCursor%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.QueryCursor" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納し、発生するイベントを識別する <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>特定のルーティング イベントを発生させます。 発生する <see cref="T:System.Windows.RoutedEvent" /> は、提供された <see cref="T:System.Windows.RoutedEventArgs" /> インスタンス内で識別されます \(そのイベント データの <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティとして\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `e` パラメーターは、ルーティングされたイベントのすべてのデータの共通の基本型として型指定された、ただし、イベント データを与えるために、生成されたイベントに対して使用可能な最も限定のイベント データの種類として必要があります。 <xref:System.Windows.RoutedEventArgs> 派生クラスでは、特定のイベントが発生したときに特定の実際のデータ プロパティが含まれています。  
  
 <xref:System.Windows.RoutedEventArgs> イベントの状態のプロパティだけではありません。ルーティングされたイベントを発生させるも特定します。 このイベントの発生パターンと、ルーティングされたイベント データの両方とは異なる [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントに関連するプロパティを通常だけが含まれるイベントおよびデータのクラスです。  
  
   
  
## 例  
 次の例は、イベント データを作成、イベント識別子をデータに追加し、カスタム ルーティング イベントを発生させるイベント データ インスタンスを使用します。  
  
 [!code-csharp[ContentElementsSmorgasbord\#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord\#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素からすべてのキャプチャされたタッチ デバイスを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素には、キャプチャが保持されている場合は、マウスのキャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この要素がキャプチャを保持していない場合は、このメソッドを呼び出しても効果はありません。 値を確認してください <xref:System.Windows.ContentElement.IsMouseCaptured%2A> このメソッドを呼び出す前にします。  
  
   
  
## 例  
 次のハンドラーは、キャプチャまたはマウス ボタンの状態に従ってマウスのキャプチャを解放します。 例では、な用途のためマウス ポインターを移動するよりもその他の代わりに、キャプチャしたマウスの動きを使用する方法を示しています、 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]です。  
  
 [!code-csharp[ContentElementsSmorgasbord\#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord\#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素には、キャプチャが保持されている場合は、スタイラス デバイスのキャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この要素がキャプチャを保持していない場合は、このメソッドを呼び出しても効果はありません。 値を確認してください <xref:System.Windows.ContentElement.IsStylusCaptured%2A> このメソッドを呼び出す前にします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">解放するデバイスです。</param>
        <summary>この要素から指定されたタッチ デバイスを解放しようとしています。</summary>
        <returns>
          <see langword="true" /> タッチ デバイスが解放された場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドラーがアタッチされているルーティング イベントの識別子。</param>
        <param name="handler">この要素のイベント ハンドラー コレクションから削除する特定のハンドラー実装。</param>
        <summary>指定したルーティング イベント ハンドラーをこの要素から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これを使用するための最も一般的なシナリオ [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] を実装する場合は、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] カスタム ルーティング イベントのハンドラーの"remove"ロジックを実装するときに特に関連付けられている「ラッパー」イベント、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] レベルです。 これを次の例「解説」のセクションでは、このシナリオを示しています。  
  
 このメソッドを呼び出しても何も起こりませんメソッド呼び出しの入力パラメーターと一致する基準で登録されたハンドラーが存在しない場合。  
  
 複数のイベント ハンドラーのストアが削除される最初のハンドラーにのみ、条件に一致する 1 つのハンドラーがアタッチされます。 この動作は [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] の動作、 `-=` 演算子。  
  
 どちらも `routedEvent` も `handler` あります `null`します。 いずれかの値として入力しようとしています。 `null` 、例外が発生します。  
  
 このメソッドは無視、 `handledEventsToo` 場合は、ハンドラーが最初に提供されるパラメーターについては、追加、 <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 処理済みのイベントの処理を有効に署名します。 ハンドラーのいずれかの種類が削除されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスでの内容をシリアル化する必要かどうかを返す、 <see cref="P:System.Windows.ContentElement.CommandBindings" /> このクラスのインスタンスのプロパティです。</summary>
        <returns>
          <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.ContentElement.CommandBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるには `true` 場合 <xref:System.Windows.ContentElement.CommandBindings%2A> ローカルに設定します。  
  
 これは、 `ShouldSerialize` ために、メソッドが提供される、 <xref:System.Windows.UIElement.CommandBindings%2A> プロパティには、単純な既定値はありません。 このメソッドは、プロパティが既定値から変更されたかどうかを示します。 デザイナーを開発または独自コントロールを組み込むことを開発する場合に通常、このメソッドが呼び出す、 <xref:System.Windows.UIElement>です。  
  
 詳細については、「[ShouldSerialize and Reset Methods](http://msdn.microsoft.com/ja-jp/7b6c5e00-3771-46b4-9142-5a80d5864a5e)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスでの内容をシリアル化する必要かどうかを返す、 <see cref="P:System.Windows.ContentElement.InputBindings" /> このクラスのインスタンスのプロパティです。</summary>
        <returns>
          <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.ContentElement.InputBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるには `true` 場合 <xref:System.Windows.ContentElement.InputBindings%2A> ローカルに設定します。  
  
 これは、 `ShouldSerialize` ために、メソッドが提供される、 <xref:System.Windows.UIElement.InputBindings%2A> プロパティには、単純な既定値はありません。 このメソッドは、プロパティが既定値から変更されたかどうかを示します。 デザイナーを開発または独自コントロールを組み込むことを開発する場合に通常、このメソッドが呼び出す、 <xref:System.Windows.UIElement>です。  
  
 詳細については、「[ShouldSerialize and Reset Methods](http://msdn.microsoft.com/ja-jp/7b6c5e00-3771-46b4-9142-5a80d5864a5e)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusButtonDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusButtonDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewStylusButtonDown>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusButtonUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusButtonUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewStylusButtonUp>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewStylusDown>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.StylusEnter> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 直接イベント ルーティング方法の処理を使用します。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、ルーティング イベントの動作のスタイルでイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.ContentElement.StylusEnter> スタイラスがこのイベントをさらに、要素の境界に入った時点を追跡するレポート文字どおり、 <xref:System.Windows.ContentElement.IsStylusOver%2A> からプロパティ値が変更 `false` に `true` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusEnter> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusEnter> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusInAirMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusInAirMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewStylusInAirMove>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusInRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusInRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusInRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewStylusInRange>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusInRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスが要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.ContentElement.StylusLeave> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 直接イベント ルーティング方法の処理を使用します。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、ルーティング イベントの動作のスタイルでイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.ContentElement.StylusLeave> スタイラスから削除すると、このイベント要素の境界の詳細のトラックが文字どおり報告された、 <xref:System.Windows.ContentElement.IsStylusOver%2A> からプロパティ値が変更 `true` に `false` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusLeave> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusLeave> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素上を移動すると発生します。 このイベントを発生させるには、デジタイザー上でスタイラスを移動する必要があります。 それ以外の場合は、代わりに <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> が発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewStylusMove>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスが検出可能になるにはデジタイザーから離れすぎているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusOutOfRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusOutOfRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスのジェスチャの詳細については、次を参照してください。 <xref:System.Windows.Input.SystemGesture>します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusSystemGesture> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusSystemGesture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.StylusUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.StylusUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewStylusUp>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnStylusUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.StylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  このイベントは、複合コントロールの内部の実装で処理されるに既にマーク可能性があります。 以下の解説を参照してください。  
  
 <xref:System.Windows.ContentElement.TextInput> イベントは、複合コントロールの内部実装によって処理済みとして既にマークことがあります。 など、 <xref:System.Windows.Controls.TextBox> 複合コントロールは、ここで、 <xref:System.Windows.ContentElement.TextInput> ; 内の合成処理として、イベントは既に設定されています。 コントロールは、この操作するため、コントロールがいくつかの種類のコントロールに特別な意味を持つものとして、方向キーなどの入力を解釈する必要があります。 使用する場合 <xref:System.Windows.ContentElement.PreviewTextInput> テキスト入力用のハンドラーをアタッチする、イベントとしてより良い結果が表示される場合があります。 この手法は、コントロールの複合が済みとマークされたこのイベントを処理し、ハンドラーがイベントの経路上のイベントを受信できないように、ほとんどの場合を回避できます。  
  
 <xref:System.Windows.ContentElement.TextInput> イベントは、コンポーネントまたはデバイスに依存しない方法でテキストの入力を待機するアプリケーションを使用します。 キーボードの主要な手段は、 <xref:System.Windows.ContentElement.TextInput>, 、音声認識、手書き認識、およびその他の入力デバイス上げることもできますが、 <xref:System.Windows.ContentElement.TextInput>です。  
  
 キーの組み合わせのため、既定のキーボードまたは入力方式エディターを通じて\-複数のキー イベントが 1 つのテキスト入力イベントを発生させる可能性があります。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.ContentElement.TextInput> 一部であるクラスのメンバーのリスト <xref:System.Windows.ContentElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.ContentElement.TextInput> イベントは、基になるに関連付けられている <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_TextInput"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TextInputEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewTextInput>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnTextInput%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.TextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、 <xref:System.Windows.ContentElement.PreviewTouchDown> と <xref:System.Windows.ContentElement.TouchDown> 指が画面をタッチし、移動するまでのイベントが発生しません。 画面に指を押すと、により、キーを押して移動せず保持しているとの動作を保持する <xref:System.Windows.Input.Stylus>です。 プレス アンド ホールド動作では、マウスの右クリックに相当します。  
  
 発生する、 <xref:System.Windows.ContentElement.PreviewTouchDown> と <xref:System.Windows.ContentElement.TouchDown> 指が、画面をタッチするとすぐに発生するイベントの設定、 <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName> 添付プロパティを `false` この要素のです。  
  
<a name="routedEventInfo_TouchDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewTouchDown>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnTouchDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.TouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがから移動すると発生外部からこの要素の範囲内です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは発生常にこの UI 要素にタッチ デバイスがキャプチャされるかどうか。  
  
<a name="routedEventInfo_TouchEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnTouchEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.TouchEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキャプチャされているすべてのタッチ デバイスを取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素にキャプチャされているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ビジュアル ツリーで、この要素にキャプチャされているすべてのタッチ デバイスまたはすべての子要素を取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上にあるすべてのタッチ デバイスを取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素上にあるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ビジュアル ツリーで、この要素上にあるすべてのタッチ デバイスまたはすべての子要素を取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素またはそのビジュアル ツリー内のすべての子要素の上にあるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがから移動すると発生するこの要素の範囲外の内部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_TouchLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnTouchLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.TouchLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_TouchMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewTouchMove>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnTouchMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.TouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_TouchUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.ContentElement.PreviewTouchUp>です。  
  
-   オーバーライド <xref:System.Windows.ContentElement.OnTouchUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.ContentElement.TouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素で指定した依存関係プロパティにアニメーションを適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したルーティング イベントのためのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素で指定したプロパティのアニメーションを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>