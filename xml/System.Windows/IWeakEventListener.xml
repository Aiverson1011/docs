<Type Name="IWeakEventListener" FullName="System.Windows.IWeakEventListener">
  <TypeSignature Language="C#" Value="public interface IWeakEventListener" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IWeakEventListener" />
  <TypeSignature Language="DocId" Value="T:System.Windows.IWeakEventListener" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>WeakEvent パターンを通じてイベントを受信するクラスのイベントをリッスンしているサポートを提供し、 <see cref="T:System.Windows.WeakEventManager" />です。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.WeakEventManager> \(ディスパッチャ\) を呼び出してイベントを転送する、 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> このインターフェイスを実装して、呼び出すことによってリスナーとして追加されているクラスのメソッド <xref:System.Windows.WeakEventManager> 事前メソッドです。  
  
 WeakEvent パターンの主な理由は、イベント ソースに、イベント リスナーの可能性がある独立したオブジェクトの有効期間がある場合があります。 中心となるイベントのディスパッチを使用して、 <xref:System.Windows.WeakEventManager> ガベージ リスナーのハンドラーが収集する \(または手動で削除\) を有効場合でも、ソース オブジェクトの有効期間は、リスナー越えています。 これに対しを使用して通常のイベント フックアップ `+=` や構文の同等の言語に固有のイベント ハンドラーへの強い参照を保持するためにまだ接続して可能性のあるソースが発生します。 これは、適切なタイミングでガベージ コレクトされないリスナーの参照を保持します。  
  
 ソースとリスナー間のリレーションシップがこのパターンの使用を提案する 1 つの一般的な状況は、データ バインド用にソース更新イベントの処理です。  
  
 WeakEvent パターンを使用すると、アプリケーションの外部イベントをリッスンします。 のみを定義する必要があります、 <xref:System.Windows.WeakEventManager> でリッスンしている動作を提供し、 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A>, を使用して、 <xref:System.Windows.WeakEventManager> 参照、ハンドラーをアタッチするのにはなく `+=`です。  
  
   
  
## 例  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.WeakEventManager" />
  </Docs>
  <Members>
    <Member MemberName="ReceiveWeakEvent">
      <MemberSignature Language="C#" Value="public bool ReceiveWeakEvent (Type managerType, object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReceiveWeakEvent(class System.Type managerType, object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.IWeakEventListener.ReceiveWeakEvent(System.Type,System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="managerType">種類、 <see cref="T:System.Windows.WeakEventManager" /> このメソッドを呼び出すことです。</param>
        <param name="sender">イベントを発生させたオブジェクト。</param>
        <param name="e">イベント データ。</param>
        <summary>中央のイベント マネージャーからイベントを受信します。</summary>
        <returns>
          <see langword="true" /> リスナーは、イベントを処理します。 によってエラーと見なされます、 <see cref="T:System.Windows.WeakEventManager" /> 処理 WPF リスナーを処理しないイベントのリスナを登録します。 メソッドが返す必要がありますかを問わず、 <see langword="false" /> が認識または処理しないイベントを受信した場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、実装 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> 2 つの仮想的なイベントの WeakEvent パターンをサポートする `ClockwiseSpin` と `CounterclockwiseSpin` 専用ある <xref:System.Windows.WeakEventManager> \(非表示\)。 この実装は、イベント データをキャスト、サポートされている各イベントのクラス ハンドラー スタブを呼び出します \(この場合、2 つのイベントがイベントのデータ型を共有 `SpinEventArgs`\)。 実装は、 `false` 受信したイベントが予想される場合。  
  
 [!code-csharp[CorePseudocode\#IWeakEventListener](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#iweakeventlistener)]
 [!code-vb[CorePseudocode\#IWeakEventListener](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#iweakeventlistener)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This method is intended to receive all possible events where the receiver is in a listener list. Particularly if implementing for a class that is listening for more than one event, you must check the type of the incoming <paramref name="managerType" /> parameter in order to know which event the call corresponds to. This is why each event that is to be part of the pattern must have a dedicated <see cref="T:System.Windows.WeakEventManager" />. Also, the <paramref name="e" /> parameter is typed as the general <see cref="T:System.EventArgs" />. Therefore, in order get any specific properties out of the event data, your implementation will need to cast to the specific event data type.  
  
 Typically, after checking for the identity of the event based on the <see cref="T:System.Windows.WeakEventManager" /> type, your implementation should call a private class handler. Your class handler could conceivably be the very same class handler that is used to handle that event for listeners that are added through the conventional event pattern of adding via <see langword="+=" /> to the event on the sender. The following example section provides a rough implementation template.</para>
        </block>
        <altmember cref="T:System.Windows.WeakEventManager" />
      </Docs>
    </Member>
  </Members>
</Type>