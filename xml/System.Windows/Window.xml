<Type Name="Window" FullName="System.Windows.Window">
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>作成、構成、表示、およびウィンドウとダイアログ ボックスの有効期間を管理する機能を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 ユーザーとスタンドアロン アプリケーションの間の対話ポイントは、ウィンドウです。 A [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] ウィンドウは、2 つの領域で構成されます。  
  
-   アイコン、タイトル、システム メニューの windows の表示要素をホストする非クライアント領域は、最小化ボタン、ボタン、\[復元\] ボタン、\[閉じる\] ボタン、および罫線を最大化します。  
  
-   アプリケーション固有のコンテンツをホストしているクライアント領域です。  
  
 標準のウィンドウは、次の図で示されます。  
  
 271ac3d9-a442-4ef9-b596-8104944a513e  
  
 <xref:System.Windows.Window> 作成、構成、表示、および windows とダイアログ ボックスの両方の有効期間を管理する機能をカプセル化し、次の主要サービスを提供します。  
  
 **Lifetime Management**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **ウィンドウ管理**: <xref:System.Windows.Window.GetWindow%2A>, 、<xref:System.Windows.Window.OwnedWindows%2A>, 、<xref:System.Windows.Window.Owner%2A>です。  
  
 **Appearance and Behavior**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **ダイアログ ボックス**: <xref:System.Windows.Window.DialogResult%2A>, 、<xref:System.Windows.Window.ShowDialog%2A>です。  
  
 さらに、 <xref:System.Windows.Application> のすべてのアプリケーションでウィンドウを管理するための特別なサポートを公開します。  
  
-   アプリケーションでは、現在アプリケーションでインスタンス化されているすべてのウィンドウのリストを保持します。 この一覧がによって公開されている、 <xref:System.Windows.Application.Windows%2A> プロパティです。  
  
-   既定では、 <xref:System.Windows.Application.MainWindow%2A> 最初への参照で自動的に設定されている <xref:System.Windows.Window> アプリケーションでインスタンス化されています。 そのため、このウィンドウ アプリケーションのメイン ウィンドウ。  
  
 A <xref:System.Windows.Window> マークアップ、マークアップおよび分離コード、またはコードを使用して実装できます。  
  
 <xref:System.Windows.Window> windows およびスタンドアロン アプリケーションのダイアログ ボックスを表示する、主に使用します。 ただし、ウィザードなど、ウィンドウ レベルのナビゲーションを必要とするアプリケーションを使用できます <xref:System.Windows.Navigation.NavigationWindow> 代わりに、 <xref:System.Windows.Navigation.NavigationWindow> から派生 <xref:System.Windows.Window> し、ブラウザ スタイルのナビゲーションのサポートを拡張します。  
  
> [!NOTE]
>  使用して他のコンテンツおよびコンテンツのコンテナーにナビゲート可能なコンテンツの島を組み込むことが <xref:System.Windows.Controls.Frame>です。  
  
 <xref:System.Windows.Window> 必要な `UnmanagedCode` をインスタンス化するためのセキュリティ アクセス許可。 これは、次のような影響があります。  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]\-展開済みのスタンドアロン アプリケーションは、インターネットまたはローカル イントラネット ゾーンから起動すると、アクセス許可の昇格を要求します。  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 何も依頼未満の完全なアクセス許可では、ウィンドウやダイアログ ボックスのインスタンスを作成できません。  
  
 スタンドアロン アプリケーションの配置とセキュリティの考慮事項については、次を参照してください。 [WPF のセキュリティ方針 \- プラットフォーム セキュリティ](http://msdn.microsoft.com/ja-jp/2a39a054-3e2a-4659-bcb7-8bcea490ba31)します。  
  
 A <xref:System.Windows.Window> は、 <xref:System.Windows.Controls.ContentControl>, 、つまり、任意の型 \(文字列、イメージ、パネルなど\) の 1 つのオブジェクトを含めることができます。 詳細については、<xref:System.Windows.Controls.ContentControl> クラスを参照してください。 また、 <xref:System.Windows.Window> がルートであり、そのため、別の要素のコンテンツの一部をすることはできません。  
  
> [!NOTE]
>  <xref:System.Windows.FrameworkElement.Height%2A>, 、<xref:System.Windows.FrameworkElement.Width%2A>, 、<xref:System.Windows.Window.Top%2A>, 、および <xref:System.Windows.Window.Left%2A> に設定されたプロパティ、 <xref:System.Windows.Window> スタイルでは適用されません実行時にします。  
  
## ウィンドウ コントロールのカスタマイズ  
 複数に同じプロパティ設定を適用する <xref:System.Windows.Window> コントロールを使用して、 <xref:System.Windows.FrameworkElement.Style%2A> プロパティです。 既定値を変更する <xref:System.Windows.Controls.ControlTemplate> コントロール固有の外観を与えるためです。 作成の詳細については、 <xref:System.Windows.Controls.ControlTemplate>, を参照してください [ControlTemplate を作成することで、既存のコントロールの外観のカスタマイズ](http://msdn.microsoft.com/ja-jp/678dd116-43a2-4b8c-82b5-6b826f126e31)します。  パーツおよびに固有の状態を確認する、 <xref:System.Windows.Window>, を参照してください [ウィンドウのスタイルとテンプレート](http://msdn.microsoft.com/ja-jp/2dfdf025-347b-4342-bf28-95206c273f35)します。  
  
 コントロールの既定のスタイルでは、このコントロールの依存関係プロパティを設定する場合があります。  プロパティが既定のスタイルが設定されている場合、アプリケーションでコントロールが表示されたときに、プロパティが既定値から変更可能性があります。 既定のスタイルは、デスクトップ テーマでは、アプリケーションが実行されているときに使用が決定されます。  詳細については、次を参照してください。 [Default WPF Themes](http://go.microsoft.com/fwlink/?LinkID=158252)します。  
  
> [!NOTE]
>  Visual プロパティの設定は効果プロパティは、両方に存在する場合 <xref:System.Windows.Window> コントロールの既定のテンプレートとを使用して設定します。 「を変更する視覚的構造の、」の「コントロール」セクションで visual プロパティの一覧が見つかります [ControlTemplate 作成することで、既存のコントロールの外観のカスタマイズ](http://msdn.microsoft.com/ja-jp/678dd116-43a2-4b8c-82b5-6b826f126e31)します。  
  
   
  
## 例  
 次の例は、ウィンドウの標準的なのマークアップのみを使用して定義します。  
  
 [!code-xml[WindowSnippets\#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 コードのみを使用して標準的なウィンドウを定義する方法を例を示します。  
  
 [!code-csharp[WindowSnippets\#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets\#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 次の例は、ウィンドウの標準的なのマークアップおよび分離コードの組み合わせを使用して定義します。  
  
 [!code-xml[WindowSnippets\#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets\#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets\#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Window" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コンス トラクターは、 <xref:System.Windows.FrameworkElement.Width%2A>, 、<xref:System.Windows.FrameworkElement.Height%2A>, 、<xref:System.Windows.Window.Top%2A>, 、および <xref:System.Windows.Window.Left%2A> プロパティを既定の <xref:System.Windows.Window> 値。  
  
 内で、ウィンドウが作成された場合、 <xref:System.AppDomain> を持つ、 <xref:System.Windows.Application> オブジェクトのコンス トラクターを追加、 <xref:System.Windows.Window> オブジェクトのセットを <xref:System.Windows.Application>\-経由で windows の管理、 <xref:System.Windows.Application.Windows%2A> のプロパティ、 <xref:System.Windows.Application> オブジェクトです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission for this object to call unsafe native methods. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ウィンドウが前面に移動しようとしてアクティブ化します。</summary>
        <returns>
          <see langword="true" /> 場合、 <see cref="T:System.Windows.Window" /> が正常に有効になっているそれ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ウィンドウがアクティブかどうかを決定する規則で使用されるものと同じ、 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` 関数 \(User32.dll\)。  
  
 ウィンドウがアクティブ化される場合、 [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] ユーザーのフォア グラウンドのアプリケーションではないアプリケーションを <xref:System.Windows.Application.Activated> イベントが発生します。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">for permission to activate a window. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウがフォアグラウンド ウィンドウになったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A window is activated \(becomes the foreground window\) when:  
  
-   The window is first opened.  
  
-   A user switches to a window by selecting it with the mouse, pressing ALT\+TAB, or from Task Manager.  
  
-   A user clicks the window's taskbar button.  
  
 Windows that need to detect when they become activate can handle the <xref:System.Windows.Window.Activated> event.  
  
 After a window is first activated, it may be deactivated and reactivated many times during its lifetime. If an application's behavior or state depends on its activation state, it can inspect <xref:System.Windows.Window.IsActive%2A> to determine which activation state it's in.  
  
 An application can also be <xref:System.Windows.Application.Activated>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはウィンドウのクライアント領域が透明度をサポートするかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> ウィンドウが透明度をサポートしている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Windows.Controls.Control.Background%2A> ウィンドウのプロパティが、透明に設定を使用したカラー <xref:System.Windows.Media.Brushes.Transparent%2A> ウィンドウは非透過的なままなどです。 つまり、デスクトップと、実行中のアプリケーション"beneath"ウィンドウを表示できません。 この種類の透明度を有効にする <xref:System.Windows.Window.AllowsTransparency%2A> に設定する必要があります `true`します。  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> 四角形以外の windows の作成を支援するが存在して、その結果、ときに <xref:System.Windows.Window.AllowsTransparency%2A> に設定されている `true`, 、ウィンドウの <xref:System.Windows.Window.WindowStyle%2A> にプロパティを設定する必要があります <xref:System.Windows.WindowStyle.None>します。  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">持つウィンドウ、 <see cref="P:System.Windows.Window.WindowStyle" /> 以外の値の値 <see cref="F:System.Windows.WindowStyle.None" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.AllowsTransparency" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">A <see cref="T:System.Windows.Size" /> ウィンドウが自体とその子を配置に使用する最終的なサイズを反映します。</param>
        <summary>配置やウィンドウとその子要素のサイズを変更するには、このメソッドをオーバーライドします。</summary>
        <returns>A <see cref="T:System.Windows.Size" /> 使用された実際のサイズを反映します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.ArrangeOverride%2A> 場合に呼び出さない、 <xref:System.Windows.UIElement.Visibility%2A> プロパティの値を持つ <xref:System.Windows.Visibility.Collapsed>です。 場合の値、 <xref:System.Windows.UIElement.Visibility%2A> プロパティが、 <xref:System.Windows.Visibility.Hidden> または <xref:System.Windows.Visibility.Visible>, 、<xref:System.Windows.Window.ArrangeOverride%2A> が呼び出されます。  
  
> [!NOTE]
>  ときにいずれか <xref:System.Windows.Window.Show%2A> または <xref:System.Windows.Window.ShowDialog%2A> を呼び出すと、 <xref:System.Windows.UIElement.Visibility%2A> のプロパティ、 <xref:System.Windows.Window> に設定されている <xref:System.Windows.Visibility.Visible>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>手動で閉じる、 <see cref="T:System.Windows.Window" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Windows.Window> いくつかは、いずれかを使用して閉じることがよく知られている、システムによって提供されるメカニズムは、そのなど、タイトル バーにあります。  
  
-   ALT キーを押しながら F4 キー。  
  
-   システム メニュー &#124; **Close**.  
  
-   **閉じる** \] ボタンをクリックします。  
  
 A <xref:System.Windows.Window> を含めて、開発者から提供されているクライアント領域内のいくつかのよく知られているメカニズムのいずれかを使用して終了することもできます。  
  
-   **File** &#124; **終了** メイン ウィンドウにします。  
  
-   **File** &#124; **閉じる** または **閉じる** 子ウィンドウのボタンをクリックします。  
  
> [!NOTE]
>  **\[Ok\]** と **キャンセル** をダイアログ ボックスにボタンがもと、開発者が提供が、可能性は <xref:System.Windows.Window.DialogResult%2A>, 、呼び出すことによって開かれたウィンドウを自動的に終了する <xref:System.Windows.Window.ShowDialog%2A>です。  
  
 これらのメカニズムを必要とすると、明示的に呼び出す <xref:System.Windows.Window.Close%2A> 、ウィンドウを閉じます。  
  
> [!NOTE]
>  呼び出して、ウィンドウが開かれている場合 <xref:System.Windows.Window.ShowDialog%2A>, を使用して、 <xref:System.Windows.Controls.Button> とその <xref:System.Windows.Controls.Button.IsCancel%2A> プロパティが true に設定をボタンがクリックされたか、または esc キーが押されたときに自動的に閉じます。 使用して、ウィンドウが開かれた場合 <xref:System.Windows.Window.Show%2A>, 、ただし、 <xref:System.Windows.Window.Close%2A> からこのような明示的に呼び出す必要があります <xref:System.Windows.Controls.Primitives.ButtonBase.Click> のイベント ハンドラー、 <xref:System.Windows.Controls.Button>です。  
  
 ウィンドウを閉じると、 <xref:System.Windows.Window.Closing> イベントが発生します。 場合、 <xref:System.Windows.Window.Closing> イベントがキャンセルされていない次のようにします。  
  
-   <xref:System.Windows.Window> から削除 <xref:System.Windows.Application.Windows%2A?displayProperty=fullName> \(場合、 <xref:System.Windows.Application> オブジェクトが存在する\)。  
  
-   <xref:System.Windows.Window> 所有者から削除 <xref:System.Windows.Window> 所有者\/所有している関係が確立された場合、所有する前に <xref:System.Windows.Window> が表示された前後所有者 <xref:System.Windows.Window> を開きました。  
  
-   <xref:System.Windows.Window.Closed> イベントが発生します。  
  
-   アンマネージ リソースによって作成された、 <xref:System.Windows.Window> に破棄されます。  
  
-   場合 <xref:System.Windows.Window.ShowDialog%2A> 表示に対して呼び出された、 <xref:System.Windows.Window>, 、<xref:System.Windows.Window.ShowDialog%2A> を返します。  
  
 閉じる、 <xref:System.Windows.Window> が原因で終了する、所有するすべての windows です。 さらに、終了、 <xref:System.Windows.Window> 方法に応じて実行を停止するアプリケーションが発生する可能性があります <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=fullName> プロパティを設定します。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
   
  
## 例  
 例を次に、 **ファイル** &#124; **終了** を明示的に呼び出す処理されているメニュー <xref:System.Windows.Window.Close%2A>します。  
  
 [!code-xml[WindowCloseSnippets\#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets\#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets\#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">for permission to use all windows and user input events without restriction. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウが閉じるときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントが発生した後、ウィンドウを閉じるを防ぐことはできません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> 設定すると、または <see cref="M:System.Windows.Window.Show" />, 、<see cref="M:System.Windows.Window.ShowDialog" />, 、または <see cref="M:System.Windows.Window.Hide" /> ウィンドウを閉じて中に呼び出されます。</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>直後に発生する <see cref="M:System.Windows.Window.Close" /> が呼び出され、処理することで、ウィンドウのクロージャをキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.Closing> ウィンドウが閉じられるときを検出するために処理することができます \(ときなど、 <xref:System.Windows.Window.Close%2A> と呼びます\)。 さらに、 <xref:System.Windows.Window.Closing> が閉じないようにするのには使用できます。 ウィンドウの終了を回避するのに設定することができます、 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> のプロパティ、 <xref:System.ComponentModel.CancelEventArgs> 引数 `true`します。  
  
 <xref:System.Windows.Window.Closing> イベントが発生したときに <xref:System.Windows.Window.Close%2A> と呼ばれる場合は、ウィンドウの閉じるボタンがクリックされた場合、または alt キーを押しながら f4 キーを押した場合。  
  
 その所有者を使用してウィンドウによって所有されるウィンドウが開いていたかどうか <xref:System.Windows.Window.Show%2A>, 、および所有者は、ウィンドウが閉じられる、所有されているウィンドウの <xref:System.Windows.Window.Closing> イベントは発生しません。 ウィンドウの所有者が閉じている場合 \(を参照してください <xref:System.Windows.Window.Owner%2A>\)、 <xref:System.Windows.Window.Closing> 所有されるウィンドウでは発生しません。  
  
 場合 <xref:System.Windows.Application.Shutdown%2A> が呼び出される、 <xref:System.Windows.Window.Closing> 各ウィンドウのイベントが発生します。 ただし場合、 <xref:System.Windows.Window.Closing> が取り消されると、キャンセルが無視されます。  
  
 ユーザーのログオフまたはシャット ダウンするために、セッションが終了した場合 <xref:System.Windows.Window.Closing> は発生しません。 処理 <xref:System.Windows.Application.SessionEnding> アプリケーション クロージャをキャンセルするコードを実装します。  
  
 表示し、アプリケーションの有効期間中に複数回ウィンドウを非表示にして、ウィンドウのたびに再インスタンス化したくない場合は、これを表示する、処理できる、 <xref:System.Windows.Window.Closing> イベント、キャンセルするか、および呼び出し、 <xref:System.Windows.Window.Hide%2A> メソッドです。 次に、呼び出します <xref:System.Windows.Window.Show%2A> に開き直すの同じインスタンスでします。  
  
   
  
## 例  
 次の例は、 <xref:System.Windows.Window> を閉じるには、ユーザーが必要かどうかを決定します。  
  
 [!code-xml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
[!code-xml[WindowClosingSnippets#WindowClosingXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml2)]  
  
 [!code-csharp[WindowClosingSnippets#WindowClosingCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs#windowclosingcodebehind1)]
 [!code-vb[WindowClosingSnippets#WindowClosingCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb#windowclosingcodebehind1)]  
[!code-csharp[WindowClosingSnippets#WindowClosingCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs#windowclosingcodebehind2)]
[!code-vb[WindowClosingSnippets#WindowClosingCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb#windowclosingcodebehind2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> 設定すると、または <see cref="M:System.Windows.Window.Show" />, 、<see cref="M:System.Windows.Window.ShowDialog" />, 、または <see cref="M:System.Windows.Window.Close" /> ウィンドウを閉じて中に呼び出されます。</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウのコンテンツがレンダリングされた後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the window has no content, this event is not raised.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウが背景ウィンドウになったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A window is deactivated \(becomes a background window\) when:  
  
-   A user switches to another window in the current application.  
  
-   A user switches to the window in another application by using ALT\+TAB or by using Task Manager.  
  
-   A user clicks the taskbar button for a window in another application.  
  
 Windows that need to detect when they become deactivated by handling the <xref:System.Windows.Window.Deactivated> event.  
  
 After a window is first deactivated, it may be reactivated and deactivated many times during its lifetime. If an application's behavior or state depends on its activation state, it can inspect <xref:System.Windows.Window.IsActive%2A> to determine which activation state it's in.  
  
 An application can also be <xref:System.Windows.Application.Deactivated>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定から返される値は、ダイアログの結果の値、 <see cref="M:System.Windows.Window.ShowDialog" /> メソッドです。</summary>
        <value>A <see cref="T:System.Nullable`1" /> 型の値 <see cref="T:System.Boolean" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.DialogResult%2A> ユーザーが受け入れるかどうかを判断する\] ダイアログ ボックスが映っているコードから使用することができます \(`true`\) または取り消し済み \(`false`\)\] ダイアログ ボックス。 ダイアログ ボックスが受け入れられた場合は、コードがユーザーによって収集されたデータを取得し、それを処理するには、ダイアログ ボックスを開くことにこのことを示します。 ダイアログ ボックスが取り消された場合、これは示してコードの呼び出しを停止する追加の処理します。  
  
 既定では、ユーザーが、次のいずれかと、ダイアログ ボックスが取り消されます。  
  
-   押されたalt キーを押しながら f4 キー。  
  
-   クリックする、 **閉じる** \] ボタンをクリックします。  
  
-   選択した **閉じる** システム メニューからです。  
  
 このような場合のすべてのページで <xref:System.Windows.Window.DialogResult%2A> は `false` 既定では。  
  
 ダイアログ ボックスが、ボタンは、ダイアログ ボックスをキャンセルする特殊なボタンが公開されていますが <xref:System.Windows.Controls.Button.IsCancel%2A> にプロパティが設定されている `true`します。 このように構成されているボタンでは、押すか、または ESC キーが押されたときに、ウィンドウは自動的に閉じます。 このような場合は、のいずれかで <xref:System.Windows.Window.DialogResult%2A> まま `false`します。  
  
 ダイアログ ボックスでは、ボタン、\[accept\] ボタンも通常は提供が <xref:System.Windows.Controls.Button.IsDefault%2A> にプロパティが設定されている `true`します。 このように構成されているボタンを発生させる、 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントか、ENTER キーが押されるとします。 ただし、ダイアログ ボックスに自動的に閉じないや設定は <xref:System.Windows.Window.DialogResult%2A> に `true`します。 このコードをから通常手動で作成する必要があります、 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 既定のボタンのイベント ハンドラーです。  
  
 <xref:System.Windows.Window.DialogResult%2A> `null` \] ダイアログ ボックスが表示されている場合、許容されるも取り消されました。  
  
 によって返された値からダイアログ結果を得ることができます\] ダイアログ ボックスを閉じた後 <xref:System.Windows.Window.ShowDialog%2A> メソッド、またはを調べることによって、 <xref:System.Windows.Window.DialogResult%2A> プロパティです。  
  
 <xref:System.Windows.Window.DialogResult%2A> ときのみ設定可能、 <xref:System.Windows.Window> を呼び出すことによって開くその <xref:System.Windows.Window.ShowDialog%2A> メソッドです。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
   
  
## 例  
 次の例は、\[ok\] ボタンと \[キャンセル\] ボタンを返す、適切なを構成する方法を示しています。 <xref:System.Windows.Window.DialogResult%2A>します。  
  
 [!code-xml[WindowDialogResultSnippets\#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets\#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets\#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" /> 呼び出して、ウィンドウが開かれる前に設定されている <see cref="M:System.Windows.Window.ShowDialog" />します。  
  
 または  
  
 <see cref="P:System.Windows.Window.DialogResult" /> 呼び出しによって開かれたウィンドウで設定されている <see cref="M:System.Windows.Window.Show" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Window が表示されている画面の DPI が変更されたあとに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>画面 Window の DPI が変更中であるときの <see cref="T:System.Windows.RoutedEvent" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ウィンドウのクライアント領域の表示部分でマウスの左ボタンを押したドラッグされるウィンドウを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウスの左ボタンがダウンする必要があります <xref:System.Windows.Window.DragMove%2A> が呼び出されます。 マウスの左ボタンが押されたときを検出する方法の 1 つは、処理、 <xref:System.Windows.UIElement.MouseLeftButtonDown> イベントです。  
  
 <xref:System.Windows.Window.DragMove%2A> が呼び出されると、左側のウィンドウのクライアント領域の表示部分でマウス ボタンが押される必要があります。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
   
  
## 例  
 次の例は、上書きする方法を示しています。 <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> を呼び出す <xref:System.Windows.Window.DragMove%2A>します。  
  
 [!code-csharp[WindowDragMoveSnippets\#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets\#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">マウスの左ボタンが押されていません。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">for permission to drag a window. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">依存オブジェクト。</param>
        <summary>参照を返す、 <see cref="T:System.Windows.Window" /> コンテンツに依存関係オブジェクトが存在するツリーをホストするオブジェクト。</summary>
        <returns>A <see cref="T:System.Windows.Window" /> ホスト ウィンドウへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ウィンドウは、見えなくなります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 表示されていない場合、ウィンドウが閉じられていないとは、どちらも、 <xref:System.Windows.Window.Closing> も <xref:System.Windows.Window.Closed> イベントが発生します。 代わりに、ウィンドウの <xref:System.Windows.UIElement.Visibility%2A> にプロパティが設定されている <xref:System.Windows.Visibility.Hidden?displayProperty=fullName>します。  
  
 ウィンドウが、アプリケーションの場合 <xref:System.Windows.Application.MainWindow%2A> およびアプリケーションの <xref:System.Windows.Application.ShutdownMode%2A> は <xref:System.Windows.ShutdownMode.OnMainWindowClose>, 、アプリケーションがシャット ダウンしません。 同様に、アプリケーションが停止されない場合は、ウィンドウのみのウィンドウでは、アプリケーションのシャット ダウン モードは <xref:System.Windows.ShutdownMode.OnLastWindowClose>です。  
  
 表示して、アプリケーションの有効期間中に複数回ウィンドウを非表示にして、毎回ウィンドウを再インスタンス化したくない場合は、これを表示する、処理できる、 <xref:System.Windows.Window.Closing> イベント、キャンセルするか、および呼び出し、 <xref:System.Windows.Window.Hide%2A> メソッドです。 次に、呼び出します <xref:System.Windows.Window.Show%2A> を再び開くに同じインスタンスでします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Hide" /> ウィンドウを閉じている途中で呼び出されます \(<see cref="E:System.Windows.Window.Closing" />\) または閉じられて \(<see cref="E:System.Windows.Window.Closed" />\)。</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはウィンドウのアイコンを設定します。</summary>
        <value>
          <see cref="T:System.Windows.Media.ImageSource" /> アイコンを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] スタンドアロン アプリケーションでは、2 種類のアイコンを設定します。  
  
-   1 つのアセンブリのアイコンを使用して指定されている、 `<ApplicationIcon>` アプリケーションのプロジェクト内のプロパティは、ファイルをビルドします。 このアイコンは、アセンブリのデスクトップのアイコンとして使用されます。  
  
    > [!NOTE]
    >  Visual Studio でのデバッグ時のホスティング プロセスによって、アイコンが表示されません。 実行可能ファイルを実行する場合は、アイコンが表示されます。 詳細については、「[Hosting Process \(vshost.exe\)](http://msdn.microsoft.com/ja-jp/c6b9e2be-f18d-4d75-ac52-56d55784734b)」を参照してください。  
  
-   1 つのアイコンを設定して指定されているウィンドウごと <xref:System.Windows.Window.Icon%2A>します。 各ウィンドウのタイトル バー、タスク バー ボタン、および \[ALT キーと TAB アプリケーションの選択リスト エントリにこのアイコンが使用されます。  
  
 A [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ウィンドウには、常にアイコンが表示されます。 設定して指定されていないときに <xref:System.Windows.Window.Icon%2A>, 、[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 次の規則に基づいて表示するアイコンを選択します。  
  
1.  指定した場合は、アセンブリのアイコンを使用します。  
  
2.  アセンブリのアイコンが指定されていない場合は、既定値を使用して [!INCLUDE[TLA#tla_win](~/includes/tlasharptla-win-md.md)] アイコン。  
  
 使用する場合 <xref:System.Windows.Window.Icon%2A> カスタム ウィンドウ アイコンを指定するには、設定して既定のアプリケーション アイコンを戻すことができます <xref:System.Windows.Window.Icon%2A> に `null`します。  
  
 1 つのアイコンは、さまざまな方法で使用できます [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)], 、alt キーを押しながら TAB ファイルの選択リストを含むウィンドウで、ウィンドウのタスク バーのタイトル バーに表示されています。 別のサイズを使用するアイコンが表示これらの各alt キーを押しながら TAB ファイルの選択リストで、サイズが 32 × 32 ピクセルのアイコンが表示されている間、ウィンドウのタイトル バーおよびタスク バーで、16 x 16 ピクセルのアイコンが表示されます。 などのアプリケーションによっては、 [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], 、提供、 **ビュー** メニューを表示するアイコンのサイズを選択することができます。  
  
 要求を満たすさまざまな画面サイズ、アイコン ファイルは 1 つまたは複数の実際アイコンを使用して、それぞれが特定のサイズと色深度を対象とするアイコンのバージョンを表すので構成されます。 たとえば、16 x 16 ピクセル、16 色と 256 色の両方でサイズが 32 × 32 ピクセルのアイコンが含まれている可能性があります中に、1 つのアイコンはの 16 色は、1 つの 16 x 16 ピクセル アイコンを必要のみがあります。  
  
 アイコン ファイル内のすべての使用可能なサイズと色深度を示すアイコンが存在する場合 <xref:System.Windows.Window> 、適切なアイコンを使用します。 アイコン ファイルには、すべての可能なアイコンのサブセットのみが含まれている場合 <xref:System.Windows.Window> サイズと色の解像度が高い順に次の最も適切なアイコンを使用します。  
  
 アイコンは常に使用することになります <xref:System.Windows.Window>, に使用されるアイコンが必要なサイズと色深度対象としないことができます。 たとえば、表示の場合、256 色、サイズが 32 × 32 ピクセルのアイコンとして 16 色の 16 x 16 ピクセルのアイコンを使用ことがあります。 これは保たれますなどの視覚効果が望ましくない可能性がありますが、すべてのサイズと色深度のアイコンを作成することで回避することがあります。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.IconProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、\[ウィンドウ\] アイコンを設定する方法を示します。  
  
 [!code-xml[WindowIconSnippets\#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets\#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets\#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">for permission to set the icon. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.Icon" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウがアクティブかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> ウィンドウがアクティブである場合それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アクティブなウィンドウ、ユーザーの現在の前面のウィンドウであり、フォーカスは、タイトル バーのアクティブな外観で順位。 アクティブなウィンドウは明示的に設定されていないすべてのトップレベル ウィンドウの最上部にもなります、 <xref:System.Windows.Window.Topmost%2A> プロパティです。  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.IsActiveProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.IsActive" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはデスクトップに関連して、ウィンドウの左端の位置を設定します。</summary>
        <value>ウィンドウの位置の左端の論理単位 \(1\/96 インチ\)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Windows.Window> 最大化または最小化、この値は、復元の左端のポイントを <xref:System.Windows.Window>です。  
  
 このプロパティは、スタイルを設定することはできません。  
  
 値が指定されていない場合 <xref:System.Windows.Window.Left%2A> システムの既定値に設定されています。 設定して、システムの既定値を指定することも <xref:System.Windows.Window.Left%2A> に <xref:System.Double.NaN>します。 どちらも <xref:System.Double.NegativeInfinity> も <xref:System.Double.PositiveInfinity> の有効な値は、 <xref:System.Windows.Window.Left%2A>です。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.LeftProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.Left" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウの位置が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ウィンドウの場所は、タイミングを変更します。  
  
-   ユーザーは、ウィンドウのタイトル バーをドラッグして、ウィンドウを移動します。  
  
-   後に、ウィンドウを移動 <xref:System.Windows.Window.DragMove%2A> が呼び出されます。  
  
-   いずれか、 <xref:System.Windows.Window.Left%2A> または <xref:System.Windows.Window.Top%2A> プロパティがプログラムで設定します。  
  
-   **移動** ウィンドウの \[システム\] メニューのメニュー項目を選択します。  
  
-   <xref:System.Windows.Window.WindowState%2A> プロパティを変更します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウの論理上の子要素の列挙子を取得します。</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" /> ウィンドウの論理上の子要素です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">A <see cref="T:System.Windows.Size" /> このウィンドウは、子プロセスに与えることが利用可能なサイズを反映します。 無限大は、ウィンドウのサイズがどのようなコンテンツを使用することを示すために、値として指定できます。</param>
        <summary>ウィンドウのサイズを測定するには、このメソッドをオーバーライドします。</summary>
        <returns>A <see cref="T:System.Windows.Size" /> このウィンドウは、子供のサイズの計算に基づくレイアウト中に必要なを決定するサイズを反映します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.MeasureOverride%2A> 場合に呼び出さない、 <xref:System.Windows.UIElement.Visibility%2A> プロパティの値を持つ <xref:System.Windows.Visibility.Collapsed>です。 場合の値、 <xref:System.Windows.UIElement.Visibility%2A> プロパティが、 <xref:System.Windows.Visibility.Hidden> または <xref:System.Windows.Visibility.Visible>, 、<xref:System.Windows.Window.MeasureOverride%2A> が呼び出されます。  
  
> [!NOTE]
>  ときにいずれか <xref:System.Windows.Window.Show%2A> または <xref:System.Windows.Window.ShowDialog%2A> を呼び出すと、 <xref:System.Windows.UIElement.Visibility%2A> のプロパティ、 <xref:System.Windows.Window> に設定されている <xref:System.Windows.Visibility.Visible>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Window.Activated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.OnActivated%2A> は、<xref:System.Windows.Window.Activated> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Window> よりも優先 <xref:System.Windows.Window.OnActivated%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Window.OnActivated%2A> 基本クラスの場合は <xref:System.Windows.Window.Activated> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Window.Closed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.OnClosed%2A> は、<xref:System.Windows.Window.Closed> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Window> よりも優先 <xref:System.Windows.Window.OnClosed%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Window.OnClosed%2A> 基本クラスの場合は <xref:System.Windows.Window.Closed> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Window.Closing" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.OnClosing%2A> は、<xref:System.Windows.Window.Closing> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Window> よりも優先 <xref:System.Windows.Window.OnClosing%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Window.OnClosing%2A> 基本クラスの場合は <xref:System.Windows.Window.Closing> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">古いコンテンツ ツリーのルートへの参照。</param>
        <param name="newContent">新しいコンテンツ ツリーのルートへの参照。</param>
        <summary>ときに呼び出されます、 <see cref="P:System.Windows.Controls.ContentControl.Content" /> プロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Window.ContentRendered" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.OnContentRendered%2A> は、<xref:System.Windows.Window.ContentRendered> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Window> よりも優先 <xref:System.Windows.Window.OnContentRendered%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Window.OnContentRendered%2A> 基本クラスの場合は <xref:System.Windows.Window.ContentRendered> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>作成して返します、 <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> オブジェクトの <see cref="T:System.Windows.Window" />です。</summary>
        <returns>A <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> オブジェクトの <see cref="T:System.Windows.Window" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Window.Deactivated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.OnDeactivated%2A> は、<xref:System.Windows.Window.Deactivated> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Window> よりも優先 <xref:System.Windows.Window.OnDeactivated%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Window.OnDeactivated%2A> 基本クラスの場合は <xref:System.Windows.Window.Deactivated> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">以前の DPI スケール設定。</param>
        <param name="newDpi">新規の DPI スケール設定。</param>
        <summary>このウィンドウが表示される DPI が変更するときに呼び出されます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Window.LocationChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.OnLocationChanged%2A> は、<xref:System.Windows.Window.LocationChanged> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Window> よりも優先 <xref:System.Windows.Window.OnLocationChanged%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Window.OnLocationChanged%2A> 基本クラスの場合は <xref:System.Windows.Window.LocationChanged> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary>ときに呼び出されます、 <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> イベントが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この実装では、処理済みの状態は変更されません \(、 <xref:System.Windows.RoutedEventArgs.Handled%2A> プロパティ\) の <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> イベント データ。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If you override <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, always call the base implementation in your <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> implementation. Failure to call the base implementation prevents base classes from handling the event, which might change the run-time behavior of the final class. You can call the base implementation either before or after your special handling, depending on your requirements.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Window.SourceInitialized" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.OnSourceInitialized%2A> は、<xref:System.Windows.Window.SourceInitialized> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Window> よりも優先 <xref:System.Windows.Window.OnSourceInitialized%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Window.OnSourceInitialized%2A> 基本クラスの場合は <xref:System.Windows.Window.SourceInitialized> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Window.StateChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.OnStateChanged%2A> は、<xref:System.Windows.Window.StateChanged> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Window> よりも優先 <xref:System.Windows.Window.OnStateChanged%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Window.OnStateChanged%2A> 基本クラスの場合は <xref:System.Windows.Window.StateChanged> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">以前の親です。 ある場合は null に設定、 <see cref="T:System.Windows.DependencyObject" /> 以前の親はありませんでした。</param>
        <summary>ウィンドウの親が変更されたときに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このウィンドウは、オーナー ウィンドウのコレクションを取得します。</summary>
        <value>A <see cref="T:System.Windows.WindowCollection" /> このウィンドウは、オーナー ウィンドウへの参照を格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 所有されるウィンドウは 1 つ持つ <xref:System.Windows.Window.Owner%2A> プロパティは、オーナー ウィンドウと呼ばれる別のウィンドウへの参照。 列挙できるオーナー ウィンドウを所有しているすべてのウィンドウを検索するには、 <xref:System.Windows.WindowCollection> によって返される、 <xref:System.Windows.Window.OwnedWindows%2A> プロパティです。  
  
   
  
## 例  
 次の例は、列挙する方法を示しています。 <xref:System.Windows.Window.OwnedWindows%2A>します。  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets\#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets\#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 <see cref="T:System.Windows.Window" /> を所有しているこの <see cref="T:System.Windows.Window" />します。</summary>
        <value>A <see cref="T:System.Windows.Window" /> オブジェクトを所有している <see cref="T:System.Windows.Window" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出して親ウィンドウによって子ウィンドウが開かれたときに <xref:System.Windows.Window.ShowDialog%2A>, 、親と子の両方のウィンドウ間の暗黙的なリレーションシップが確立します。 この関係を最小限に抑え、最大化、および復元に関するなどの特定の動作が適用されます。  
  
 呼び出して、親ウィンドウによって子ウィンドウが作成されたときに <xref:System.Windows.Window.Show%2A>, 、ただし、子ウィンドウには、親ウィンドウとの関係はありません。 これによって、次のことが起こります。  
  
-   子ウィンドウには、親ウィンドウへの参照がありません。  
  
-   子ウィンドウの動作は、親ウィンドウの動作に依存しません。いずれかのウィンドウ、もう一方を扱うことができる最小化したり、最大化し、他方とは無関係に復元します。  
  
 子ウィンドウと、親ウィンドウの間のリレーションシップを作成できるように <xref:System.Windows.Window> 所有権の概念をサポートしています。 所有権が確立されるときに、 <xref:System.Windows.Window.Owner%2A> 別のウィンドウ \(オーナー ウィンドウ\) への参照を含むウィンドウ \(所有されるウィンドウ\) のプロパティを設定します。  
  
 このリレーションシップが確立されると、次の動作が発生します。  
  
-   オーナー ウィンドウが最小化されている場合、所有しているすべてのウィンドウも最小化します。  
  
-   所有されているウィンドウを最小化されている場合、所有者が最小化されていません。  
  
-   オーナー ウィンドウが最大化されている場合は、オーナー ウィンドウと所有されるウィンドウの両方が復元されます。  
  
-   オーナー ウィンドウでは、所有されるウィンドウをカバーできることはありません。  
  
-   使用していない開いているウィンドウを所有している <xref:System.Windows.Window.ShowDialog%2A> モーダルではありません。 ユーザーは、オーナー ウィンドウとも対話できます。  
  
-   オーナー ウィンドウを閉じると、所有されるウィンドウも閉じます。  
  
-   その所有者を使用してウィンドウによって所有されるウィンドウが開いていたかどうか <xref:System.Windows.Window.Show%2A>, 、および所有者は、ウィンドウが閉じられる、所有されているウィンドウの <xref:System.Windows.Window.Closing> イベントは発生しません。  
  
 呼び出すことによって、子ウィンドウを開いたとき <xref:System.Windows.Window.ShowDialog%2A>, 、設定する必要がありますも、 <xref:System.Windows.Window.Owner%2A> 子ウィンドウのプロパティです。 ない場合は、ユーザーはタスク バー ボタンを押して、ウィンドウの子と親ウィンドウの両方を復元することできません。 代わりに、タスク バー ボタンを押すことになる子と親の両方のウィンドウでそれらを選択するを含む、windows の一覧選択したウィンドウのみが復元されます。  
  
> [!IMPORTANT]
>  設定する必要があります、 <xref:System.Windows.Window.Owner%2A> プロパティを呼び出しているが開かれているウィンドウを <xref:System.Windows.Window.ShowDialog%2A> で正しく動作するようにします。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
   
  
## 例  
 次の例では、所有者\/所有している関係を確立する方法を示します。  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets\#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets\#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ウィンドウが、それ自体を所有しようとしています。  
  
 または  
  
 2 つのウィンドウは、相互に所有しようとします。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.Owner" /> プロパティが設定されて表示可能なウィンドウを使用して表示 <see cref="M:System.Windows.Window.ShowDialog" />  
  
 または  
  
 <see cref="P:System.Windows.Window.Owner" /> 以前に表示されていないウィンドウのプロパティを設定します。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">for permission to use all windows and user input events without restriction. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはサイズ変更モードを設定します。</summary>
        <value>A <see cref="T:System.Windows.ResizeMode" /> サイズ変更モードを指定する値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の 4 つのオプションがあります。  
  
-   **NoResize**します。 ユーザーは、ウィンドウをサイズ変更できません。 最大および最小化ボタンは表示されません。  
  
-   **CanMinimize**します。 ユーザーは、のみウィンドウを最小化し、タスク バーから復元できます。 最小化、最大化ボタンは表示されますが最小化ボタンのみが有効にします。  
  
-   **CanResize**します。 ユーザーには、ウィンドウの周囲、最小と最大化ボタン、およびドラッグ可能なアウトラインを使用して、ウィンドウのサイズを変更する全機能があります。 最小化、最大化ボックスが表示され、有効になっています。 \(既定値\)。  
  
-   **CanResizeWithGrip**します。 このオプションは、同じ機能を持ち <xref:System.Windows.ResizeMode.CanResize>, がウィンドウの右下隅に「サイズ変更グリップ」を追加します。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.ResizeModeProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.ResizeMode" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最小化または最大化する前に、ウィンドウの場所とサイズを取得します。</summary>
        <value>A <see cref="T:System.Windows.Rect" /> を指定するサイズとウィンドウの位置される前に最小化または最大化します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 復元の四角形が最小化または最大化する前に、このウィンドウによって占有される領域です。 使用する <xref:System.Windows.Window.RestoreBounds%2A> をアプリケーションが閉じられる前に、最後のサイズとウィンドウの位置を保存し、次回ユーザーが離れたときに、ウィンドウを復元するアプリケーションの起動時にそれらの値を取得します。  
  
 照会する場合は、 <xref:System.Windows.Window.RestoreBounds%2A> ウィンドウを表示する前に、または終了した <xref:System.Windows.Rect.Empty%2A> が返されます。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
   
  
## 例  
 次の例では使用 <xref:System.Windows.Window.RestoreBounds%2A> およびストレージを実現し、ウィンドウの場所とサイズが同じで、ウィンドウが表示された前回の時間を分離します。  
  
 [!code-xml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">for permission to query for the size and location of a window's bounding rectangle. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ウィンドウを開き、新しく開かれたウィンドウが閉じるを待機せずに返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Windows.Window> クラスがインスタンス化され、既定で表示されていません。<xref:System.Windows.Window.Show%2A> ウィンドウを表示し、終了するウィンドウを待たずにすぐを返します。 その結果、開かれたウィンドウは、アプリケーションの他のウィンドウとの対話からユーザーを妨げません。 この種のウィンドウと呼ばれる、 *モードレス* ウィンドウです。 モードレス ウィンドウの一般的な例は、\[プロパティ\] ウィンドウ、ツールボックス、およびパレットです。 特定のウィンドウとのやり取りにユーザーを制限するには、呼び出すことによって、このウィンドウを開きます <xref:System.Windows.Window.ShowDialog%2A>します。  
  
 呼び出しによって開かれたウィンドウ <xref:System.Windows.Window.Show%2A> は自動的に開いたウィンドウと関係を持つ、具体的には、開かれたウィンドウが知らないいるウィンドウを開いたときです。 使用してこの関係を確立することができます、 <xref:System.Windows.Window.Owner%2A> プロパティと管理を使用して、 <xref:System.Windows.Window.OwnedWindows%2A> プロパティです。  
  
 呼び出す <xref:System.Windows.Window.Show%2A> の設定と同じ結果が得られます <xref:System.Windows.UIElement.Visibility%2A> のプロパティ、 <xref:System.Windows.Window> オブジェクトを <xref:System.Windows.Visibility.Visible>します。 ただし、タイミングの観点から 2 つの差があります。  
  
 呼び出す <xref:System.Windows.Window.Show%2A> にした場合のみを返す同期操作には、 <xref:System.Windows.FrameworkElement.Loaded> 子ウィンドウのイベントが発生しました。  
  
 [!code-csharp[WindowShowTimingSnippets\#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets\#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 設定 <xref:System.Windows.UIElement.Visibility%2A>, 、ただし、非同期操作をすぐに返すには。  
  
 [!code-csharp[WindowShowTimingSnippets\#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets\#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 設定するときに <xref:System.Windows.UIElement.Visibility%2A>, を設定する前に登録する、ウィンドウ イベント <xref:System.Windows.UIElement.Visibility%2A> 設定するメソッドの後になるまでが発生しない <xref:System.Windows.UIElement.Visibility%2A> 実行が完了しました。  
  
   
  
## 例  
 次の例では、モードレス ウィンドウを開く方法を示します。  
  
 [!code-csharp[WindowShowSnippets\#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets\#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Show" /> ウィンドウを閉じている途中で呼び出されます \(<see cref="E:System.Windows.Window.Closing" />\) または閉じられて \(<see cref="E:System.Windows.Window.Closed" />\)。</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはを最初に表示されるときに、ウィンドウがアクティブにするかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> 最初に表示されたときにウィンドウがアクティブにする場合それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときにウィンドウの <xref:System.Windows.Window.ShowActivated%2A> プロパティに設定 `false` が開くと、ウィンドウがアクティブ化されていないとその <xref:System.Windows.Window.Activated> ユーザーが手動で選択して、ウィンドウを起動するまで、イベントは発生しません。 ウィンドウを選択すると、後にアクティブにし、通常を非アクティブにします。  
  
 ウィンドウが開くと、アクティブ化されていることを防ぐため、 <xref:System.Windows.Window.ShowActivated%2A> にプロパティを設定する必要があります `false` ウィンドウが表示される前に \(を呼び出して <xref:System.Windows.Window.Show%2A>\) 設定; <xref:System.Windows.Window.ShowActivated%2A> に `false` 後、ウィンドウが表示される場合は、影響を与えません。  
  
 設定 <xref:System.Windows.Window.ShowActivated%2A> に `false` が呼び出すことによって、モーダルで開かれているウィンドウの <xref:System.Windows.Window.ShowDialog%2A>, 、実際の影響を与えません。 モーダル ウィンドウは有効になりませんが、モーダル ウィンドウは、その他のアプリケーションを開く windows のライセンス認証をユーザーをできなくなります。  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.ShowActivatedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、マークアップを使用して認証されることがなく開かれている期間を構成する方法を示します。  
  
 [!code-xml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets\#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets\#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 次の例では、コードを使用してアクティブ化が開くようにウィンドウを構成する方法を示します。  
  
 [!code-csharp[WindowShowActivatedSnippets\#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets\#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.ShowActivated" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ウィンドウが開き、新しく開かれたウィンドウが閉じられる場合にのみ返ります。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> 型の値 <see cref="T:System.Boolean" /> アクティビティが受け入れられましたかどうかを指定する \(<see langword="true" />\) または取り消し済み \(<see langword="false" />\)。 戻り値は、の値、 <see cref="P:System.Windows.Window.DialogResult" /> プロパティ ウィンドウを閉じる前にします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Windows.Window> クラスがインスタンス化され、既定で表示されていません。<xref:System.Windows.Window.ShowDialog%2A> ウィンドウを表示、アプリケーションでは、他のすべてのウィンドウを無効にして、ウィンドウが閉じられる場合にのみ返ります。 この種のウィンドウと呼ばれる、 *モーダル* ウィンドウです。  
  
 モーダル ウィンドウは、主に、ダイアログ ボックスとして使用します。 ダイアログ ボックスは特殊なファイルを開いたり、ドキュメントの印刷などのタスクを実行するユーザーと対話するアプリケーションで使用されるウィンドウです。 ダイアログ ボックスには、ユーザーを受け入れるか、ダイアログ ボックスを閉じる前に、表示されているタスクの取り消しを一般的できるようにします。<xref:System.Windows.Window.ShowDialog%2A> 返します、 <xref:System.Nullable%601><xref:System.Boolean> 、アクティビティが受け入れられるか、取り消されたかどうかを指定する値。 戻り値は、の値、 <xref:System.Windows.Window.DialogResult%2A> プロパティ ウィンドウを閉じる前にします。 詳細については、「<xref:System.Windows.Window.DialogResult%2A>」を参照してください。  
  
 呼び出しによって開かれたウィンドウ、 <xref:System.Windows.Window.ShowDialog%2A> はメソッドに自動的に開いたウィンドウとの関係がありません。 具体的には、開かれたウィンドウが知らないいるウィンドウを開いたときです。 使用してこの関係を確立することができます、 <xref:System.Windows.Window.Owner%2A> プロパティと管理を使用して、 <xref:System.Windows.Window.OwnedWindows%2A> プロパティです。 サポートするために [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] オートメーション \(を参照してください [UI Automation Overview](http://msdn.microsoft.com/ja-jp/65847654-9994-4a9e-b36d-2dd5d998770b)\)、 <xref:System.Windows.Window.Owner%2A> の呼び出しによって開いたウィンドウを設定する必要があります <xref:System.Windows.Window.ShowDialog%2A>します。  
  
 ときに、モーダル [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ウィンドウ \(を呼び出して、ウィンドウが開かれた <xref:System.Windows.Window.ShowDialog%2A>\) を閉じると、既にアクティブ化されたウィンドウを再アクティブ化します。 場合は、モーダル [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ウィンドウには、オーナー ウィンドウ \(を参照してください <xref:System.Windows.Window.Owner%2A>\)、オーナー ウィンドウが再アクティブ化したときに、モーダル [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] にアクティブだったウィンドウがなければ、ウィンドウが閉じられます。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
   
  
## 例  
 次の例では、モーダル ウィンドウを開く方法を示します。  
  
 [!code-csharp[WindowShowDialogSnippets\#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets\#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.ShowDialog" /> ウィンドウを閉じている途中で呼び出されます \(<see cref="E:System.Windows.Window.Closing" />\) または閉じられて \(<see cref="E:System.Windows.Window.Closed" />\)。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">for permission to activate a window. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはウィンドウのタスク バー ボタンにするかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> ウィンドウに、タスク バー ボタンがある場合それ以外の場合、 <see langword="false" />です。 ウィンドウがブラウザーでホストされている場合に適用されません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 <xref:System.Windows.Window.ShowInTaskbar%2A> に設定されている `true`, 、ウィンドウは、alt キーを押しながら TAB アプリケーションの選択リストにも表示されます。  
  
 タスク バー ボタンと alt キーを押しながら TAB アプリケーションの選択リストの両方に使用されるアイコンは、の値、 <xref:System.Windows.Window.Icon%2A> プロパティです。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.ShowInTaskbar" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウのサイズがコンテンツのサイズに合わせて自動的に調整されるかどうかを示す値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Windows.SizeToContent" /> 値。 既定値は、<see cref="F:System.Windows.SizeToContent.Manual" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.SizeToContent%2A> に設定されている <xref:System.Windows.SizeToContent.WidthAndHeight>, 、いずれかを設定 <xref:System.Windows.FrameworkElement.Height%2A> または <xref:System.Windows.FrameworkElement.Width%2A> は影響しません。 両方のプロパティを設定することができますが、設定された値は、ウィンドウには適用されません。  
  
 <xref:System.Windows.Window.SizeToContent%2A> に設定されている <xref:System.Windows.SizeToContent.Height>, 設定 <xref:System.Windows.FrameworkElement.Height%2A> ウィンドウの高さを変更することはできません。  
  
 <xref:System.Windows.Window.SizeToContent%2A> に設定されている <xref:System.Windows.SizeToContent.Width>, 設定 <xref:System.Windows.FrameworkElement.Width%2A> ウィンドウの幅を変更することはできません。  
  
 場合 <xref:System.Windows.Window.SizeToContent%2A> 以外の値を持つ <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> 自動的に設定されている <xref:System.Windows.SizeToContent.Manual> 場合は、ユーザーは、サイズ変更グリップを使用して、境界線をドラッグするかによって、ウィンドウをサイズ変更します。  
  
-   によって、ウィンドウ自体のサイズを変更する方法でコンテンツのサイズが変更された場合 <xref:System.Windows.FrameworkElement.SizeChanged> が発生します。  
  
 ウィンドウが透明の場合 \(を参照してください <xref:System.Windows.Window.AllowsTransparency%2A>\)、設定をする必要がある <xref:System.Windows.Window.SizeToContent%2A> に <xref:System.Windows.SizeToContent.WidthAndHeight> ウィンドウが表示されているコンテンツを超えないことを確認します。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.SizeToContentProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、設定する方法、 <xref:System.Windows.Window.SizeToContent%2A> コンテンツに合わせてウィンドウのサイズを変更する方法を指定するコード内のプロパティです。  
  
 [!code-csharp[HOWTOWindowManagementSnippets\#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets\#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.SizeToContent" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>相互運用をサポートするためにこのイベントは Win32です。 「<see cref="T:System.Windows.Interop.HwndSource" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときに、ウィンドウの <see cref="P:System.Windows.Window.WindowState" /> プロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 Windows 7 タスク バーの縮小表示、 <see cref="T:System.Windows.Window" />です。</summary>
        <value>Windows 7 タスク バーの縮小表示、 <see cref="T:System.Windows.Window" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用する方法の詳細についての [!INCLUDE[win7](~/includes/win7-md.md)] タスク バーの縮小表示を参照してください、 <xref:System.Windows.Shell.TaskbarItemInfo> クラスです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.TaskbarItemInfo" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはウィンドウのタイトルを設定します。</summary>
        <value>A <see cref="T:System.String" /> ウィンドウのタイトルを格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タイトル、 <xref:System.Windows.Window>, 、<xref:System.Windows.Navigation.NavigationWindow>, 、または [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], を使用して設定することも <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=fullName>です。  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.TitleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.Title" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはデスクトップに関連して、ウィンドウの上端の位置を設定します。</summary>
        <value>ウィンドウの最上位の論理単位 \(1\/96 インチ\) での位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Windows.Window> 最大化または最小化、この値は、復元の上端のポイントを <xref:System.Windows.Window>です。  
  
 このプロパティは、スタイルを設定することはできません。  
  
 値が指定されていない場合 <xref:System.Windows.Window.Top%2A> システムの既定値に設定されています。 設定して、システムの既定値を指定することも <xref:System.Windows.Window.Top%2A> に <xref:System.Double.NaN>します。 どちらも <xref:System.Double.NegativeInfinity> も <xref:System.Double.PositiveInfinity> の有効な値は、 <xref:System.Windows.Window.Top%2A>です。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.TopProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または最上位の z オーダーでウィンドウが表示されるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> ウィンドウが、一番上にある場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ウィンドウが <xref:System.Windows.Window.Topmost%2A> にプロパティが設定されている `true` の上側にすべてのウィンドウの <xref:System.Windows.Window.Topmost%2A> プロパティに設定されて `false`します。  
  
 Windows のグループで <xref:System.Windows.Window.Topmost%2A> にプロパティが設定されている `true`, 、現在アクティブになっているウィンドウが最上位ウィンドウです。 同様にする必要があるのグループの <xref:System.Windows.Window.Topmost%2A> にプロパティが設定されている `false`します。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.TopmostProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.Topmost" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.Top" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または、最初に表示される場合は、ウィンドウの位置を設定します。</summary>
        <value>A <see cref="T:System.Windows.WindowStartupLocation" /> 最初に表示されるときに、ウィンドウの左上の位置を示す値。 既定値は、<see cref="F:System.Windows.WindowStartupLocation.Manual" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定 <xref:System.Windows.WindowStartupLocation> に <xref:System.Windows.WindowStartupLocation.Manual> ウィンドウ」の手順に従って配置がその <xref:System.Windows.Window.Left%2A> と <xref:System.Windows.Window.Top%2A> プロパティの値。 どちらの場合、 <xref:System.Windows.Window.Left%2A> または <xref:System.Windows.Window.Top%2A> プロパティが指定されていない場合、その値は、によって決定されます。 [!INCLUDE[TLA2#tla_mswin](~/includes/tla2sharptla-mswin-md.md)]します。  
  
 設定 <xref:System.Windows.WindowStartupLocation.CenterScreen> ウィンドウをマウスのカーソルを含む画面の中央に配置することができます。  
  
 設定 <xref:System.Windows.WindowStartupLocation> に <xref:System.Windows.WindowStartupLocation.CenterOwner> によって、オーナー ウィンドウの中央に配置されるウィンドウ \(を参照してください <xref:System.Windows.Window.Owner%2A>\)、指定されています。 オーナー ウィンドウには、別の WPF ウィンドウまたは WPF 以外のウィンドウのいずれかを指定できます。  
  
> [!NOTE]
>  WPF 以外の windows での WPF ウィンドウの詳細については、次を参照してください。 [WPF と Win32 の相互運用性](http://msdn.microsoft.com/ja-jp/0ffbde0d-701d-45a3-a6fa-dd71f4d9772e) と <xref:System.Windows.Interop.WindowInteropHelper>です。  
  
 同様に、ウィンドウの位置を決定オーナー ウィンドウが指定されていない場合、 <xref:System.Windows.WindowStartupLocation> に設定されている <xref:System.Windows.WindowStartupLocation.Manual>します。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティの値を取得できません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはウィンドウが復元になっていること、最小化、または最大化されているかどうかを示す値を設定します。</summary>
        <value>A <see cref="T:System.Windows.WindowState" /> ウィンドウを復元、最小化、または最大化されているかどうかを決定します。 既定値は <see cref="F:System.Windows.WindowState.Normal" /> \(復元\)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サイズと場所が格納されているウィンドウを最小化または最大化する前に <xref:System.Windows.Window.RestoreBounds%2A>します。 値を使用してそのサイズと位置の値が復元されたウィンドウが復元されるときに <xref:System.Windows.Window.RestoreBounds%2A>します。  
  
 ときに、 <xref:System.Windows.Window.WindowState%2A> プロパティが変更されると、 <xref:System.Windows.Window.StateChanged> が発生します。  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.WindowStateProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.WindowState" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはウィンドウの境界線スタイルを設定します。</summary>
        <value>A <see cref="T:System.Windows.WindowStyle" /> ウィンドウの境界線スタイルを指定します。 既定値は、<see cref="F:System.Windows.WindowStyle.SingleBorderWindow" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Window.WindowStyle%2A> いずれか、 <xref:System.Windows.WindowStyle> 列挙値を含む <xref:System.Windows.WindowStyle.None>, 、<xref:System.Windows.WindowStyle.ToolWindow>, 、<xref:System.Windows.WindowStyle.SingleBorderWindow> \(既定\)、および <xref:System.Windows.WindowStyle.ThreeDBorderWindow>です。  
  
 次の図は、ウィンドウのスタイルを示します [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] \(Windows Vista Aero テーマを有効になっている透明なガラス\)。  
  
 1a3f5340-3e34-40ea-80b6-352e41bd49d1  
  
> [!NOTE]
>  設定またはウィンドウがブラウザーでホストされている場合は、このプロパティを取得できません。  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Window.WindowStyleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.WindowStyle" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>