<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>ルーティング イベントに関連付けられている状態情報とイベント データを格納します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なる <xref:System.Windows.RoutedEventArgs> 、1 つを併用 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>します。 イベント データをパッケージ化するため、このクラスは、 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, 、追加のイベントの状態情報を提供すること、およびルーティングされたイベントに関連付けられているハンドラーは起動のイベント システムによって使用されます。  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このパラメーターなしのコンス トラクター、新しいすべてのパブリック プロパティを使用する場合 <xref:System.Windows.RoutedEventArgs> インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 既定値は `null`です。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値は `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> 既定値は `null`です。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 既定値は `null`です。  
  
 Null 値 <xref:System.Windows.RoutedEventArgs.Source%2A> と <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> のみからといって、 <xref:System.Windows.RoutedEventArgs> データは、ソースを指定する操作を行わない。 呼び出しでこのインスタンスを使用すると <xref:System.Windows.UIElement.RaiseEvent%2A>, 、  <xref:System.Windows.RoutedEventArgs.Source%2A> と <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 要素であるイベントを発生させたでは、routing リスナーに渡されるに基づいて値が設定されます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">このインスタンスにルーティングされたイベント識別子、 <see cref="T:System.Windows.RoutedEventArgs" /> クラスです。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.RoutedEventArgs" /> クラスの指定したルーティングされたイベント識別子を使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードされたコンス トラクターを使用する場合は、新しいプロパティを指定しない <xref:System.Windows.RoutedEventArgs> インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値は `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> 既定値は `null`です。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 既定値は `null`です。  
  
 Null 値 <xref:System.Windows.RoutedEventArgs.Source%2A> と <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> のみからといってこの <xref:System.Windows.RoutedEventArgs> ソースを指定する操作を行わない。 呼び出しでこのインスタンスを使用すると <xref:System.Windows.UIElement.RaiseEvent%2A>, 、  <xref:System.Windows.RoutedEventArgs.Source%2A> と <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 要素であるイベントを発生させたでは、routing リスナーに渡されるに基づいて値が設定されます。  
  
   
  
## 例  
 次の例は、新しい <xref:System.Windows.RoutedEventArgs> への呼び出しで使用する <xref:System.Windows.UIElement.RaiseEvent%2A>です。  
  
 [!code-csharp[RoutedEventCustom\#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom\#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">このインスタンスにルーティングされたイベント識別子、 <see cref="T:System.Windows.RoutedEventArgs" /> クラスです。</param>
        <param name="source">イベントを処理するときに報告を代替のソース。 これによって事前に埋め、 <see cref="P:System.Windows.RoutedEventArgs.Source" /> プロパティです。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.RoutedEventArgs" /> クラス、指定したルーティングされたイベント識別子を使用して、イベントの別のソースを宣言する機会を与えています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードされたコンス トラクターを使用する場合は、新しいプロパティを指定しない <xref:System.Windows.RoutedEventArgs> インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値は `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 既定値は `null`です。  
  
 Null 値 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> は、イベントを発生し、ルーティング、を通じてに渡される要素に基づいて設定されますが、読み取りは `null` 呼び出しの前にします。  
  
 渡すときは、この署名を使用して <xref:System.Windows.RoutedEventArgs> などの仮想メソッドを <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, 呼び出しに引数を使用する場所、 <xref:System.Windows.UIElement.RaiseEvent%2A> 内部的にします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ルーティング イベントがルートをたどる際のイベント処理の現在の状態を示す値を取得または設定します。</summary>
        <value>設定時に、イベントを処理済みとしてマークする場合は <see langword=" true" />、マークしない場合は <see langword="false" /> に設定します。 この値を読み取る場合、<see langword=" true" /> は、クラス ハンドラーまたはルート上にある一部のインスタンス ハンドラーのいずれかが、このイベントを処理済みとして既にマークしていることを示します。<see langword="false" /> は、いずれのハンドラーもイベントを処理済みとしてマークしていないことを示します。  
  
 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Marking the event handled will limit the visibility of the routed event to listeners along the event route. The event does still travel the remainder of the route, but only handlers specifically added with **parameterReference tag is not supported!!!!**  
 **languageKeyword tag is not supported!!!!**  
 in the <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> method call will be invoked in response. Default handlers on instance listeners \(such as those expressed in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]\) will not be invoked. Handling events that are marked handled is not a common scenario.  
  
 If you are a control author defining your own events, the decisions you make regarding event handling at the class level will impact users of your control as well as any users of derived controls, and potentially other elements that are either contained by your control or that contain your control. For more information, see [Marking Routed Events as Handled, and Class Handling](http://msdn.microsoft.com/ja-jp/5e745508-4861-4b48-b5f6-5fc7ce5289d2).  
  
 In very rare circumstances it is appropriate to handle events where  <xref:System.Windows.RoutedEventArgs.Handled%2A> is marked **languageKeyword tag is not supported!!!!**  
, and modify the event arguments by changing <xref:System.Windows.RoutedEventArgs.Handled%2A> to **languageKeyword tag is not supported!!!!**  
. This can be necessary in certain areas of input events of controls, such as key handling of <xref:System.Windows.UIElement.KeyDown> versus <xref:System.Windows.UIElement.TextInput> where low level and high level input events compete for the handling, and each is attempting to work with a different routing strategy.  
  
   
  
## 例  
 The following example implements an event handler that marks the event handled.  
  
 [!code-csharp[ClassHandling\#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling\#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">呼び出すジェネリック ハンドラー\/デリゲート実装。</param>
        <param name="genericTarget">指定したハンドラーが呼び出されるターゲット。</param>
        <summary>派生クラスでオーバーライドされた場合、型固有の方法でイベント ハンドラーを呼び出す方法を提供します。これにより、基本実装よりも効率が向上する場合があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 基本の実装には、いかなる場合においても、ハンドラーが行われていない文字どおりの右側のハンドラーを決定するためにリフレクションが組み込まれています。 <xref:System.Windows.RoutedEventHandler>, 、このリフレクション手順がいくつかのパフォーマンスの影響、ができます。 呼び出しがより効率的でリフレクションに依存しません。 これは、このメソッドをオーバーライドすることを選択、ルーティングされたイベント引数クラスで使用されるこのメソッドの用途シナリオです。 実装呼び出さないでください。 ベースこのメソッドの実装はタイプ セーフなハンドラーの呼び出しを担当する既に必要があります。  
  
   
  
## 例  
 実装に使用できる基本的なパターンを示しています。 擬似コードを次に示します。 ここでは、 `MyRoutedEventHandler` のサブクラスである <xref:System.Windows.RoutedEventHandler>です。  
  
 [!code-csharp[CorePseudocode\#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode\#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This method is intended to be overridden by derived event data classes to provide more efficient invocation of their delegates. The implementation should cast the provided <paramref name="genericHandler" /> to the type-specific delegate, and then invoke that handler.  
  
 The default implementation will attempt to invoke the provided handler, attempting to cast it as <see cref="T:System.Windows.RoutedEventHandler" />. If either <paramref name="genericHandler" /> or <paramref name="genericTarget" /> is provided as <see langword="null" />, exceptions will be raised.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">新しい値 <see cref="P:System.Windows.RoutedEventArgs.Source" /> に設定されています。</param>
        <summary>派生クラスでオーバーライドされた場合は、通知コールバックのエントリを提供するたびにポイントの値、 <see cref="P:System.Windows.RoutedEventArgs.Source" /> インスタンス変更のプロパティです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Changing the reported source of an event programmatically can potentially require updating the type-specific data within the event. For this reason, the <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> method is protected virtual and is intended to be overridden by subclasses of <see cref="T:System.Windows.RoutedEventArgs" />.  
  
 This method has no default implementation.</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親クラスによって <see cref="P:System.Windows.RoutedEventArgs.Source" /> が調整される前の、純粋なヒット テストで判断される元の報告ソースを取得します。</summary>
        <value>複合要素ツリーを平坦化するなどの目的でクラス処理によって <see cref="P:System.Windows.RoutedEventArgs.Source" /> が調整される前の、元の報告ソース。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、いったん、クラスの前にイベント ハンドラーやインスタンス ハンドラーが呼び出されると、このポイント以降は調整しないで、その値を取得します。 元のソース情報は、イベント データで報告されているのと同様はクラス ハンドラーまたはクラスの実装に対して読み取り専用です。  
  
 ソースを調整することが一般的なケースに含まれるコントロールのコンテンツ モデル内のコンテンツの要素 \(たとえば、リスト項目のコンテンツとしてリストの項目要素を報告、 <xref:System.Windows.RoutedEventArgs.Source%2A> リスト項目内の実際の要素があると、 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>です。  
  
 さまざまな要素およびコンテンツ モデルによってソース調整では、クラスによって異なります。 イベント ソースを調整する各クラスがソースは、最も役に立つ大半の入力シナリオと、クラスが対象とするシナリオの報告を予測しようとして、セットをソースとして、 <xref:System.Windows.RoutedEventArgs.Source%2A>です。 このソースがあるは、イベントの処理に関連でない場合は、確認してください。 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 代わりにする場合は、より適切な別のソースがレポートを参照してください。 入力イベントの詳細については、次を参照してください。 [入力の概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.RoutedEventArgs" /> インスタンスに関連付けられている <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> を取得または設定します。</summary>
        <value>呼び出されたイベントの識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この値を設定することはできません、 <xref:System.Windows.RoutedEventArgs> を既ににルーティングされました \(たとえば、ハンドラーを通じて引数を取得した\) 場合。 これを行うときと、例外が生成されます。 イベントの呼び出しの生成に使用されていないインスタンスでのみ設定できます。  
  
 値 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> することはできません `null` いつでもできます。  
  
   
  
## 例  
 次の例は、最初のコンス トラクターを持つ新しいルーティングされたイベント データを作成し、設定、 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 、後続の操作とプロパティ。 必要があります <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> ルーティングされたイベントを発生させる前に設定します。  
  
 [!code-csharp[ColorPicker\_v2\#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker\_v2\#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">イベントのルーティング中に <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 値を変更しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベントを発生させたオブジェクトへの参照を取得または設定します。</summary>
        <value>イベントを発生させたオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 発生元の要素の次のルートを実際に通過したイベントのバブリング ルーティングおよびトンネリング、ルーティングされていないイベントまだトンネリングの値であることを発生させた要素までの <xref:System.Windows.RoutedEventArgs.Source%2A> の値とは異なるありますが、 `sender` イベント引数クラスのパラメーターです。 特定のハンドラーで、最も重要度は、イベントに関連する 2 つの要素のうち \(<xref:System.Windows.RoutedEventArgs.Source%2A>, を発生させた要素または `sender`, 、処理は、現在の要素\) は、ハンドラーのアドレスを指定するアプリケーション ロジックに依存します。  
  
 このプロパティの設定は通常のみ行われますオーバーライドまたは実装するその他の [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 場合などのイベント ソースを調整するクラス イベントを処理します。 特に、処理済みと、ハンドラーが、イベントをマークしない場合、インスタンス ハンドラーからイベント ソースを再設定はお勧めしません。  
  
 実行をリセットする場合 <xref:System.Windows.RoutedEventArgs.Source%2A> 、別のイベント ソースをレポートする <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> は引き続きレポートの最初のソースが、生成元で発生した <xref:System.Windows.UIElement.RaiseEvent%2A> を呼び出します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>