<Type Name="UIElement3D" FullName="System.Windows.UIElement3D">
  <TypeSignature Language="C#" Value="public abstract class UIElement3D : System.Windows.Media.Media3D.Visual3D, System.Windows.IInputElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract UIElement3D extends System.Windows.Media.Media3D.Visual3D implements class System.Windows.IInputElement" />
  <TypeSignature Language="DocId" Value="T:System.Windows.UIElement3D" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Media3D.Visual3D</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <see cref="T:System.Windows.UIElement3D" /> は、Windows Presentation Foundation (WPF) の要素および基本表示特性における WPF コア レベル実装構築の基底クラスです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D> 3D の特定の要素を表すクラスを派生するため、抽象基本クラスです。  
  
 3D の要素の入力、重点を置くこと、およびイベント処理の動作の多くで一般的で定義されて、 <xref:System.Windows.UIElement3D> クラスです。 これには、キーボード、マウス、およびスタイラスからの入力、および関連するステータスのプロパティについては、イベントが含まれます。 ルーティングされたイベントは、これらのイベントの多くは、バブル、両方のルーティングの入力に関連するイベントの多くがあるバージョンだけでなく、イベントのトンネルのバージョン。 これらのイベントのペアは、通常、コントロールを作成する最も関心を持ってイベントです。  
  
 <xref:System.Windows.UIElement3D> 含まれています [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] に関連した、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] イベント モデルでは、指定させることができるメソッドを含む要素のインスタンスが基づいているイベントをルーティングします。  
  
 A <xref:System.Windows.UIElement3D> で具体的に定義されている次の機能を持つ、 <xref:System.Windows.UIElement3D> クラス。  
  
-   ユーザー入力に応答できます \(イベントの処理を使用して、入力の送信先の制御などのルーティングやコマンドのルーティング\)。  
  
-   要素の論理ツリー内のルートに移動するルーティングされたイベントを発生させることができます。  
  
> [!IMPORTANT]
>  <xref:System.Windows.UIElement3D.Visibility%2A> 状態では、すべての入力をその要素での処理に影響します。 表示されていない要素は、ヒット テストに参加していないと、要素があるとの境界上にマウスが場合でも、入力イベントを受け取りません場合に表示されていた。  
  
 異なり、 <xref:System.Windows.UIElement> 、クラス、 <xref:System.Windows.UIElement3D> クラスではレイアウトは含まれません。 したがって、 <xref:System.Windows.UIElement3D> クラスが含まれません **メジャー** または **配置** メソッドです。  
  
 派生したクラス <xref:System.Windows.UIElement3D> の独自のコレクションを保持および <xref:System.Windows.Media.Media3D.Visual3D> オーバーライドすることによってオブジェクト <xref:System.Windows.Media.Media3D.Visual3D.GetVisual3DChild%2A> と <xref:System.Windows.Media.Media3D.Visual3D.Visual3DChildrenCount%2A> も新しいに合格する必要があります <xref:System.Windows.Media.Media3D.Visual3D> オブジェクトを <xref:System.Windows.Media.Media3D.Visual3D.AddVisual3DChild%2A>します。  
  
 <xref:System.Windows.UIElement3D> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 次の例から派生させる方法、 <xref:System.Windows.UIElement3D> を作成するクラス、 `Sphere` クラス。  
  
 [!code-csharp[Shapes\#Sphere](~/samples/snippets/csharp/VS_Snippets_Wpf/Shapes/CSharp/Sphere.cs#sphere)]
 [!code-vb[Shapes\#Sphere](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Shapes/visualbasic/sphere.vb#sphere)]  
  
 完全なサンプルを参照してください。 [UIElement3D Sphere Sample](http://go.microsoft.com/fwlink/?LinkID=160044)します。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIElement3D ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.UIElement3D" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.%23ctor%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">処理するルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 例外を発生させずは、同じイベントに対して同じハンドラーを複数回追加できます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装において考慮する必要があります副作用がある可能性がありますを検討してください。  
  
 通常の"add"アクセサーの実装を提供するこのメソッドを使用する、 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] カスタム ルーティング イベントのイベントのアクセス パターンです。  
  
 <xref:System.Windows.UIElement3D.AddHandler%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドルするルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <param name="handledEventsToo">イベント データ内でルーティング イベントがハンドル済みとしてマークされている場合でも呼び出されるようにハンドラーを登録するには <see langword="true" />。ルーティング イベントが既にハンドル済みとしてマークされている場合はハンドラーを呼び出ないという既定の条件を使用してハンドラーを登録する場合は <see langword="false" />。  
  
 既定値は、<see langword="false" /> です。  
  
 ルーティング イベントの再処理を機械的に要求しないでください。 詳細については、「解説」を参照してください。</param>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。 イベント ルート上の別の要素により既にハンドル済みとしてマークされているルーティング イベントに対し、指定したハンドラーが呼び出されるようにするには、<paramref name="handledEventsToo" /> を <see langword="true" /> に指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複雑な作業は、実用的な方法で低レベルの入力イベントを処理します。 多くのコントロールと、特定のイベントが処理され、マーク、他のより直観的なイベントで交換の動作を実装します。 一般に、そのための設計上の意図がある場合を処理済みとして、コントロールはプラットフォームの入力イベントをマークだけです。 特定のシナリオで、設計上の意図、特定の入力イベントの処理が必要とは限りません。 そのを登録するようなシナリオはハンドラー `handledEventsToo` として `true` が適切です。 日常的に行いますされません。 処理される場合でも、すべてのイベントに応答ハンドラーを呼び出すと、独自のアプリケーション イベント処理ロジックが複雑になります。 ハンドラーのロジックが大きな場合は、パフォーマンスの低下を参照してください可能性があります。 既にいくつかのコントロールは、アプリケーション ロジックで処理するイベントを処理は開発プロセス中に発見した場所の場合の処理済みのイベントのハンドラーのアタッチの使用を予約する必要があります。  
  
 クラスの処理を特定のイベントとコントロールの組み合わせの動作を回避するためのもう 1 つの方法では、そのイベントのプレビューを代わりに使用します。 たとえば場合、 <xref:System.Windows.UIElement3D.MouseLeftButtonDown> 処理済みとしてマークは、クラスの処理によってこともできますのハンドラーを追加する <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> 代わりにします。  
  
 例外を発生させずは、同じイベントに対して同じハンドラーを複数回追加できます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装において考慮する必要があります副作用がある可能性がありますを検討してください。  
  
 通常の"add"アクセサーの実装を提供するこのメソッドを使用する、 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] カスタム ルーティング イベントのイベントのアクセス パターンです。  
  
 <xref:System.Windows.UIElement3D.AddHandler%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">ハンドラーに追加されるイベントのルートです。</param>
        <param name="e">ハンドラーの追加に使用されるイベントのデータ。 このメソッドを使用して、 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> ハンドラーを作成するイベント データのプロパティです。</param>
        <summary>指定したハンドラーを追加する <see cref="T:System.Windows.EventRoute" /> 現在の <see cref="T:System.Windows.UIElement3D" /> イベント ハンドラーのコレクション。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コンテンツ ホスト要素で使用できます \(いずれかを実装するもの <xref:System.Windows.IContentHost> またはいない場合は\) の子要素のハンドラーを追加する、 <xref:System.Windows.EventRoute>です。  
  
 <xref:System.Windows.UIElement3D.AddToEventRoute%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ アンド ドロップ操作の対象として使用できるかどうかを示す値を取得または設定します。</summary>
        <value>この要素をドラッグアンドドロップ操作の対象として使用できる場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ドラッグ アンド ドロップ操作が既定では、有効でないと、設定して意図的に有効にする必要があります <xref:System.Windows.UIElement3D.AllowDrop%2A> に `true`します。 この基本的な設定を超えるドラッグ アンド ドロップの動作は完全に特定の実装とによって定義されていない <xref:System.Windows.UIElement3D> またはその他の要素の基本クラスです。 たとえば、特定のコントロール <xref:System.Windows.Controls.RichTextBox>, 、既定の動作を持つ操作を行います。 ドラッグ アンド ドロップの詳細については、次を参照してください。 [ドラッグ アンド ドロップの概要](http://msdn.microsoft.com/ja-jp/1a5b27b0-0ac5-4cdf-86c0-86ac0271fa64)します。  
  
 <xref:System.Windows.UIElement3D.AllowDrop%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.AllowDropProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.AllowDrop" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.AllowDropProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、少なくとも 1 つのタッチをキャプチャするかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 少なくとも 1 つのタッチの場合はこの要素にキャプチャします。それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.AreAnyTouchesCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のすべての子要素には、少なくとも 1 つのタッチがキャプチャされているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素またはそのビジュアル ツリー内のすべての子要素にキャプチャされる場合は、少なくとも 1 つのタッチそれ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.AreAnyTouchesCapturedWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上に少なくとも 1 つのタッチが押されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素上には、少なくとも 1 つのタッチが押された場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.AreAnyTouchesDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のすべての子要素の上に少なくとも 1 つのタッチが押されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素またはそのビジュアル ツリー内のすべての子要素の上には、少なくとも 1 つのタッチが押された場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.AreAnyTouchesOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.CaptureMouse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にマウスのキャプチャを強制しようとします。</summary>
        <returns>
          <see langword="true" /> マウスが正常にキャプチャされた場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャプチャされる要素を有効にする必要があります。 確認するかどうか <xref:System.Windows.UIElement3D.IsEnabled%2A> は `true` を呼び出す前に <xref:System.Windows.UIElement3D.CaptureMouse%2A>します。  
  
 呼び出す場合 <xref:System.Windows.UIElement3D.CaptureMouse%2A> 返します `true`, 、し <xref:System.Windows.UIElement3D.IsMouseCaptured%2A> も `true`です。  
  
 呼び出す場合 <xref:System.Windows.UIElement3D.CaptureMouse%2A> を返します `true`, 、 <xref:System.Windows.UIElement3D.GotMouseCapture> と <xref:System.Windows.UIElement3D.IsMouseCapturedChanged> イベントが発生すると <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=fullName> 要素としてデータを報告するイベントの場所、 <xref:System.Windows.UIElement3D.CaptureMouse%2A> メソッドが呼び出されます。 キャプチャを強制する場合は、既存のキャプチャを妨げることがあります: 特にのマウスでドラッグ アンド ドロップに関連するキャプチャします。  
  
 すべての要素からマウスのキャプチャをクリアするを呼び出す <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=fullName> で、 `element` として指定されたパラメーター `null`します。  
  
 <xref:System.Windows.UIElement3D.CaptureMouse%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.CaptureStylus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>強制的にこの要素にスタイラスをキャプチャしようとします。</summary>
        <returns>
          <see langword="true" /> スタイラスが正常にキャプチャされた場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装を常に基になる既定のスタイラス デバイスに基づいて `true`します。 ただし、入力システムのデバイスの実装を提供する入力デバイスを拡張する場合は、異なる結果を返す可能性のある代替のスタイラス デバイスの実装を含む、システムを作成することです。  
  
 スタイラスをキャプチャする要素は、スタイラスがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このメソッドを呼び出す、基になる静的 <xref:System.Windows.Input.Stylus> メソッド <xref:System.Windows.Input.Stylus.Capture%2A>します。 実際のキャプチャの動作は、アクティブなスタイラス デバイスの実装によって実装されます。  
  
 キャプチャされる要素を有効にする必要があります。 確認するかどうか <xref:System.Windows.UIElement3D.IsEnabled%2A> は `true` を呼び出す前に返す <xref:System.Windows.UIElement3D.CaptureStylus%2A>します。  
  
 呼び出す場合 <xref:System.Windows.UIElement3D.CaptureStylus%2A> 返します `true`, 、<xref:System.Windows.UIElement3D.IsStylusCaptured%2A> も `true`です。  
  
 <xref:System.Windows.UIElement3D.CaptureStylus%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">キャプチャするデバイスです。</param>
        <summary>この要素に強制的にタッチをキャプチャしようとします。</summary>
        <returns>
          <see langword="true" /> この要素に指定したタッチがキャプチャされている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.CaptureTouch%2A> 戻ります `false` 場合、 <xref:System.Windows.Input.TouchDevice> 別の要素にキャプチャされています。  
  
 場合 <xref:System.Windows.UIElement3D.CaptureTouch%2A> 返します `true`, 、 <xref:System.Windows.UIElement3D.GotTouchCapture> イベントが発生します。  
  
 解放するにはこの要素から 1 つのタッチのキャプチャを使用して、 <xref:System.Windows.UIElement3D.ReleaseTouchCapture%2A> メソッドを解放する、タッチ デバイスを指定します。 解放するにはこの要素からすべてのタッチを使用して、 <xref:System.Windows.UIElement3D.ReleaseAllTouchCaptures%2A> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コレクションを取得 <see cref="T:System.Windows.Input.CommandBinding" /> この要素に関連付けられているオブジェクト。</summary>
        <value>すべてのコレクション <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Windows.Input.CommandBinding> この要素の特定のコマンドのコマンドの処理を有効にし、コマンド、そのイベントでは、この要素にアタッチされたハンドラー間のリンケージを宣言します。  
  
 別の一般的な方法を設定する、 <xref:System.Windows.UIElement3D.CommandBindings%2A> コレクションは、使用する <xref:System.Windows.Input.CommandManager> メソッド プログラムを使用しています。  
  
 <xref:System.Windows.UIElement3D.CommandBindings%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## XAML プロパティ要素の使用  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## XAML 値  
 *oneOrMoreCommandBindings*  
 1 つまたは複数 <xref:System.Windows.Input.CommandBinding> 要素。 これらの各、 <xref:System.Windows.Input.CommandBinding.Command%2A> 属性既知のコマンドに設定され、に対して属性が設定、 <xref:System.Windows.Input.CommandBinding.CanExecute> と <xref:System.Windows.Input.CommandBinding.Executed> ハンドラーの実装です。 詳細については、「<xref:System.Windows.Input.CommandBinding>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.DragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName> attached event for this class, so that <xref:System.Windows.UIElement3D.DragEnter?displayProperty=fullName> is part of the class members list when <xref:System.Windows.UIElement3D> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.UIElement3D.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName> attached event and receive the same event data instance.  
  
 <xref:System.Windows.UIElement3D.DragEnter> is introduced in the .NET Framework version 3.5.  For more information, see [.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90).  
  
<a name="routedEventInfo_DragEnter"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement3D.DragEnterEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.UIElement3D.PreviewDragEnter>.  
  
-   Override <xref:System.Windows.UIElement3D.OnDragEnter%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.DragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 <xref:System.Windows.UIElement3D.DragEnterEvent> is introduced in the .NET Framework version 3.5.  For more information, see [.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90).  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.DragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName> attached event for this class so that <xref:System.Windows.UIElement3D.DragLeave?displayProperty=fullName> is part of the class members list when <xref:System.Windows.UIElement3D> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.UIElement3D.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName> attached event and receive the same event data instance.  
  
 <xref:System.Windows.UIElement3D.DragLeave> is introduced in the .NET Framework version 3.5.  For more information, see [.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90).  
  
<a name="routedEventInfo_DragLeave"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement3D.DragLeaveEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.UIElement3D.PreviewDragLeave>.  
  
-   Override <xref:System.Windows.UIElement3D.OnDragLeave%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragEnter" />
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
        <altmember cref="E:System.Windows.UIElement3D.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.DragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 <xref:System.Windows.UIElement3D.DragLeaveEvent> is introduced in the .NET Framework version 3.5.  For more information, see [.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90).  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.DragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event occurs even if the drag originates in the element bounds. If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.UIElement3D.DragEnter> and related preview events.  
  
 This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=fullName> attached event for this class so that <xref:System.Windows.UIElement3D.DragOver?displayProperty=fullName> is part of the class members list when <xref:System.Windows.UIElement3D> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.UIElement3D.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=fullName> attached event and receive the same event data instance.  
  
 <xref:System.Windows.UIElement3D.DragOver> is introduced in the .NET Framework version 3.5.  For more information, see [.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90).  
  
<a name="routedEventInfo_DragOver"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement3D.DragOverEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.UIElement3D.PreviewDragOver>.  
  
-   Override <xref:System.Windows.UIElement3D.OnDragOver%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragEnter" />
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
        <altmember cref="E:System.Windows.UIElement3D.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.DragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 <xref:System.Windows.UIElement3D.DragOverEvent> is introduced in the .NET Framework version 3.5.  For more information, see [.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90).  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.Drop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=fullName> attached event for this class so that <xref:System.Windows.UIElement3D.Drop?displayProperty=fullName> is part of the class members list when <xref:System.Windows.UIElement3D> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.UIElement3D.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=fullName> attached event and receive the same event data instance.  
  
 <xref:System.Windows.UIElement3D.Drop> is introduced in the .NET Framework version 3.5.  For more information, see [.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90).  
  
<a name="routedEventInfo_Drop"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement3D.DropEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.UIElement3D.PreviewDrop>.  
  
-   Override <xref:System.Windows.UIElement3D.OnDrop%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
        <altmember cref="E:System.Windows.UIElement3D.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.Drop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 <xref:System.Windows.UIElement3D.DropEvent> is introduced in the .NET Framework version 3.5.  For more information, see [.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90).  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素に論理フォーカスを設定しようとします。</summary>
        <returns>
          <see langword="true" /> 場合論理し、この要素にキーボード フォーカスが設定されました <see langword="false" /> 論理フォーカスが設定された場合のみです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスを <xref:System.Windows.UIElement3D.Focusable%2A> と <xref:System.Windows.UIElement3D.IsEnabled%2A> 両方 `true`します。  
  
 要素は、特定のツリー内でのフォーカスを取得できる、有効な場合は、イベントの処理が、たとえプレビュー フォーカス イベントにフォーカスがある、許可しないことによって応答 \(複合コントロールなど\) ためこのメソッドは `false`です。  
  
 呼び出す場合  <xref:System.Windows.UIElement3D.Focus%2A> 返します `true`, 、<xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> と <xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A> も `true`です。  
  
 関連するプロパティがない場合 `true`, を呼び出したときに、  <xref:System.Windows.UIElement3D.Focus%2A>, 、1 つ以上の次のイベントが次の順序で発生します: <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus>, 、<xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus> \(ソースは新しいフォーカス ターゲット\)、 <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged>, 、<xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged>, 、<xref:System.Windows.UIElement3D.LostKeyboardFocus>, 、<xref:System.Windows.UIElement3D.GotKeyboardFocus> \(ソースは新しいフォーカス ターゲット\)。  
  
 この呼び出しを成功させるためには、アプリケーションの他の要素は、以前にフォーカスがあるに必要です。  
  
 一般にフォーカスが 2 つの異なる概念によって制御されます。 キーボード フォーカスと論理フォーカスは、常に同じではありません。 このメソッドは、論理フォーカスを設定し、キーボード フォーカスを設定しようとしてもします。 キーボード フォーカスを具体的には、設定のユーザー入力によってこの問題は発生するプログラムの手段はありません。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.Focus%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.Focusable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素がフォーカスを得ることができるかどうかを示す値を取得または設定します。</summary>
        <value>要素がフォーカス可能な場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は <see langword="false" /> ですが、「解説」をご覧ください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスがある要素だけでは、キーボード入力を受け取ります。  
  
 <xref:System.Windows.UIElement3D.Focusable%2A> [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] 何が実際には、依存関係プロパティのプロパティ アクセサー。 この特定の依存関係プロパティでは、要素の派生クラスで設定が異なります見かけ上の「既定」値が非常によくあります。 これは、2 つの方法のいずれかで一般的に発生します。  
  
-   特定の派生クラスで依存関係プロパティが継承されますが、派生したクラスのオーバーライドの依存関係プロパティのメタデータとプロパティの既定値を変更します。  
  
 <xref:System.Windows.UIElement3D.Focusable%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.FocusableProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement3D.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.FocusableChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.Focusable" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.FocusableChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.Focusable" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.FocusableProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.GetUIParentCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、別の方法を返す ユーザー インターフェイス (UI) ビジュアル親が存在しない場合、この要素の親です。</summary>
        <returns>派生クラスの実装が代替親レポートに接続している場合のオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの既定の仮想実装 `null`します。<xref:System.Windows.FrameworkElement> 実用的な実装を提供します。  
  
 別の親は、要素が別の親の構造体を作成することで、そのイベントは、標準の親にビジュアル ツリーをルーティングの標準的なパターンから逸脱した方法でルーティングまたはプレビュー ルーティング戦略の下位方向へ場所の場合、イベントのルーティングに使用されます。  
  
 <xref:System.Windows.UIElement3D.GetUIParentCore%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素を対象とするドラッグ アンド ドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.GiveFeedback> イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。 視覚的なフィードバックは、ドラッグ アンド ドロップ操作が、プロセスを強化します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.UIElement3D.GiveFeedback> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.GiveFeedback> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.GiveFeedback> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.GiveFeedbackEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewGiveFeedback>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnGiveFeedback%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.GiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.GiveFeedbackEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスがメソッド呼び出しを使用して強制的に意図的に直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 ここでは、要素にキーボード フォーカスが残り、このシナリオで、 <xref:System.Windows.UIElement3D.Focus%2A> メソッドはまだ論理フォーカスを取得します。  
  
 このイベントのより正確な解釈がその it 発生する状況の値、 <xref:System.Windows.UIElement3D.IsFocused%2A> からルート内の要素のプロパティが変更された `false` に `true`します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを受け取る要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを得られる実際の要素を特定のイベント データ。  
  
 <xref:System.Windows.UIElement3D.GotFocus> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_GotFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.GotFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnGotFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.GotFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.GotFocusEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged> 要素のフォーカスの状態を保持するプロパティの状態の変更を追跡するようなイベント <xref:System.Windows.UIElement3D.GotKeyboardFocus> イベントは、多くの同じ状況で発生します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際にアタッチされている要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスがある実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.UIElement3D.GotKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.GotKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.GotKeyboardFocus> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.GotKeyboardFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnGotKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.GotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.GotKeyboardFocusEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotMouseCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウスをキャプチャする要素は、境界外にマウス ポインターがあって、マウス入力を受け取ります。 マウスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャしは、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャされたします。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> 、イベントをマウスを持つ実際の要素を特定のデータをキャプチャします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.UIElement3D.GotMouseCapture> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.GotMouseCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.GotMouseCapture> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.GotMouseCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnGotMouseCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.GotMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.GotMouseCaptureEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotStylusCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスをキャプチャする要素は、ポインターがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスでは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャを保持します。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> 、イベント データがキャプチャを持つ実際の要素を特定します。  
  
 このイベントは、このクラスにアタッチされるイベントのエイリアスを作成できるように <xref:System.Windows.UIElement3D.GotStylusCapture> 一部であるクラスのメンバー一覧をいつ <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.GotStylusCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.GotStylusCapture> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.GotStylusCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnGotStylusCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.GotStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.GotStylusCaptureEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotTouchCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、タッチがキャプチャされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.GotTouchCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnGotTouchCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.GotTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関連付けられている入力のバインディングのコレクションを取得します。</summary>
        <value>入力バインディングのコレクションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 入力バインディングは、コマンドを入力デバイスのバインディングをサポートします。 たとえば、 <xref:System.Windows.Input.MouseBinding> 入力マウス デバイスに固有のプロパティを含むバインディングを実装します。  
  
 入力バインディングとバインディングのインスタンスを宣言するだけでなく、型に関連する、入力バインディングのコレクションが含まれます。  
  
 関連するプロパティ、 <xref:System.Windows.UIElement3D.CommandBindings%2A>, 、コマンドのショートカット キーのコレクションを保持します。 これは、プロセスは停止コマンドの処理 \- 既知のコマンドに関連付けられているアクションの次のレベルを表しているという点で入力バインディングとは異なります。  
  
 <xref:System.Windows.UIElement3D.InputBindings%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## XAML プロパティ要素の使用  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## XAML 値  
 *oneOrMoreInputBindings*  
 1 つまたは複数 <xref:System.Windows.Input.InputBinding> 要素 \(通常、 <xref:System.Windows.Input.KeyBinding> または <xref:System.Windows.Input.MouseBinding> 派生クラス\)。 これらの各が予期、 <xref:System.Windows.Input.InputBinding.Command%2A> と <xref:System.Windows.Input.InputBinding.Gesture%2A> 属性が設定されます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateModel">
      <MemberSignature Language="C#" Value="public void InvalidateModel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.InvalidateModel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要素を表すモデルが無効になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クラスを派生する場合、 <xref:System.Windows.UIElement3D> クラスと共にこのメソッドを使用する、 <xref:System.Windows.UIElement3D.OnUpdateModel%2A> 要素のモデルを更新する方法です。  
  
 高度なシナリオでこのメソッドを呼び出す必要があるだけです。 このような高度なシナリオの 1 つは、派生クラスには、外観に影響する複数のプロパティと、基になるモデルを 1 回のみ更新するかどうかです。  
  
 <xref:System.Windows.UIElement3D.InvalidateModel%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 次の例から派生させる方法、 <xref:System.Windows.UIElement3D> を作成するクラス、 `Sphere` クラス。  
  
 [!code-csharp[Shapes\#Sphere](~/samples/snippets/csharp/VS_Snippets_Wpf/Shapes/CSharp/Sphere.cs#sphere)]
 [!code-vb[Shapes\#Sphere](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Shapes/visualbasic/sphere.vb#sphere)]  
  
 完全なサンプルを参照してください。 [UIElement3D Sphere Sample](http://go.microsoft.com/fwlink/?LinkID=160044)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が ユーザー インターフェイス (UI) で有効かどうかを示す値を取得または設定します。</summary>
        <value>コンポーネントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クラスに固有の実装によってこのプロパティは影響を受けることに注意してください <xref:System.Windows.UIElement3D.IsEnabledCore%2A> 実行時に多くの場合、特定の要素にします。 したがって、ここで表示されている既定値がありますいない効果的です。 この値を設定しようとしても可能性があるによってオーバーライドされますによって返される値 <xref:System.Windows.UIElement3D.IsEnabledCore%2A>です。  
  
 有効になっていない要素は、ヒット テストやフォーカスに参加していないと、そのため、入力イベントのソースはできません。  
  
 <xref:System.Windows.UIElement3D.IsEnabled%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsEnabledProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsEnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsEnabledChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsEnabled" /> プロパティでこの要素を変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsEnabledChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>戻り値になる値を取得 <see cref="P:System.Windows.UIElement3D.IsEnabled" /> 派生クラスです。</summary>
        <value>コンポーネントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsEnabledCore%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled. (If the parent is not enabled, the child element cannot be effectively enabled in practical [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</para>
        </block>
        <altmember cref="E:System.Windows.UIElement3D.IsEnabledChanged" />
        <altmember cref="P:System.Windows.UIElement3D.IsEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsEnabled" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsEnabledProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に論理フォーカスがあるかどうかを判断する値を取得します。</summary>
        <value>この要素に論理フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーションは、複数のフォーカス区分をなど\] メニューの内容と、アプリケーションの残りの部分の間に、論理フォーカスはキーボード フォーカスと異なる場合があります。 このシナリオでは、アプリケーションの UI の 1 つの要素にキーボード フォーカスが設定できるだけ、ただし、他のフォーカス区分の特定の要素がありますも保持する論理フォーカスします。 論理フォーカスの詳細については、次を参照してください。 [フォーカス概要](http://msdn.microsoft.com/ja-jp/0230c4eb-0c8a-462b-ac4b-ae3e511659f4)します。  
  
 \(これは読み取り専用\)、このプロパティを設定してフォーカスを設定しないとします。 このプロパティの一般的な使用方法がの依存関係プロパティとして使用するには、 <xref:System.Windows.Setter> または <xref:System.Windows.EventTrigger>です。 フォーカスを設定するプログラムを使用して、 <xref:System.Windows.UIElement3D.Focus%2A>です。 ユーザーによる操作やマウスのキャプチャの動作を含む可能性、コントロールの実装で、フォーカスを設定もできます。  
  
 <xref:System.Windows.UIElement3D.IsFocused%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsFocusedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.Focusable" />
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsFocusedProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisible">
      <MemberSignature Language="C#" Value="public bool IsHitTestVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHitTestVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsHitTestVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が、表示される内容のある部分からのヒット テストの結果として返されるかどうかを宣言する値を取得または設定します。</summary>
        <value>この要素が少なくとも 1 つの点からヒット テストの結果として返される場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティで有効な値は、論理ツリー内のヒット テスト可能な要素の相対位置が反映されます。 たとえば、要素の子要素にある要素が表示されているテストをヒットしません、子のプロパティの有効な値のまま `false`, 場合でも、その値をローカルに設定しようとしています。 この理由は、設定しないことが重要 <xref:System.Windows.UIElement3D.IsHitTestVisible%2A> に `false` 複合コントロールの任意の入力を必要なまたはそのコントロールでヒット テストしない限り、します。 ヒット テストの詳細については、次を参照してください。 [ビジュアル層でテスト ヒット](http://msdn.microsoft.com/ja-jp/b1a64b61-14be-4d75-b89a-5c67bebb2c7b)します。  
  
 <xref:System.Windows.UIElement3D.IsHitTestVisible%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsHitTestVisible"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsHitTestVisibleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsHitTestVisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsHitTestVisibleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsHitTestVisible" /> この要素に依存関係プロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsHitTestVisibleChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHitTestVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHitTestVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsHitTestVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsHitTestVisible" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsHitTestVisibleProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Input Method Editor \(IME\) などの入力方式システムがこの要素への入力の処理に対して有効になっているかどうかを示す値を取得します。</summary>
        <value>入力方式がアクティブである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 基礎となる添付プロパティの既定値は <see langword="true;" /> ですが、この値は実行時の入力方式の実際の状態の影響を受けます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 添付プロパティによって返される値を返します <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=fullName> 現在有効な入力方法 \(キーボード、音声、他の入力デバイス\)。  
  
 <xref:System.Windows.UIElement3D.IsInputMethodEnabled%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがあるかどうかを示す値を取得します。</summary>
        <value>この要素にキーボード フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスに関連するイベントは、このプロパティの値への変更を伴うことができます。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> <xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A> でよく使われるクラスのイベント ハンドラー内でその他の入力に関連するイベントのインスタンス要素は既にキーボード フォーカス、またはイベントとキーボード イベントで組み合わせて発生時のマウスを決定するかを決定します。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsKeyboardFocusedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotFocus" />
        <altmember cref="E:System.Windows.UIElement3D.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsKeyboardFocusedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsKeyboardFocused" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsKeyboardFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusedProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キーボード フォーカスがその要素またはそのビジュアル ツリーの子要素内の任意の場所にあるかどうかを示す値を取得します。</summary>
        <value>キーボード フォーカスがその要素またはその子要素にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの値に対する変更で通常発生、 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged> イベント、派生クラスがオーバーライドされない限り、 <xref:System.Windows.UIElement3D.OnIsKeyboardFocusWithinChanged%2A> を抑制する状況、イベントです。  
  
 このプロパティを直接設定しないが、要素にフォーカスを設定するにを呼び出して <xref:System.Windows.UIElement3D.Focus%2A>, を作成したりして、 <xref:System.Windows.UIElement3D.MoveFocus%2A> 要求します。 このプロパティの値を変更するこれらのメソッド呼び出しのいずれかの可能性があります。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> <xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A> 通常内で使用されるクラスのイベント ハンドラーの他の入力に関連するイベントのインスタンス要素は既にキーボード フォーカス、またはイベントとキーボード イベントで組み合わせて発生時のマウスを決定するかを決定します。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsKeyboardFocusWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsKeyboardFocusWithin" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsKeyboardFocusWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にマウスがキャプチャされるかどうかを示す値を取得します。</summary>
        <value>要素にマウス キャプチャがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウスの状態のキャプチャ プロセスでのドラッグ アンド ドロップの操作に関連しています。  
  
 <xref:System.Windows.UIElement3D.IsMouseCaptured%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsMouseCapturedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureMouse" />
        <altmember cref="E:System.Windows.UIElement3D.GotMouseCapture" />
        <altmember cref="E:System.Windows.UIElement3D.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsMouseCapturedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsMouseCaptured" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsMouseCapturedChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsMouseCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsMouseCapturedProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはビジュアル ツリー内の子要素がマウスのキャプチャを保持するかどうかを決定する値を取得します。</summary>
        <value>この要素または格納されている要素がマウス キャプチャを持つ場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsMouseCaptureWithin%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsMouseCaptureWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseCaptured" />
        <altmember cref="M:System.Windows.UIElement3D.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsMouseCaptureWithin" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsMouseCaptureWithinChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsMouseCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsMouseCaptureWithinProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。</summary>
        <value>マウス ポインターがヒット テストと同じ要素の結果上にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり <xref:System.Windows.UIElement3D.IsMouseOver%2A>, 、のみ、このプロパティは `true` マウス ポインターがリテラルの要素の上にある場合などは、ヒット テストとして。 マウス ポインターが代わりに子要素の場合、このプロパティになります `false`します。 コントロールをいないオーサリングするほとんどのシナリオを使用して <xref:System.Windows.UIElement3D.IsMouseOver%2A> 代わりにします。  
  
 この要素によって、マウスがキャプチャされていて、このプロパティは、 `true` のキャプチャ時に、このプロパティを返し続けます `true` マウスのキャプチャが失われ、ポインターはその境界から出るまでです。  
  
 <xref:System.Windows.UIElement3D.IsMouseDirectlyOver%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsMouseDirectlyOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement3D.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsMouseDirectlyOverChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsMouseDirectlyOver" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsMouseDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsMouseDirectlyOverProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsMouseDirectlyOverChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素 \(ビジュアル ツリー内の子要素を含む\) の上にあるかどうかを示す値を取得します。</summary>
        <value>マウス ポインターが要素またはその子要素の上にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 通常、コントロールに合成できるため、すべてのコントロール \(ビジュアル ツリー\) 内のさまざまな要素が含まれるコントロールに対してマウスの状態を報告です。 たとえば、 <xref:System.Windows.Controls.ListBox> スタイルのコントロールがレポート <xref:System.Windows.UIElement3D.IsMouseOver%2A> として `true` 場合は、geometry 上にマウスが任意の場所も含めて <xref:System.Windows.Controls.ListBoxItem>します。  
  
 類似しています"IsMouseOverChanged"イベントが存在しないがいくつかのようなイベントを行います。 たとえば、処理 <xref:System.Windows.UIElement3D.MouseEnter>, 、<xref:System.Windows.UIElement3D.MouseMove>, 、および <xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged>です。  
  
 この要素がマウスをキャプチャする場合に、このプロパティが残ります `true` マウスのキャプチャが失われ、マウス ポインターが要素の境界を離れるまでです。  
  
 一部のコントロールは、意図的に、マウスに直接関係しない特定の操作上にマウス ポインターをキャプチャします。 これにより、 <xref:System.Windows.UIElement3D.IsMouseOver%2A> される `true` マウスが移動がない場合でもです。  
  
 <xref:System.Windows.UIElement3D.IsMouseOver%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsMouseOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsMouseOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsMouseOverProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素によってスタイラスがキャプチャされるかどうかを示す値を取得します。</summary>
        <value>要素にスタイラスのキャプチャがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.IsStylusCaptured%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsStylusCapturedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureStylus" />
        <altmember cref="E:System.Windows.UIElement3D.GotStylusCapture" />
        <altmember cref="E:System.Windows.UIElement3D.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsStylusCapturedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsStylusCaptured" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsStylusCapturedChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsStylusCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsStylusCapturedProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素、または要素の境界とそのビジュアル ツリー内の要素がスタイラス キャプチャを保持するかどうかを示す値を取得します。</summary>
        <value>この要素または格納されている要素がスタイラスのキャプチャを持つ場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.IsStylusCaptureWithin%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsStylusCaptureWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureStylus" />
        <altmember cref="P:System.Windows.UIElement3D.IsStylusCaptured" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsStylusCaptureWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsStylusCaptureWithin" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsStylusCaptureWithinChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsStylusCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsStylusCaptureWithinProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsStylusCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスの位置が要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。</summary>
        <value>スタイラス ポインターがヒット テストと同じ要素結果の上にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり <xref:System.Windows.UIElement3D.IsStylusOver%2A>, 、このプロパティはのみ `true` スタイラスが要素上にある場合。 スタイラスの代わりに、子要素または要素のより深い複合 \(ビジュアル ツリー\) の一部である要素を場合、このプロパティになります `false`します。  
  
 コントロールは複合方法がわかっていない限り、\(たとえば、このプロパティを使用したカスタム コントロール テンプレートで定義したコントロールの\) このプロパティは、予期しない結果を返す場合があります。 コントロールをいないオーサリングするほとんどのシナリオを使用して <xref:System.Windows.UIElement3D.IsStylusOver%2A> 代わりにします。  
  
 この要素は、スタイラスをキャプチャすると、このプロパティは、 `true` のキャプチャ時に、このプロパティの値 `true` スタイラスをキャプチャが失われ、スタイラスがその境界から出るまでです。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.IsStylusDirectlyOver%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsStylusDirectlyOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsStylusDirectlyOverChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsStylusDirectlyOver" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsStylusDirectlyOverChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsStylusDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsStylusDirectlyOverProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスのカーソルがこの要素 \(子ビジュアル要素を含む\) の上にあるかどうかを示す値を取得します。</summary>
        <value>スタイラスのカーソルが要素またはその子要素の上にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この要素にスタイラスをキャプチャがある場合は、このプロパティは返す引き続き `true` スタイラスをキャプチャは失われ、ポインターがその範囲外になるまでです。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.IsStylusOver%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsStylusOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsStylusOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsStylusOverProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が ユーザー インターフェイス (UI) に表示されるかどうかを示す値を取得します。</summary>
        <value>要素が表示される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 決定、 <xref:System.Windows.UIElement3D.IsVisible%2A> 値は、さまざまな要因を考慮します。 これに対し、 <xref:System.Windows.UIElement3D.Visibility%2A>, 、表示と非表示に要素をプログラムで作成するよう設定可能なプロパティのみを示します。  
  
 このプロパティの値に対する変更で発生は通常、 <xref:System.Windows.UIElement3D.IsVisibleChanged> イベントです。 一致がない [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] "に \*"を直接クラス ハンドラーをアタッチすることがまだクラス処理をオーバーライド メソッドを許可するいくつかの派生クラスを動作をオーバーライドし、イベントを処理する必要が <xref:System.Windows.EventManager.RegisterClassHandler%2A>です。  
  
 要素、 <xref:System.Windows.UIElement3D.IsVisible%2A> は `false` いない入力イベント \(またはコマンド\) に参加で操作を実行しないメジャーのいずれかに影響を与えるまたは配置のレイアウトのパス、フォーカスを設定していない、タブ シーケンス、およびヒット テストでは報告されません。 します。 これに対して、要素、 <xref:System.Windows.UIElement3D.IsEnabled%2A> は `false` イベントおよびコマンド、およびヒット テストには参加してこれにフォーカスを設定します。  
  
 <xref:System.Windows.UIElement3D.IsVisible%2A> スタイルのトリガーとして使用するのにはありません。 使用して <xref:System.Windows.UIElement3D.IsVisible%2A> スタイルとしては、トリガーによって予期しない結果が必要があります。<xref:System.Windows.UIElement3D.IsVisible%2A> 場合は、下位レベルの入力実装が目的です。  
  
 <xref:System.Windows.UIElement3D.IsVisible%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_IsVisible"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.IsVisibleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsVisibleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement3D.IsVisible" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
 <xref:System.Windows.UIElement3D.IsVisibleChanged> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.IsVisible" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.IsVisibleProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.KeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがある状態でいずれかのキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.UIElement3D.KeyDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.KeyDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.KeyDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_KeyDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.KeyDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewKeyDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnKeyDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.KeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.KeyDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.KeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがある状態でキーが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.UIElement3D.KeyUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.KeyUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.KeyUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_KeyUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.KeyUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewKeyUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnKeyUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.KeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.KeyUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッド呼び出しを使用して意図的にフォーカスを外しているにもかかわらず、直前のキーボード フォーカスが異なるスコープ内に存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 シナリオではこのことがキーボード フォーカスは、要素を <xref:System.Windows.UIElement3D.Focus%2A> メソッドはまだ論理フォーカスを取得します。  
  
 このイベントのより正確な解釈がその it 発生する状況の値、 <xref:System.Windows.UIElement3D.IsFocused%2A> からルート内の要素のプロパティが変更される `true` に `false`します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを得られる実際の要素を特定のイベント データ。  
  
 <xref:System.Windows.UIElement3D.LostFocus> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_LostFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.LostFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnLostFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.LostFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.LostFocusEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.LostKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.LostKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.LostKeyboardFocus> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.LostKeyboardFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnLostKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.LostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.LostKeyboardFocusEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostMouseCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素がマウスをキャプチャは、境界外のポインターがあってもマウス入力を受け取ります。 マウスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> キャプチャを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.LostMouseCapture> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.LostMouseCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.LostMouseCapture> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.LostMouseCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnLostMouseCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.LostMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.LostMouseCaptureEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostStylusCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスをキャプチャする要素は、ポインターがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.LostStylusCapture> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.LostStylusCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.LostStylusCapture> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.LostStylusCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnLostStylusCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.LostStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.LostStylusCaptureEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostTouchCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素は、タッチのキャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.LostTouchCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnLostTouchCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.LostTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.MouseDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.MouseDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.MouseDown> イベントは、多くの場合、いずれかと共に <xref:System.Windows.UIElement3D.MouseLeftButtonDown> または <xref:System.Windows.UIElement3D.MouseRightButtonDown>, 、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。<xref:System.Windows.UIElement3D.MouseLeftButtonDown><xref:System.Windows.UIElement3D.MouseRightButtonDown> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.UIElement3D.MouseLeftButtonDown> または <xref:System.Windows.UIElement3D.MouseRightButtonDown>です。  
  
> [!IMPORTANT]
>  一部のコントロールには、固有のクラスのマウス ボタンのイベント処理があります。 イベントをマウスの左ボタンは、クラス、コントロールの処理が最も可能性の高いイベントです。 クラスの多くの場合、処理が、基になるをマーク <xref:System.Windows.Input.Mouse> クラス イベントを処理します。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンスのハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。  
  
 前の「重要」に説明されている問題を解決し、それでも <xref:System.Windows.UIElement3D.MouseDown> クラスによるこれらソリューションのいずれかの処理を含む派生クラスでイベントをマウスの左ボタンのイベント。  
  
-   ハンドラーのアタッチ、 <xref:System.Windows.UIElement3D.PreviewMouseDown> コントロールによって処理済みとマークされていないイベント。 これはプレビュー イベントであるため、ルート ルートから始まり、コントロールまでトンネルに注意してください。  
  
-   呼び出して、コントロールのハンドラーを手続き的登録 <xref:System.Windows.UIElement3D.AddHandler%2A> ハンドラーにルーティングされたイベント データの処理としてマークされている場合でも、イベントをリッスンできる署名オプションを選択します。  
  
 <xref:System.Windows.UIElement3D.MouseDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_MouseDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.MouseDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewMouseDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnMouseDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.MouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.MouseDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.MouseEnter> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 直接イベント ルーティング方法の処理を使用します。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。  
  
 <xref:System.Windows.UIElement3D.MouseEnter> マウス ポインターがこのイベントをさらに、要素の境界に入った時点を追跡するレポート文字どおり、 <xref:System.Windows.UIElement3D.IsMouseOver%2A> からプロパティ値が変更 `false` に `true` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.MouseEnter> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.MouseEnter> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.MouseEnter> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.MouseEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnMouseEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.MouseEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.MouseEnterEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.MouseLeave> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 直接イベント ルーティング方法の処理を使用します。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。  
  
 <xref:System.Windows.UIElement3D.MouseLeave> マウスが離れると、要素にある場合、このイベントは、複数のトラックが文字どおり報告された、 <xref:System.Windows.UIElement3D.IsMouseOver%2A> からプロパティ値が変更 `true` に `false` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.MouseLeave> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.MouseLeave> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.MouseLeave> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_MouseLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.MouseLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnMouseLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.MouseLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.MouseLeaveEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseLeftButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてバブルのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.UIElement3D>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement3D.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement3D.MouseLeftButtonDown> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。 場合によってクラス ハンドラーが生成されるイベントに関する情報もなど <xref:System.Windows.Controls.Control.MouseDoubleClick>します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement3D>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement3D>します。  
  
> [!IMPORTANT]
>  クラスの多くの場合、処理が、基になるをマーク <xref:System.Windows.Input.Mouse> クラス イベントを処理します。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンスのハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。  
  
 前の「重要」に説明されている問題を解決し、それでも <xref:System.Windows.UIElement3D.MouseLeftButtonDown> クラスによるこれらソリューションのいずれかの処理を含む派生クラスでイベントをマウスの左ボタンのイベント。  
  
-   ハンドラーのアタッチ、 <xref:System.Windows.UIElement3D.PreviewMouseDown> コントロールによって処理済みとマークされていないイベント。 これはプレビュー イベントであるため、ルート ルートから始まり、コントロールまでトンネルに注意してください。  
  
-   呼び出して、コントロールのハンドラーを手続き的登録 <xref:System.Windows.UIElement3D.AddHandler%2A> ハンドラーにルーティングされたイベント データの処理としてマークされている場合でも、イベントをリッスンできる署名オプションを選択します。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.MouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.MouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseLeftButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてバブルのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.UIElement3D>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement3D.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement3D.MouseLeftButtonUp> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement3D>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement3D>します。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.MouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnMouseLeftButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.MouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.MouseMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.MouseMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.MouseMove> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_MouseMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.MouseMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewMouseMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnMouseMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement3D.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.MouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.MouseMoveEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseRightButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてバブルのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.UIElement3D>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement3D.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement3D.MouseRightButtonDown> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。 場合によってクラス ハンドラーが生成されるイベントに関する情報もなど <xref:System.Windows.Controls.Control.MouseDoubleClick>します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement3D>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement3D>します。  
  
 右側のボタンのマウス イベントは、アプリケーション シナリオでネイティブ処理を頻繁にあります。 たとえば、マウスの右ボタンを押すがコンテキスト メニューを表示します。 参照してください [ContextMenu の概要](http://msdn.microsoft.com/ja-jp/16909c42-799a-4561-91e0-7d69dcfeea91)します。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.MouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.MouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseRightButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてバブルのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.UIElement3D>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement3D.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement3D.MouseRightButtonUp> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement3D>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement3D>します。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.MouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnMouseRightButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.MouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.MouseUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.MouseUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.MouseUp> イベントは、多くの場合、いずれかと共に <xref:System.Windows.UIElement3D.MouseLeftButtonUp> または <xref:System.Windows.UIElement3D.MouseRightButtonUp>, 、2 つの標準のマウス ボタンのいずれかのリリースに対応します。<xref:System.Windows.UIElement3D.MouseLeftButtonUp><xref:System.Windows.UIElement3D.MouseRightButtonUp> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.UIElement3D.MouseLeftButtonUp> または <xref:System.Windows.UIElement3D.MouseRightButtonUp>です。  
  
 <xref:System.Windows.UIElement3D.MouseUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_MouseUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.MouseUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewMouseUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnMouseUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.MouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.MouseUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。そのため、表示された場合、 <xref:System.Windows.UIElement3D.MouseWheel> フォーカスがあるか、キャプチャした要素からのイベント、マウス ポインターのほう別の要素上です。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.MouseWheel> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.MouseWheel> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.MouseWheel> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.MouseWheelEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewMouseWheel>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnMouseWheel%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.MouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.MouseWheelEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">走査の各要求を視覚的に移動するには、既存のタブ オーダーまたは、方向を走査するモードにはいずれかを示すプロパティが含まれています。</param>
        <summary>この要素から別の要素にフォーカスを移動しようとします。 フォーカスを移動する方向は、この要素のビジュアルの親の組織内で解釈されますが、ガイダンスの方向を指定します。</summary>
        <returns>
          <see langword="true" /> 要求の検査が実行された場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの戻り値を確認してください。 戻り値 `false` 走査の各要求はラップする要求していないと、走査は、コントロールの構成で定義されているタブ ストップが実行されて、返される可能性があります。  
  
 <xref:System.Windows.UIElement3D.MoveFocus%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected virtual void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">アクセス キー イベントをイベント データ。 イベント データ レポートがどのキーが呼び出され、を示すかどうか、 <see cref="T:System.Windows.Input.AccessKeyManager" /> も、これらのイベントの送信を制御するオブジェクトはその他の要素にこのアクセス キーの呼び出しを送信します。</param>
        <summary>呼び出されるときは、この要素に有効なアクセス キーのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 実際の AccessKey イベントが存在しない、 <xref:System.Windows.UIElement3D> クラス、またはその他のハンドラーをアタッチすることができますか。 専用マネージャー クラスを使用して、イベントの代わりに、発生元が <xref:System.Windows.Input.AccessKeyManager>, 、入力モデル全体に適用されるアクセス キーを検索するすべての入力を後に処理します。  
  
 <xref:System.Windows.UIElement3D.OnAccessKey%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The default implementation of this method in <see cref="T:System.Windows.UIElement3D" /> sets keyboard focus to this element (by calling <see cref="M:System.Windows.UIElement3D.Focus" />). Implementations should perpetuate this behavior if they are focusable, because it is an expected behavior for accessibility scenarios. Note that the base implementation does nothing with the passed event data and raises no further event; it just sets the focus.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnCreateAutomationPeer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>特定のクラスを返す <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> の実装、 Windows Presentation Foundation (WPF) インフラストラクチャです。</summary>
        <returns>型固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnCreateAutomationPeer%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The implementation of this method is typically to call the constructor of a specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.  
  
 All <see cref="T:System.Windows.UIElement3D" /> derived classes should implement this method in order to provide their own specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations to the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure. For details on implementing this pattern, see <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnDragEnter%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragLeave" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnDragLeave%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragOver" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnDragOver%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.Drop" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnDrop%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnGiveFeedback%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.RoutedEventArgs" />。 このイベント データには、<see cref="E:System.Windows.UIElement3D.GotFocus" /> イベントの識別子が含まれている必要があります。</param>
        <summary>指定のイベント データを使用して、<see cref="E:System.Windows.UIElement3D.GotFocus" /> ルーティング イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、仮想がイベントを発生させる既定の実装です。  
  
 これを \* メソッドの実装の目的は、イベントが発生して、この同じメソッドの実装が内部的に呼び出され、イベントを発生させるときに、 <xref:System.Windows.UIElement3D.IsFocused%2A> プロパティ値が変更されます。<xref:System.Windows.UIElement3D.OnGotFocus%2A> 実装が異なるその他の [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] に \* のみそのイベントのクラス処理を追加する便利な手段を提供の実装です。  
  
 <xref:System.Windows.UIElement3D.OnGotFocus%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation. Otherwise, the <see cref="E:System.Windows.UIElement3D.GotFocus" /> event is not raised during typical user operations that ordinarily set focus to this element. If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.UIElement3D.Focusable" /> to <see langword="false" />.</para>
        </block>
        <altmember cref="P:System.Windows.UIElement3D.Focusable" />
        <altmember cref="E:System.Windows.UIElement3D.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnGotKeyboardFocus%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnGotMouseCapture%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnGotStylusCapture%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement3D.GotTouchCapture" /> タッチがこの要素にキャプチャされるときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnGotTouchCapture%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement3D.OnGotTouchCapture%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement3D.GotTouchCapture> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement3D.OnGotTouchCapture%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement3D.IsKeyboardFocusedChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドを呼び出すときの値、 <xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> 依存関係プロパティが変更されました。 仮想メソッドでは、最初に呼び出され、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、  <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 <xref:System.Windows.UIElement3D.OnIsKeyboardFocusedChanged%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素によって <see cref="E:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged" /> イベントが発生する直前に呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドを呼び出すときの値、 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に呼び出され、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 <xref:System.Windows.UIElement3D.OnIsKeyboardFocusWithinChanged%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement3D.IsMouseCapturedChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドを呼び出すときの値、 <xref:System.Windows.UIElement3D.IsMouseCaptured%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に呼び出され、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement3D.IsMouseCapturedChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、 <xref:System.Windows.UIElement3D.IsMouseCapturedChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 <xref:System.Windows.UIElement3D.OnIsMouseCapturedChanged%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnIsMouseCaptureWithinChanged%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This virtual method is called when the value of the <see cref="P:System.Windows.UIElement3D.IsMouseCaptureWithin" /> dependency property changes its value. The virtual method is called first and can manipulate the event data as necessary. Then the <see cref="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance. Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.  
  
 This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation. You may call base either before or after your special handling, depending on your requirements.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement3D.IsMouseDirectlyOverChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドを呼び出すときの値、 <xref:System.Windows.UIElement3D.IsMouseDirectlyOver%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に呼び出され、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、 <xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 <xref:System.Windows.UIElement3D.OnIsMouseDirectlyOverChanged%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement3D.IsStylusCapturedChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドを呼び出すときの値、 <xref:System.Windows.UIElement3D.IsStylusCaptured%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に呼び出され、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement3D.IsStylusCapturedChanged> 同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティングされたイベントではないことを確認します。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 <xref:System.Windows.UIElement3D.OnIsStylusCapturedChanged%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement3D.IsStylusCaptureWithinChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドを呼び出すときの値、 <xref:System.Windows.UIElement3D.IsStylusCaptureWithin%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に呼び出され、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement3D.IsStylusCaptureWithinChanged> 同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティングされたイベントではないことを確認します。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 <xref:System.Windows.UIElement3D.OnIsStylusCaptureWithinChanged%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.UIElement3D.IsStylusDirectlyOverChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドを呼び出すときの値、 <xref:System.Windows.UIElement3D.IsStylusDirectlyOver%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に呼び出され、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement3D.IsStylusDirectlyOverChanged> 同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティングされたイベントではないことを確認します。 したがってクラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 <xref:System.Windows.UIElement3D.OnIsStylusDirectlyOverChanged%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーボード操作は、専用の入力マネージャーによって処理されます。 たとえば、入力とコマンド バインドのキー入力に依存しているその他のプログラミング機能は、一般的なキーストロークとして公開される前にキーストロークを処理することがあります。 これらの入力システムの機能、イベントを処理し、としてマークする場合は、 <xref:System.Windows.UIElement3D.OnKeyDown%2A> は呼び出されません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnKeyDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーボード操作は、専用の入力マネージャーによって処理されます。 たとえば、入力とコマンド バインドのキー入力に依存しているその他のプログラミング機能は、一般的なキーストロークとして公開される前にキーストロークを処理することがあります。 これらの入力システムの機能、イベントを処理し、としてマークする場合は、 <xref:System.Windows.UIElement3D.OnKeyUp%2A> は呼び出されません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnKeyUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。 このイベント データには、<see cref="E:System.Windows.UIElement3D.LostFocus" /> イベントの識別子が含まれている必要があります。</param>
        <summary>渡されたイベント データを使用して、<see cref="E:System.Windows.UIElement3D.LostFocus" /> ルーティング イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、仮想がイベントを発生させる既定の実装です。  
  
 これを \* メソッドの実装の目的は、イベントが発生して、この同じメソッドの実装が内部的に呼び出され、イベントを発生させるときに、 <xref:System.Windows.UIElement3D.IsFocused%2A> プロパティ値が変更されます。 この実装が異なるその他の [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] に \* のみそのイベントのクラス処理を追加する便利な手段を提供の実装です。  
  
 <xref:System.Windows.UIElement3D.OnLostFocus%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation. Otherwise, the <see cref="E:System.Windows.UIElement3D.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element. If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.UIElement3D.Focusable" /> to <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnLostKeyboardFocus%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnLostMouseCapture%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnLostStylusCapture%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement3D.LostTouchCapture" /> タッチのキャプチャを失ったときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnLostTouchCapture%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement3D.OnLostTouchCapture%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement3D.LostTouchCapture> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement3D.OnLostTouchCapture%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、押されたマウス ボタンおよび処理済み状態に関する詳細を報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.UIElement3D.OnMouseDown%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.UIElement3D.MouseLeftButtonDown> と <xref:System.Windows.UIElement3D.MouseRightButtonDown>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.UIElement3D.OnMouseDown%2A>, 、下にはアクションのすべての可能なマウス ボタンのクラス処理を考慮できるという意味です。 この動作が望ましくない可能性があります。 そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnMouseDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、直接ルーティング方法と、ルーティングされたイベント。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
 <xref:System.Windows.UIElement3D.OnMouseEnter%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 添付イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、直接ルーティング方法と、ルーティングされたイベント。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
 <xref:System.Windows.UIElement3D.OnMouseLeave%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement3D.MouseLeftButtonDown" /> ルーティング イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.MouseLeftButtonDown> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.UIElement3D> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement3D.MouseLeftButtonDown>します。 マークすることができますが、 <xref:System.Windows.UIElement3D.MouseLeftButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement3D> リッスン <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement3D> をオーバーライドして <xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Button> させ <xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A> 、派生クラスで基本クラスの実装を呼び出さずにただし、このオーバーライドを無効に、 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントです。  
  
 <xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.UIElement3D.MouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.MouseLeftButtonUp> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.UIElement3D> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement3D.MouseLeftButtonUp>します。 マークすることができますが、 <xref:System.Windows.UIElement3D.MouseLeftButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement3D> リッスン <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement3D> をオーバーライドして <xref:System.Windows.UIElement3D.OnMouseLeftButtonUp%2A>します。  
  
 <xref:System.Windows.UIElement3D.OnMouseLeftButtonUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnMouseMove%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement3D.MouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Windows.UIElement3D.MouseRightButtonDown> event appears to travel a bubbling route but actually travels in an indirect way. <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> is the underlying event that is bubble routed, and each <xref:System.Windows.UIElement3D> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.UIElement3D.MouseRightButtonDown>. Although you can mark the <xref:System.Windows.UIElement3D.MouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route. However, you might want to mark the event as handled in order to prevent general instance handlers \(those that did not specify **parameterReference tag is not supported!!!!**  
\) from being invoked.  
  
 The default implementation for general mouse event handling in <xref:System.Windows.UIElement3D> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> and converts it to an appropriate local event. If you want to override this logic, you must create a derived class. In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>. You cannot change the mouse handling behavior of <xref:System.Windows.UIElement3D> by overriding <xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A>.  
  
 Alternatively, you can override this method in order to change event handling for a specific mouse state. Whether you choose to call the base implementation depends on your scenario. Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A>. For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.  
  
 <xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A> is introduced in the .NET Framework version 3.5.  For more information, see [.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement3D.MouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.MouseRightButtonUp> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.UIElement3D> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement3D.MouseRightButtonUp>します。 マークすることができますが、 <xref:System.Windows.UIElement3D.MouseRightButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement3D> リッスン <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement3D> をオーバーライドして <xref:System.Windows.UIElement3D.OnMouseRightButtonUp%2A>します。  
  
 <xref:System.Windows.UIElement3D.OnMouseRightButtonUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウス ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.UIElement3D.OnMouseUp%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.UIElement3D.MouseLeftButtonUp> と <xref:System.Windows.UIElement3D.MouseRightButtonUp>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.UIElement3D.OnMouseUp%2A>, 、クラス処理をすべての可能なマウスのボタンの操作を考慮できることが示すされます。 この動作が望ましくない可能性があります。 そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnMouseUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnMouseWheel%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDragEnter%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDragLeave%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDragOver%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDrop%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewGiveFeedback%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>未処理の<see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewGotKeyboardFocus%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewKeyDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewKeyUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewLostKeyboardFocus%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 添付ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> と <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A>, 、下にはアクションのすべての可能なマウス ボタンのクラス処理を考慮できるという意味です。 この動作が望ましくない可能性があります。 そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.UIElement3D> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>します。 マークすることができますが、 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement3D> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement3D> をオーバーライドして <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Button> させ <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A> 、派生クラスで基本クラスの実装を呼び出さずにただし、このオーバーライドを無効に、 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントです。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.UIElement3D> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>します。 マークすることができますが、 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement3D> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement3D> をオーバーライドして <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp%2A>します。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseMove%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.UIElement3D> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement3D.MouseRightButtonDown>します。 マークすることができますが、 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement3D> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement3D> をオーバーライドして <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Control> させ <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A> 呼び出しベースにしていることがなく、派生クラスで、このオーバーライドを無効に含まれている、管理上のコンテキスト\] メニューの \[サービスの <xref:System.Windows.Controls.Control> の既定の動作です。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.UIElement3D> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>します。 マークすることができますが、 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement3D> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement3D> をオーバーライドして <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp%2A>します。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> と <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A>, 、クラス処理をすべての可能なマウスのボタンの操作を考慮できることが示すされます。 この動作が望ましくない可能性があります。 そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseWheel%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewQueryContinueDrag%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusButtonDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusButtonUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusInAirMove%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusInRange%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusMove%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  
  
 The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  
  
 Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement3D> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusOutOfRange%2A> is introduced in the .NET Framework version 3.5.  For more information, see [.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusSystemGesture%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnPreviewTextInput%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.UIElement3D.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement3D.PreviewTouchDown" /> タッチがこの要素を押したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement3D.PreviewTouchDown> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement3D.PreviewTouchMove" /> タッチがこの要素内に移動したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement3D.PreviewTouchMove> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement3D.PreviewTouchUp" /> タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement3D.PreviewTouchUp> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnQueryContinueDrag%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnQueryCursor%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnStylusButtonDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnStylusButtonUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnStylusDown%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的は、のような [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
 <xref:System.Windows.UIElement3D.OnStylusEnter%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnStylusInAirMove%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnStylusInRange%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的は、のような [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
 <xref:System.Windows.UIElement3D.OnStylusLeave%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnStylusMove%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnStylusOutOfRange%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnStylusSystemGesture%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnStylusUp%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement3D> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
 <xref:System.Windows.UIElement3D.OnTextInput%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement3D.TouchDown" /> タッチがこの要素の内部を押したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnTouchDown%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement3D.OnTouchDown%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement3D.TouchDown> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement3D.OnTouchDown%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement3D.TouchEnter" /> ルーティングされたイベントから、タッチに移動したときに発生するこの要素の境界内に外部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnTouchEnter%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement3D.OnTouchEnter%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement3D.TouchEnter> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement3D.OnTouchEnter%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement3D.TouchLeave" /> からタッチを移動するときに発生するルーティングされたイベントにこの要素の範囲外の内部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnTouchLeave%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement3D.OnTouchLeave%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement3D.TouchLeave> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement3D.OnTouchLeave%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement3D.TouchMove" /> タッチがこの要素内に移動したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnTouchMove%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement3D.OnTouchMove%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement3D.TouchMove> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement3D.OnTouchMove%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement3D.TouchUp" /> タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnTouchUp%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement3D.OnTouchUp%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement3D.TouchUp> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement3D.OnTouchUp%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUpdateModel">
      <MemberSignature Language="C#" Value="protected virtual void OnUpdateModel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUpdateModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnUpdateModel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされるときに、操作のレンダリングに参加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クラスを派生する場合、 <xref:System.Windows.UIElement3D> クラスと共にこのメソッドを使用する、 <xref:System.Windows.UIElement3D.InvalidateModel%2A> 要素のモデルを更新する方法です。  
  
 高度なシナリオでこのメソッドを呼び出す必要があるだけです。 このような高度なシナリオの 1 つは、派生クラスには、外観に影響する複数のプロパティと、基になるモデルを 1 回のみ更新するかどうかです。 内で、 <xref:System.Windows.UIElement3D.OnUpdateModel%2A> メソッドを更新することが、 <xref:System.Windows.Media.Media3D.Visual3D.Visual3DModel%2A> のプロパティ、 <xref:System.Windows.Media.Media3D.Visual3D> クラスです。  
  
 このメソッド既定の実装ではない、 <xref:System.Windows.UIElement3D> クラスです。  
  
 <xref:System.Windows.UIElement3D.OnUpdateModel%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 次の例から派生させる方法、 <xref:System.Windows.UIElement3D> を作成するクラス、 `Sphere` クラス。  
  
 [!code-csharp[Shapes\#Sphere](~/samples/snippets/csharp/VS_Snippets_Wpf/Shapes/CSharp/Sphere.cs#sphere)]
 [!code-vb[Shapes\#Sphere](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Shapes/visualbasic/sphere.vb#sphere)]  
  
 完全なサンプルを参照してください。 [UIElement3D Sphere Sample](http://go.microsoft.com/fwlink/?LinkID=160044)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">以前の親です。 これは、として提供されること <see langword="null" /> 場合、 <see cref="T:System.Windows.DependencyObject" /> 親要素は既にありませんでした。</param>
        <summary>ときに呼び出さこれの親要素 <see cref="T:System.Windows.UIElement3D" /> 基になる visual 親に、変更を報告します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.OnVisualParentChanged%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If you override this method, always call the base implementation. The default base implementation performs some internal maintenance of reverse-inherited property state. Failing to call the base implementation will invalidate this state.  
  
 This method overrides <see cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />. <see cref="T:System.Windows.FrameworkElement" /> and <see cref="T:System.Windows.Window" /> both also override the <see cref="T:System.Windows.UIElement3D" /> implementation of <see cref="M:System.Windows.UIElement3D.OnVisualParentChanged(System.Windows.DependencyObject)" />, and <see cref="T:System.Windows.Window" /> seals it.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">要求されたフォーカスの移動の方向です。</param>
        <summary>派生クラスでオーバーライドされた場合は、実際にその要素にフォーカスを移動せず指定したフォーカスの移動の方向のフォーカスを受け取る要素を返します。</summary>
        <returns>要素がフォーカスを受け取った場合 <see cref="M:System.Windows.UIElement3D.MoveFocus(System.Windows.Input.TraversalRequest)" /> が実際に呼び出されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このクラスでは、このメソッドの既定の実装が完了していないと、常に返します `null`します。  
  
 <xref:System.Windows.UIElement3D.PredictFocus%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewDragEnter> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewDragEnter> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewDragEnter> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewDragEnterEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.DragEnter>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewDragEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewDragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewDragEnterEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewDragLeave> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewDragLeave> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewDragLeave> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewDragLeaveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.DragLeave>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewDragLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewDragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewDragLeaveEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewDragOver> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewDragOver> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewDragOver> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewDragOverEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.DragOver>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewDragOver%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewDragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewDragOverEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDrop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewDrop> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewDrop> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewDrop> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewDropEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.Drop>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewDrop%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewDrop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewDropEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewGiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作が開始されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.PreviewGiveFeedback> イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewGiveFeedback> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewGiveFeedback> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewGiveFeedback> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewGiveFeedbackEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.GiveFeedback>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewGiveFeedback%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewGiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewGiveFeedbackEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、ルーティングのトンネリングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際にアタッチされている要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスがある実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewGotKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.GotKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewGotKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocusEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewKeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがある状態でいずれかのキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーの処理は、コマンドの実行とテキストの合成などの他のプラットフォーム機能と対話します。 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewKeyDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewKeyDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewKeyDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.KeyDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewKeyDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewKeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewKeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがある状態でキーが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーの処理は、コマンドの実行とテキストの合成などの他のプラットフォーム機能と対話します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewKeyUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewKeyUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewKeyUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.KeyUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewKeyUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewKeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、ルーティングのトンネリングを使用しているために、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewLostKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.LostKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewLostKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocusEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewMouseDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewMouseDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseDown> イベントは、多くの場合、いずれかと共に <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> または <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>, 、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown><xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> または <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>です。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewMouseDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.MouseDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewMouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.UIElement3D>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement3D.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。 場合によってクラス ハンドラーが生成されるイベントに関する情報もなど <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement3D>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement3D>します。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.UIElement3D>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement3D.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement3D>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement3D>します。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントが発生した両方要素境界内にマウス ポインターが最初に入ると、マウス ポインターが要素の境界内に残っているときに移動するともとします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewMouseMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewMouseMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseMove> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewMouseMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.MouseMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewMouseMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewMouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseMoveEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.UIElement3D>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement3D.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。 場合によってクラス ハンドラーが生成されるイベントに関する情報もなど <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement3D>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement3D>します。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、要素ツリーに沿った各が再度発生する直接ルーティングされたイベントを実際には <xref:System.Windows.UIElement3D>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement3D.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement3D>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement3D>します。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewMouseUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewMouseUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseUp> イベントは、多くの場合、いずれかと共に <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> または <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>, 、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp><xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> または <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>です。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewMouseUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.MouseUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewMouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。そのため、フォーカスがあるか、キャプチャした要素からこのイベントを受信する場合、マウス ポインターのほう別の要素上です。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewMouseMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewMouseMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseWheel> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewMouseWheelEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.MouseWheel>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewMouseWheel%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewMouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseWheelEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewQueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.PreviewQueryContinueDrag> イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作をキャンセルする必要があるかどうかを宣言します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewQueryContinueDrag> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewQueryContinueDrag> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewQueryContinueDrag> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewQueryContinueDragEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.QueryContinueDrag>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewQueryContinueDrag%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewQueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewQueryContinueDragEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewStylusButtonDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewStylusButtonDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewStylusButtonDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.StylusButtonDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewStylusButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewStylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewStylusButtonUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewStylusButtonUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewStylusButtonUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.StylusButtonUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewStylusButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewStylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewStylusDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewStylusDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewStylusDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.StylusDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewStylusDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewStylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusInAirMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewStylusInAirMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewStylusInAirMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInAirMove> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewStylusInAirMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.StylusInAirMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewStylusInAirMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewStylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInAirMoveEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusInRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewStylusInRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewStylusInRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInRange> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewStylusInRangeEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.StylusInRange>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewStylusInRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewStylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInRangeEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素上にある間にスタイラスが移動すると発生します。 このイベントを発生させるためには、デジタイザーによって検出されている間にスタイラスが移動する必要があります。それ以外の場合には、代わりに <see cref="E:System.Windows.UIElement3D.PreviewStylusInAirMove" /> が発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewStylusMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewStylusMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusMove> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewStylusMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.StylusMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewStylusMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewStylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusMoveEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusOutOfRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがデジタイザーから離れすぎているために検出されないときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewStylusOutOfRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewStylusOutOfRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusOutOfRange> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewStylusOutOfRangeEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.StylusOutOfRange>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewStylusOutOfRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewStylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusOutOfRangeEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusSystemGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスのジェスチャについては、次を参照してください。 <xref:System.Windows.Input.SystemGesture>します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewStylusSystemGesture> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewStylusSystemGesture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusSystemGesture> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewStylusSystemGestureEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.StylusSystemGesture>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewStylusSystemGesture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewStylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusSystemGestureEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewStylusDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewStylusDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewStylusUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.StylusUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewStylusUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewStylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.PreviewTextInput> イベントは、コンポーネントまたはデバイスに依存しない方法でテキストの入力を待機するアプリケーションを使用します。 キーボードの主要な手段は、 <xref:System.Windows.UIElement3D.PreviewTextInput>; が、音声認識、手書き認識、およびその他の入力デバイスも <xref:System.Windows.UIElement3D.PreviewTextInput>です。  
  
 キーの組み合わせのため、既定のキーボードまたは入力方式エディターを通じて\-複数のキー イベントが 1 つだけのテキスト入力イベントを発生させる可能性があります。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.PreviewTextInput> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.PreviewTextInput> イベントは、基になるに関連付けられている <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.PreviewTextInput> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewTextInputEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.TextInput>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewTextInput%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewTextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.PreviewTextInputEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTouchDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、 <xref:System.Windows.UIElement3D.PreviewTouchDown> と <xref:System.Windows.UIElement3D.TouchDown> 指が画面をタッチし、移動するまでのイベントが発生しません。 画面に指を押すと、により、キーを押して移動せず保持しているとの動作を保持する <xref:System.Windows.Input.Stylus>です。 プレス アンド ホールド動作では、マウスの右クリックに相当します。  
  
 発生する、 <xref:System.Windows.UIElement3D.PreviewTouchDown> と <xref:System.Windows.UIElement3D.TouchDown> 指が、画面をタッチするとすぐに発生するイベントの設定、 <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName> 添付プロパティを `false` この要素のです。  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewTouchDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.TouchDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewTouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewTouchMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.TouchMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewTouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTouchUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.PreviewTouchUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement3D.TouchUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.PreviewTouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.QueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.QueryContinueDrag> イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作をキャンセルする必要があるかどうかを決定します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.QueryContinueDrag> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.QueryContinueDrag> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.QueryContinueDrag> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.QueryContinueDragEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewQueryContinueDrag>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnQueryContinueDrag%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.QueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.QueryContinueDragEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.QueryCursor" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カーソルの表示が要求されると発生します。 このイベントは、マウス ポインターが別の位置へ移動するたびに要素上で発生します。したがって、場合によってはカーソル オブジェクトを移動先の位置に基づいて変更する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.QueryCursor> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.QueryCursor> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 このイベントの名前によって参照されているカーソルは、必ずしも \(挿入ポイントとも呼ばれ\) テキストのカーソルではありません。 代わりに、いくつかの可能な入力に関連するデバイスまたはの概念に関連する画面に表示されるグラフィカルな表示を宣言するオブジェクトは、このコンテキストでのカーソル [!INCLUDE[TLA2#tla_win](~/includes/tla2sharptla-win-md.md)] プログラミングします。 そのオブジェクトがによって表される、 <xref:System.Windows.Input.Cursor> クラス [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]します。[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 入力システムでは、マウス ポインターの画面上の位置を表す場合は、このカーソルを変更することができます。 定義済みの値を使用して、 <xref:System.Windows.Input.Cursors> 列挙型、またはするには、画像ファイルとしてカスタムのカーソルを宣言できます。  
  
 リッスン、 <xref:System.Windows.UIElement3D.QueryCursor> イベントは、カーソルの管理のための効率的な手法ではありません。 各要素がで独自のカーソル動作を定義する代わりに、 <xref:System.Windows.FrameworkContentElement.Cursor%2A> と <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>です。 ブラウザー リダイレクトにのみ依存 <xref:System.Windows.UIElement3D.QueryCursor> WPF フレームワーク レベルの基本要素を使用していないかで異常な場合に、カーソルの動作を定義する要素ごとの単位ではニーズに合わないかどうか。 応答でのカーソルの動作の実装の詳細については <xref:System.Windows.UIElement3D.QueryCursor>, を参照してください <xref:System.Windows.Input.QueryCursorEventHandler>します。  
  
 <xref:System.Windows.UIElement3D.QueryCursor> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_QueryCursor"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.QueryCursorEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnQueryCursor%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.QueryCursor" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.QueryCursorEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納し、発生するイベントを識別する <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>特定のルーティング イベントを発生させます。 発生する <see cref="T:System.Windows.RoutedEvent" /> は、提供された <see cref="T:System.Windows.RoutedEventArgs" /> インスタンス内で識別されます \(そのイベント データの <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティとして\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `e` パラメーターは、ルーティングされたイベントのすべてのデータの共通の基本型として型指定された、ただし、イベント データを与えるために、生成されたイベントに対して使用可能な最も限定のイベント データの種類として必要があります。 <xref:System.Windows.RoutedEventArgs> 派生クラスでは、特定のイベントが発生したときに特定の実際のデータ プロパティが含まれています。  
  
 <xref:System.Windows.RoutedEventArgs> イベントの状態のプロパティだけではありません。ルーティングされたイベントを発生させるも特定します。 このイベントの発生パターンと、ルーティングされたイベント データの両方とは異なる [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントに関連するプロパティを通常だけが含まれるイベントおよびデータのクラスです。  
  
 <xref:System.Windows.UIElement3D.RaiseEvent%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseAllTouchCaptures" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素からすべてのキャプチャされたタッチ デバイスを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseMouseCapture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素には、キャプチャが保持されている場合は、マウスのキャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この要素がキャプチャを保持していない場合は、このメソッドを呼び出しても効果はありません。 値を確認してください <xref:System.Windows.UIElement3D.IsMouseCaptured%2A> このメソッドを呼び出す前にします。  
  
 <xref:System.Windows.UIElement3D.ReleaseMouseCapture%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseStylusCapture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素には、キャプチャが保持されている場合は、スタイラス デバイスのキャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この要素がキャプチャを保持していない場合は、このメソッドを呼び出しても効果はありません。 値を確認してください <xref:System.Windows.UIElement3D.IsStylusCaptured%2A> このメソッドを呼び出す前にします。  
  
 <xref:System.Windows.UIElement3D.ReleaseStylusCapture%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">解放するデバイスです。</param>
        <summary>この要素から指定されたタッチ デバイスを解放しようとしています。</summary>
        <returns>
          <see langword="true" /> タッチ デバイスが解放された場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドラーが添付されているルーティング イベントの識別子。</param>
        <param name="handler">この要素のイベント ハンドラー コレクションから削除する特定のハンドラー実装。</param>
        <summary>指定したルーティング イベント ハンドラーをこの要素から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これを使用するための最も一般的なシナリオ [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] を実装する場合は、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] カスタム ルーティング イベントのハンドラーの"remove"ロジックを実装するときに特に関連付けられている「ラッパー」イベント、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] レベルです。  
  
 このメソッドを呼び出しても何も起こりませんメソッド呼び出しの入力パラメーターと一致する基準で登録されたハンドラーが存在しない場合。  
  
 複数のイベント ハンドラーのストアが削除される最初のハンドラーにのみ、条件に一致する 1 つのハンドラーがアタッチされます。 この動作は [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] の動作、 `-=` 演算子。  
  
 どちらも `routedEvent` も `handler` あります `null`します。 いずれかの値として入力しようとしています。 `null` 、例外が発生します。  
  
 このメソッドは無視、 `handledEventsToo` 場合は、ハンドラーが最初に提供されるパラメーターについては、追加、 <xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 処理済みのイベントの処理を有効に署名します。 ハンドラーのいずれかの種類が削除されます。  
  
 <xref:System.Windows.UIElement3D.RemoveHandler%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ShouldSerializeCommandBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスでの内容をシリアル化する必要かどうかを返す、 <see cref="P:System.Windows.UIElement3D.CommandBindings" /> このクラスのインスタンスのプロパティです。</summary>
        <returns>
          <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.UIElement3D.CommandBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるには `true` 場合 <xref:System.Windows.UIElement3D.CommandBindings%2A> ローカルに設定します。  
  
 これは、 `ShouldSerialize` ために、メソッドが提供される、 <xref:System.Windows.UIElement3D.CommandBindings%2A> プロパティには、単純な既定値はありません。 このメソッドは、プロパティが既定値から変更されたかどうかを示します。 デザイナーを開発または独自コントロールを組み込むことを開発する場合に通常、このメソッドが呼び出す、 <xref:System.Windows.UIElement3D>です。  
  
 詳細については、「[ShouldSerialize and Reset Methods](http://msdn.microsoft.com/ja-jp/7b6c5e00-3771-46b4-9142-5a80d5864a5e)」を参照してください。  
  
 <xref:System.Windows.UIElement3D.ShouldSerializeCommandBindings%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ShouldSerializeInputBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスでの内容をシリアル化する必要かどうかを返す、 <see cref="P:System.Windows.UIElement3D.InputBindings" /> このクラスのインスタンスのプロパティです。</summary>
        <returns>
          <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.UIElement3D.InputBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるには `true` 場合 <xref:System.Windows.UIElement3D.InputBindings%2A> ローカルに設定します。  
  
 これは、 `ShouldSerialize` ために、メソッドが提供される、 <xref:System.Windows.UIElement3D.InputBindings%2A> プロパティには、単純な既定値はありません。 このメソッドは、プロパティが既定値から変更されたかどうかを示します。 デザイナーを開発または独自コントロールを組み込むことを開発する場合に通常、このメソッドが呼び出す、 <xref:System.Windows.UIElement3D>です。  
  
 詳細については、「[ShouldSerialize and Reset Methods](http://msdn.microsoft.com/ja-jp/7b6c5e00-3771-46b4-9142-5a80d5864a5e)」を参照してください。  
  
 <xref:System.Windows.UIElement3D.ShouldSerializeInputBindings%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusButtonDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusButtonDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusButtonDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusButtonDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewStylusButtonDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusButtonDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusButtonUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusButtonUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusButtonUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusButtonUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewStylusButtonUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusButtonUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusDown> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewStylusDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusDownEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.StylusEnter> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 直接イベント ルーティング方法の処理を使用します。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、ルーティング イベントの動作のスタイルでイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.UIElement3D.StylusEnter> スタイラスがこのイベントをさらに、要素の境界に入った時点を追跡するレポート文字どおり、 <xref:System.Windows.UIElement3D.IsStylusOver%2A> からプロパティ値が変更 `false` に `true` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusEnter> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusEnter> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusEnter> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusEnterEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusInAirMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusInAirMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusInAirMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusInAirMove> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusInAirMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewStylusInAirMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusInAirMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusInAirMoveEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusInRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusInRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusInRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusInRange> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusInRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusInRangeEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewStylusInRange>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusInRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusInRangeEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスが要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.StylusLeave> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2) 直接イベント ルーティング方法の処理を使用します。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、ルーティング イベントの動作のスタイルでイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.UIElement3D.StylusLeave> スタイラスから削除すると、このイベント要素の境界の詳細のトラックが文字どおり報告された、 <xref:System.Windows.UIElement3D.IsStylusOver%2A> からプロパティ値が変更 `true` に `false` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusLeave> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusLeave> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusLeave> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusLeaveEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素上を移動すると発生します。 このイベントを発生させるには、デジタイザー上でスタイラスを移動する必要があります。 それ以外の場合は、代わりに <see cref="E:System.Windows.UIElement3D.StylusInAirMove" /> が発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusMove> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewStylusMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusMoveEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusOutOfRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスが検出可能になるにはデジタイザーから離れすぎているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusOutOfRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusOutOfRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusOutOfRange> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusOutOfRangeEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewStylusOutOfRange>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusOutOfRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusOutOfRangeEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusSystemGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスのジェスチャの詳細については、次を参照してください。 <xref:System.Windows.Input.SystemGesture>します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusSystemGesture> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusSystemGesture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusSystemGesture> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusSystemGestureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewStylusSystemGesture>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusSystemGesture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusSystemGestureEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.StylusUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.StylusUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 <xref:System.Windows.UIElement3D.StylusUp> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_StylusUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.StylusUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewStylusUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnStylusUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.StylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.StylusUpEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.TextInput> イベントは、コンポーネントまたはデバイスに依存しない方法でテキストの入力を待機するアプリケーションを使用します。 キーボードの主要な手段は、 <xref:System.Windows.UIElement3D.TextInput>, 、音声認識、手書き認識、およびその他の入力デバイス上げることもできますが、 <xref:System.Windows.UIElement3D.TextInput>です。  
  
 キーの組み合わせのため、既定のキーボードまたは入力方式エディターを通じて\-複数のキー イベントが 1 つのテキスト入力イベントを発生させる可能性があります。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement3D.TextInput> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement3D> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement3D.TextInput> イベントは、基になるに関連付けられている <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement3D.TextInput> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="routedEventInfo_TextInput"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.TextInputEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewTextInput>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnTextInput%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.TextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 <xref:System.Windows.UIElement3D.TextInputEvent> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、 <xref:System.Windows.UIElement3D.PreviewTouchDown> と <xref:System.Windows.UIElement3D.TouchDown> 指が画面をタッチし、移動するまでのイベントが発生しません。 画面に指を押すと、により、キーを押して移動せず保持しているとの動作を保持する <xref:System.Windows.Input.Stylus>です。 プレス アンド ホールド動作では、マウスの右クリックに相当します。  
  
 発生する、 <xref:System.Windows.UIElement3D.PreviewTouchDown> と <xref:System.Windows.UIElement3D.TouchDown> 指が、画面をタッチするとすぐに発生するイベントの設定、 <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName> 添付プロパティを `false` この要素のです。  
  
<a name="routedEventInfo_TouchDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.TouchDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewTouchDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnTouchDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.TouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがから移動すると発生外部からこの要素の範囲内です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは発生常にこの要素にタッチ デバイスがキャプチャされるかどうか。  
  
<a name="routedEventInfo_TouchEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.TouchEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnTouchEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.TouchEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキャプチャされているすべてのタッチ デバイスを取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素にキャプチャされているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ビジュアル ツリーで、この要素にキャプチャされているすべてのタッチ デバイスまたはすべての子要素を取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上にあるすべてのタッチ デバイスを取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素上にあるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ビジュアル ツリーで、この要素上にあるすべてのタッチ デバイスまたはすべての子要素を取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素またはそのビジュアル ツリー内のすべての子要素の上にあるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがから移動すると発生するこの要素の範囲外の内部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_TouchLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.TouchLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnTouchLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.TouchLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_TouchMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.TouchMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewTouchMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnTouchMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.TouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_TouchUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.TouchUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement3D.PreviewTouchUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement3D.OnTouchUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement3D.TouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility Visibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility Visibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.Visibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の ユーザー インターフェイス (UI) 可視性を取得または設定します。</summary>
        <value>列挙体の値。 既定値は <see cref="F:System.Windows.Visibility.Visible" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの設定の値に影響を与えます <xref:System.Windows.UIElement3D.IsVisible%2A>, が発生する可能性がさらに、 <xref:System.Windows.UIElement3D.IsVisibleChanged> イベントです。 ただし、 <xref:System.Windows.UIElement3D.IsVisible%2A> がその他の要因に影響を与える、それを含む親の可視性の設定のインスタンス。  
  
 要素、 <xref:System.Windows.UIElement3D.Visibility%2A> は <xref:System.Windows.Visibility.Visible> 入力イベント \(またはコマンド\) に参加していないと、ヒット テストでは報告されません。  
  
 <xref:System.Windows.UIElement3D.Visibility%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
<a name="dependencyPropertyInfo_Visibility"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement3D.VisibilityProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsVisible" />
        <altmember cref="T:System.Windows.Visibility" />
      </Docs>
    </Member>
    <Member MemberName="VisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.VisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement3D.Visibility" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement3D.VisibilityProperty> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>