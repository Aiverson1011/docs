<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>依存関係プロパティ システムに参加しているオブジェクトを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Windows.DependencyObject> class enables [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] property system services on its many derived classes.  
  
 The property system's primary function is to compute the values of properties, and to provide system notification about values that have changed. Another key class that participates in the property system is <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> enables the registration of dependency properties into the property system, and provides identification and information about each dependency property, whereas <xref:System.Windows.DependencyObject> as a base class enables objects to use the dependency properties.  
  
 <xref:System.Windows.DependencyObject> services and characteristics include the following:  
  
-   Dependency property hosting support. You register a dependency property by calling the <xref:System.Windows.DependencyProperty.Register%2A> method, and storing the method's return value as a public static field in your class.  
  
-   Attached property hosting support. You register an attached property by calling the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, and storing the method's return value as a public static read\-only field in your class. \(There are also additional member requirements; note that this represents a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] specific implementation for attached properties. For details, see [Attached Properties Overview](http://msdn.microsoft.com/ja-jp/75928354-dc01-47e8-a018-8409aec1f32d).\) Your attached property can then be set on any class that derives from <xref:System.Windows.DependencyObject>.  
  
-   Get, set, and clear utility methods for values of any dependency properties that exist on the <xref:System.Windows.DependencyObject>.  
  
-   Metadata, coerce value support, property changed notification, and override callbacks for  dependency properties or attached properties. Also, the <xref:System.Windows.DependencyObject> class facilitates the per\-owner property metadata for a dependency property.  
  
-   A common base class for classes derived from <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, or <xref:System.Windows.Media.Visual>. \(<xref:System.Windows.UIElement>, another base element class, has a class hierarchy that includes <xref:System.Windows.Media.Visual>.\)  
  
   
  
## 例  
 The following example derives from <xref:System.Windows.DependencyObject> to create a new abstract class. The class then registers an attached property and includes support members for that attached property.  
  
 [!code-csharp[WPFAquariumSln\#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln\#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.DependencyObject" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <see cref="T:System.Windows.DependencyProperty" /> オブジェクト参照によって識別される、消去対象の依存関係プロパティ。</param>
        <summary>プロパティのローカル値をクリアします。 クリアするプロパティは <see cref="T:System.Windows.DependencyProperty" /> 識別子で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Clearing the property value by calling <xref:System.Windows.DependencyObject.ClearValue%2A> does not necessarily give a dependency property the default value that is specified in the dependency property metadata. Clearing the property only specifically clears whatever local value may have been applied. For more information, see [Dependency Property Value Precedence](http://msdn.microsoft.com/ja-jp/1fbada8e-4867-4ed1-8d97-62c07dad7ebc).  
  
   
  
## 例  
 The following example iterates all properties that have local values set on an object, then calls <xref:System.Windows.DependencyObject.ClearValue%2A> to clear the values of each such property.  
  
 [!code-csharp[DPClearValue\#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue\#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">シールされている <see cref="T:System.Windows.DependencyObject" /> で <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> を呼び出そうとしました。</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">消去する依存関係プロパティのキー。</param>
        <summary>読み取り専用プロパティのローカル値を消去します。 消去するプロパティは、<see cref="T:System.Windows.DependencyPropertyKey" /> で指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Windows.DependencyPropertyKey> identifies a read\-only dependency property for property system operations. Classes that define read\-only dependency properties should not expose this key with public access. A publicly exposed key would provide a public code pathway that negated the read\-only character of the property, if methods such as <xref:System.Windows.DependencyObject.ClearValue%2A> or <xref:System.Windows.DependencyObject.SetValue%2A> could be called outside the class or assembly, referencing the key.  
  
 Clearing the property value by calling <xref:System.Windows.DependencyObject.ClearValue%2A> does not necessarily give a dependency property the default value that is specified in the dependency property metadata. Clearing the value only specifically clears whatever local value may have been applied. For more information, see [Dependency Property Value Precedence](http://msdn.microsoft.com/ja-jp/1fbada8e-4867-4ed1-8d97-62c07dad7ebc).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">シールされている <see cref="T:System.Windows.DependencyObject" /> で <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> を呼び出そうとしました。</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">強制する依存関係プロパティの識別子。</param>
        <summary>指定した依存関係プロパティの値を強制します。 これは、呼び出し元の <see cref="T:System.Windows.DependencyObject" /> の依存関係プロパティのプロパティ メタデータで指定されている <see cref="T:System.Windows.CoerceValueCallback" /> 関数を呼び出すことによって実現されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 In addition to being explicitly invoked through calling <xref:System.Windows.DependencyObject.CoerceValue%2A>, the <xref:System.Windows.CoerceValueCallback> for a dependency property is also invoked internally whenever the dependency property value is being re\-evaluated by the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system.  
  
 When you invoke the <xref:System.Windows.DependencyObject.CoerceValue%2A> method, you are ultimately invoking the coerce value callback for the property that you specify. Typically you will invoke <xref:System.Windows.DependencyObject.CoerceValue%2A> only if you know that a coerce value callback exists, and if you know the callback's criteria for coercion.  
  
 The most common scenario for calling <xref:System.Windows.DependencyObject.CoerceValue%2A> is within class handling or property change callbacks of related properties that influence each other's values in a dependent way. For more information, see [Dependency Property Callbacks and Validation](http://msdn.microsoft.com/ja-jp/48db5fb2-da7f-49a6-8e81-3540e7b25825).  
  
   
  
## 例  
 The following example calls <xref:System.Windows.DependencyObject.CoerceValue%2A> within a <xref:System.Windows.PropertyChangedCallback> implementation that is used as the <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> for a different dependency properties on the same class. This is a common pattern for introducing true value dependencies between dependency properties.  
  
 [!code-csharp[DPCallbackOverride\#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride\#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="dp" /> またはその値が無効であるか、存在しません。</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Windows.DependencyObjectType" /> をラップする、 CLR のこのインスタンスの型。</summary>
        <value>A <see cref="T:System.Windows.DependencyObjectType" /> をラップする、 CLR のこのインスタンスの型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、メソッドから返されるオブジェクトの戻り値の型がある場合に役立ちます。 <xref:System.Windows.DependencyObject> プロパティ システムで特定の操作、その種類に応じて実行するとします。 たとえば方が効率的に呼び出す <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> を使用して、 <xref:System.Windows.DependencyObjectType> ではなく、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 型です。 <xref:System.Windows.DependencyObjectType> 高速の参照を容易になります。  
  
   
  
## 例  
 次の擬似コードの例では `MySubClass` 予測するその他の派生クラスがの既定値を変更することがあります、 `MyCustom` 依存関係プロパティ。 クラスの既定のコンス トラクター ポリモーフィズムを活用することによって、実際の派生クラスを特定する、 <xref:System.Windows.DependencyObjectType> 値の派生クラスのインスタンスとしてそのコンス トラクターが使用されるたびにします。  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Windows.DependencyObject" /> 現在のインスタンスと比較します。</param>
        <summary>指定されたかどうかを決定 <see cref="T:System.Windows.DependencyObject" /> は現在と同じ <see cref="T:System.Windows.DependencyObject" />します。</summary>
        <returns>
          <see langword="true" /> 2 つのインスタンスが同じである場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この実装は、参照の等価性のみで含まれているプロパティの値の等価性を評価しようとはしません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> overrides and then seals two basic <see cref="T:System.Object" /> methods: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> and <see cref="M:System.Windows.DependencyObject.GetHashCode" />. The overrides call the <see cref="T:System.Object" /> implementations, resulting in an object equality behavior. The purpose of these deliberate overrides is to prevent derived classes from trying to define a value equality for a <see cref="T:System.Windows.DependencyObject" />. Value equalities for <see cref="T:System.Windows.DependencyObject" /> will never be accurate because of the innate property value-changing capabilities of a <see cref="T:System.Windows.DependencyObject" /> and its dependency properties. This includes fundamental [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] features such as data binding and the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Windows.DependencyObject" /> のハッシュ コードを取得します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> overrides and then seals two <see cref="T:System.Object" /> methods: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> and <see cref="M:System.Windows.DependencyObject.GetHashCode" />. The overrides call the <see cref="T:System.Object" /> implementations, resulting in an object equality behavior. The purpose of these deliberate overrides is to prevent derived classes from trying to define a value equality for a <see cref="T:System.Windows.DependencyObject" />. Value equalities for <see cref="T:System.Windows.DependencyObject" /> will never be accurate because of the innate property value-changing capabilities of a <see cref="T:System.Windows.DependencyObject" /> and its dependency properties. This includes fundamental [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] features such as data binding and the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>どの依存関係プロパティに値を設定ローカルに決定するための特殊な列挙子を作成 <see cref="T:System.Windows.DependencyObject" />します。</summary>
        <returns>専用のローカル値の列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A *ローカル値* で設定された依存関係プロパティの値は、 <xref:System.Windows.DependencyObject.SetValue%2A>, プロパティ システムの他の側面ではなく、します。  
  
 <xref:System.Windows.LocalValueEnumerator> 呼び出すことによって取得 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> をローカルに設定されたプロパティを列挙するために使用する値を <xref:System.Windows.DependencyObject> インスタンス。 このような各プロパティは、列挙子で表されます、 <xref:System.Windows.LocalValueEntry> 、固有の仕様を参照するプロパティを持つオブジェクト <xref:System.Windows.DependencyProperty> とその値。 この手法をローカルで設定を列挙する際の値として使用できます最適化またはローカルの値の他の処理などのプロパティ値を判断、 <xref:System.Windows.DependencyObject> が変わってしまう場合、それらをクリアします。  
  
> [!IMPORTANT]
>  返された <xref:System.Windows.LocalValueEnumerator> を含めることが <xref:System.Windows.LocalValueEntry> は読み取り専用依存関係プロパティの値を計算して、プロパティ システムを依存関係プロパティのレコードです。 たとえばをレイアウトを使って確立された幅を持つ visual フレームワーク要素がのローカル値をレポート <xref:System.Windows.FrameworkElement.ActualWidth%2A>します。 それらをリセットするためにローカルの値を取得する場合は、確認、 <xref:System.Windows.DependencyProperty.ReadOnly%2A> の各プロパティの識別子の値 <xref:System.Windows.LocalValueEntry> ことを確認する、 <xref:System.Windows.DependencyProperty> 問題は読み取り専用です。  
  
   
  
## 例  
 次の例は、ローカルの値はオブジェクトで設定を持つすべてのプロパティを反復処理を順に呼び出して <xref:System.Windows.DependencyObject.ClearValue%2A> このような各プロパティの値をクリアします。  
  
 [!code-csharp[DPClearValue\#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue\#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">値を取得するプロパティの <see cref="T:System.Windows.DependencyProperty" /> 識別子。</param>
        <summary>
          <see cref="T:System.Windows.DependencyObject" /> のこのインスタンスにある依存関係プロパティの現在の有効値を返します。</summary>
        <returns>現在の有効値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 *有効な値* プロパティ システムによって、値を要求している任意の呼び出し元に返されるプロパティの値を指定します。 有効な値は、プロパティ システムの値の優先順位に関係するすべての可能な入力を評価したプロパティのシステムの結果です。 これには、強制型変換とアニメーションが含まれます。 詳細については、次を参照してください。 [依存関係プロパティの値の優先順位](http://msdn.microsoft.com/ja-jp/1fbada8e-4867-4ed1-8d97-62c07dad7ebc)します。  
  
 このメソッドは返されません <xref:System.Windows.DependencyProperty.UnsetValue>します。<xref:System.Windows.DependencyProperty.UnsetValue> そしてときに内部的にも強制コールバックを通じて公開されるさまざまな容量で使用されているプロパティのシステムの sentinel 値です。  
  
 プロパティの型にする必要がありますが不明な場合は、詳細ながあるかどうかを判断する要求された依存関係プロパティの識別子を照会できます <xref:System.Windows.DependencyProperty.PropertyType%2A> 戻り値に変換できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定された <paramref name="dp" /> またはその値が無効か、指定された <paramref name="dp" /> が存在しません。</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <see cref="T:System.Windows.DependencyProperty" /> を無効にするプロパティの識別子。</param>
        <summary>指定した依存関係プロパティに対する有効な値を再評価します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すと <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, 、any 関連付けられている、該当する <xref:System.Windows.CoerceValueCallback> または <xref:System.Windows.PropertyChangedCallback> 関数登録されているその依存関係プロパティを呼び出すことがあります。  
  
 呼び出す <xref:System.Windows.DependencyObject.InvalidateProperty%2A> をローカルの値の設定を持つプロパティの効果はありません、ため、ローカルの値のアニメーションを除く他のプロパティのシステム入力よりも優先されます。 ただし、呼び出すことが <xref:System.Windows.DependencyObject.ClearValue%2A>, 、まず <xref:System.Windows.DependencyObject.InvalidateProperty%2A>します。 詳細については、次を参照してください。 [依存関係プロパティの値の優先順位](http://msdn.microsoft.com/ja-jp/1fbada8e-4867-4ed1-8d97-62c07dad7ebc)します。  
  
 呼び出す <xref:System.Windows.DependencyObject.InvalidateProperty%2A> は依存関係プロパティの多くのシナリオに必ずしも適用されません。 依存関係プロパティが、構成要素のいずれかの値が変更されたのため無効になった場合、プロパティ システムは無効にし、依存関係プロパティを自動的に再評価します。 ただし、シナリオは、まだいくつか適切な場所 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 役に立ちます。 具体的には、使用することができます <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 強制値またはプロパティの内部依存関係プロパティのコールバックを変更します。 使用することも <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 推奨を実装することがない場合、データ ソースに対するバインディングの再評価を強制する <xref:System.ComponentModel.INotifyPropertyChanged> 通知メカニズム \(おそらくからを取得できないか、またはデータが静的メンバーのデータ クラスを消費している場合\)。  
  
   
  
## 例  
 次の例では <xref:System.Windows.DependencyObject.InvalidateProperty%2A> カスタム プロパティにするたびに、無効化されたプロパティの計算に関連するプロパティを変更します。 これを呼び出すことの代替手法、 <xref:System.Windows.DependencyObject.CoerceValue%2A> メソッド、プロパティを無効には呼び出すことも、ために登録 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>します。  
  
 [!code-csharp[PropertySystemEsoterics\#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics\#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>\(読み取り専用\)、このインスタンスが現在シールされているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> このインスタンスは、シールされている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この値は、内部的に設定されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">関心のある依存関係プロパティの識別子、そのタイプのプロパティ メタデータ、新旧の値を含むイベント データ。</param>
        <summary>この <see cref="T:System.Windows.DependencyObject" /> に指定されたいずれかの依存関係プロパティの有効な値が更新されるたびに呼び出されます。 変更された特定の依存関係プロパティは、イベント データで報告されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは通常、個々 のプロパティの変更を検出するか、ケースごとにプロパティの無効化を実行するものでありません。<xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 代わりに、一般的な無効化パターンの変更プロパティの広範な分類に関する特定の情報がわかっている場合です。 変更など、 <xref:System.Windows.Freezable> の値の型の変更があります、 <xref:System.Windows.Freezable>, 、または可能性があります、サブプロパティを他の内に変更がある <xref:System.Windows.Freezable> 参照します。<xref:System.Windows.Freezable> の実装をオーバーライド <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> かを判断プロパティが、サブプロパティでし、いずれの場合の適切な基本クラス ロジックを提供するかどうかの内部情報を使用します。  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> オブジェクトの有効期間中に何度もを呼び出す可能性があります、します。 特定のプロパティのメタデータをオーバーライドし、適用する場合、全体的なプロパティのシステムのパフォーマンスを向上できますので、 <xref:System.Windows.CoerceValueCallback> または <xref:System.Windows.PropertyChangedCallback> 個々 のプロパティです。 ただし場合は、このメソッドを使用、 <xref:System.Windows.DependencyObject> 一定数値と相互に依存関係プロパティにはが含まれています表示動作する必要がありますを再実行する複数の関連するプロパティの無効化の場合のようにロジックが含まれている場合、またはです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Always call the base implementation. Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, causing incorrect values to be reported.</para>
        </block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">値を取得する対象のプロパティの <see cref="T:System.Windows.DependencyProperty" /> 識別子。</param>
        <summary>ローカルの依存関係プロパティの値を返します \(存在する場合\)。</summary>
        <returns>ローカル値を返します。またはローカル値が設定されていない場合は、sentinel 値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用する必要があります <xref:System.Windows.DependencyObject.GetValue%2A> 依存関係プロパティの"get"操作で最も一般的です。<xref:System.Windows.DependencyObject.ReadLocalValue%2A> 返しませんさまざまな状況に対する有効な値、値がローカルで設定されていません。  
  
 スタイル、テーマ、テンプレートで設定されている値の場合は、メタデータ、またはプロパティ値の継承の既定値はローカルの値であると見なされません。 ただし、バインディング、およびその他の式が評価された後、ローカルの値であると見なされます。  
  
 このメソッドが戻るとき、ローカルの値が設定されていない <xref:System.Windows.DependencyProperty.UnsetValue>します。  
  
 戻り値は以外の場合 <xref:System.Windows.DependencyProperty.UnsetValue>, 、戻り値に変換できるより具体的な種類があるかどうかを判断する要求された依存関係プロパティのメタデータを照会することができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">設定する依存関係プロパティの識別子。</param>
        <param name="value">新しいローカル値。</param>
        <summary>依存関係プロパティ値のソースを変更せずにその値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、プログラムを使用して、アプリケーションの宣言されたプロパティを使用するを無効にすることがなく、独自のプロパティのいずれかの値を設定するコンポーネントによって使用されます。<xref:System.Windows.DependencyObject.SetCurrentValue%2A> メソッドですが、既存のトリガーのデータ バインドの有効な値を変更して、スタイルは引き続き機能します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">読み取り専用の依存関係プロパティ、またはシールされている <see cref="T:System.Windows.DependencyObject" /> 上のプロパティを変更しようとしました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> が、<paramref name="dp" /> プロパティに登録されている正しい型ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">設定する依存関係プロパティの識別子。</param>
        <param name="value">新しいローカル値。</param>
        <summary>依存関係プロパティ識別子を指定して、該当する依存関係プロパティのローカル値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された型が最初に登録されているとおりに、依存関係プロパティの宣言された型が一致しない場合、例外がスローされます。`value` パラメーターは、適切な型として常に提供する必要があります。  
  
 例外条件はによって影響を受ける可能性がある、 <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> に設定されている依存関係プロパティの依存関係プロパティの識別子が存在するコールバック。 それ以外の場合、指定された値に問題がある \(たとえば、ネイティブ型は Double と文字列を渡すなど\) の一般的な型チェックの状態。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">読み取り専用の依存関係プロパティ、またはシールされている <see cref="T:System.Windows.DependencyObject" /> 上のプロパティを変更しようとしました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> が、<paramref name="dp" /> プロパティに登録されている正しい型ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">設定するプロパティの <see cref="T:System.Windows.DependencyPropertyKey" /> 識別子。</param>
        <param name="value">新しいローカル値。</param>
        <summary>依存関係プロパティの <see cref="T:System.Windows.DependencyPropertyKey" /> 識別子で指定した読み取り専用の依存関係プロパティのローカル値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この署名は通常、読み取り専用の依存関係プロパティのカスタム クラスで定義されている値を設定するときに使用します。 一般に、 <xref:System.Windows.DependencyObject.SetValue%2A> 依存関係プロパティの特定の値を提供する内部ロジックを実装して、その依存関係プロパティを登録した型からのみ呼び出されます。 詳細については、次を参照してください。 [読み取り専用依存関係プロパティ](http://msdn.microsoft.com/ja-jp/f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1)します。  
  
 指定された型が最初に登録されているとおりに、依存関係プロパティの宣言された型が一致しない場合、例外がスローされます。`value` パラメーターは、適切な型として常に提供する必要があります。 例外条件はによって影響を受ける可能性がある、 <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> に設定されている依存関係プロパティの依存関係プロパティの識別子が存在するコールバック。  
  
   
  
## 例  
 次の例では、読み取り専用の依存関係プロパティを定義と共に、 `public static readonly` <xref:System.Windows.DependencyProperty> プロパティ コンシューマーとの get アクセサーに必要な読み取り専用の露出を提供する、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] ラッパーです。  
  
 [!code-csharp[WPFAquariumSln\#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln\#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">シリアル化する必要がある依存関係プロパティの識別子。</param>
        <summary>シリアル化プロセスが、指定された依存関係プロパティの値をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns>指定された依存関係プロパティの値をシリアル化する必要がある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装 `true` 依存関係プロパティに設定されたローカル値をいたすべての場合、 <xref:System.Windows.DependencyObject>です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Overrides for this method might handle specific dependency properties differently.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ローカルの依存関係プロパティの値を設定します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>プロパティのローカル値をクリアします。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>