<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>登録時の条件など、特定の種類に適用されるときの依存関係プロパティの動作を定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティのメタデータを定義し、呼び出すときに、依存関係プロパティの登録時に使用、 <xref:System.Windows.DependencyProperty.Register%2A> メソッド \(または、アタッチされるプロパティまたは読み取り専用の依存関係プロパティの変化形\) を呼び出すときに、元の所有者登録後に、または、 <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> メソッドです。<xref:System.Windows.DependencyProperty.AddOwner%2A> プロパティのメタデータもかかります。  
  
 このクラスは、それらの各呼び出しで使用できる具象基底クラスです。 ただし、派生クラスのいずれかなどを使用してメタデータを指定する非常に一般的なは <xref:System.Windows.FrameworkPropertyMetadata>です。 これらの派生クラスでのみ実装されているプロパティ システムとレイアウト動作を有効にするかを検出するのに便利ですが、ブール型プロパティ値として格納されている詳細なメタデータのサポート、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] フレームワーク レベルです。  
  
 このクラスのいくつかのプロパティは、オブジェクト モデルへの読み取り\/書き込みがなどのプロパティのシステム操作で使用されているインスタンスの前に記述できない <xref:System.Windows.DependencyProperty.Register%2A> または <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>です。 これらの各プロパティ コンス トラクターによって設定されても可能性しますが、公開されるように <xref:System.Windows.PropertyMetadata.Merge%2A> メソッドの実装が設定できます。  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## XAML テキストの使用方法  
 この型、およびこの型のメンバーは、通常は使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">いくつかの特定の型の値として通常提供される依存関係プロパティを指定する既定値です。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.PropertyMetadata" /> にこのメタデータが適用される依存関係プロパティの指定された既定値を持つクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された値の型 `defaultValue` 一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 \(この不一致は実行時例外を発生させる\) のコンパイル時に、不一致が検出できないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。  
  
 ですが、既定ではパラメーターなしのコンス トラクターでは、1、 `defaultValue` の <xref:System.Windows.DependencyProperty.UnsetValue> は指定できません。 そのようにしようとすると、例外が発生します。  
  
   
  
## 例  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 値に設定することはできません <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムによって呼び出されるハンドラーの実装への参照。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.PropertyMetadata" /> 、指定したクラス <see cref="T:System.Windows.PropertyChangedCallback" /> の参照を実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">通常、いくつかの特定の型の値として提供、依存関係プロパティの既定値。</param>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムによって呼び出されるハンドラーの実装への参照。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.PropertyMetadata" /> 指定された既定値を持つクラスと <see cref="T:System.Windows.PropertyChangedCallback" /> の参照を実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された値の型 `defaultValue` 一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 \(この不一致は実行時例外を発生させる\) のコンパイル時に、不一致が検出できないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。  
  
 ですが、既定ではパラメーターなしのコンス トラクターでは、1、 `defaultValue` の <xref:System.Windows.DependencyProperty.UnsetValue> は指定できません。 そのようにしようとすると、例外が発生します。  
  
   
  
## 例  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 値に設定することはできません <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">通常、いくつかの特定の型の値として提供、依存関係プロパティの既定値。</param>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムによって呼び出されるハンドラーの実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムが呼び出すたびに呼び出されるハンドラーの実装への参照を <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> このプロパティに対してです。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.PropertyMetadata" /> クラスが指定された既定値およびコールバックを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定する場合、 <xref:System.Windows.CoerceValueCallback> ではなく、 <xref:System.Windows.PropertyChangedCallback>, を渡すことができます `null` の `propertyChangedCallback` パラメーター。  
  
 指定された値の型 `defaultValue` 一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 \(この不一致は実行時例外を発生させる\) のコンパイル時に、不一致が検出できないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。  
  
 ですが、既定ではパラメーターなしのコンス トラクターでは、1、 `defaultValue` の <xref:System.Windows.DependencyProperty.UnsetValue> は指定できません。 そのようにしようとすると、例外が発生します。  
  
   
  
## 例  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 値に設定することはできません <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の参照、 <see cref="T:System.Windows.CoerceValueCallback" /> このメタデータに指定されています。</summary>
        <value>A <see cref="T:System.Windows.CoerceValueCallback" /> の参照を実装します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティのメタデータのコールバックは、このプロパティの値が同じ既存の依存関係プロパティのメタデータを使用するほとんどのシナリオの重要ではありませんので、通常のパブリック メンバーを含む型ではありません。 このプロパティが公開されている理由の 1 つは、基本メタデータとメタデータのオーバーライド追加の両方を指定する場合、メタデータのサブクラスは、必要なマージ ロジックを実行できるように、 <xref:System.Windows.CoerceValueCallback>です。 ただし、既定値はマージのロジックを <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> は、1 つ前を置き換えることです。  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 読み取り\/書き込みとしてオブジェクト モデルで定義されます。 これは、 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> の初期化後に調整することができます、 <xref:System.Windows.PropertyMetadata> オブジェクト自体です。 ただしへの呼び出しの一部として、メタデータを使用したら <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 、プロパティ システムは封印するメタデータ インスタンスがそのプロパティを変更できないと見なされますようになりました。 設定しようとしています。 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> したら <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの既定値を取得または設定します。</summary>
        <value>プロパティの既定値。 パラメーターなしのコンストラクターで作成された <see cref="T:System.Windows.PropertyMetadata" /> インスタンスの既定値は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> になります。「解説」をご覧ください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read\-write. This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself. However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable. Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.  
  
 Although it is the default per the parameterless constructor, a **parameterReference tag is not supported!!!!**  
 of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor. Attempting to do so will raise an exception.  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## XAML Text Usage  
 Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">いったん作成した後は、値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。「解説」をご覧ください。</exception>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>そのメタデータ インスタンスの変更できない状態に何らかの方法でプロパティに、メタデータが適用されているかどうかを決定する値を取得します。</summary>
        <value>
          <see langword="true" /> メタデータ インスタンスが不変であり、ない場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 さまざまなプロパティ <xref:System.Windows.PropertyMetadata>, など <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, 、読み取り\/書き込みとしてオブジェクト モデルで定義されています。 これは、初期化の後にこれらのプロパティを調整できるため、 <xref:System.Windows.PropertyMetadata> オブジェクト自体です。 ただしへの呼び出しの一部として、依存関係プロパティに適用するメタデータ <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 、プロパティ システムは封印するメタデータ インスタンスがそのプロパティを変更できないと見なされますようになりました。 これらの呼び出しのいずれかの時点で <xref:System.Windows.PropertyMetadata.OnApply%2A> が呼び出されるにこのプロパティの値を設定および `true`です。  
  
   
  
## 例  
 次の例チェック <xref:System.Windows.PropertyMetadata.IsSealed%2A> カスタム メタデータ プロパティの設定操作の前にします。  
  
 [!code-csharp[PropertyMetadataAPIs\#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">このインスタンスの値と比較する基本のメタデータ。</param>
        <param name="dp">このメタデータを適用する依存関係プロパティ。</param>
        <summary>このメタデータと基本のメタデータをマージします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メタデータがオーバーライドされるときに、このメソッドは内部的に使用 \(<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> メソッド\)。  
  
   
  
## 例  
 次の例では、プロパティのメタデータに追加のプロパティを追加するカスタム メタデータ型のマージを実装します。  
  
 [!code-csharp[PropertyMetadataAPIs\#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations. For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.  
  
 Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.  
  
 The exact behavior of the merge is up to you. You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">メタデータが適用されている依存関係プロパティ。</param>
        <param name="targetType">型固有のメタデータは、この場合は、このメタデータに関連付けられている型。 これが既定のメタデータである場合は、この値は、null 参照です。</param>
        <summary>このメタデータがメタデータはシールされた旨を示すプロパティに適用されると呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サブクラスはことを保証のデータ構造の任意の可変性、 <xref:System.Windows.PropertyMetadata> サブクラスとマークされるべき変更不可として 1 回 <xref:System.Windows.PropertyMetadata.OnApply%2A> が呼び出されます。 メタデータがプロパティのシステム操作に適用されると呼び出されます \(登録、所有者を追加、メタデータをオーバーライドする\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の参照、 <see cref="T:System.Windows.PropertyChangedCallback" /> このメタデータに指定されています。</summary>
        <value>A <see cref="T:System.Windows.PropertyChangedCallback" /> の参照を実装します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティのメタデータのコールバックは、このプロパティの値が同じ既存の依存関係プロパティのメタデータを使用するほとんどのシナリオの重要ではありませんので、宣言の型では、通常のパブリック メンバーではありません。 このプロパティが公開されている理由の 1 つは、基本メタデータとメタデータのオーバーライド追加の両方を指定する場合、メタデータ クラスは、必要なマージ ロジックを実行できるように、 <xref:System.Windows.PropertyChangedCallback>です。 既定のマージ ロジックはすべて維持するために、 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> テーブルとそれらの最初を実行している階層の最下位のクラスの呼び出しごとに実装します。  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 読み取り\/書き込みとしてオブジェクト モデルで定義されます。 これは、 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> の初期化後に調整することができます、 <xref:System.Windows.PropertyMetadata> オブジェクト自体です。 ただしへの呼び出しの一部として、メタデータを使用したら <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 、プロパティ システムは封印するメタデータ インスタンスがそのプロパティを変更できないと見なされますようになりました。 設定しようとしています。 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> したら <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>