<Type Name="DependencyPropertyKey" FullName="System.Windows.DependencyPropertyKey">
  <TypeSignature Language="C#" Value="public sealed class DependencyPropertyKey" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyPropertyKey extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyPropertyKey" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>読み取り専用の依存関係プロパティへの書き込みアクセスの制限の依存関係プロパティの識別子を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.DependencyPropertyKey> メソッドを使用して、依存関係プロパティの登録の呼び出しの戻り値としてインスタンスが取得された <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> または <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>です。  
  
 依存関係プロパティを登録する型を使用できます、 <xref:System.Windows.DependencyPropertyKey> への呼び出しで <xref:System.Windows.DependencyObject.SetValue%2A> と <xref:System.Windows.DependencyObject.ClearValue%2A> クラス ロジックの一部として、このプロパティの値を調整します。 キーのアクセス レベルで許可されている場合の関連するクラスも使用できます、キーと依存関係プロパティ。 たとえば、internal としてキーを宣言することができ、同じアセンブリ内の他の種類は、その依存関係プロパティを設定できます。  
  
 <xref:System.Windows.DependencyPropertyKey> 返される読み取り専用の依存関係によってプロパティの登録できるようにしない、パブリック プロパティを設定可能なしたがって読み取り専用の依存関係プロパティとして登録ポイントを解読する際に、キーを公開するためです。 また、キーを公開すると、不一致な利用可能な依存関係プロパティの動作とその [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 好ましくないクラス設計プロパティ ラッパーの実装です。  
  
 公開する代わりにキー自体を公開すると、代わりに、 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> の値、 <xref:System.Windows.DependencyPropertyKey> として、 `public static readonly`<xref:System.Windows.DependencyProperty> クラスにします。 これにより、特定のローカル設定値を列挙するなどのシステム操作のプロパティで有効な依存関係プロパティの識別子を返すプロパティです。 ただし、識別子を取得したためにはのすべての機能がない、 <xref:System.Windows.DependencyProperty> の多くのプロパティのシステム操作です。  
  
   
  
## 例  
 次の例は、読み取り専用の依存関係プロパティを登録し、また他のクラス メンバーには、2 つのキーを使用します。 get"ラッパー"を実装すると、値を設定する保護された特定の操作の識別子としては、他のプロパティ値の計算に基づきます。  
  
 [!code-csharp[WPFAquariumSln\#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln\#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この読み取り専用の特殊な依存関係プロパティの識別子に関連付けられている依存関係プロパティの識別子を取得します。</summary>
        <value>関連する依存関係プロパティの識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> 値には、プロパティ システム操作で同じインターフェイスの一部を使用したのと読み取り\/書き込みの依存関係プロパティの使用で参加に共通する読み取り専用プロパティの識別子が有効になります。  
  
 読み取り専用の依存関係プロパティの get プロパティ アクセサーを実装するために作成し、公開する必要があります、 <xref:System.Windows.DependencyProperty> クラス上の識別子。 これには 2 つの目的があります。  
  
-   クラスの独自のニーズ、 <xref:System.Windows.DependencyProperty> プロパティのラッパーの get アクセサーを実装するために識別子。 使用する、 <xref:System.Windows.DependencyProperty> のパラメーターとして、 <xref:System.Windows.DependencyObject.GetValue%2A> 呼び出しを get アクセサーを実装します。  
  
-   <xref:System.Windows.DependencyProperty> 識別子は、メタデータに依存するその他のメソッドを使用すると、標準的な形式でアクセスできるように、プロパティ システムに、依存関係プロパティを公開します。 たとえば、呼び出した場合 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> いくつか <xref:System.Windows.DependencyObject> ローカル プロパティの設定 \(値と識別子\) の列挙体識別子を取得し、読み取り専用の依存関係プロパティを使用するように返される、 <xref:System.Windows.DependencyProperty> キーではなく値します。 公開する、 <xref:System.Windows.DependencyProperty> 識別子が任意の方法で、読み取り専用の依存関係プロパティのセキュリティを強化していないが、それ以降の派生クラスとクラスのインスタンスの両方に対してより厄介なプロパティに関連する操作を使用するだけです。  
  
 公開する、  <xref:System.Windows.DependencyProperty> クラスの識別子を呼び出す <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> 、キー上で直接します。 この値を使用して、作成、 `public static readonly`<xref:System.Windows.DependencyProperty> と平行クラス上の識別子、 <xref:System.Windows.DependencyPropertyKey>です。  
  
   
  
## 例  
 次の例では <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> を公開する、 <xref:System.Windows.DependencyProperty> 識別子 \(`AquariumGraphicProperty`\) の `AquariumGraphic` クラスの読み取り専用の依存関係プロパティ。 この例も示します、 <xref:System.Windows.DependencyPropertyKey> \(内部のメンバー\) として作成し、get アクセサーを `AquariumGraphic`します。  
  
 [!code-csharp[WPFAquariumSln\#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln\#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">型をこの依存関係プロパティが存在して、メタデータをオーバーライドする必要があります。</param>
        <param name="typeMetadata">この型に対して提供されるメタデータ。</param>
        <summary>この依存関係プロパティの識別子によって表される読み取り専用の依存関係プロパティのメタデータを上書きします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 読み取り\/書き込みの依存関係プロパティのメタデータのオーバーライドと同様の理由で実行され、メタデータに指定された動作は、機能の設定を変更できるためにキーのレベルのアクセスに制限は読み取り専用の依存関係プロパティのメタデータのオーバーライド \(既定値のインスタンス\)。  
  
 として読み取り\/書き込みの依存関係プロパティを持つ、読み取り専用の依存関係プロパティのメタデータのオーバーライドのみ行ってください \(これは特定のプロパティを登録するオブジェクトのインスタンスがインスタンス化時に相当\)、プロパティ システムによって使用されるプロパティの前にします。 呼び出す <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> として自体を提供する型の静的コンス トラクター内でのみ実行する必要があります、 `forType` メソッド、またはそのクラスの同等の初期化のパラメーターです。  
  
 このメソッドが効率的に転送する、 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> を渡して、メソッド、 <xref:System.Windows.DependencyPropertyKey> インスタンス キーのパラメーターとして。  
  
   
  
## 例  
 次の例では、クラスは継承する既存の読み取り専用の依存関係プロパティのメタデータをオーバーライドします。 この場合、シナリオの目的は、基本プロパティのメタデータが含まれていない強制値コールバックを追加するでした。 メタデータのオーバーライドは、通常、その他の理由のいずれか適切向けに、メタデータを上書きすることも可能性があります \(既定値を変更する追加 <xref:System.Windows.FrameworkPropertyMetadataOptions> 値などです\)。  
  
 [!code-csharp[WPFAquariumSln\#RODPOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodpoverride)]
 [!code-vb[WPFAquariumSln\#RODPOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodpoverride)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">実行しようとしたメタデータの読み取り\/書き込みの依存関係プロパティのオーバーライド \(実行できないこの署名を使用\)。</exception>
        <exception cref="T:System.ArgumentException">メタデータが、提供された型に存在するプロパティに既に確立しています。</exception>
        <altmember cref="T:System.Windows.DependencyProperty" />
        <altmember cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      </Docs>
    </Member>
  </Members>
</Type>