<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.Windows.FrameworkContentElement" /> は、<see cref="T:System.Windows.ContentElement" /> 基底クラスの WPF フレームワーク レベルの実装および拡張です。<see cref="T:System.Windows.FrameworkContentElement" /> は、補足の入力 API \(ツールヒントやコンテキスト メニューなど\)、ストーリーボード、データ バインディング用のデータ コンテキスト、スタイルのサポート、および論理ツリーのヘルパー API に関するサポートを追加します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.FrameworkContentElement> 独自のレンダリング動作は定義されていません実際のインスタンス化 <xref:System.Windows.FrameworkContentElement> コードまたはマークアップ内のクラス インスタンスは可能ですで何も表示されない、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] アプリケーション [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]します。 受け取るクラスによって提供されるロジックをレンダリングする必要があります <xref:System.Windows.FrameworkContentElement> 子要素、または、コンテンツ モデルの一部として <xref:System.Windows.FrameworkContentElement> クラスを派生します。  
  
 <xref:System.Windows.FrameworkContentElement> 意図的に同一の多くは対応している [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] として <xref:System.Windows.FrameworkElement>します。 一部の注 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] で検出された <xref:System.Windows.FrameworkElement> 必要はありません、 <xref:System.Windows.FrameworkContentElement> と同じです。 いくつかの <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] は geometry 表現やレイアウトなどの機能に対しては関連しないが、 <xref:System.Windows.FrameworkContentElement>です。  
  
 既存の大多数 <xref:System.Windows.FrameworkContentElement> 派生クラスに存在しています、 <xref:System.Windows.Documents> 名前空間。 これらの派生クラスの多くは、フロー ドキュメント モデルの要素を実装します。 などの特定の派生クラス <xref:System.Windows.Documents.Hyperlink> いくつかのコントロールのような機能がありますから派生した <xref:System.Windows.FrameworkContentElement> コントロールのような要素がフロー ドキュメント モデルに参加できるまだようにします。  
  
   
  
## 例  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.FrameworkContentElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">追加される子要素。</param>
        <summary>指定した要素をこの要素の子として追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method can throw an exception if called at a time when the logical tree is being iterated by another process.  
  
 Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment \(for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class\). You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead. Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element \(content host\).  
  
 For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](http://msdn.microsoft.com/ja-jp/e83f25e5-d66b-4fc7-92d2-50130c9a6649).  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要素が初期化される前に呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Override this method to provide special handling that should occur before your element is initialized during the element loading process.  
  
 Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.  
  
 The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">開始するストーリー ボードです。</param>
        <summary>指定したストーリー ボードに含まれているアクションのシーケンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 署名を使用しないため、 `isControllable`, 、パラメーター、そのパラメーターが指定されている場合、または `false`, 、「保留」の期間に達するとすぐに、アニメーションに関連付けられているタイムライン クロックは削除されます。 そのため 1 回実行された後、アニメーションを再開できません。 アニメーションを制御する必要もありますストーリー ボードを名前付き、またはコード内のインスタンスとしてアクセスできるようにすることに注意してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">開始するストーリー ボードです。</param>
        <param name="handoffBehavior">ストーリー ボードに記載されているプロパティが既にアニメーションされる場合に使用する動作を表す列挙体の値。</param>
        <summary>プロパティが既にアニメーション化する場合に発生する処理を指定するオプションを指定したストーリー ボードに含まれているアクションのシーケンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 署名を使用しないため、 `isControllable`, 、パラメーター、そのパラメーターが指定されている場合、または `false`, 、「保留」の期間に達するとすぐに、アニメーションに関連付けられているタイムライン クロックは削除されます。 そのため 1 回実行された後、アニメーションを再開できません。 アニメーションを制御する必要もありますストーリー ボードを名前付き、またはコード内のインスタンスとしてアクセスできるようにすることに注意してください。  
  
## 使用して、HandoffBehavior の作成  
 適用すると、 <xref:System.Windows.Media.Animation.Storyboard>, 、<xref:System.Windows.Media.Animation.AnimationTimeline>, 、または <xref:System.Windows.Media.Animation.AnimationClock> を使用してプロパティに、 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, 、 <xref:System.Windows.Media.Animation.Clock> 以前そのプロパティに関連付けられているオブジェクトがシステム リソースの使用を継続; タイミング システムが、時計を自動的に削除されません。  
  
 使用して多数の時計を適用すると、パフォーマンスの問題を回避する <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, 、完了した後、アニメーション化されたプロパティからクロックを構成することを削除する必要があります。 クロックを削除するためにいくつかの方法があります。  
  
-   プロパティからすべてのクロックを削除するには、使用、 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> または <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> アニメーション オブジェクトのメソッドです。 アニメーション化する最初のパラメーターとしてプロパティを指定し、 `null` 、2 つ目です。 これにより、すべてのアニメーション クロックがプロパティから削除されます。  
  
-   固有の仕様を削除する <xref:System.Windows.Media.Animation.AnimationClock> にクロックのリストを使用して、 <xref:System.Windows.Media.Animation.Clock.Controller%2A> のプロパティ、 <xref:System.Windows.Media.Animation.AnimationClock> を取得する、 <xref:System.Windows.Media.Animation.ClockController>, 、まず、 <xref:System.Windows.Media.Animation.ClockController.Remove%2A> のメソッド、 <xref:System.Windows.Media.Animation.ClockController>です。 これは、通常、 <xref:System.Windows.Media.Animation.Clock.Completed> クロックのイベント ハンドラーです。 唯一のルート クロックを使用して制御できることに注意してください、 <xref:System.Windows.Media.Animation.ClockController>、 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 子クロックのプロパティを返します `null`します。 なお、 <xref:System.Windows.Media.Animation.Clock.Completed> クロックの有効期間が無限の場合、イベントは発生しません。  その場合は、ユーザーを決定する必要がありますを呼び出すタイミング <xref:System.Windows.Media.Animation.ClockController.Remove%2A>します。  
  
 これは、主に有効期間が長いオブジェクトにおけるアニメーションの問題です。  オブジェクトがガベージ コレクションである場合は、そのクロックが切断されても、ガベージ コレクションします。  
  
 クロック オブジェクトに関する詳細については、次を参照してください。 [アニメーションおよびタイミング システムの概要](http://msdn.microsoft.com/ja-jp/172cd5a8-a333-4c81-9456-fafccc19f382)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">開始するストーリー ボードです。</param>
        <param name="handoffBehavior">ストーリー ボードに示されているプロパティが既にアニメーション化する場合に使用する動作を表す列挙体の値。</param>
        <param name="isControllable">アニメーションが制御できるかどうかを宣言 \(一時停止できる\) の開始後にします。</param>
        <summary>開始後に、アニメーションのコントロールの状態を指定して、指定されたストーリー ボードに含まれているアクションのシーケンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 署名を使用しないため、 `isControllable`, 、パラメーター、そのパラメーターが指定されている場合、または `false`, 、「保留」の期間に達するとすぐに、アニメーションに関連付けられているタイムライン クロックは削除されます。 そのため 1 回実行された後、アニメーションを再開できません。 アニメーションを制御するも必要であるストーリー ボードを名前付き、またはコード内のインスタンスとしてアクセスできるようにすることに注意してください。  
  
## 使用して、HandoffBehavior の作成  
 適用すると、 <xref:System.Windows.Media.Animation.Storyboard>, 、<xref:System.Windows.Media.Animation.AnimationTimeline>, 、または <xref:System.Windows.Media.Animation.AnimationClock> を使用してプロパティに、 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, 、 <xref:System.Windows.Media.Animation.Clock> 以前そのプロパティに関連付けられているオブジェクトがシステム リソースの使用を継続; タイミング システムがこれらの時計を自動的に削除されません。  
  
 使用して多数の時計を適用すると、パフォーマンスの問題を回避する <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, 、完了した後、アニメーション化されたプロパティからクロックを構成することを削除する必要があります。 クロックを削除するためにいくつかの方法があります。  
  
-   プロパティからすべてのクロックを削除するには、使用、 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> または <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> アニメーション オブジェクトのメソッドです。 アニメーション化する最初のパラメーターとしてプロパティを指定し、 `null` 、2 つ目です。 これにより、すべてのアニメーション クロックがプロパティから削除されます。  
  
-   固有の仕様を削除する <xref:System.Windows.Media.Animation.AnimationClock> にクロックのリストを使用して、 <xref:System.Windows.Media.Animation.Clock.Controller%2A> のプロパティ、 <xref:System.Windows.Media.Animation.AnimationClock> を取得する、 <xref:System.Windows.Media.Animation.ClockController>, 、まず、 <xref:System.Windows.Media.Animation.ClockController.Remove%2A> のメソッド、 <xref:System.Windows.Media.Animation.ClockController>です。 これは、通常、 <xref:System.Windows.Media.Animation.Clock.Completed> クロックのイベント ハンドラーです。 唯一のルート クロックを使用して制御できることに注意してください、 <xref:System.Windows.Media.Animation.ClockController>、 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 子クロックのプロパティを返します `null`します。 なお、 <xref:System.Windows.Media.Animation.Clock.Completed> クロックの有効期間が無限の場合、イベントは発生しません。  その場合は、ユーザーを決定する必要がありますを呼び出すタイミング <xref:System.Windows.Media.Animation.ClockController.Remove%2A>します。  
  
 これは、主に有効期間が長いオブジェクトにおけるアニメーションの問題です。  オブジェクトがガベージ コレクションである場合は、そのクロックが切断されても、ガベージ コレクションします。  
  
 クロック オブジェクトに関する詳細については、次を参照してください。 [アニメーションおよびタイミング システムの概要](http://msdn.microsoft.com/ja-jp/172cd5a8-a333-4c81-9456-fafccc19f382)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、<see cref="T:System.Windows.Data.BindingGroup" />要素に使用されます。</summary>
        <value>
          <see cref="T:System.Windows.Data.BindingGroup" />要素に使用されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A<xref:System.Windows.Data.BindingGroup>オブジェクトの複数のプロパティの値を検証するために使用できます。 たとえば、アプリケーションがアドレスを入力するように求めるし、その型のオブジェクトが設定されます`Address`、プロパティを持つ`Street`、 `City`、 `ZipCode`、および`Country`ユーザーが指定した値を持つ。 アプリケーションが 4 つを含むパネル<xref:System.Windows.Controls.TextBox>コントロール、それぞれは、オブジェクトのプロパティのいずれかにバインドします。 使用することができます、<xref:System.Windows.Controls.ValidationRule>で、<xref:System.Windows.Data.BindingGroup>を検証する、`Address`オブジェクト。 たとえば、<xref:System.Windows.Controls.ValidationRule>郵便番号が有効住所の国であることを確認できます。  
  
 子要素を継承、<xref:System.Windows.Data.BindingGroup>だけで、他の継承可能なプロパティと同様に、親要素からです。  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|メタデータ プロパティに設定**は true。**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>それに含まれるスクロール可能な領域内に、この要素を表示しようとします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出すことで効果的を呼び出す <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> 要素が含まれる親スクロール可能な領域の \(親が非常に適して、 <xref:System.Windows.FrameworkElement>, ではなく、 <xref:System.Windows.FrameworkContentElement>\)。 スクロール可能な領域には、この要素が含まれていない、イベントが発生しますまだがなければ有効です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を使用して、コンテキスト メニューが要求されるたびに表示されるコンテキスト メニュー要素 ユーザー インターフェイス (UI) からこの要素内で。</summary>
        <value>この要素を使用して、コンテキスト メニューです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例の場所、 <xref:System.Windows.Controls.ContextMenu> 上、 <xref:System.Windows.Documents.Paragraph>です。  
  
 [!code-xml[ContentElementsSmorgasbord\#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のコンテキスト メニューを閉じる直前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 閉じないようにするには、コンテキスト メニュー、イベントのハンドラーは、処理済みとしてマークします。  
  
 このイベントとして使用する、 <xref:System.Windows.EventTrigger> スタイルでは、基になるサービスのイベント識別子を参照する必要があります。  
  
 [!code-xml[CorePseudocode\#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 \(ために、この使用法が必要でイベントの実装 <xref:System.Windows.FrameworkContentElement> 公開サービスの基になるイベントはいない適切にマップされる、 <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> トリガーで使用するための識別子\)。  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## 例  
 次の例は、名前付き領域にカーソルを変更するハンドラーを実装 `DisplayArea` \(非表示\)。 コメントのヒントに、 <xref:System.Windows.UIElement> の使用状況、実際にこのサンプルは同じですが、場合 `DisplayArea` された、 <xref:System.Windows.FrameworkContentElement>です。  
  
 [!code-csharp[cursors\#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors\#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別、 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2)します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントが登録されているときに、イベント識別子のオブジェクトは作成されます \(表示 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>\) クラスのハンドラーを追加するために使用して \(を参照してください <xref:System.Windows.EventManager.RegisterClassHandler%2A>\)。 識別子のオブジェクトには、識別名、所有者の種類、ハンドラーの種類、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のコンテキスト メニューを開いたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コンテキスト メニューを手動で開く、処理済みとして、イベントのハンドラーに関連するイベントをマークする必要があります。 それ以外の場合、既存の値、 <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> プロパティが自動的にコンテキスト メニューを開き、使用されます。 イベントを処理済みのマークを付け、既定のアクションを効果的に取り消しの値にリセットすることにより、 <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> プロパティ、開き、新しい <xref:System.Windows.Controls.ContextMenu>します。 ただしはタイミングの問題を認識する必要があります。 により、コンテキスト メニューを完全に置き換えるために、 <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> ハンドラー、初期のコンテキスト メニューにはできません null\/空です。 また、イベントを処理し、新しいコンテキスト メニューを手動で開く必要があります。 詳細については、「 [方法: ContextMenuOpening イベントを処理](http://msdn.microsoft.com/ja-jp/789652fb-1951-4217-934a-7843e355adf4)します。  
  
 このイベントとして使用する、 <xref:System.Windows.EventTrigger> スタイルでは、基になるサービスのイベント識別子を参照する必要があります。  
  
 [!code-xml[CorePseudocode\#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 \(ために、この使用法が必要でイベントの実装 <xref:System.Windows.FrameworkContentElement> 公開サービスの基になるイベントはいない適切にマップされる、 <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> トリガーで使用するための識別子\)。  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別、 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2)します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントが登録されているときに、イベント識別子のオブジェクトは作成されます \(表示 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>\) クラスのハンドラーを追加するために使用して \(を参照してください <xref:System.Windows.EventManager.RegisterClassHandler%2A>\)。 識別子のオブジェクトには、識別名、所有者の種類、ハンドラーの種類、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上にマウス ポインターが置かれたときに表示されるカーソルを取得または設定します。</summary>
        <value>表示対象のカーソル。 既定値はこの依存関係プロパティごとに <see langword="null" /> として定義されます。 ただし、実行時における実用的な既定値は、さまざまな要因から取得されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを設定すると [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], 、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] の型変換にプロセッサが依存しています、 <xref:System.Windows.Input.Cursor> クラス文字列を評価します。 指定された文字列に評価、 <xref:System.Windows.Input.CursorType> 値。 詳細については、「<xref:System.Windows.Input.Cursor>」を参照してください。  
  
 このプロパティによって確立されると、カーソルは、マウス ポインターがこの要素は表示されないかどうかの値に依存しても、 <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> プロパティです。 また、アクティブなドラッグ、マウスのキャプチャ、編集モード、コントロール内のテキストなどのイベント関連の考慮事項では、このプロパティで指定した値よりも優先順位の高いカーソルは影響はも。  
  
 このプロパティを最終的な既定値に設定の動作を元に戻すに設定 `null` 再度します。  
  
 `null` 既定、つまり本当に、実際的なカーソルの値の決定はここでは遅延し、別の場所から取得する必要があります。 上の既定のカーソルの任意のソースからプログラムで値を持たない存在している場合、 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] アプリケーションは矢印になります。  
  
 上にあるマウスが移動するたび、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] アプリケーションが例外を <xref:System.Windows.ContentElement.QueryCursor> イベントです。 イベント バブル、経路上の任意の要素、イベントを処理し、このイベントの引数を使用してカーソルの値を設定する機会があります。 このような場合、イベントが処理され、引数を変更した値を持つことのファクトよりも優先の値、 <xref:System.Windows.FrameworkContentElement.Cursor%2A> あらゆるレベルでプロパティしない限り、 <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> 設定されています。  
  
 カスタムのカーソルを作成しない場合は、通常、このプロパティを設定の静的プロパティの値、 <xref:System.Windows.Input.Cursors> クラスです。  
  
 設定、 <xref:System.Windows.Input.Cursor> にカスタム値が有効でない部分的に信頼します。 カスタムのカーソルの詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、カーソルをカスタム値に設定します。  
  
 [!code-csharp[cursors\#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors\#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素がデータ バインディングに含まれている場合に、その要素のデータ コンテキストを取得または設定します。</summary>
        <value>データ コンテキストとして使用するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 *Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.  
  
 Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object. Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.  
  
 This dependency property inherits property values. If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.  
  
 Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>. For more information, see [How to: Specify the Binding Source](http://msdn.microsoft.com/ja-jp/55d47757-2648-4a52-987f-b767953f168c).  
  
 In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration. You can use either property element syntax or attribute syntax. Attribute syntax is shown in the example on this page. You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## XAML Property Element Usage  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## XAML Attribute Usage  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## XAML Values  
 *dataContextObject*  
 A directly embedded object that serves as data context for any bindings within the parent element. Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass. Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.  
  
 *bindingUsage*  
 A binding usage that evaluates to an appropriate data context. For details, see [Binding Markup Extension](http://msdn.microsoft.com/ja-jp/83d6e2a4-1b0c-4fc8-bd96-b5e98800ab63).  
  
 *resourceExtension*  
 One of the following: `StaticResource`, or `DynamicResource`. This usage is used when referring to raw data defined as an object in resources. See [XAML Resources](http://msdn.microsoft.com/ja-jp/91580b89-a0a8-4889-aecb-fddf8e63175f).  
  
 *contextResourceKey*  
 The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|Metadata properties set to **languageKeyword tag is not supported!!!!**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.  
  
 [!code-csharp[ContentElementsSmorgasbord\#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord\#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素のデータ コンテキストが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 データ コンテキストとデータ バインディングの詳細については、次を参照してください。 [データ バインドの概要](http://msdn.microsoft.com/ja-jp/c707c95f-7811-401d-956e-2fffd019a211)します。  
  
> [!IMPORTANT]
>  要素のときに <xref:System.Windows.FrameworkContentElement.DataContext%2A> この要素のすべてのデータ バインド プロパティの変更が影響を受ける可能性があります。 これは、データ コンテキストを継承するには、現在の要素の子孫の要素であるすべての要素と現在の要素自体に適用されます。 このようなすべてのバインドを再解釈新しい <xref:System.Windows.FrameworkContentElement.DataContext%2A> バインドで新しい値を反映するようにします。 これらの変更の順序に関する保証はありません、 <xref:System.Windows.FrameworkContentElement.DataContextChanged> イベントです。  変更は、イベントの前に、または任意の組み合わせで、イベントの後に発生します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはテーマには、このコントロールのスタイル テンプレートを検索に使用するキーを設定します。</summary>
        <value>スタイルのキー。 テーマ スタイルの参照の一部として正常に機能するこの値はあると想定、 <see cref="T:System.Type" /> の要素のスタイルを設定します。<see langword="null" /> 場合によっては、指定できる値は、します。「解説」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、通常は直接の set アクセス操作子のいずれかを通して設定されません。 代わりに、新しいサブクラスを作成するたびに、この依存関係プロパティの型に固有のメタデータをオーバーライドします。 ときにサブクラス化する、呼び出し、 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> に対するメソッド、 <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> コントロールのサブクラスの静的コンス トラクター内の識別子。  
  
 など、インライン クラスのインスタンス <xref:System.Windows.Documents.Bold> 実際には、ほとんどの実装をオーバーライドする以外、 <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> で静的コンス トラクターといくつかのインスタンス コンス トラクターを公開するメタデータです。 要素で囲まれているファクト、 <xref:System.Windows.Documents.Bold> ゲインをタグ付け、 <xref:System.Windows.Documents.TextElement.FontWeight%2A> プロパティの <xref:System.Windows.FontWeights.Bold%2A> の既定値の設定によって参照されているテーマ スタイル内に実装する <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> に `typeof(Bold)`します。  
  
 要素またはコントロールは意図的にテーマ スタイルを使用する場合は、設定、 <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> プロパティを `true`します。  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要素が初期化された直後後に呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 読み込みプロセスで、要素が初期化されるときに発生する特別な処理を提供するのには、このメソッドを実装します。  
  
 実装は、\(既定値\) の基本実装では、初期化を追跡するためのいくつかの内部フラグを設定するため、基本クラスの実装を呼び出す必要があります。  
  
 場合 <xref:System.Windows.FrameworkContentElement.BeginInit%2A> が呼び出された基本実装を発生させる、 <xref:System.Windows.FrameworkContentElement.Initialized> イベントです。 それ以外の場合 <xref:System.Windows.FrameworkContentElement.BeginInit%2A> が呼び出されなかったかではない可能性があるかどうかを確認 <xref:System.Windows.FrameworkContentElement.BeginInit%2A> が呼び出されると、イベントは発生しません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">検索する要素の名前です。</param>
        <summary>指定した識別名を持つ要素を検索します。</summary>
        <returns>要求された要素。 あります <see langword="null" /> 一致する要素が見つからなかった場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この要素に子要素がある場合は、要求された名前を持つ要素を再帰的には、すべて検索はこれらの子要素です。  
  
   
  
## 例  
 次の例では、参照先内で名前によって見つかった要素のプロパティを設定 <xref:System.Windows.Documents.FlowDocument> ページ上。  
  
 [!code-csharp[ContentElementsSmorgasbord\#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord\#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">検索するリソースのキー識別子。</param>
        <summary>指定されたキーを使用してリソースを検索し、要求されたリソースが見つからない場合は例外をスローします。</summary>
        <returns>見つかったリソース。または一致するリソースが見つからなかった場合は <see langword="null" /> \(<see langword="null" /> の場合は例外もスローします\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  キーが見つからないことがこのメソッドを呼び出した場合、例外がスローされます。 この場合、例外を処理しないようにする場合は呼び出す必要が <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>です。<xref:System.Windows.FrameworkContentElement.TryFindResource%2A> 返します `null` とリソースが検出され、例外をスローしません。  
  
 呼び出し元の要素で、リソースが見つからない場合は、ツリーになるのと同じ方法で検索すると、リソースが実行時にキーによって要求された、論理ツリーを使用して親ツリーを検索します。  
  
 通常、戻り値は返されたリソースの値を設定しようとしていたプロパティの型をキャストするとすぐにします。  
  
   
  
## 例  
 次の例では、マークアップで定義されているリソースを検索し、ルーティングされたイベントに応答内の要素の特定のプロパティに適用されます。  
  
 [!code-csharp[ContentElementsSmorgasbord\#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord\#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">要求されたリソース キーは見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がキーボード フォーカスを受け取ったときに適用される外観、効果、またはその他のスタイル特性のカスタマイズを可能にするオブジェクトを取得または設定します。</summary>
        <value>フォーカスに適用する目的のスタイル。 依存関係プロパティで宣言されている既定値は、空の静的 <see cref="T:System.Windows.Style" /> です。 ただし、実行時の有効値は、多くの場合、コントロールのテーマ サポートによって提供されたスタイルです \(ただし、常にそうであるとは限りません\)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを設定すると [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], 、スタイルはほとんどの場合を要素としてインラインではなく、リソースとして定義およびとして参照されているリソースは、通常、 <xref:System.Windows.StaticResourceExtension>です。  
  
 このプロパティが視覚的な外観に影響を与えますが、メタデータにように報告されないことに注意してください。 これは、視覚的な外観の変更イベントにより実行されるは、常に適用され、したがっては限らないメタデータに、visual またはレイアウトの情報です。  
  
 概念的には、コントロールに適用されたフォーカスの視覚的な動作は、要素間で一貫している必要があります。 一貫性を実現する最も賢明な方法では、全体のテーマを作成している場合にのみフォーカス表示スタイルを変更します。 個々 のスタイルとテーマの一部ではなく、このプロパティを設定がありません、このプロパティの使用目的キーボード フォーカスに関してユーザー エクスペリエンスに混乱する可能性があります。 トリガー \(スタイルの\) などを使用して入力の状態をそれぞれのプロパティをはるかに優れた方法は、要素固有の動作は意図的に一貫性のあるテーマである場合、 <xref:System.Windows.UIElement.IsFocused%2A> または <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, が、既存のフォーカス表示スタイルに視覚的に干渉しないようにするためです。 目的で設計の詳細については <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> と代替プロパティの焦点は、「 [コントロール、および FocusVisualStyle フォーカスのスタイル](http://msdn.microsoft.com/ja-jp/786ac576-011b-4d72-913b-558deccb9b35)します。  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## XAML 属性の使用方法  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## XAML プロパティ要素の使用  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## XAML 値  
 *resourceExtension*  
 次のいずれか: またはです。 参照してください [XAML リソース](http://msdn.microsoft.com/ja-jp/91580b89-a0a8-4889-aecb-fddf8e63175f)します。  
  
 *styleResourceKey*  
 要求されているスタイルを識別するキー。 このキーは既存のリソースを <xref:System.Windows.ResourceDictionary>です。  
  
> [!NOTE]
>  プロパティ要素構文は、技術的に可能ですが、推奨されません。 参照してください [インライン スタイルおよびテンプレート](http://msdn.microsoft.com/ja-jp/69a1a3f9-acb5-4e2c-9c43-2e376c055ac4)します。  使用してバインド参照または <xref:System.Windows.Data.Binding> も可能であればが一般的ではありません。  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうかこの <see cref="T:System.Windows.FrameworkContentElement" /> を実行してください、 ユーザー インターフェイス (UI) とこのインスタンスのによって宣言されたカーソルをレンダリングする <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> プロパティです。</summary>
        <value>
          <see langword="true" /> このインスタンスを使用するには、この要素上にカーソルの表示を強制的に \(すべての子要素を含む\) のカーソルについての設定します。それ以外の場合 <see langword="false" />します。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを設定 `true` 子要素で設定されているカーソル設定よりも優先されます。 そのため、一般にアプリケーション [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 子要素は、カーソルを指定しようとしている場合は特に、ユーザーにとってわかりにくくなる可能性があります。 設定 <xref:System.Windows.FrameworkElement.ForceCursor%2A> は、コントロールのサブクラス化または複合のシナリオに適しています。  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、要素上でカーソルを強制的します。  
  
 [!code-xml[ForceCursor\#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">ターゲット <see cref="T:System.Windows.DependencyProperty" /> 元となるバインディングを取得します。</param>
        <summary>取得、 <see cref="T:System.Windows.Data.BindingExpression" /> 指定したプロパティのバインドにします。</summary>
        <returns>返します。、 <see cref="T:System.Windows.Data.BindingExpression" /> ターゲットがデータにバインドの場合それ以外の場合、 <see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、プロパティを照会して、バインディングを取得します。  
  
 [!code-csharp[ContentElementsSmorgasbord\#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord\#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ビジュアル親が存在しない場合に、この要素に対する代替の論理上の親を返します。 この場合、<see cref="T:System.Windows.FrameworkContentElement" /> の親の値は常に <see cref="P:System.Windows.FrameworkContentElement.Parent" /> プロパティの値と同じになります。</summary>
        <returns>このメソッドの WPF フレームワーク レベルの実装が非ビジュアルの親接続を持つ場合は <see langword="null" /> 以外の値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装では、予想される 1 つ visual の親を返します。 カスタム実装は、代替親リレーションシップを返す場合があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときにこの <see cref="T:System.Windows.FrameworkContentElement" /> が初期化されています。 場合と一致する、この場所の値、 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> からプロパティが変更された <see langword="false" /> \(または未定義\) に <see langword="true" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントになります発生するたびに、 <xref:System.Windows.FrameworkContentElement.EndInit%2A> または <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> メソッドが呼び出されます。 これらのメソッドを呼び出すことが加えられた、コードの意図的または、 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 読み込みプロセスです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.FrameworkContentElement" /> で使用される入力のコンテキストを取得または設定します。</summary>
        <value>代替の入力メソッドからの入力を解釈する方法を変更する入力スコープ。 既定値は <see langword="null" /> です \(コマンドの既定の処理が行われます\)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この依存関係プロパティは、プロパティの値を継承します。 その他の値を持たない子要素があるかどうかは <xref:System.Windows.FrameworkElement.InputScope%2A> ローカル値またはスタイルを通じて確立されると、プロパティ システムは、される値を設定、 <xref:System.Windows.FrameworkElement.InputScope%2A> 割り当てられているこの値を持つ最も近い親要素の値。  
  
 ただし、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 構文の使用方法が表示されているし、構文的に許可されているでこのプロパティを設定 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 一般的ではありません。  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>いずれかで読み込まれると、この要素が初期化されたかどうかを示す値を取得 Extensible Application Markup Language (XAML), 、かをその <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> メソッドが呼び出されます。</summary>
        <value>
          <see langword="true" /> 前述の読み込みやメソッドの呼び出しは、要素が初期化される場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティがありますも `true` 新しい親要素を持つし、そのために再読み込みされたことになるように、この要素が要素ツリー内で移動されたかどうか。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がプレゼンテーションの読み込まれたかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 現在の要素は、要素ツリーにアタッチし、描画されている場合 <see langword="false" /> 要素が読み込まれた要素ツリーにアタッチされていない場合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しく構築されたインスタンスからこのプロパティは、まず `false`, 、開いたまま `true` に設定されていると `true`, コードによって、後で削除された場合でも、します。  
  
   
  
## 例  
 次のコード例を使用して <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> 関数を確保するために、条件の確認として `displayData` \(非表示\) が有効な要素上で起動に対して、オンデマンドでハンドラーの一部として動作するページです。 イベント ハンドラーとして同じロジックが実行される <xref:System.Windows.FrameworkContentElement.Loaded>します。  
  
 [!code-csharp[ContentElementsSmorgasbord\#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord\#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>個々の要素に適用されるローカリゼーション\/グローバリゼーション言語情報を取得または設定します。</summary>
        <value>この要素のカルチャ情報。 既定値は、<see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> の値が文字列 "en\-US" に設定された <see cref="T:System.Windows.Markup.XmlLanguage" /> インスタンスです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 文字列の形式では、RFC 3066 標準に従います。 たとえば、u. s."EN\-US"は英語です。 参照してください <xref:System.Windows.Markup.XmlLanguage> 値と形式についてです。  
  
 この依存関係プロパティは、プロパティの値を継承します。 その他の値を持たない子要素があるかどうかは <xref:System.Windows.FrameworkElement.Language%2A> ローカル値またはスタイルを通じて確立されると、プロパティ システムは、される値を設定、 <xref:System.Windows.FrameworkElement.Language%2A> 割り当てられているこの値を持つ最も近い親要素の値。  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.Language" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のレイアウトやレンダリングが完了し、操作を受け入れる準備が整ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 直接ルーティング イベントは、ルートに従っていない、発生した、同じ要素内でのみ処理されます。 ルーティング イベントは、その他のルーティング イベントの動作をサポートして直接: アクセス可能なハンドラーのコレクションをサポートし、として使用できる、 <xref:System.Windows.EventTrigger> スタイルでします。  
  
<a name="routedEventInfo_Loaded"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別、 <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2)します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントが登録されているときに、イベント識別子のオブジェクトは作成されます \(表示 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>\) クラスのハンドラーを追加するために使用して \(を参照してください <xref:System.Windows.EventManager.RegisterClassHandler%2A>\)。 識別子のオブジェクトには、識別名、所有者の種類、ハンドラーの種類、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>論理上の子のこの要素の要素に対応する列挙子を取得します。</summary>
        <value>この要素の論理上の子要素に対する列挙子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用する方法の詳細についての <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> と <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, を参照してください [WPF のツリー](http://msdn.microsoft.com/ja-jp/e83f25e5-d66b-4fc7-92d2-50130c9a6649)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">フォーカスがある列挙体の値として、移動する方向です。</param>
        <summary>この要素から別の要素にキーボード フォーカスを移動します。</summary>
        <returns>返します。 <see langword="true" /> フォーカスを正常に移動させる場合 <see langword="false" /> が存在しないと方向にターゲット要素が指定されている場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の識別名を取得または設定します。 この名前はインスタンス参照を提供するため、XAML の解析中に参照が構築されると、プログラムの分離コード \(イベント ハンドラー コードなど\) は要素を参照できるようになります。</summary>
        <value>要素の名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの最も一般的な使用方法を指定するが、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] マークアップ内の要素名。  
  
 このプロパティを設定する WPF フレームワーク レベルの便利なプロパティを本質的にでは、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Attribute](http://msdn.microsoft.com/ja-jp/b7e61222-e8cf-48d2-acd0-6df3b7685d48)します。  
  
 取得する、 <xref:System.Windows.FrameworkContentElement.Name%2A> コードからは通常ありません、メソッドを呼び出すだけで済みます既に適切な参照をコードにある場合、要素のプロパティを参照し、一般的に必要ではありませんので、 <xref:System.Windows.FrameworkContentElement.Name%2A>です。 例外は、オーバー ロードされたに意味があるかどうかは文字列内でその名前を表示すると便利である場合 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]します。 設定、 <xref:System.Windows.FrameworkContentElement.Name%2A> コードから場合元 <xref:System.Windows.FrameworkContentElement.Name%2A> がマークアップからセットことも避けてとプロパティを変更しても、オブジェクト参照は変更されません。 このようなオブジェクト参照が作成されるは、基になる名前のスコープが中に明示的に作成された場合にのみ [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ロードします。  
  
 具体的に呼び出す必要があります <xref:System.Windows.FrameworkContentElement.RegisterName%2A> で効果的な変更を行うには <xref:System.Windows.FrameworkContentElement.Name%2A> 既に読み込まれた要素のプロパティです。  
  
 1 つ注意すべきな場合は設定場所 <xref:System.Windows.FrameworkContentElement.Name%2A> コードからは重要なは、\[ストーリー ボードは名前付けの要素がに対して実行します。 名前を登録する前にも必要になるをインスタンス化し、割り当て、 <xref:System.Windows.NameScope> インスタンス。 使用例」を参照してください。 または [ストーリー ボードの概要](http://msdn.microsoft.com/ja-jp/1a698c3c-30f1-4b30-ae56-57e8a39811bd)します。  
  
 設定 <xref:System.Windows.FrameworkContentElement.Name%2A> からコードには、アプリケーションが制限されているが、特に、アプリケーションにページが再読み込みして、必ずしもその対応するページの分離コードが実行時のコードではありません、ナビゲーション モデルを採用している場合より一般的には要素名で検索します。 ユーティリティ メソッド <xref:System.Windows.FrameworkContentElement.FindName%2A>, 、いずれかから利用できる <xref:System.Windows.FrameworkContentElement>, で要素を検索できます <xref:System.Windows.FrameworkContentElement.Name%2A> その要素の論理ツリーを再帰的にします。 使用することも、 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> の静的メソッド <xref:System.Windows.LogicalTreeHelper>, 、により、 <xref:System.Windows.FrameworkContentElement.Name%2A> 文字列を引数として。  
  
 よく使用されるルート要素 \(<xref:System.Windows.Window>, 、<xref:System.Windows.Controls.Page> たとえば\) インターフェイスを実装する <xref:System.Windows.Markup.INameScope>です。 このインターフェイスの実装は、名前は、自分のスコープで明確であることを強制する必要があります。  
  
<a name="dependencyPropertyInfo_Name"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.Name" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>呼び出されるたびに、 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> ルーティングされたイベントがそのルート上でこのクラスに達するとします。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。  
  
 このメソッドの目的は、類似する部分が [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: 派生クラスをインスタンス ハンドラーではなくクラス ハンドラーから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントを子要素、必ずしも要素でハンドラーを呼び出すことで発生する可能性がありますのでルーティングされたイベントに異なります。 したがって、実装、イベント引数のソースのプロパティを考慮する必要が \(およびほとんどの場合、イベントを再発生しようとしないで\)。 サブクラス <xref:System.Windows.FrameworkContentElement> にイベントがルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すこともできます。 イベントの引数を受け取り、意図的に経路を短縮する処理済みとしてイベントをマークする 1 つの潜在的なシナリオです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのイベント データ。</param>
        <summary>呼び出されるたびに、 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> ルーティングされたイベントがそのルート上でこのクラスに達するとします。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスがこのメソッドを実装している場合は、base\(\) を呼び出す必要があります。  
  
 このメソッドの目的は、類似する部分が [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: 派生クラスをインスタンス ハンドラーではなくクラス ハンドラーから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントを子要素、必ずしも要素である、実装が、イベント引数のソースのプロパティを考慮するようにハンドラーを呼び出す \(ほとんどの場合、イベントを再発生しようとしないで\) で発生する可能性がありますのでルーティングされたイベントに異なります。 サブクラス <xref:System.Windows.FrameworkContentElement> にイベントがルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すこともできます。 イベントの引数を受け取り、意図的に経路を短縮する処理済みとしてイベントをマークする 1 つの潜在的なシナリオです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのイベント データ。</param>
        <summary>クラスのハンドラーを <see cref="E:System.Windows.ContentElement.GotFocus" /> イベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このクラスのハンドラーは、この要素からイベントが発生した場合、この要素の適切なフォーカスの動作を設定します。 イベントのソース ツリー内の別の要素だった場合、ハンドラーは何も行いません。  
  
 これらの既定の動作を要素にフォーカスを変更するのには、このメソッドをオーバーライドします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのイベント データ。</param>
        <summary>
          <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> イベントを発生させます。 このメソッドが呼び出されるたびに <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> に設定されている <see langword="true" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドの既定の実装は、このトピックで前述したように、イベントを発生させます。 上書きは、この動作を保持する base\(\) を呼び出す必要があります。  
  
 なお、 <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> プロパティは読み取り専用です。 そのため、このように初期化の動作を強制的に設定できません。 初期化\] 設定はでのみ実行するためのもので、 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] フレームワークです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">変更されたプロパティ \(古い値と新しい値を含む\) を示すイベント データ。</param>
        <summary>この <see cref="T:System.Windows.FrameworkContentElement" /> の依存関係プロパティの有効値が更新された場合に必ず呼び出されます。 変更が発生した特定の依存関係プロパティが引数パラメーターで報告されます。<see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> をオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、通常、プロパティの変更または無効化を検出するためにはありません。 代わりにものでは、一般的な無効化のパターンを変更するためのプロパティの広範な分類に関する特定の情報がわかっている場合。  
  
 このメソッドでは、オブジェクトの有効期間中に何度もを呼び出す可能性があります。 特定のプロパティのメタデータをオーバーライドし、適用する場合、パフォーマンスを向上できますので、 <xref:System.Windows.CoerceValueCallback> または <xref:System.Windows.PropertyChangedCallback> 個々 のプロパティです。 ただし場合は、このメソッドを使用、 <xref:System.Windows.FrameworkContentElement> 一定数値と相互に依存関係プロパティにはが含まれています表示動作する必要がありますを再実行する複数の関連するプロパティの無効化の場合のようにロジックが含まれている場合、またはです。  
  
 同じ名前を持つ `OnPropertyChanged` 異なるシグネチャを持つメソッド \(パラメーターの型が <xref:System.ComponentModel.PropertyChangedEventArgs>\) さまざまなクラスに表示されることができます。 ある `OnPropertyChanged` のコントラクトの一部で、データ オブジェクトの通知に使用 <xref:System.ComponentModel.INotifyPropertyChanged>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Always call the base implementation, as the first operation in your implementation. Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">元のスタイル。</param>
        <param name="newStyle">新しいスタイル。</param>
        <summary>この要素の変更で使用されているスタイルと呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドはスタイルが変更された条件を示す内部フラグを設定する既定の実装です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Always call the base implementation, otherwise styles cannot be applied. Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values. Theme changes will potentially invoke this method.</para>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>呼び出されるたびに、 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> ルーティングされたイベントがそのルート上でこのクラスに達するとします。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスがこのメソッドを実装している場合は、base\(\) を呼び出す必要があります。  
  
 このメソッドの目的は、類似する部分が [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] のイベント パターン On \* メソッド: 派生クラスをインスタンス ハンドラーではなくクラス ハンドラーから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントを子要素、必ずしも要素である、実装が、イベント引数のソースのプロパティを考慮するようにハンドラーを呼び出す \(ほとんどの場合、イベントを再発生しようとしないで\) で発生する可能性がありますのでルーティングされたイベントに異なります。 サブクラス <xref:System.Windows.FrameworkContentElement> にイベントがルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すこともできます。 イベントの引数を受け取り、意図的に経路を短縮する処理済みとしてイベントをマークする 1 つの潜在的なシナリオです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>呼び出されるたびに、 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> ルーティングされたイベントがそのルート上でこのクラスに達するとします。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスがこのメソッドを実装している場合は、base\(\) を呼び出す必要があります。  
  
 このメソッドの目的は、類似する部分が [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: 派生クラスをインスタンス ハンドラーではなくクラス ハンドラーから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントを子要素、必ずしも要素であるハンドラーを呼び出す \(ほとんどの場合、イベントを再発生しようとしないで\) で発生する可能性がありますのでルーティングされたイベントに異なります。 サブクラス <xref:System.Windows.FrameworkContentElement> にイベントがルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すこともできます。 イベントの引数を受け取り、意図的に経路を短縮する処理済みとしてイベントをマークする 1 つの潜在的なシナリオです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはこの要素がテーマ スタイルのスタイル プロパティを組み込むかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> この要素は、テーマのスタイル プロパティを使用していない場合すべての元のスタイル プロパティには、ローカル アプリケーションのスタイルとテーマ スタイル プロパティは適用されません。<see langword="false" /> 場合は、アプリケーションのスタイルが最初に、適用し、アプリケーション スタイルに具体的に設定されていないプロパティのテーマ スタイルを適用します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの最も一般的な使用方法は、テーマが適用されたスタイルを提供しているスタイルの setter 内の間接の使用率です。  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の論理ツリー内での親を取得します。</summary>
        <value>この要素の論理上の親。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 論理上の親要素の可能性がある変更された可能性が、アプリケーションの機能、このプロパティの値を保持してもその変更は反映されないことに注意してください。 通常必要があります値を取得することを必要とせずにすぐにします。  
  
 参照してください [WPF のツリー](http://msdn.microsoft.com/ja-jp/e83f25e5-d66b-4fc7-92d2-50130c9a6649) 詳細については、要素を検索には、この方法が適切では論理ツリーは、およびシナリオを走査します。  
  
 プロパティ システムは可能性のある再計算要素のすべてのプロパティ値、親を再指定、いくつかのプロパティは、論理ツリーを使用して値を継承するため。<xref:System.Windows.FrameworkContentElement.DataContext%2A> にバインドを変更することもを適用します。  
  
 要素の親の変更は通常のみ行うにはコレクションの操作専用を使用して追加メソッド、または削除、または、要素のコンテンツのプロパティを設定します。  
  
 使用するための最も一般的なシナリオ、 <xref:System.Windows.FrameworkContentElement.Parent%2A> の参照を取得して、さまざまなを取得するプロパティは、 <xref:System.Windows.FrameworkContentElement> 親からのプロパティ値です。 テンプレートで、 <xref:System.Windows.FrameworkContentElement.Parent%2A> テンプレートの最終的になる `null`します。 この点を通過し、テンプレートが実際に適用されている論理ツリーに拡張を使用 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>します。  
  
   
  
## 例  
 次の例の確認を表示するかどうか、 <xref:System.Windows.FrameworkContentElement.Parent%2A> の <xref:System.Windows.Documents.TextPointer> は、特定の型。  
  
 [!code-csharp[TextPointer\_snippets\#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer\_snippets\#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">使用予定のフォーカスの変更を特定する必要があります方向です。</param>
        <summary>指定したフォーカスの移動方向をこの要素に相対的なフォーカスを受け取るが、実際には、フォーカスを移動できない次の要素を決定します。 このメソッドは、封印され、オーバーライドすることはできません。</summary>
        <returns>焦点を当てている次の要素は、フォーカスが実際に走査された場合に移動します。 返される <see langword="null" /> 、指定した方向にこの要素に相対的なフォーカスを移動できない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> 実際には、フォーカスを移動するが関連の方法です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">次の手順のいずれかを指定した、 <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, 、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, 、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, 、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />です。 次の手順はの無効 <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> \(の法律が <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />\)。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">指定された名前とオブジェクトのマッピングに使用する名前です。</param>
        <param name="scopedElement">マッピングを表すオブジェクト。</param>
        <summary>アクセスを簡略化するアクセサーを提供、 <see cref="T:System.Windows.NameScope" /> の登録方法です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出すのための便利なメソッドは、 <xref:System.Windows.NameScope.RegisterName%2A>です。 実装からなものが見つかるまで、連続する親要素は確認 <xref:System.Windows.NameScope> 実装を実装する要素を検索して見つかった <xref:System.Windows.Markup.INameScope>します。 名前のスコープの詳細については、次を参照してください。 [WPF XAML 名前スコープ](http://msdn.microsoft.com/ja-jp/52bbf4f2-15fc-40d4-837b-bb4c21ead7d4)します。  
  
 呼び出す <xref:System.Windows.FrameworkContentElement.RegisterName%2A> はコードで作成されたときに、アプリケーションのアニメーションのストーリー ボードを正しくフックするために必要です。 これは、ストーリー ボードのプロパティのキーのいずれかのため <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, 、ターゲット要素への参照を実行することではなく実行時の名前の参照を使用します。 これは、その要素が、コードから参照渡しでアクセス可能な場合でも当てはまります。 ストーリー ボードのターゲットの名前を登録する必要がある理由の詳細については、次を参照してください。 [ストーリー ボードの概要](http://msdn.microsoft.com/ja-jp/1a698c3c-30f1-4b30-ae56-57e8a39811bd)します。 コンテンツの要素のアニメーションは、コントロールのアニメーションよりもまれ、 [ストーリー ボードの概要](http://msdn.microsoft.com/ja-jp/1a698c3c-30f1-4b30-ae56-57e8a39811bd) コントロールのシナリオに重点を置いています。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">削除する要素。</param>
        <summary>この要素の論理ツリーから、指定した要素を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 子コレクション サポートを追加するときに、シナリオを派生するクラスを主に適しています。  
  
 ほとんど <xref:System.Windows.FrameworkContentElement> 派生クラスを含むという関係する専用のコレクションを公開する \(たとえば、 <xref:System.Windows.Documents.Span.Inlines%2A> で、 <xref:System.Windows.Documents.Span> クラスです。 <xref:System.Windows.Documents.Section.Blocks%2A> で、 <xref:System.Windows.Documents.Section> クラス\)。 通常、このようなクラスから派生すると、論理ツリーを直接操作する必要を回避できます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または現在のローカルに定義されたリソース ディクショナリを設定します。</summary>
        <value>現在のローカルに定義されたリソース。 これは、キーがディクショナリ内のリソースをアクセスする場所のリソースのディクショナリです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 リソース ディクショナリに完全にまたは部分的に定義できる [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] は、通常、プロパティ要素として作成し、個々 のページまたはアプリケーションのルート要素には、通常です。 このレベルでリソース ディクショナリを配置すると、ページ内の個々 の子要素 \(またはアプリケーションの場合は、任意のページ\) を見つけやすいになります。 ほとんどのアプリケーション シナリオのことをお勧めのスタイルをリソース ディクショナリ内のオブジェクト要素として定義するようにスタイル リソース全体が自己完結できるように、外部のリソースとして定義することも \(この方法は、分担デザイナーと開発者の責任を編集することが必要な物理ファイルを分割することにより、役立ちます\)。  
  
 このプロパティには、リソース ディクショナリのみがその要素内で直接宣言を返すことに注意してください。 これは、実際のリソース ルックアップ プロセスの子要素がアクセスできる場所の検索の方向を再帰的に、それぞれの親要素で定義されているリソースとは異なるです。  
  
 リソースは、コレクション内からコードで参照することもできますでリソースが作成されたことに注意してください [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] は間違いなくアクセスできないようにするまで後 <xref:System.Windows.FrameworkContentElement.Loaded> 辞書を宣言した要素を発生させます。 実際には、リソースは、非同期的に解析され、でも、 <xref:System.Windows.FrameworkContentElement.Loaded> イベントが参照できるように保証、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] リソースを定義します。 この理由からアクセスすることは一般的にのみ [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] またはその他の実行時のコードの一部としてリソースを定義 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] スタイルや属性の値をリソース拡張機能の参照などの手法です。 コードによって、リソースにアクセスするときに本質的と等価であるから作成された参照に [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 基になる <xref:System.Windows.ResourceDictionary> を追加、削除、またはコードを使用してから、コレクション内のリソースを照会するに必要なメソッドをサポートしています。<xref:System.Windows.FrameworkContentElement.Resources%2A> プロパティは、新しいまたは異なる要素のリソースのコレクションを完全に置き換えるというシナリオをサポートするために設定可能な <xref:System.Windows.ResourceDictionary>です。  
  
 注意して、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] に示す構文の要素を含まない、 <xref:System.Windows.ResourceDictionary>です。 これは、暗黙の型のコレクション構文の例コレクション要素を表すタグを省略することができます。 代わりに、コレクションにアイテムとして追加する要素を指定します。 暗黙の型のコレクションの詳細については、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], を参照してください [XAML 構文の詳細](http://msdn.microsoft.com/ja-jp/67cce290-ca26-4c41-a797-b68aabc45479)します。 1 つのケースで、 <xref:System.Windows.ResourceDictionary> 要素がマージされたディクショナリを導入する場合ではありません通常その子要素としては、明示的に指定されたまま <xref:System.Windows.ResourceDictionary>します。 詳細については、「 [リソース ディクショナリのトピックとマージ](http://msdn.microsoft.com/ja-jp/d159531f-05d4-49fd-b951-c332de51e5bc)します。  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## XAML プロパティ要素の使用  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## XAML 値  
 *oneOrMoreResourceElements*  
 1 つまたは複数のオブジェクト要素それぞれ、リソースを定義します。 各内にある各リソースのプロパティ要素 <xref:System.Windows.ResourceDictionary> の一意の値が必要、 [x:Key Attribute](http://msdn.microsoft.com/ja-jp/1985cd45-f197-42d5-b75e-886add64b248), から値を取得するときに一意のキーとして使用できる、 <xref:System.Windows.ResourceDictionary>です。  
  
   
  
## 例  
 次の例では確立、 <xref:System.Windows.FrameworkContentElement.Resources%2A> コレクションに、 <xref:System.Windows.Documents.FlowDocument> ルート要素です。<xref:System.Windows.Documents.FlowDocument> 一般的な選択肢は、いくつかのいずれかであるため <xref:System.Windows.FrameworkContentElement> ページのルート、またはこのようなアプリケーションと同様より高いレベルでは、ルート要素では、およびリソースとして意味のあるクラスが一般的に格納します。  
  
 [!code-xml[ContentElementsSmorgasbord\#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">バインドされたプロパティを識別します。</param>
        <param name="path">ソース プロパティ名またはバインドに使用するプロパティへのパス。</param>
        <summary>データ ソースへのパスの修飾として指定したソース プロパティ名に基づく、この要素には、バインディングをアタッチします。</summary>
        <returns>バインドの条件を記録します。 この戻り値は、エラーをチェックするために役立ちます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出すのための便利なメソッドは、 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, 、として現在のインスタンスを渡して、 <xref:System.Windows.DependencyObject>, 、新たに作成および <xref:System.Windows.Data.Binding> に基づいて、指定した `path` パラメーター。 この署名は、単純な既定のバインディングを確立している場合は便利です。 既定以外の条件へのバインディング プロパティを指定するか、使用する必要がある場合、 <xref:System.Windows.Data.MultiBinding> または <xref:System.Windows.Data.PriorityBinding>,、使用する必要があります、 <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> 署名します。  
  
   
  
## 例  
 次の例は、上のバインディングを設定、 <xref:System.Windows.Documents.Paragraph> としては、そのオブジェクトを確立する、新しいカスタム データ オブジェクトを作成することで、要素 <xref:System.Windows.FrameworkContentElement.DataContext%2A>, 、およびその中のプロパティにバインド パスを設定します。  
  
 [!code-csharp[ContentElementsSmorgasbord\#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord\#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">バインドされたプロパティを識別します。</param>
        <param name="binding">データ バインディングを表します。</param>
        <summary>指定したバインディング オブジェクトに基づいて、この要素にバインドをアタッチします。</summary>
        <returns>バインドの条件を記録します。 この戻り値は、エラーをチェックするために役立ちます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出すのための便利なメソッドは、 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, 、として現在のインスタンスを渡して、 <xref:System.Windows.DependencyObject>です。  
  
   
  
## 例  
 次の例は、上のバインディングを設定、 <xref:System.Windows.Documents.Paragraph> 要素を新しいを作成する <xref:System.Windows.Data.Binding> 新たに構築するソースを設定して `DateTime` オブジェクトです。  
  
 [!code-csharp[ContentElementsSmorgasbord\#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord\#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">リソースのバインド先となるプロパティです。</param>
        <param name="name">リソースの名前。</param>
        <summary>指定した名前のリソースを検索しへのリソース参照を指定したプロパティを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 リソースの参照を使用すると同様、 [DynamicResource マークアップ拡張機能](http://msdn.microsoft.com/ja-jp/7324f243-03af-4c2b-b0db-26ac6cdfcbe4) マークアップにします。 リソース参照では、実行時の遅延単位で指定したプロパティの値を提供する内部式を作成します。 式は、リソース ディクショナリは、内部イベントを通じて変更後の値を示す場合、または現在の要素が親を再指定されるたびに再評価されます \(親の変更は、ディクショナリの検索パスを変更、\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスでの内容をシリアル化する必要かどうかを返す、 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> このクラスのインスタンスのプロパティです。</summary>
        <returns>
          <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.FrameworkContentElement.Resources" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるには `true` 、ローカルの少なくとも 1 つのキーを持つリソースがある限り、 <xref:System.Windows.FrameworkContentElement.Resources%2A>です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスでの内容をシリアル化する必要かどうかを返す、 <see cref="P:System.Windows.FrameworkContentElement.Style" /> このクラスのインスタンスのプロパティです。</summary>
        <returns>
          <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.FrameworkContentElement.Style" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるには `true` 場合、 <xref:System.Windows.Style> ローカルに設定します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の変更のバインディングに参加しているデータ ソース、関連付けられていると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベント サーフェス、 <xref:System.Windows.Data.Binding.SourceUpdated> いずれかが発生するイベントを <xref:System.Windows.Data.Binding> この要素に関連付けられています。  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## XAML 属性の使用方法  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が使用するスタイルを取得または設定します。</summary>
        <value>要素に適用される既定以外のスタイル \(存在する場合\)。 それ以外の場合は <see langword="null" />。 既定で構築された <see cref="T:System.Windows.FrameworkContentElement" /> の既定値は <see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在のスタイルは、既定のスタイル リソースによってページまたはアプリケーション レベル \(暗黙的なスタイル\)、一般にその型のオブジェクトに適用するスタイルとテーマからによって提供される多くの場合。 このプロパティは既定の設定したり返したり \(テーマ\) スタイルが、暗黙的なスタイルまたは明示的なスタイルを返します。 暗黙的または明示的なスタイルの場合、スタイルをリソースとしてアクセスまたはローカルに定義されているかどうかは関係ありません。  
  
 スタイルの設定の制限があります。 全体をリセットする <xref:System.Windows.FrameworkContentElement.Style%2A> プロパティを新しい <xref:System.Windows.Style> いつでもレイアウトの再構成を強制します。 ただし、そのスタイルが使用中で読み込まれた要素で配置されるとすぐとして、 <xref:System.Windows.Style> 見なす必要がありますシールします。 使用中のスタイルの個々 のプロパティを変更しようとしています \(などのコレクション内のすべて <xref:System.Windows.Style.Setters%2A>\) がスローされる例外が発生します。 マークアップで定義されているスタイルは、\(リソース\) のリソース ディクショナリから読み込まれるか \(インライン スタイル\) に含まれるページが読み込まれるとすぐに、使用中であると見なされます。  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> 特殊な優先順位を持つ依存関係プロパティです。 ローカルで設定スタイルが一般に、プロパティ システムで最高の優先順位で動作します。 場合、 <xref:System.Windows.FrameworkContentElement.Style%2A> プロパティ システムがその型を指定する定義済みのリソースとしての暗黙的なスタイルのチェックの読み込み中にこの時点では、null です。 この手順の後にスタイルがまだ null し、スタイルは、既定の \(テーマ\) スタイルから取得します、に既定のスタイルが返されない場合、 <xref:System.Windows.FrameworkContentElement.Style%2A> プロパティの値。 参照してください [依存関係プロパティの値の優先順位](http://msdn.microsoft.com/ja-jp/1fbada8e-4867-4ed1-8d97-62c07dad7ebc)します。  
  
<a name="xamlAttributeUsage_Style"></a>   
## XAML 属性の使用方法  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## XAML 値  
 *resourceExtension*  
 次のいずれか: またはです。 参照してください [XAML リソース](http://msdn.microsoft.com/ja-jp/91580b89-a0a8-4889-aecb-fddf8e63175f)します。  
  
 *styleResourceKey*  
 要求されているスタイルを識別するキー。 このキーは既存のリソースを <xref:System.Windows.ResourceDictionary>です。  
  
> [!NOTE]
>  プロパティ要素構文は、技術的に可能ですが、推奨されません。 参照してください [インライン スタイルおよびテンプレート](http://msdn.microsoft.com/ja-jp/69a1a3f9-acb5-4e2c-9c43-2e376c055ac4)します。  使用してバインド参照または <xref:System.Windows.Data.Binding> も可能であればが一般的ではありません。  
  
<a name="dependencyPropertyInfo_Style"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## 例  
 次の例では確立、 <xref:System.Windows.FrameworkContentElement.Resources%2A> コレクションに、 <xref:System.Windows.Documents.FlowDocument> ルート要素として特定のスタイルをリソースとして参照し、 <xref:System.Windows.Documents.Paragraph>です。  
  
 [!code-xml[ContentElementsSmorgasbord\#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.Style" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">要求されたアンビエント プロパティの名前。</param>
        <summary>このメンバーの説明については、<see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> メソッドのトピックを参照してください。</summary>
        <returns>
          <see langword="true" /> 場合 <paramref name="propertyName" /> がそれ以外の場合、入力 <see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Windows.FrameworkContentElement> のインスタンスが <xref:System.Windows.Markup.IQueryAmbient> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはこの要素に関するカスタム情報を格納するために使用する任意のオブジェクト値を設定します。</summary>
        <value>任意の値。 このプロパティに既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは他のタグのプロパティに似ています [!INCLUDE[TLA#tla_ms](~/includes/tlasharptla-ms-md.md)] などのプログラミング モデル [!INCLUDE[TLA#tla_vba](~/includes/tlasharptla-vba-md.md)] または [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)]です。 アプリケーション開発者はサブクラス化を強制することがなく任意の要素に関する基本的なカスタム情報を格納する既存の場所を提供するものでは。  
  
<a name="xamlValues_Tag"></a>   
## XAML 値  
 プロパティ要素の使用を設定するために使用する必要はこのプロパティはオブジェクトを受け取るため、 <xref:System.Windows.FrameworkContentElement.Tag%2A> プロパティに [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 文字列などの既知と組み込みの型コンバーターを使用したオブジェクト以外のすべてにします。 この方法で使用されるオブジェクトが通常含まれていません標準 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 名前空間やしたがってを必要と外部名前空間を名前空間のマッピングとして追加される [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 要素。  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.Tag" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素のバインドに関連する対象プロパティが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベント サーフェス、 <xref:System.Windows.Data.Binding.TargetUpdated> いずれかが発生するイベントを <xref:System.Windows.Data.Binding> この要素に関連付けられています。 これは通常、対象のバインドが双方向のバインドであること、およびバインドされた依存関係プロパティに前のプロパティ値の検証またはプロパティをサポートするキャッシュのスキームあたりの無効化が確認されたことに意味します。  
  
 このイベントのイベントの引数が変更されたプロパティにバインドされているどのに通知されます。  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## XAML 属性の使用方法  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の親テンプレートへの参照を取得します。 このプロパティは、要素がテンプレートによって作成されていない場合は無効です。</summary>
        <value>この要素が作成される原因となった <see cref="T:System.Windows.FrameworkTemplate" /> <see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> が属する要素。 多くの場合、この値は <see langword="null" /> です。「解説」をご覧ください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 テンプレートは、実際には共有オブジェクト、テンプレートの内容が 1 回だけ作成される場所です。 そのため、テンプレートから付属している要素へのオブジェクト参照を取得する場合は、見かけ上の論理ツリーは、ページのルートには到達できません表示可能性があります。 このようなテンプレートへの参照をページの論理ツリーを接続するために取得する必要があります、 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 値し、必要に応じて、その要素ツリーのナビゲーションに続行します。  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 一般に `null` 共通オブジェクト用の一般的な手段を使用してアプリケーションのページからのオブジェクト参照を入手した場合、その要素おそらく作成されていない場合、テンプレートからあるためです。 あるケース <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> できない可能性があります `null` ヒット テスト イベントの元のテンプレートの要素から返された列挙子は、使用したりする、特定の低レベル入力イベントの処理などの操作が含まれます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定でこの要素に対して表示されるツールチップ オブジェクト、 ユーザー インターフェイス (UI)です。</summary>
        <value>ツールヒント オブジェクト。 なぜこのパラメーターがない厳密に型指定の詳細については、以下の「解説」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの値が型の場合 <xref:System.Windows.Controls.ToolTip>, で使用されるツール ヒントをそれが、 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]です。  値は、その他の種類のかどうかは、その値として使用されます、 *コンテンツ* の <xref:System.Windows.Controls.ToolTip> 提供されるシステムによって \(作成\) します。 詳細については、「<xref:System.Windows.Controls.ToolTipService>」を参照してください。 サービス クラスは、ツール ヒントをさらにカスタマイズするために使用される添付プロパティを提供します。  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## XAML 属性の使用方法  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## XAML プロパティ要素の使用  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## XAML 値  
 *toolTipContent*  
 表示テキストとなる文字列、 <xref:System.Windows.FrameworkContentElement.ToolTip%2A>です。  
  
 *方法*  
 コンテンツとして使用される、オブジェクト要素形式で提供される一部のオブジェクト、 <xref:System.Windows.FrameworkContentElement> です。 通常、 <xref:System.Windows.FrameworkElement> またはその他の要素のレイアウト複合を作成する、 <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, 、最終的に、合成のテキスト コンテンツを格納します。 この使用方法で、 <xref:System.Windows.Controls.ToolTip> 要素が作成され、解析されたから暗黙的に [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], 、および *方法* として content が設定されているその <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName> プロパティです。  
  
 \<`ToolTip` ...\/\>  
 「<xref:System.Windows.Controls.ToolTip>」を参照してください。  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例の値の設定、 <xref:System.Windows.FrameworkElement.ToolTip%2A> プロパティ文字列を直接します。  
  
 [!code-csharp[TableSnippets2\#\_Table\_RowGroups\_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2\#\_Table\_RowGroups\_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のツールヒントが閉じる直前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ツールヒントが閉じないように、イベントのハンドラー必要があります、処理済みとしてマークします。  
  
 このイベントがすることはできません、 <xref:System.Windows.EventTrigger> スタイルでします。 これは、このイベントの識別子のフィールドは、イベントの追加と削除メソッドを公開しないサービスの実装を再使用するためです。  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別、 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2)します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントが登録されているときに、イベント識別子のオブジェクトは作成されます \(表示 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>\) クラスのハンドラーを追加するために使用して \(を参照してください <xref:System.Windows.EventManager.RegisterClassHandler%2A>\)。 識別子のオブジェクトには、識別名、所有者の種類、ハンドラーの種類、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のツールヒントが開いたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ツール ヒントを手動で開く、処理済みとして、イベントのハンドラーに関連するイベントをマークする必要があります。 それ以外の場合の値、 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> プロパティが自動的にコンテキスト メニューを開き、使用されます。 イベントを処理済みのマークを付け、既定のアクションを効果的に取り消しの値にリセットすることにより、 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> プロパティ、開き、新しい <xref:System.Windows.Controls.ContextMenu>します。 場合はこのイベントを発生しませんに注意してください <xref:System.Windows.FrameworkContentElement.ToolTip%2A> null 参照は、それ以外の場合、または設定解除します。  
  
 このイベントがすることはできません、 <xref:System.Windows.EventTrigger> スタイルでします。 これは、このイベントの識別子のフィールドは、イベントの追加と削除メソッドを公開しないサービスの実装を再使用するためです。  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別、 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2)します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントが登録されているときに、イベント識別子のオブジェクトは作成されます \(表示 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>\) クラスのハンドラーを追加するために使用して \(を参照してください <xref:System.Windows.EventManager.RegisterClassHandler%2A>\)。 識別子のオブジェクトには、識別名、所有者の種類、ハンドラーの種類、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">検索するリソースのキー識別子。</param>
        <summary>指定されたキーを使用してリソースを検索し、見つかった場合はそのリソースを返します。</summary>
        <returns>見つかったリソース。 リソースが見つからなかった場合は、<see langword="null" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ツリーになるのと同じ方法で、論理ツリーを使用して親ツリーを検索する場合は、リソースが呼び出し元の要素で見つからなかった、動的リソース参照は、実行時にキーによって要求された場合は検索します。  
  
 通常、戻り値は返されたリソースの値を設定しようとしていたプロパティの型をキャストするとすぐにします。  
  
 <xref:System.Windows.FrameworkContentElement.FindResource%2A> で指定されたキーを使用して、リソースが見つからない場合、例外をスローする点を除いて、メソッドが同様の動作です。  
  
   
  
## 例  
 次の例では、マークアップで定義されているリソースを検索し、ルーティングされたイベントに応答内の要素の特定のプロパティに適用されます。  
  
 [!code-csharp[ContentElementsSmorgasbord\#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord\#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み込まれた要素の要素ツリーから要素が削除されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 直接ルーティング イベントは、ルートに従っていない、発生した、同じ要素内でのみ処理されます。 ルーティング イベントは、その他のルーティング イベントの動作をサポートして直接: アクセス可能なハンドラーのコレクションをサポートし、として使用できる、 <xref:System.Windows.EventTrigger> スタイルでします。  
  
<a name="routedEventInfo_Unloaded"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別、 <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2)します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントが登録されているときに、イベント識別子のオブジェクトは作成されます \(表示 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>\) クラスのハンドラーを追加するために使用して \(を参照してください <xref:System.Windows.EventManager.RegisterClassHandler%2A>\)。 識別子のオブジェクトには、識別名、所有者の種類、ハンドラーの種類、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">現在のスコープから削除するオブジェクトの名前のペアの名前です。</param>
        <summary>アクセスを簡素化、 <see cref="T:System.Windows.NameScope" /> メソッドの登録を解除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 必要だけ名前の登録を解除する同じ名を持つ別の要素を再登録する場合です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の既定のスタイルを再適用 <see cref="T:System.Windows.FrameworkContentElement" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したストーリー ボードに含まれているアクションのシーケンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した依存関係プロパティのためのバインディングをこの要素に添付します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>