<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>依存関係プロパティのメタデータを報告または適用します。特に、フレームワークに固有のプロパティのシステム特性を追加します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 このクラスから派生 <xref:System.Windows.PropertyMetadata> \(を通じて <xref:System.Windows.UIPropertyMetadata>\)。 ほとんどの WPF フレームワーク レベルのアプリケーションの開発目的に <xref:System.Windows.FrameworkPropertyMetadata> は基本のメタデータの種類ではなく、依存関係プロパティのメタデータに使用される型 <xref:System.Windows.PropertyMetadata> または <xref:System.Windows.UIPropertyMetadata>です。 これは、既存の依存関係プロパティとカスタム依存関係プロパティのほとんどのシナリオの両方に当てはまります。  
  
 これで宣言されたメンバー クラスの追加条項、 <xref:System.Windows.PropertyMetadata> 基本クラスに指定するか、レポートのプロパティの継承、データ バインド、レイアウトなどの WPF フレームワーク レベル プロパティ システム動作をさまざまなブール型プロパティが含まれます。  
  
 作成するためのいくつかのコンス トラクター シグネチャ、 <xref:System.Windows.FrameworkPropertyMetadata> インスタンスを <xref:System.Windows.FrameworkPropertyMetadataOptions> パラメーター。<xref:System.Windows.FrameworkPropertyMetadataOptions> 列挙型、コンス トラクターで初期の動作を指定する場合のみ使用され、後はそれ以外の場合は公開されません <xref:System.Windows.FrameworkPropertyMetadata> を構築します。 構築されたインスタンスを取得またはコンス トラクターの呼び出しで使用する列挙値の名前を共有するさまざまなプロパティから対応する情報を設定できます。  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## XAML テキストの使用方法  
 このクラスは、通常では使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 次の例としてメタデータを取得、依存関係プロパティの特定の所有者に、初期基本 <xref:System.Windows.PropertyMetadata> 型です。 そのメタデータは <xref:System.Windows.FrameworkPropertyMetadata>です。 有効なキャストが返される場合は <xref:System.Windows.FrameworkPropertyMetadata>, 、し、さまざまな <xref:System.Windows.FrameworkPropertyMetadata> プロパティの値が \(非表示\)、シンプルな UI を通して報告されます。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 すべての値をシグネチャ <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> がプロパティの既定値にします。<xref:System.Windows.PropertyMetadata.DefaultValue%2A>`null`, と、さまざまな <xref:System.Windows.FrameworkPropertyMetadata> ブール型プロパティがある `false`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">通常、特定の種類の値として提供される、依存関係プロパティの既定値。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 指定された既定値を持つクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された値の型 `defaultValue` と一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 この不一致は、コンパイル時に検出可能ではないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。 既定値の型、プロパティ型の不一致の結果が実行時エラーのため、プロパティ システムは、実行時まで、プロパティの有効な値を評価しません。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> プロパティ システムに特別な意味があり、依存関係プロパティの既定値として使用することはできません。  
  
   
  
## 例  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定されている <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムを呼び出すハンドラーの実装への参照。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 、指定したクラス <see cref="T:System.Windows.PropertyChangedCallback" /> コールバックします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">通常、特定の種類の値として提供される、依存関係プロパティの既定値。</param>
        <param name="flags">メタデータのオプション フラグ \(を組み合わせた <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値\)。 これらのオプションは、レイアウトやデータ バインドなどのシステムと対話する依存関係プロパティの特性を指定します。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> した既定値とフレームワーク レベルのメタデータのオプションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された値の型 `defaultValue` と一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 この不一致は、コンパイル時に検出可能ではないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。 既定値の型、プロパティ型の不一致の結果が実行時エラーのため、プロパティ システムは、実行時まで、プロパティの有効な値を評価しません。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> プロパティ システムに特別な意味があり、依存関係プロパティの既定値として使用することはできません。  
  
 値にフラグを設定しますとしてマーク、 `flags` パラメーターはブール値を設定 <xref:System.Windows.FrameworkPropertyMetadata> と一致しているプロパティ <xref:System.Windows.FrameworkPropertyMetadataOptions> フラグの名前を `true`します。 メタデータが特定のプロパティのシステム操作に適用されていない限り、その後、メタデータでは、プロパティの値を変更できます。  
  
   
  
## 例  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定されている <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">通常、特定の種類の値として提供される、依存関係プロパティの既定値。</param>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムを呼び出すハンドラーの実装への参照。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスで提供されている既定値と指定された <see cref="T:System.Windows.PropertyChangedCallback" /> コールバックします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された値の型 `defaultValue` と一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 この不一致は、コンパイル時に検出可能ではないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。 既定値の型、プロパティ型の不一致の結果が実行時エラーのため、プロパティ システムは、実行時まで、プロパティの有効な値を評価しません。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> プロパティ システムに特別な意味があり、依存関係プロパティの既定値として使用することはできません。  
  
   
  
## 例  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定されている <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムを呼び出すハンドラーの実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムが呼び出すたびに呼び出されるハンドラーの実装への参照を <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> のこの依存関係プロパティ。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 指定したコールバック クラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この実装を選択し、基本の初期化子の呼び出しを追加、 `coerceValueCallback` ベースのインスタンスのプロパティを設定します。  
  
   
  
## 例  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">通常、特定の種類の値として提供される、依存関係プロパティの既定値。</param>
        <param name="flags">メタデータのオプション フラグ \(を組み合わせた <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値\)。 これらのオプションは、レイアウトやデータ バインドなどのシステムと対話する依存関係プロパティの特性を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムを呼び出すハンドラーの実装への参照。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> は提供されている既定の値とフレームワーク メタデータ オプション、クラスし、指定された <see cref="T:System.Windows.PropertyChangedCallback" /> コールバックします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された値の型 `defaultValue` と一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 この不一致は、コンパイル時に検出可能ではないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。 既定値の型、プロパティ型の不一致の結果が実行時エラーのため、プロパティ システムは、実行時まで、プロパティの有効な値を評価しません。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> プロパティ システムに特別な意味があり、依存関係プロパティの既定値として使用することはできません。  
  
 値にフラグを設定しますとしてマーク、 `flags` パラメーターはブール値を設定 <xref:System.Windows.FrameworkPropertyMetadata> と一致しているプロパティ <xref:System.Windows.FrameworkPropertyMetadataOptions> フラグの名前を `true`します。 メタデータが特定のプロパティのシステム操作に適用されていない限り、引き続きメタデータでは、プロパティの値を変更できます。  
  
   
  
## 例  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定されている <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">通常、特定の種類として提供される、依存関係プロパティの既定値。</param>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムを呼び出すハンドラーの実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムが呼び出すたびに呼び出されるハンドラーの実装への参照を <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> のこの依存関係プロパティ。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスが提供されている既定値および指定したコールバックを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された値の型 `defaultValue` と一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 この不一致は、コンパイル時に検出可能ではないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。 既定値の型、プロパティ型の不一致の結果が実行時エラーのため、プロパティ システムは、実行時まで、プロパティの有効な値を評価しません。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> プロパティ システムに特別な意味があり、依存関係プロパティの既定値として使用することはできません。  
  
   
  
## 例  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定されている <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">通常、特定の種類として提供される、依存関係プロパティの既定値。</param>
        <param name="flags">メタデータのオプション フラグ \(を組み合わせた <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値\)。 これらのオプションは、レイアウトやデータ バインドなどのシステムと対話する依存関係プロパティの特性を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムを呼び出すハンドラーの実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムが呼び出すたびに呼び出されるハンドラーの実装への参照を <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> このプロパティに対してです。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 既定値とフレームワーク メタデータ オプションでは、指定したコールバック クラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された値の型 `defaultValue` と一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 この不一致は、コンパイル時に検出可能ではないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。 既定値の型、プロパティ型の不一致の結果が実行時エラーのため、プロパティ システムは、実行時まで、プロパティの有効な値を評価しません。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> プロパティ システムに特別な意味があり、依存関係プロパティの既定値として使用することはできません。  
  
 値にフラグを設定しますとしてマーク、 `flags` パラメーターはブール値を設定 <xref:System.Windows.FrameworkPropertyMetadata> と一致しているプロパティ <xref:System.Windows.FrameworkPropertyMetadataOptions> フラグの名前を `true`します。 メタデータが特定のプロパティのシステム操作に適用されていない限り、引き続きメタデータでは、プロパティの値を変更できます。  
  
   
  
## 例  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定されている <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">通常、特定の種類として提供される、依存関係プロパティの既定値。</param>
        <param name="flags">メタデータのオプション フラグ \(を組み合わせた <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値\)。 これらのオプションは、レイアウトやデータ バインドなどのシステムと対話する依存関係プロパティの特性を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムを呼び出すハンドラーの実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムが呼び出すたびに呼び出されるハンドラーの実装への参照を <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> この依存関係プロパティにします。</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> 防ぐため、プロパティ システムにこのメタデータが適用されるプロパティをアニメーション化します。 このようなプロパティには、アニメーション化が試行されると、プロパティ システムから送信された、実行時に例外が発生します。<see langword="false" /> プロパティをアニメーション化を許可します。 既定値は、<see langword="false" /> です。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> した既定値およびフレームワークのメタデータのオプション、指定したコールバック、およびブール値をプロパティのアニメーションを防ぐために使用できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された値の型 `defaultValue` と一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 この不一致は、コンパイル時に検出可能ではないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。 既定値の型、プロパティ型の不一致の結果が実行時エラーのため、プロパティ システムは、実行時まで、プロパティの有効な値を評価しません。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> プロパティ システムに特別な意味があり、依存関係プロパティの既定値として使用することはできません。  
  
 `isAnimationProhibited` パラメーターの初期値の設定、 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> プロパティは、イミディ エイト ベースして宣言 <xref:System.Windows.UIPropertyMetadata> クラスです。  
  
 値にフラグを設定しますとしてマーク、 `flags` パラメーターはブール値を設定 <xref:System.Windows.FrameworkPropertyMetadata> と一致しているプロパティ <xref:System.Windows.FrameworkPropertyMetadataOptions> フラグの名前を `true`します。 メタデータが特定のプロパティのシステム操作に適用されていない限り、引き続きメタデータでは、プロパティの値を変更できます。  
  
   
  
## 例  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定されている <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">通常、特定の種類として提供される、依存関係プロパティの既定値。</param>
        <param name="flags">メタデータのオプション フラグ \(を組み合わせた <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値\)。 これらのオプションは、レイアウトやデータ バインドなどのシステムと対話する依存関係プロパティの特性を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効な値が変更されるたびに、プロパティ システムを呼び出すハンドラーの実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムが呼び出すたびに呼び出されるハンドラーの実装への参照を <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> このプロパティに対してです。</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> 防ぐため、プロパティ システムにこのメタデータが適用されるプロパティをアニメーション化します。 このようなプロパティには、アニメーション化が試行されると、プロパティ システムから送信された、実行時に例外が発生します。 既定値は、<see langword="false" /> です。</param>
        <param name="defaultUpdateSourceTrigger">
          <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> がこのプロパティのバインドが適用されるときに使用する、 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 設定 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />します。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 既定値とフレームワークのメタデータを持つクラス オプションを指定したコールバック、ブール値、プロパティと、データ バインディングの更新トリガーの既定値のアニメーションを無効にするために使用できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された値の型 `defaultValue` と一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 この不一致は、コンパイル時に検出可能ではないために、適用されている依存関係プロパティの型とメタデータの既定値の型間で不一致がある場合は、デバッグが困難にできます。 既定値の型、プロパティ型の不一致の結果が実行時エラーのため、プロパティ システムは、実行時まで、プロパティの有効な値を評価しません。  
  
 値 <xref:System.Windows.DependencyProperty.UnsetValue> プロパティ システムに特別な意味があり、依存関係プロパティの既定値として使用することはできません。  
  
 `isAnimationProhibited` パラメーターの初期値の設定、 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> プロパティは、イミディ エイト ベースして宣言 <xref:System.Windows.UIPropertyMetadata> クラスです。  
  
 バインディングのソースの更新動作の詳細については、次を参照してください。 [データ バインドの概要](http://msdn.microsoft.com/ja-jp/c707c95f-7811-401d-956e-2fffd019a211)します。  
  
 値にフラグを設定しますとしてマーク、 `flags` パラメーターはブール値を設定 <xref:System.Windows.FrameworkPropertyMetadata> と一致しているプロパティ <xref:System.Windows.FrameworkPropertyMetadataOptions> フラグの名前を `true`します。 メタデータが特定のプロパティのシステム操作に適用されていない限り、引き続きメタデータでは、プロパティの値を変更できます。  
  
   
  
## 例  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定されている <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。「解説」を参照してください。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティが配置パスに潜在的に影響するかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティが配置パスに影響する可能性がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement> の実装が含まれて <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 要素上に存在するすべての依存関係プロパティに対する有効な値の変更を監視します。 ロジックの一環として、変更する効果的な依存関係プロパティの値し、を使用してメタデータがある <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 設定 `true` がその要素の視覚効果を無効化する遅延の要求を開始 \(への呼び出し <xref:System.Windows.UIElement.InvalidateArrange%2A>\)。 この実装は WPF フレームワーク レベルが既に配置されているため、通常必要はありませんと依存関係プロパティを検索する <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 大幅に交換または WPF フレームワーク レベル レイアウトの動作を変更する場合を除き、します。  
  
 カスタム <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 実装の依存関係プロパティの変更のような動作が存在することもできます、 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> は `true`です。  
  
 派生クラスのプロパティを <xref:System.Windows.PropertyMetadata> 通常は読み取り\/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただしへの呼び出しの一部として、メタデータを使用した後 <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, プロパティ システムはそのメタデータ インスタンスをシール、およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとすると <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## XAML テキストの使用方法  
 このクラスのメンバーは、通常では使用か [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 次の例は、さまざまな依存関係から、既定のメタデータを取得するプロパティ フィールドで、各種の値のクエリを実行 <xref:System.Windows.FrameworkPropertyMetadata> にプロパティを情報を使用して、「メタデータ ブラウザー」を実装するテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティが測定パスに影響する可能性があるかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティが測定パスに影響する可能性がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement> の実装が含まれて <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 要素上に存在するすべての依存関係プロパティに対する有効な値の変更を監視します。 ロジックの一環として、変更する効果的な依存関係プロパティの値し、を使用してメタデータがある <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 設定 `true` がその要素の視覚効果を無効化する遅延の要求を開始します。 この実装は WPF フレームワーク レベルが既に配置されているため、通常必要はありませんと依存関係プロパティを検索する <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 大幅に交換または WPF フレームワーク レベル レイアウトの動作を変更する場合を除き、します。  
  
 カスタム <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 実装の依存関係プロパティの変更のような動作が存在することもできます、 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> は `true`です。  
  
 派生クラスのプロパティを <xref:System.Windows.PropertyMetadata> 通常は読み取り\/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただしへの呼び出しの一部として、メタデータを使用した後 <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, プロパティ システムはそのメタデータ インスタンスをシール、およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとすると <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## XAML テキストの使用方法  
 このクラスのメンバーは、通常では使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 次の例は、さまざまな依存関係から、既定のメタデータを取得するプロパティ フィールドで、各種の値のクエリを実行 <xref:System.Windows.FrameworkPropertyMetadata> にプロパティを情報を使用して、「メタデータ ブラウザー」を実装するテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティがその親要素のレイアウトの配置パスに潜在的に影響するかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する可能性のある依存関係プロパティが特にその親要素の配置パスに影響する可能性がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element. As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> set to `true` will initiate a deferred request to invalidate the visuals for the parent element.  
  
 Generally, you do not need to report changes of a <xref:System.Windows.FrameworkElement> property to a parent element using <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> because the element itself would already have its own <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as **languageKeyword tag is not supported!!!!**  
. That is usually sufficient, because changes in the child element generally initiate a parent arrange when appropriate. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is sometimes used for a <xref:System.Windows.FrameworkContentElement> derived class. In this case, the child element sets a property, but a <xref:System.Windows.FrameworkContentElement> derived class does not control its own rendering. The rendering is handled by a <xref:System.Windows.FrameworkElement> parent element that serves as the content host. For instance, a change to the value of the <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName> attached property by a child element invalidates arrange of the parent, because the position of the child in the parent must be changed. Therefore, the <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName> attached property has metadata where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is **languageKeyword tag is not supported!!!!**  
. Another example is <xref:System.Windows.Controls.Control.Padding%2A>; when this property changes, the parent might change the positioning of the child, depending on available space.  
  
 Because this WPF framework\-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> unless you are substantially replacing or modifying the WPF framework\-level layout behavior.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is **languageKeyword tag is not supported!!!!**  
.  
  
 Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read\-write. This is so they can be adjusted after initialization of the instance. However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable. Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is **languageKeyword tag is not supported!!!!**  
 on this metadata instance will raise an exception.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## XAML Text Usage  
 Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティがその親要素のレイアウトの測定パスに潜在的に影響するかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティが特にその親要素の測定パスに影響する可能性がある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element. As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> set to `true` will initiate a deferred request to invalidate the visuals for the parent element. Because this WPF framework\-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> unless you are substantially replacing or modifying the WPF framework\-level layout behavior.  
  
 Generally, you do not need to report changes of a <xref:System.Windows.FrameworkElement> property to a parent element using <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> because the element itself would already have its own <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> as **languageKeyword tag is not supported!!!!**  
. That is usually sufficient, because changes in the child element generally initiate a parent measure pass when appropriate. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is sometimes used for a <xref:System.Windows.FrameworkContentElement> derived class. In this case, the child element sets a property, but a <xref:System.Windows.FrameworkContentElement> derived class does not control its own rendering. The rendering is handled by a <xref:System.Windows.FrameworkElement> parent element that serves as the content host. For instance, a change to the value of the <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName> property by a child element invalidates measure of the parent, because the relative spacing of paragraphs might change and might increase or decrease the content host size. Therefore, the <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName> property has metadata where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is **languageKeyword tag is not supported!!!!**  
.  
  
 Content host elements also frequently look for changes in dependency properties where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is **languageKeyword tag is not supported!!!!**  
, as part of content host rendering logic. For instance, the <xref:System.Windows.Controls.TextBox> element must respond to certain changes within text that might require that the bounding box of the <xref:System.Windows.Controls.TextBox> itself be changed.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is **languageKeyword tag is not supported!!!!**  
.  
  
 Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read\-write. This is so they can be adjusted after initialization of the instance. However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable. Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is **languageKeyword tag is not supported!!!!**  
 on this metadata instance will raise an exception.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## XAML Text Usage  
 Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティが一般的なレイアウトに何らかの形で影響する \(配置や測定に特に影響を与えないが再描画が必要になる\) 可能性があるかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティがレンダリングに影響を与える場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement> の実装が含まれて <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 要素上に存在するすべての依存関係プロパティに対する有効な値の変更を監視します。 ロジックの一環として、変更する効果的な依存関係プロパティの値し、を使用してメタデータがある <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 設定 `true` がその要素の視覚効果を無効化する遅延の要求を開始します。 この実装は WPF フレームワーク レベルが既に配置されているため、通常必要はありませんと依存関係プロパティを検索する <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 大幅に交換または WPF フレームワーク レベル レイアウトの動作を変更する場合を除き、します。  
  
 カスタム <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 実装の依存関係プロパティの変更のような動作が存在することもできます、 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> は `true`です。  
  
 いずれかのプロパティの派生クラス <xref:System.Windows.PropertyMetadata> 通常は読み取り\/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただしへの呼び出しの一部として、メタデータを使用した後 <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, プロパティ システムはそのメタデータ インスタンスをシール、およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとすると <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## XAML テキストの使用方法  
 このクラスのメンバーは、通常では使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 次の例は、さまざまな依存関係から、既定のメタデータを取得するプロパティ フィールドで、各種の値のクエリを実行 <xref:System.Windows.FrameworkPropertyMetadata> にプロパティを情報を使用して、「メタデータ ブラウザー」を実装するテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロパティが既定で双方向をバインドするかどうかを示す値を取得または設定します。</summary>
        <value>既定でこのメタデータが存在する依存関係プロパティが双方向をバインドする場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 In absence of this property being **languageKeyword tag is not supported!!!!**  
, binding updates are one\-way by default, based on the default behavior of the <xref:System.Windows.Data.Binding> constructors or equivalent [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.  
  
 In existing elements, you will usually find this property set to **languageKeyword tag is not supported!!!!**  
 in metadata for dependency properties that both report state and are modifiable by user action, for example <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=fullName>.  
  
 This property only reports the default binding update characteristics of the dependency property in general. Any binding set to this property on an instance can locally set the <xref:System.Windows.Data.Binding.Mode%2A> property of the binding and change this default.  
  
 Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read\-write. This is so they can be adjusted after initialization of the instance. However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable. Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is **languageKeyword tag is not supported!!!!**  
 on this metadata instance will raise an exception.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## XAML Text Usage  
 Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## 例  
 The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定設定を取得または <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> を使用するにはこのメタデータを含むプロパティのバインドが適用されるときに、 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> に設定 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />します。</summary>
        <value>以外の場合、列挙体の値 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生クラスのプロパティを <xref:System.Windows.PropertyMetadata> 通常は読み取り\/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただしへの呼び出しの一部として、メタデータを使用した後 <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, プロパティ システムはそのメタデータ インスタンスをシール、およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとすると <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## XAML テキストの使用方法  
 このクラスのメンバーは、通常では使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このプロパティが <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; を設定する値はバインディングで要求された場合の既定値になるはずです。</exception>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの値が継承可能かどうかを示す値を取得または設定します。</summary>
        <value>プロパティ値が継承可能な場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティ値の継承の機能である、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] という特定の依存関係プロパティ ローカルで設定できますか、間もなくのルート要素に WPF フレームワーク レベルでプロパティのシステム、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 要素ツリーし、その値もそのプロパティを処理する子要素の論理ツリー内のすべての要素によって継承されます。 既定では、プロパティ値の継承が無効であり、有効にするにはパフォーマンスへの影響です。 詳細については、「 [プロパティ値の継承](http://msdn.microsoft.com/ja-jp/d7c338f9-f2bf-48ed-832c-7be58ac390e4)します。  
  
> [!NOTE]
>  非添付依存関係プロパティに対して動作するプロパティ値の継承が表示されますが、実行時のツリーで特定オブジェクト間の分割を使用して非添付プロパティの継承の動作は未定義です。 常に使用する <xref:System.Windows.DependencyProperty.RegisterAttached%2A> を指定したプロパティを登録する <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> メタデータにします。  
  
 派生クラスのプロパティを <xref:System.Windows.PropertyMetadata> 通常は読み取り\/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただしへの呼び出しの一部として、メタデータを使用した後 <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, プロパティ システムはそのメタデータ インスタンスをシール、およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとすると <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
<a name="xamlTextUsage_Inherits"></a>   
## XAML テキストの使用方法  
 このクラスのメンバーは、通常では使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 次の例は、さまざまな依存関係から、既定のメタデータを取得するプロパティ フィールドで、各種の値のクエリを実行 <xref:System.Windows.FrameworkPropertyMetadata> にプロパティを情報を使用して、「メタデータ ブラウザー」を実装するテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティのデータ バインドがサポートされているかどうかを示す値を取得します。</summary>
        <value>このメタデータが適用される依存関係プロパティでデータ バインドがサポートされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、報告 `false` の 2 つの可能な条件のいずれか: 依存関係プロパティが \(に示される依存関係プロパティの識別子、メタデータではありません\)、読み取り専用であるために、依存関係プロパティへのいずれかのデータ バインディングが許可されていません、別のメタデータ プロパティの値は <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, に設定されている `true` このメタデータにします。 呼び出し元は、両方を確認する必要はありませんのために、しやすくするためにこのプロパティを公開 <xref:System.Windows.DependencyProperty.ReadOnly%2A> と <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>です。  
  
 それ以外の場合の読み取り\/書き込みプロパティは、データ バインディングをサポートしていないことを指定するメタデータを作成しようとする場合は、フラグを指定します。 <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> \(とわずかな名前付け規約の違いに注意してください <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>\)。  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## XAML テキストの使用方法  
 このクラスのメンバーは、通常では使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 次の例は、さまざまな依存関係から、既定のメタデータを取得するプロパティ フィールドで、各種の値のクエリを実行 <xref:System.Windows.FrameworkPropertyMetadata> にプロパティを情報を使用して、「メタデータ ブラウザー」を実装するテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティがデータ バインディングをサポートしているかどうかを示す値を取得または設定します。</summary>
        <value>プロパティがデータ バインドをサポートしない場合は<see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメタデータ プロパティに設定されているメモ `true` 専用のプロパティを読み取り\/書き込みプロパティであるにもかかわらず、データ バインディングをサポートする必要があります。 期待されるは、依存関係プロパティが宣言されているほとんどの場合、データ バインドが必要である、データ バインドが依存関係プロパティが便利な場合の主なシナリオのいずれかであるためです。 異なり <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, 、これだけで変わらないので、特定のバインドでは変更できます。 後で、既定値です。 このプロパティを設定 `true` 依存関係プロパティのメタデータで、メタデータの式によっては、その値をその依存関係プロパティに適用することからすべてのバインドは無効にします。  
  
 読み取り専用の依存関係プロパティは \(変更された値を適用可能な set アクセス操作子がない\) ため、データをバインディングをサポートしていませんが、レポートではまだ `false` の <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>です。 これは、プロパティに対応するため、 <xref:System.Windows.FrameworkPropertyMetadataOptions> メタデータが実際に確立する方法、常に報告、プロパティの名前を付けることを示唆する最後の結果の動作ではなくと同等の値を報告します。 依存関係プロパティがデータ バインドを許可するかどうかを確認するのには通常をチェックする <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 代わりにします。<xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 両方をチェックするための便利な機能は、 <xref:System.Windows.DependencyProperty.ReadOnly%2A> と <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> 単一の操作として、予期される結果を生成します。  
  
 派生クラスのプロパティを <xref:System.Windows.PropertyMetadata> 通常は読み取り\/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただしへの呼び出しの一部として、メタデータを使用した後 <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, プロパティ システムはそのメタデータ インスタンスをシール、およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとすると <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## XAML テキストの使用方法  
 このクラスのメンバーは、通常では使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ジャーナル実装の一部としてアプリケーションが格納できる、または格納する必要のあるジャーナル情報がこのプロパティに格納されているかどうか示す値を取得または設定します。</summary>
        <value>このメタデータが適用される依存関係プロパティに対してジャーナルを実行する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生クラスのプロパティを <xref:System.Windows.PropertyMetadata> 通常は読み取り\/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただしへの呼び出しの一部として、メタデータを使用した後 <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, プロパティ システムはそのメタデータ インスタンスをシール、およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとすると <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
<a name="xamlTextUsage_Journal"></a>   
## XAML テキストの使用方法  
 このクラスのメンバーは、通常では使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">マージする基本のメタデータ。</param>
        <param name="dp">このメタデータが適用されている依存関係プロパティ。</param>
        <summary>ソース メタデータと基本メタデータのマージを有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、メタデータがオーバーライドされるときに内部的に使用されます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Classes that derive from <see cref="T:System.Windows.PropertyMetadata" /> (or this class particularly) should override this method to account for any metadata properties they have added in their implementations. For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.  
  
 Always call the base implementation prior to your own implementation, because the base implementation takes care of merging all the properties already defined on previous types in the hierarchy.  
  
 The behavior added by the <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation in <see cref="T:System.Windows.FrameworkPropertyMetadata" /> is that specific WPF framework-level properties in the metadata such as <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> are combined in a bitwise or operation.  
  
 The <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> behavior also implements the behavior when you override the property metadata on an existing dependency property by calling <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., using override metadata that is <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">メタデータが適用されている依存関係プロパティ。</param>
        <param name="targetType">型固有のメタデータは、この場合は、このメタデータに関連付けられている型。 これが既定のメタデータである場合は、この値を指定できます <see langword="null" />します。</param>
        <summary>このメタデータがメタデータはシールされた旨を示すプロパティに適用されると呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 データ構造の任意の可変性、 <xref:System.Windows.FrameworkPropertyMetadata> インスタンスとマークされるべき変更不可としてこのメソッドが呼び出されるとします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implementation of this method does nothing beyond calling the base implementation.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の論理ツリー内の特定のコンテンツ境界にまたがってプロパティ値の継承を評価するかどうかを示す値を取得または設定します。</summary>
        <value>プロパティ値の継承が特定のコンテンツ境界をまたがる場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメタデータは、特別な親要素と子要素の境界にまたがって頻度の低い適用プロパティ値の継承の動作の変更を報告します。 このような境界の標準的な例の内容は、 <xref:System.Windows.Controls.Frame>, 、どこで、 <xref:System.Windows.Controls.Frame> の存在とは無関係に、コンテンツを再読み込み取得可能性があります、 <xref:System.Windows.Controls.Frame>です。 目的のプロパティのシステムの動作は、プロパティ値の継承がの内容に、 <xref:System.Windows.Controls.Frame>, 、次の内容の要素をフレームをホストしているアプリケーションが所有または管理していない可能性があるためです。 使用してメタデータを指定する <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> に設定 `true`, を指定しても、 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> として `true`, 、プロパティが継承するでもにメタデータを適用すると、 <xref:System.Windows.Controls.Frame> 境界またはのような境界です。  
  
 派生クラスのプロパティを <xref:System.Windows.PropertyMetadata> 通常は読み取り\/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただしへの呼び出しの一部として、メタデータを使用した後 <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, プロパティ システムはそのメタデータ インスタンスをシール、およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとすると <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## XAML テキストの使用方法  
 このクラスのメンバーは、通常では使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティのサブプロパティが格納オブジェクトのレンダリングに影響しないかどうかを示す値を取得または設定します。</summary>
        <value>サブプロパティ値の変更がレンダリングに影響しない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメタデータ オプションは、関連する型が、独自のプロパティの値を参照型の場合に依存関係プロパティです。 通常、システムのレイアウト ロジックは、サブプロパティを含む任意の依存関係プロパティに可能性のあるレイアウトは影響は、別の描画パスの変更のすべてのサブ プロパティをチェックすることが実際に実行されているよりも時間がかかるためのことを想定することです。 このオプションを設定 `true` は WPF フレームワーク レベルのレイアウト システムの実装のパフォーマンスを最適化するために役立ちます。  
  
 派生クラスのプロパティを <xref:System.Windows.PropertyMetadata> 通常は読み取り\/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただしへの呼び出しの一部として、メタデータを使用したら <xref:System.Windows.DependencyProperty.Register%2A>, 、<xref:System.Windows.DependencyProperty.AddOwner%2A>, 、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, プロパティ システムはそのメタデータ インスタンスをシール、およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとすると <xref:System.Windows.PropertyMetadata.IsSealed%2A> は `true` このメタデータをインスタンスで例外が発生します。  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## XAML テキストの使用方法  
 このクラスのメンバーは、通常では使用されない [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータは依存関係プロパティの操作に既に適用されているので、メタデータはシールされ、かつメタデータのプロパティは設定できません。</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
  </Members>
</Type>