<Type Name="Freezable" FullName="System.Windows.Freezable">
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>変更可能な状態と読み取り専用 \(固定\) の状態を持つオブジェクトを定義します。<see cref="T:System.Windows.Freezable" /> から派生するクラスは、詳細な変更通知を提供し、変更不可にすることが可能で、自身のクローンを作成できます。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Freezable> クラスを提供できる特別な機能が変更またはコピーにかかるコストはオブジェクトを使用する場合、アプリケーションのパフォーマンスを向上します。 例として <xref:System.Windows.Freezable> オブジェクトには、次が含まれます。  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## Freezable から派生します。  
 派生したクラス <xref:System.Windows.Freezable> 、次の機能を取得します。  
  
-   特殊な状態。 読み取り専用 \(固定\) の状態および書き込み可能な状態です。  
  
-   スレッドの安全性: 固定された <xref:System.Windows.Freezable> オブジェクトは、スレッド間で共有できます。  
  
-   変更通知の詳細: その他とは異なり <xref:System.Windows.DependencyObject> オブジェクト、 <xref:System.Windows.Freezable> サブ プロパティの値が変わる場合、オブジェクトは変更通知を提供します。  
  
-   簡単な複製: Freezable クラスが既にディープ クローンを生成するいくつかのメソッドを実装します。  
  
 使用して、独自に作成について <xref:System.Windows.Freezable> オブジェクトを参照してください [Freezable オブジェクトの概要](http://msdn.microsoft.com/ja-jp/89c71692-4f43-4057-b611-67c6a8a863a2)します。  
  
 ]]></format>
    </remarks>
    <threadsafe>すべてのパブリック <see langword="static" /> この型のメンバーは、スレッド セーフであります。 インスタンス メンバーの場合は、スレッド セーフであるとは限りません。  
  
 ときに、 <see cref="P:System.Windows.Freezable.IsFrozen" /> プロパティは、 <see langword="false" />, 、 <see cref="T:System.Windows.Freezable" /> オブジェクトが作成されたスレッドからのみアクセスできます。 別のスレッドがスローされますからアクセスしようとすると、 <see cref="T:System.InvalidOperationException" />です。<see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> と <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> メソッドは、正しいスレッドにマーシャ リングのサポートを提供します。  
  
 ときに、 <see cref="P:System.Windows.Freezable.IsFrozen" /> プロパティは、 <see langword="true" />, 、<see cref="T:System.Windows.Freezable" /> オブジェクトは、フリー スレッドです。  詳細については、次を参照してください。 [Freezable オブジェクトの概要](http://msdn.microsoft.com/ja-jp/89c71692-4f43-4057-b611-67c6a8a863a2)します。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Windows.Freezable" /> クラスを派生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、抽象クラスの保護されたアクセシビリティのコンス トラクターです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトを変更不可能にできるかどうかを示す値を取得します。</summary>
        <value>現在のオブジェクトを変更不可能にできる場合、または既に変更不可能になっている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This method implementation uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method with <paramref name="isChecking" /> set to <see langword="true" /> to determine whether a <see cref="T:System.Windows.Freezable" /> can be made unmodifiable. To modify the way this property behaves in a derived class, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときに、 <see cref="T:System.Windows.Freezable" /> またはが含まれているオブジェクトが変更されています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 追加または現在のオブジェクトが変更できない場合は、イベント ハンドラーを削除しようとすると \(ときに、 <xref:System.Windows.Freezable.IsFrozen%2A> プロパティは `true`\)、例外がスローされます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Freezable" /> の変更可能な複製を作成し、オブジェクトの値の詳細コピーを作成します。 このメソッドは、オブジェクトの依存関係プロパティをコピーするときに式をコピーしますが \(コピーされた式は解決されなくなる場合があります\)、アニメーションやその現在の値はコピーしません。</summary>
        <returns>現在のオブジェクトの変更可能な複製。 複製されたオブジェクトの <see cref="P:System.Windows.Freezable.IsFrozen" /> プロパティは、ソースの <see cref="P:System.Windows.Freezable.IsFrozen" /> プロパティが <see langword="true." /> である場合でも、<see langword="false" /> になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects \(the methods also clone <xref:System.Windows.Freezable> objects that are not frozen\). The clone is effectively a deep copy of the current object.  
  
 The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.  
  
|Action|Clone method behavior|CloneCurrentValue method behavior|  
|------------|---------------------------|---------------------------------------|  
|Copying a dependency property that has an expression|The expression is copied, but might no longer resolve. For more information, see [Freezable Objects Overview](http://msdn.microsoft.com/ja-jp/89c71692-4f43-4057-b611-67c6a8a863a2).|The current value of the expression is copied, but not the expression itself.|  
|Copying an animated dependency property|The property's base \(non\-animated\) value is copied. Animations are not copied.|The property's current animated value is copied. Animations are not copied.|  
  
 Note that unset properties are not copied. If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.  
  
## Move a Freezable Between Threads  
 This method can be useful for moving a <xref:System.Windows.Freezable> between threads. First, make the <xref:System.Windows.Freezable> unmodifiable by calling its <xref:System.Windows.Freezable.Freeze%2A> method. Now another thread can access the <xref:System.Windows.Freezable> and make a local <xref:System.Windows.Freezable.Clone%2A> that it can access.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This method uses <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> to produce the clone. To modify the behavior of this method in a derived class, override the <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> method.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">複製する対象のオブジェクト。</param>
        <summary>基本 \(アニメーション化されていない\) プロパティ値を使用して、インスタンスを、指定した <see cref="T:System.Windows.Freezable" /> の複製 \(詳細コピー\) にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is called by the <xref:System.Windows.Freezable.Clone%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method. To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.Clone%2A> instead of calling this method directly.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  
  
-   Your derived class has data that is not exposed via dependency properties.  
  
-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  
  
 It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties, including internal expressions.  
  
 If the object has data-bound dependency properties, the expressions are copied but might no longer resolve. For more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) value of those properties is copied. Animations are not copied.  
  
 Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  
  
 The following list summarizes the expected behavior for this method:  
  
-   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  
  
-   Unset and read-only properties are not copied.  
  
-   Expressions are copied.  
  
-   None of these sub-objects are frozen on creation.  
  
-   The copy itself is not frozen.  
  
-   Animations are not copied.  
  
-   Only property base values are copied, not current animated values.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>変更可能な複製 \(ディープ コピー\) を作成、 <see cref="T:System.Windows.Freezable" /> の現在の値を使用します。</summary>
        <returns>現在のオブジェクトの変更可能な複製。 複製されたオブジェクトの <see cref="P:System.Windows.Freezable.IsFrozen" /> プロパティは、ソースの <see cref="P:System.Windows.Freezable.IsFrozen" /> プロパティが <see langword="true." /> である場合でも、<see langword="false" /> になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Freezable.Clone%2A> と <xref:System.Windows.Freezable.CloneCurrentValue%2A> メソッドの変更可能な複製を作成する固定 <xref:System.Windows.Freezable> オブジェクト \(メソッドも複製 <xref:System.Windows.Freezable> が固定されていないオブジェクト\)。 複製は、事実上、現在のオブジェクトのディープ コピーです。  
  
 次の表の違いをまとめたものです、 <xref:System.Windows.Freezable.Clone%2A> と <xref:System.Windows.Freezable.CloneCurrentValue%2A> メソッドです。  
  
|アクション|クローン メソッドの動作|CloneCurrentValue メソッドの動作|  
|-----------|------------------|-------------------------------|  
|式を持つ依存関係プロパティのコピー|式は、コピーされますが、解決できなくなる可能性があります。 詳細については、次を参照してください。 [Freezable オブジェクトの概要](http://msdn.microsoft.com/ja-jp/89c71692-4f43-4057-b611-67c6a8a863a2)します。|式そのものではありませんが、式の現在の値がコピーされます。|  
|アニメーションの依存関係プロパティのコピー|プロパティの基本 \(アニメーション化されていない\) 値がコピーされます。 アニメーションはコピーされません。|プロパティの現在のアニメーション化された値がコピーされます。 アニメーションはコピーされません。|  
  
 設定されていないプロパティがコピーしないことに注意してください。 プロパティが設定されていないが、固定の既定値を持つかどうか <xref:System.Windows.Freezable>, 、プロパティの値をそのまま、それ以外の場合に変更可能な複製で固定します。  
  
## スレッド間での Freezable を移動します。  
 このメソッドは移動役に立ちます、 <xref:System.Windows.Freezable> スレッド間でします。 最初に、作成、 <xref:System.Windows.Freezable> を使用しても変更もできない、 <xref:System.Windows.Freezable.Freeze%2A> メソッドです。 別のスレッドがアクセスできるので、 <xref:System.Windows.Freezable> し、アクセスできるローカル クローンを作成します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This method uses the <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> method to produce the clone; <see cref="T:System.Windows.Freezable" /> implementers who override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> must ensure that the copy is not frozen on creation.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">複製する <see cref="T:System.Windows.Freezable" />。</param>
        <summary>インスタンスの指定した変更可能な複製 \(ディープ コピー\) は、 <see cref="T:System.Windows.Freezable" /> プロパティの現在の値を使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、 <xref:System.Windows.Freezable.CloneCurrentValue%2A> メソッドは以外で呼び出されて、コードから直接このメソッドを上書きするときに基本実装を呼び出すときに、します。 現在のオブジェクトの変更可能なコピーを作成するには <xref:System.Windows.Freezable.CloneCurrentValue%2A> このメソッドを直接呼び出す代わりにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  
  
-   Your derived class has data that is not exposed via dependency properties.  
  
-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  
  
 It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties. If the object contains dependency properties with expressions (such as a data binding), the current value of the expression is copied but not the expression itself.  
  
 If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  
  
 Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  
  
 The following list summarizes the expected behavior for this method.  
  
-   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  
  
-   Unset and read-only properties are not copied.  
  
-   If a property is animated, its current value is copied, but the animation itself is not.  
  
-   None of these sub-objects are frozen on creation.  
  
-   The copy itself is not frozen.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Freezable" /> クラスの新しいインスタンスを初期化します。</summary>
        <returns>新しいインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、保護された方法と、動作の実際のオブジェクト固有の実装のオーバーライドの実装に依存して、 <xref:System.Windows.Freezable.CreateInstanceCore%2A> メソッドで、このメソッドは内部的に呼び出します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスとして実装された場合は、新しいインスタンスを作成、 <see cref="T:System.Windows.Freezable" /> クラスを派生します。</summary>
        <returns>新しいインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 直接 \(呼び出す場合を除きますベースの実装における\) には、このメソッドを呼び出す必要はありません。 このメソッドがによって内部的に呼び出されます、 <xref:System.Windows.Freezable.CreateInstance%2A> メソッドの新しいインスタンスが、 <xref:System.Windows.Freezable> を作成します。  
  
   
  
## 例  
 次の例では、一般的な実装の <xref:System.Windows.Freezable.CreateInstanceCore%2A>です。  
  
 [!code-csharp[freezablesample\_procedural\#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample\_procedural\#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Every <see cref="T:System.Windows.Freezable" /> derived class must implement this method. A typical implementation is to simply call the default constructor and return the result.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のオブジェクトを変更不可能にし、その <see cref="P:System.Windows.Freezable.IsFrozen" /> プロパティを <see langword="true" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 可能性を回避する、 <xref:System.InvalidOperationException> 確認してこのメソッドを呼び出すとき、 <xref:System.Windows.Freezable.CanFreeze%2A> を確認するにするかどうか、 <xref:System.Windows.Freezable> 可能であるも変更もできないこのメソッドを呼び出す前にします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> を変更不可能にすることはできません。</exception>
        <block subset="none" type="overrides">
          <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Check 制約または変更不可能な状態オブジェクト。 場合 <c>isChecking</c> は <see langword="true" />, 、オブジェクトができるかどうか、不可能な状態をチェックします。 場合 <c>isChecking</c> は <see langword="false" />, 、オブジェクトは変更不可能な状態、可能な場合です。</param>
        <param name="isChecking">
          <see langword="true" /> \(実際に固定しない\)、オブジェクトを固定できるかどうかを; を示す値を返す <see langword="false" /> を実際には、オブジェクトを固定します。</param>
        <summary>場合、 <paramref name="isChecking" /> パラメーターは、 <see langword="true" />, 、このメソッドによって示されるかどうか、指定した <see cref="T:System.Windows.Freezable" /> 不可能な状態に行んだことができます。 場合、 <paramref name="isChecking" /> パラメーターは <see langword="false" />, 、このメソッドが、指定された作成しようとしています。 <see cref="T:System.Windows.Freezable" /> 不可能な状態と、操作が成功したかどうかを示します。</summary>
        <returns>場合 <paramref name="isChecking" /> は <see langword="true" />, 、このメソッドが戻る <see langword="true" /> 場合は、指定した <see cref="T:System.Windows.Freezable" /> が不可能な状態、または <see langword="false" /> これを実行できない場合も変更もできません。 場合 <paramref name="isChecking" /> は <see langword="false" />, 、このメソッドが戻る <see langword="true" /> 場合は、指定した <see cref="T:System.Windows.Freezable" /> は変更できますが、または <see langword="false" /> これを実行できない場合も変更もできません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生した場合を除き、このメソッドを呼び出す必要はありません <xref:System.Windows.Freezable> をオーバーライドして、 <xref:System.Windows.Freezable.FreezeCore%2A> メソッドです。  このメソッドで使用できます、 <xref:System.Windows.Freezable.FreezeCore%2A> メソッド自体はクラスのデータ メンバーを固定するのには <xref:System.Windows.Freezable> オブジェクトです。  
  
 もう一度このメソッドを呼び出すには <xref:System.Windows.Freezable> \(変更不可能\) 既に凍結されているオブジェクト。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="isChecking" /> は <see langword="false" />, を作成しようとすると、 <paramref name="freezable" /> 不可能な状態に失敗しました。 オブジェクトは \(これが部分的に固定する\)、不明な状態に移行します。</exception>
        <block subset="none" type="overrides">
          <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <see langword="true" /> \(実際に固定しない\)、オブジェクトを固定できるかどうかを; を示す値を返す <see langword="false" /> を実際には、オブジェクトを固定します。</param>
        <summary>により、 <see cref="T:System.Windows.Freezable" /> オブジェクトも変更もできない、またはそれが不可能な状態かどうかをテストします。</summary>
        <returns>場合 <paramref name="isChecking" /> は <see langword="true" />, 、このメソッドが戻る <see langword="true" /> 場合、 <see cref="T:System.Windows.Freezable" /> が不可能な状態、または <see langword="false" /> これを実行できない場合も変更もできません。 場合 <paramref name="isChecking" /> は <see langword="false" />, 、このメソッドが戻る <see langword="true" /> 場合場合に、指定した <see cref="T:System.Windows.Freezable" /> は変更できますが、または <see langword="false" /> これを実行できない場合も変更もできません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 直接 \(呼び出す場合を除きますベースの実装における\) には、このメソッドを呼び出す必要はありません。 によって内部的にこのメソッドが呼び出されます、 <xref:System.Windows.Freezable.CanFreeze%2A> プロパティ \(と `isChecking` に等しい `true`\) および <xref:System.Windows.Freezable.Freeze%2A> メソッド \(と `isChecking` に等しい `false`\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.Freezable" /> implementers must override this method when the class contains data that is not stored using dependency properties.  
  
 A typical implementation would call base, then call the static <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> method on all <see cref="T:System.Windows.Freezable" /> typed properties that the class contains, returning <see langword="true" /> only if all properties were frozen (or could have been frozen, in the case of specifying <see langword="true" /> for <paramref name="isChecking" />).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>固定コピーを作成、 <see cref="T:System.Windows.Freezable" />, 、基本 \(アニメーション化されていない\) のプロパティの値を使用します。 コピーが固定されているために、任意の固定されたサブオブジェクトは、参照によってコピーされます。</summary>
        <returns>固定コピー、 <see cref="T:System.Windows.Freezable" />です。 コピーの <see cref="P:System.Windows.Freezable.IsFrozen" /> にプロパティが設定されている <see langword="true" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 確認する必要があります、 <xref:System.Windows.Freezable.CanFreeze%2A> ことを確認するには、このメソッドを呼び出す前に、プロパティ、 <xref:System.Windows.Freezable> 固定ことはできません。 使用するコピーの作成と同じではこのメソッドを使用して、 <xref:System.Windows.Freezable.Clone%2A> に固定し、 <xref:System.Windows.Freezable.Freeze%2A> メソッドです。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A> と <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 複製しないでくださいために、メソッドのコピーのパフォーマンスが向上する <xref:System.Windows.Freezable> サブオブジェクトを既に凍結されている。 参照渡しでコピーするだけです。  
  
 次の表の違いをまとめたものです、 <xref:System.Windows.Freezable.GetAsFrozen%2A> と <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> メソッドです。  
  
|アクション|GetAsFrozen メソッドの動作|GetCurrentValueAsFrozen メソッドの動作|  
|-----------|-------------------------|-------------------------------------|  
|式を持つ依存関係プロパティのコピー|メソッドをスローする <xref:System.InvalidOperationException> できないため <xref:System.Windows.Freezable.Freeze%2A> プロパティです。|式そのものではありませんが、式の現在の値がコピーされます。|  
|アニメーションの依存関係プロパティのコピー|プロパティの基本 \(アニメーション化されていない\) 値がコピーされます。 アニメーションはコピーされません。|プロパティの現在のアニメーション化された値がコピーされます。 アニメーションはコピーされません。|  
  
 設定されていないプロパティはコピーされませんも読み取り専用プロパティともことに注意してください。  
  
 コピーを作成する、 <xref:System.Windows.Freezable> いない固定、使用されている、 <xref:System.Windows.Freezable.Clone%2A> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> 式またはアニメーション化されたプロパティが含まれているために固定することはできません。</exception>
        <block subset="none" type="overrides">
          <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">コピーするインスタンス。</param>
        <summary>基本プロパティ値 \(アニメーション化されていない値\) を使用して、インスタンスを、指定した <see cref="T:System.Windows.Freezable" /> の固定された複製にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、 <xref:System.Windows.Freezable.GetAsFrozen%2A> メソッドは以外で呼び出されて、コードから直接このメソッドを上書きするときに基本実装を呼び出すときに、します。 現在のオブジェクトの固定コピーを作成するには <xref:System.Windows.Freezable.GetAsFrozen%2A> このメソッドを直接呼び出す代わりにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If you derive from <see cref="T:System.Windows.Freezable" /> you may need to override this method. Reasons to override include the following:  
  
-   Your derived class has data that is not exposed via dependency properties.  
  
-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  
  
 It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of any unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the expressions are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) values of those properties are copied. Animations are not copied.  
  
 Note that unset properties are not copied, nor are read-only properties.  
  
 If you do override this method, you must call the base implementation.  
  
 You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>固定コピーを作成、 <see cref="T:System.Windows.Freezable" /> プロパティの現在の値を使用します。 コピーが固定されているために、任意の固定されたサブオブジェクトは、参照によってコピーされます。</summary>
        <returns>固定コピー、 <see cref="T:System.Windows.Freezable" />です。 コピーの <see cref="P:System.Windows.Freezable.IsFrozen" /> にプロパティが設定されている <see langword="true" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用するコピーの作成と同じではこのメソッドを使用して、 <xref:System.Windows.Freezable.CloneCurrentValue%2A> に固定し、 <xref:System.Windows.Freezable.Freeze%2A> メソッドです。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A> と <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 複製しないでくださいために、メソッドのコピーのパフォーマンスが向上する <xref:System.Windows.Freezable> サブオブジェクトを既に凍結されている。 参照渡しでコピーするだけです。  
  
 次の表の違いをまとめたものです、 <xref:System.Windows.Freezable.GetAsFrozen%2A> と <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> メソッドです。  
  
|アクション|GetAsFrozen メソッドの動作|GetCurrentValueAsFrozen メソッドの動作|  
|-----------|-------------------------|-------------------------------------|  
|式を持つ依存関係プロパティのコピー|メソッドをスローする <xref:System.InvalidOperationException> できないため <xref:System.Windows.Freezable.Freeze%2A> プロパティです。|式そのものではありませんが、式の現在の値がコピーされます。|  
|アニメーションの依存関係プロパティのコピー|プロパティの基本 \(アニメーション化されていない\) 値がコピーされます。 アニメーションはコピーされません。|プロパティの現在のアニメーション化された値がコピーされます。 アニメーションはコピーされません。|  
  
 設定されていないプロパティはコピーされませんも読み取り専用プロパティともことに注意してください。  
  
 コピーを作成する、 <xref:System.Windows.Freezable> いない固定、使用されている、 <xref:System.Windows.Freezable.CloneCurrentValue%2A> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">コピーし、固定する <see cref="T:System.Windows.Freezable" />。</param>
        <summary>現在のインスタンスを、指定した <see cref="T:System.Windows.Freezable" /> の固定された複製にします。 オブジェクトに、アニメーション化された依存関係プロパティが存在する場合、現在アニメーション化されている値がコピーされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> メソッドは以外で呼び出されて、コードから直接このメソッドを上書きするときに基本実装を呼び出すときに、します。 現在のオブジェクトの固定コピーを作成するには <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> このメソッドを直接呼び出す代わりにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  
  
-   Your derived class has data that is not exposed via dependency properties.  
  
-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  
  
 It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation creates a new <see cref="T:System.Windows.Freezable" /> using the <see cref="M:System.Windows.Freezable.CreateInstance" /> method and makes deep copies of unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the data bindings are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  
  
 Read-only dependency properties within a <see cref="T:System.Windows.Freezable" /> are not copied by this default implementation.  
  
 If you do override this method, you must call the base implementation.  
  
 You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトが変更可能かどうかを示す値を取得します。</summary>
        <value>オブジェクトが固定されており、変更できない場合は、<see langword="true" />。オブジェクトを変更できる場合は、<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オブジェクトを変更しようとしています。 ときにその <xref:System.Windows.Freezable.IsFrozen%2A> プロパティは、 `true` スロー、 <xref:System.InvalidOperationException>です。  
  
 このプロパティとは、オブジェクト モデルの観点からは読み取り専用です。 に関するドキュメントの一部 <xref:System.Windows.Freezable> 動作が書いてあるかもしれません"設定 <xref:System.Windows.Freezable.IsFrozen%2A> に `true`"または同様の言語の他のメソッドの動作を説明しながら <xref:System.Windows.Freezable>, が、この動作が行われて内部的にクラスのインスタンスのインスタンスのメソッドが抽象クラス内に存在するプライベート変数を操作します。 このプロパティの値を設定するを呼び出す必要があります <xref:System.Windows.Freezable.Freeze%2A>します。 これを変更する 1 回限りの操作を効果的には、 <xref:System.Windows.Freezable.IsFrozen%2A> プロパティを初期の既定値から `false` 状態から、 `true` 状態です。 値の設定に使用できる方法はありませんに `false`します。 代わりに、元から作成されたディープ コピーを変更する可能性があります \(を参照してください、 <xref:System.Windows.Freezable.Clone%2A> メソッド\)。 これは、仕様であり、ケースに適用する場合に任意の派生クラスの動作方法は、場所、 <xref:System.Windows.Freezable> パターンは有用です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ときに呼び出されます現在 <see cref="T:System.Windows.Freezable" /> オブジェクトを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出すたびに、 <xref:System.Windows.Freezable.Changed> イベントが発生します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you implement a class that derives from <see cref="T:System.Windows.Freezable" />, you may override this method to perform tasks.</para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">データ メンバーの前の値。</param>
        <param name="newValue">データ メンバーの現在の値。</param>
        <summary>適切なコンテキスト ポインターが確立されているように、 <see cref="T:System.Windows.DependencyObjectType" /> が設定されているデータ メンバーです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す必要があります <xref:System.Windows.Freezable> 継承クラスごとに、 <xref:System.Windows.DependencyObject> として保存されていないデータ メンバー、 <xref:System.Windows.DependencyProperty> 設定されています。  
  
 このメソッドが呼び出される必要はありません <xref:System.Windows.DependencyObject> データ メンバーを使用して格納されている、 <xref:System.Windows.DependencyProperty>です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">データ メンバーの前の値。</param>
        <param name="newValue">データ メンバーの現在の値。</param>
        <param name="property">変更されたプロパティ。</param>
        <summary>このメンバーは、Windows Presentation Foundation (WPF) インフラストラクチャをサポートしますが、独自に作成したコードから直接使用するためのものではありません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">変更されたプロパティ、およびその変更前と変更後の値に関する情報を格納するイベント データ。</param>
        <summary>
          <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> の <see cref="T:System.Windows.DependencyObject" /> 実装を上書きして、さらに型 <see cref="T:System.Windows.Freezable" /> の変化する依存関係プロパティへの応答として任意の <see cref="E:System.Windows.Freezable.Changed" /> ハンドラーも呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント データに含まれる情報についてのみ、 <xref:System.Windows.Freezable> 自体です。 を通じて情報を取得する必要があります、 <xref:System.Windows.Freezable.Changed> ハンドラー。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>確実に、 <see cref="T:System.Windows.Freezable" /> が有効なスレッドからアクセスされています。 継承元 <see cref="T:System.Windows.Freezable" /> のいずれかの先頭にこのメソッドを呼び出す必要があります API 依存関係プロパティではないデータ メンバーを読み取る。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call the <see cref="M:System.Windows.Freezable.ReadPreamble" /> method before they attempt to access any members that are not dependency properties. The <see cref="M:System.Windows.Freezable.WritePreamble" /> method should be called before any such members are written to.  
  
 This method effectively does nothing more than call <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Freezable" /> の <see cref="E:System.Windows.Freezable.Changed" /> イベントを発生させ、その <see cref="M:System.Windows.Freezable.OnChanged" /> メソッドを呼び出します。<see cref="T:System.Windows.Freezable" /> から派生するクラスは、依存関係プロパティとして格納されていないクラス メンバーを変更するすべての API の終了時に、このメソッドを呼び出す必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies a class member that is not stored as a <see cref="T:System.Windows.DependencyProperty" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>あることを確認、 <see cref="T:System.Windows.Freezable" /> 固定されていない有効なスレッド コンテキストからアクセスされているとします。<see cref="T:System.Windows.Freezable" /> 継承クラスは、いずれかの先頭にこのメソッドを呼び出す必要があります API 依存関係プロパティではないデータ メンバーに書き込まれる。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> スレッドのコンテキストは、アクセス可能な場合は、例外をスローことを確認、 <xref:System.Windows.Freezable> インスタンスが既に凍結されています。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> インスタンスが無効になりことはできませんが、メンバーに書き込まれます。</exception>
        <block subset="none" type="overrides">
          <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call <see cref="M:System.Windows.Freezable.WritePreamble" /> before attempting to write to any members that are not dependency properties. If you call <see cref="M:System.Windows.Freezable.WritePreamble" /> in an [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], you can omit a call to <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Freezable" /> 不可能な状態のオブジェクトと設定、 <see cref="P:System.Windows.Freezable.IsFrozen" /> プロパティを <see langword="true" />, 、またはテストするかどうか、 <see cref="T:System.Windows.Freezable" /> オブジェクトが不可能な状態です。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>により、型のデータ メンバーに対して、適切なコンテキスト ポインターのように設定されている <see cref="T:System.Windows.DependencyObject" /> が変更されたばかりです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>