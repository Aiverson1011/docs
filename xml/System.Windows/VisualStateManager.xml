<Type Name="VisualStateManager" FullName="System.Windows.VisualStateManager">
  <TypeSignature Language="C#" Value="public class VisualStateManager : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VisualStateManager extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.VisualStateManager" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>状態とコントロールの状態を遷移するためのロジックを管理します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.VisualStateManager> 特定の状態にあるとき、およびコントロールの状態が変更されたときに、コントロール、コントロールの外観の状態を指定することができます。 たとえば、 <xref:System.Windows.Controls.Button> が押されていない場合よりも押されている場合、やや異なる外観があります。 2 つの状態、 <xref:System.Windows.Controls.Button> 定義が押されたときに対応 \(`"Pressed"`\) がない場合、\(`"Normal"`\)。 状態にあるときのコントロールの外観が定義されている、 <xref:System.Windows.VisualState>です。 A <xref:System.Windows.VisualState> のコレクションを含む <xref:System.Windows.Media.Animation.Storyboard> コントロールがその状態のときに、コントロールの外観がどのように変化するかを指定するオブジェクト。 コントロールに設定して表示状態を追加する、 `VisualStateManager.VisualStateGroups` コントロールのプロパティをアタッチします。 各 <xref:System.Windows.VisualStateGroup> のコレクションを含む <xref:System.Windows.VisualState> 相互に排他的であるオブジェクト。 つまり、コントロールは常にそれぞれの 1 つの状態に <xref:System.Windows.VisualStateGroup>します。  
  
 <xref:System.Windows.VisualStateManager> コントロールが特定の状態に入ったときに指定することもできます。 状態を変更する呼び出す必要のある方法は、自分のシナリオによって異なります。 使用するコントロールを作成する場合、 <xref:System.Windows.VisualStateManager> でその <xref:System.Windows.Controls.ControlTemplate>, を呼び出す、 <xref:System.Windows.VisualStateManager.GoToState%2A> メソッドです。 作成する方法の詳細についてはコントロールを使用して、 <xref:System.Windows.VisualStateManager>, を参照してください [を作成する、コントロールのある外観をカスタマイズできる](http://msdn.microsoft.com/ja-jp/9e356d3d-a3d0-4b01-a25f-2d43e4d53fe5)します。 使用する場合、 <xref:System.Windows.VisualStateManager> の外部、 <xref:System.Windows.Controls.ControlTemplate> \(を使用する場合など、 <xref:System.Windows.VisualStateManager> で、 <xref:System.Windows.Controls.UserControl> または 1 つの要素\) を呼び出す、 <xref:System.Windows.VisualStateManager.GoToElementState%2A> メソッドです。 いずれの場合、 <xref:System.Windows.VisualStateManager> を適切に開始および関連する状態に関連付けられているストーリー ボードを停止するために必要なロジックを実行します。 たとえば、コントロールが、状態を定義する `State1` と `State2`, 、それぞれが関連付けられているストーリー ボードを持ちます。 場合は、コントロールが `State1` して渡す `State2` に <xref:System.Windows.VisualStateManager.GoToState%2A> または <xref:System.Windows.VisualStateManager.GoToElementState%2A>, 、 <xref:System.Windows.VisualStateManager> でストーリー ボードを起動 `State2` 内でストーリー ボードを停止して `State1`です。  
  
 コントロールに含まれている [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] を使用して、 <xref:System.Windows.VisualStateManager> ビジュアル状態を変更します。 作成するときに、 <xref:System.Windows.Controls.ControlTemplate> に含まれているコントロールの [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], 、追加することができます <xref:System.Windows.VisualState> オブジェクトをコントロールの <xref:System.Windows.Controls.ControlTemplate> をある状態で、コントロールの外観を指定します。 含まれているコントロールの表示状態の名前を検索する [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], を参照してください [コントロールのスタイルとテンプレート](http://msdn.microsoft.com/ja-jp/c19049bb-5ceb-492d-afd2-751dca0ed8e3)します。 コントロールのロジックのハンドルの他にも何も操作する必要はありませんので、状態間で移行を定義、 <xref:System.Windows.VisualState> 新しいオブジェクト <xref:System.Windows.Controls.ControlTemplate>します。 既存のコントロールのコントロール テンプレートを作成する方法の詳細については、次を参照してください。 [ControlTemplate を作成することで、既存のコントロールの外観のカスタマイズ](http://msdn.microsoft.com/ja-jp/678dd116-43a2-4b8c-82b5-6b826f126e31)します。  
  
 状態を遷移するためのロジックを実装する場合から継承する必要があります <xref:System.Windows.VisualStateManager>, 、オーバーライド、 <xref:System.Windows.VisualStateManager.GoToStateCore%2A> メソッド、およびセット、 <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A?displayProperty=fullName> カスタム ロジックを使用してコントロールのプロパティをアタッチします。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Windows.Shapes.Rectangle> を追加し、 <xref:System.Windows.VisualStateGroup> という名前 `CommonStates` に、 `VisualStateManager.VisualStatesGroups` 添付プロパティです。 例では、定義、 `MouseOver` と `Normal`<xref:System.Windows.VisualState> 内のオブジェクト、 `CommonStates`<xref:System.Windows.VisualStateGroup>します。 ユーザーが上にマウス ポインターを移動すると、 <xref:System.Windows.Shapes.Rectangle>, 、赤に変わる緑 over 1 の 0.5 秒です。 四角形からマウスを動かしたときに、 <xref:System.Windows.Controls.Grid> 赤に変更がすぐにバックアップします。 なお、 `Normal` 状態が定義されていません、 <xref:System.Windows.Media.Animation.Storyboard>です。 A <xref:System.Windows.Media.Animation.Storyboard> は必要ありませんからときに、 <xref:System.Windows.Shapes.Rectangle> から移行、 `MouseOver` 状態から、 `Normal` 状態、 <xref:System.Windows.Media.Animation.Storyboard> の `MouseOver` が停止していると <xref:System.Windows.Media.SolidColorBrush.Color%2A> プロパティを <xref:System.Windows.Media.SolidColorBrush> 赤を返します。  
  
 [!code-xml[VSMCustomControl\#VSMNoTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#vsmnotemplate)]  
  
 次の例では、イベント ハンドラーの呼び出し、前の例で定義されている、 <xref:System.Windows.VisualStateManager.GoToElementState%2A> 状態間を遷移します。 前の例では、四角形の一部であったかどうか、 <xref:System.Windows.Controls.ControlTemplate>, を呼び出す必要があります、例、 <xref:System.Windows.VisualStateManager.GoToState%2A> メソッドです。  
  
 [!code-csharp[VSMCustomControl\#GoToElementState](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml.cs#gotoelementstate)]
 [!code-vb[VSMCustomControl\#GoToElementState](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/window1.xaml.vb#gotoelementstate)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualStateManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.VisualStateManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CustomVisualStateManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CustomVisualStateManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static System.Windows.VisualStateManager GetCustomVisualStateManager (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.VisualStateManager GetCustomVisualStateManager(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetCustomVisualStateManager(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VisualStateManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">取得する要素、 <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" /> からプロパティをアタッチします。</param>
        <summary>取得、 <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" /> 添付プロパティです。</summary>
        <returns>コントロールの状態間を遷移表示状態マネージャー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualStateGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IList GetVisualStateGroups (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList GetVisualStateGroups(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetVisualStateGroups(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">取得する要素、 <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" /> からプロパティをアタッチします。</param>
        <summary>取得、 <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" /> 添付プロパティです。</summary>
        <returns>コレクション <see cref="T:System.Windows.VisualStateGroup" /> 、指定したオブジェクトに関連付けられているオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GoToElementState">
      <MemberSignature Language="C#" Value="public static bool GoToElementState (System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToElementState(class System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToElementState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stateGroupsRoot">ルート要素を含む、 <see cref="T:System.Windows.VisualStateManager" />です。</param>
        <param name="stateName">切り替え先の状態。</param>
        <param name="useTransitions">
          <see langword="true" /> 使用する、 <see cref="T:System.Windows.VisualTransition" /> オブジェクトの状態間を遷移するそれ以外の場合、 <see langword="false" />です。</param>
        <summary>2 つの状態の間で要素を移行します。 コントロールによって定義されているのではなく、アプリケーションで定義される状態の遷移には、このメソッドを使用します。</summary>
        <returns>
          <see langword="true" /> コントロールが正常に新しい状態に遷移した場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す、 <xref:System.Windows.VisualStateManager.GoToElementState%2A> 上の外部要素を変更するメソッドを示す、 <xref:System.Windows.Controls.ControlTemplate> \(を使用する場合など、 <xref:System.Windows.VisualStateManager> で、 <xref:System.Windows.DataTemplate> または <xref:System.Windows.Window>\)。 呼び出す、 <xref:System.Windows.VisualStateManager.GoToState%2A> メソッドを使用するコントロールの状態を変更する場合は、 <xref:System.Windows.VisualStateManager> でその <xref:System.Windows.Controls.ControlTemplate>します。  
  
   
  
## 例  
 次の例では、1 から 100 までの数値を推測するユーザーの入力を要求するアプリケーションを作成します。  数値を入力すると、アプリケーションは推定値が高すぎる、不足、または適切であるかどうかを示します。  次 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 、アプリケーションのユーザー インターフェイスを作成し、4 つの状態を定義します。 `TooLow`, 、`TooHigh`, 、`Correct`, 、および `Guessing`です。 アプリケーションの開始時に、 `Guessing` 状態です。 」を参照してください。  
  
 [!code-xml[VSMGoToElementState\#GoToElementStateXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml#gotoelementstatexaml)]  
  
 次のコードでは、アプリケーションのロジックを示します。  ユーザーは、数値を入力、ボタンをクリックすると、そのアプリケーションが呼び出す <xref:System.Windows.VisualStateManager.GoToElementState%2A> に移行する `TooHigh`, 、`TooLow`, 、または `Correct` の推定値に関するユーザーにフィードバックを提供します。  この例には、呼び出し、 `GenerateNumber` メソッド、アプリケーションの開始時にします。  
  
 [!code-csharp[VSMGoToElementState\#GoToElementStateCode](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml.cs#gotoelementstatecode)]
 [!code-vb[VSMGoToElementState\#GoToElementStateCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmgotoelementstate/visualbasic/mainwindow.xaml.vb#gotoelementstatecode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stateGroupsRoot" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="stateName" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToState">
      <MemberSignature Language="C#" Value="public static bool GoToState (System.Windows.FrameworkElement control, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToState(class System.Windows.FrameworkElement control, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">状態間を遷移するコントロール。</param>
        <param name="stateName">切り替え先の状態。</param>
        <param name="useTransitions">
          <see langword="true" /> 使用する、 <see cref="T:System.Windows.VisualTransition" /> オブジェクトの状態間を遷移するそれ以外の場合、 <see langword="false" />です。</param>
        <summary>コントロールを 2 つの状態間で切り替えます。 このメソッドを持つコントロールの状態の遷移を使用して、 <see cref="T:System.Windows.Controls.ControlTemplate" />です。</summary>
        <returns>
          <see langword="true" /> コントロールが正常に新しい状態に遷移した場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す、 <xref:System.Windows.VisualStateManager.GoToState%2A> メソッドを使用するコントロールの状態を変更する場合は、 <xref:System.Windows.VisualStateManager> でその <xref:System.Windows.Controls.ControlTemplate>します。 呼び出す、 <xref:System.Windows.VisualStateManager.GoToElementState%2A> 上の外部要素を変更するメソッドを示す、 <xref:System.Windows.Controls.ControlTemplate> \(を使用する場合など、 <xref:System.Windows.VisualStateManager> で、 <xref:System.Windows.Controls.UserControl> または 1 つの要素で\)。  
  
   
  
## 例  
 次の例では、使用するコントロールを <xref:System.Windows.VisualStateManager.GoToState%2A> 状態間を遷移します。 全体の例では、次を参照してください。 [を作成する、コントロールの外観をカスタマイズできる](http://msdn.microsoft.com/ja-jp/9e356d3d-a3d0-4b01-a25f-2d43e4d53fe5)します。  
  
 [!code-csharp[VSMCustomControl\#UpdateStates](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#updatestates)]
 [!code-vb[VSMCustomControl\#UpdateStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#updatestates)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="stateName" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToStateCore">
      <MemberSignature Language="C#" Value="protected virtual bool GoToStateCore (System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot, string stateName, System.Windows.VisualStateGroup group, System.Windows.VisualState state, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GoToStateCore(class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot, string stateName, class System.Windows.VisualStateGroup group, class System.Windows.VisualState state, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToStateCore(System.Windows.FrameworkElement,System.Windows.FrameworkElement,System.String,System.Windows.VisualStateGroup,System.Windows.VisualState,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="group" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="state" Type="System.Windows.VisualState" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">状態間を遷移するコントロール。</param>
        <param name="stateGroupsRoot">ルート要素を含む、 <see cref="T:System.Windows.VisualStateManager" />です。</param>
        <param name="stateName">遷移先の状態の名前。</param>
        <param name="group">
          <see cref="T:System.Windows.VisualStateGroup" /> に状態が属しています。</param>
        <param name="state">遷移先の状態の表現です。</param>
        <param name="useTransitions">
          <see langword="true" /> 使用する、 <see cref="T:System.Windows.VisualTransition" /> オブジェクトの状態間を遷移するそれ以外の場合、 <see langword="false" />です。</param>
        <summary>コントロールの状態を移行します。</summary>
        <returns>
          <see langword="true" /> コントロールが正常に新しい状態に遷移した場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.VisualStateManager.GoToStateCore%2A> メソッドが適切に開始および遷移に関連付けられているストーリー ボードを停止するために必要なロジックを実行します。 コントロールを呼び出すと <xref:System.Windows.VisualStateManager.GoToState%2A> の状態を変更する、 <xref:System.Windows.VisualStateManager> は、次の処理します。  
  
-   1 つは、if、 <xref:System.Windows.VisualState> コントロールが遷移することが、 <xref:System.Windows.Media.Animation.Storyboard>, 、ストーリー ボードを開始します。 その後、if、 <xref:System.Windows.VisualState> がコントロールに送信元がある、 <xref:System.Windows.Media.Animation.Storyboard>, 、ストーリー ボードが終了します。  
  
-   コントロールになっている場合、 `stateName` 状態、 <xref:System.Windows.VisualStateManager.GoToState%2A> は何も実行し、返します `true`します。  
  
-   場合 `stateName` に存在しません、 <xref:System.Windows.Controls.ControlTemplate> の `control`, 、<xref:System.Windows.VisualStateManager.GoToState%2A> は何も実行し、返します `false`します。  
  
 独自に実装することができます <xref:System.Windows.VisualStateManager> ロジックを提供する別の状態を遷移します。 前に説明したロジックを変更するなど、カスタム アニメーションの種類間を遷移するロジックを指定できます。  実装する、 <xref:System.Windows.VisualStateManager>, から継承するクラスを作成 <xref:System.Windows.VisualStateManager> させ、 <xref:System.Windows.VisualStateManager.GoToStateCore%2A> メソッドです。 カスタム クラスを使用する設定、 <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> プロパティをカスタム型のオブジェクト。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanged">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanged (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanged(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">オブジェクトを <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" /> でイベントが発生しました。</param>
        <param name="oldState">コントロールが遷移している状態。</param>
        <param name="newState">状態に遷移するコントロールです。</param>
        <param name="control">このコントロールは、状態が遷移します。</param>
        <param name="stateGroupsRoot">ルート要素を含む、 <see cref="T:System.Windows.VisualStateManager" />です。</param>
        <summary>発生させる、 <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" /> 指定したイベント <see cref="T:System.Windows.VisualStateGroup" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Windows.VisualStateGroup> に設定されている、 <xref:System.Windows.Controls.ControlTemplate> 、コントロールの `control` を所有するコントロールにパラメーターが設定されている <xref:System.Windows.Controls.ControlTemplate>します。  ときに、 <xref:System.Windows.VisualStateGroup> に設定されている、 <xref:System.Windows.FrameworkElement>, 、`control` は `null` し使用する必要があります、 `stateGroupsRoot` パラメーター。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stateGroupsRoot" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="newState" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> in a derived class, be sure to call the base class’s <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanging">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanging (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanging(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">オブジェクトを <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" /> でイベントが発生しました。</param>
        <param name="oldState">コントロールが遷移している状態。</param>
        <param name="newState">状態に遷移するコントロールです。</param>
        <param name="control">このコントロールは、状態が遷移します。</param>
        <param name="stateGroupsRoot">ルート要素を含む、 <see cref="T:System.Windows.VisualStateManager" />です。</param>
        <summary>発生させる、 <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" /> 指定したイベント <see cref="T:System.Windows.VisualStateGroup" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Windows.VisualStateGroup> に設定されている、 <xref:System.Windows.Controls.ControlTemplate> 、コントロールの `control` を所有するコントロールにパラメーターが設定されている <xref:System.Windows.Controls.ControlTemplate>します。  ときに、 <xref:System.Windows.VisualStateGroup> に設定されている、 <xref:System.Windows.FrameworkElement>, 、`control` は `null` し使用する必要があります、 `stateGroupsRoot` パラメーター。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stateGroupsRoot" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="newState" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> in a derived class, be sure to call the base class’s <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static void SetCustomVisualStateManager (System.Windows.FrameworkElement obj, System.Windows.VisualStateManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCustomVisualStateManager(class System.Windows.FrameworkElement obj, class System.Windows.VisualStateManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.SetCustomVisualStateManager(System.Windows.FrameworkElement,System.Windows.VisualStateManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
        <Parameter Name="value" Type="System.Windows.VisualStateManager" />
      </Parameters>
      <Docs>
        <param name="obj">プロパティを設定するオブジェクト。</param>
        <param name="value">コントロールの状態間を遷移表示状態マネージャー。</param>
        <summary>セット、 <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" /> 添付プロパティです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroupsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisualStateGroupsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisualStateGroupsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>