<Type Name="UIElement" FullName="System.Windows.UIElement">
  <TypeSignature Language="C#" Value="public class UIElement : System.Windows.Media.Visual, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi UIElement extends System.Windows.Media.Visual implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.UIElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.UidProperty("Uid")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.Windows.UIElement" /> は、Windows Presentation Foundation (WPF) の要素および基本表示特性における WPF コア レベル実装構築の基底クラスです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement> 要素のレイアウト特性、および表示要素とその子の動作要素のレイアウトに影響を与えるが、仮想メソッドが派生クラスでオーバーライドできる公開の開始点を提供します。  
  
 多くの入力や要素の動作に重点を置いて一般でも定義されて、 <xref:System.Windows.UIElement> クラスです。 これには、キーボード、マウスおよびスタイラスからの入力、および関連するステータスのプロパティについては、イベントが含まれます。 ルーティングされたイベントは、これらのイベントの多くは、バブル、両方のルーティングの入力に関連するイベントの多くがあるバージョンだけでなく、イベントのトンネルのバージョン。 これらのイベントのペアは、通常、コントロールを作成する最も関心を持ってイベントです。  
  
 <xref:System.Windows.UIElement> 含まれています [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] に関連した、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] イベント モデルでは、指定させることができるメソッドを含む要素のインスタンスが基づいているイベントをルーティングします。  
  
 アーキテクチャとしては、 <xref:System.Windows.UIElement> と言えますにウィンドウ ハンドルとほぼ同等 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] プログラミング、または要素に [!INCLUDE[TLA#tla_dhtml](~/includes/tlasharptla-dhtml-md.md)] プログラミングします。 <xref:System.Windows.UIElement> WPF コア レベルでの基本要素です。  
  
 A <xref:System.Windows.UIElement> で具体的に定義されている次の機能を持つ、 <xref:System.Windows.UIElement> クラス。  
  
-   子要素としてレンダリングできます \(<xref:System.Windows.UIElement> から派生した <xref:System.Windows.Media.Visual>, 、高レベルのグラフィックス クラス\)  
  
-   サイズし、の使用可能な子要素を配置に使用するロジックが含まれる、 <xref:System.Windows.UIElement> \(時、レイアウト システムによって解釈されます\)  
  
-   \(コントロールにイベント ルーティング、またはコマンドのルーティングの処理に使用して入力の送信先を取得するを含む\) ユーザー入力に応答できます。  
  
-   要素の論理ツリー内のルートに移動するルーティングされたイベントを発生させることができます。  
  
-   アニメーション システムの一部の機能をサポートしています  
  
 <xref:System.Windows.FrameworkElement> WPF フレームワーク レベルの実装クラスを基に <xref:System.Windows.UIElement>, 、WPF フレームワーク レベルで特定の相互作用を追加します。<xref:System.Windows.FrameworkElement> 追加し、次の機能を定義します。  
  
-   その他のフレームワーク固有のレイアウト特性  
  
-   プロパティをレポートする豊富なメタデータのサポート  
  
-   特定のクラスに固有の実装の基本クラスとその添付プロパティを入力またはアタッチされるイベント  
  
-   スタイルのサポート  
  
-   さらにアニメーションのサポート  
  
 クラスは入れます <xref:System.Windows.ContentElement>します。<xref:System.Windows.ContentElement> クラスと同じメンバーの多く <xref:System.Windows.UIElement>; これら 2 つのクラス間の違いが、意図したものでは、全体的なコンテンツ モデルに配置するには。 A <xref:System.Windows.UIElement> 派生クラスは、通常、マークアップ内の子要素がどのような要素に制限があることを意味の比較的剛体のコンテンツ モデルを定義します。 より制限の緩い子コンテンツを作成することの容量がある可能性があります、 <xref:System.Windows.UIElement>, が、その容量が指定されたコンテンツのプロパティで集中管理通常です。 A <xref:System.Windows.ContentElement> 派生クラスは通常フロー形式のドキュメントなどのシナリオをサポートするために、コンテンツに関する限定します。  
  
> [!IMPORTANT]
>  <xref:System.Windows.UIElement.Visibility%2A> 状態では、すべての入力をその要素での処理に影響します。 表示されていない要素は、ヒット テストに参加していないと、境界を越えて、マウスが要素がある場合でも、入力イベントを受け取りません場合に表示されていた。  
  
   
  
## 例  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.UIElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型の実際には、新しいインスタンスを作成する <xref:System.Windows.UIElement> アプリケーション コードでは一般的ではありませんので <xref:System.Windows.UIElement> 基本要素です。 参照してください [要素の概要を基本](http://msdn.microsoft.com/ja-jp/2c997092-72c6-4767-bc84-74267f4eee72)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドルするルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <summary>指定したルーティング イベントにルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 例外を発生させずは、同じイベントに対して同じハンドラーを複数回追加できます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装において考慮する必要があります副作用がある可能性がありますを検討してください。  
  
 通常の"add"アクセサーの実装を提供するこのメソッドを使用する、 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] カスタム ルーティング イベントのイベントのアクセス パターンです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">処理するルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <param name="handledEventsToo">イベント データ内でルーティング イベントが処理済みとしてマークされている場合でも呼び出されるようにハンドラーを登録するには <see langword="true" />。ルーティング イベントが既に処理済みとしてマークされている場合はハンドラーを呼び出さないという既定の条件を使用してハンドラーを登録する場合は <see langword="false" />。  
  
 既定値は、<see langword="false" /> です。  
  
 ルーティング イベントの再処理を機械的に要求しないでください。 詳細については、「解説」を参照してください。</param>
        <summary>指定したルーティング イベントのためのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。 イベント ルート上の他の要素により既に処理済みとしてマークされているルーティング イベントに対し、指定したハンドラーが呼び出されるようにするには、<paramref name="handledEventsToo" /> を <see langword="true" /> に指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複雑な作業は、実用的な方法で低レベルの入力イベントを処理します。 多くのコントロールと、特定のイベントが処理され、マーク、他のより直観的なイベントで交換の動作を実装します。 一般に、そのための設計上の意図がある場合を処理済みとして、コントロールはプラットフォームの入力イベントをマークだけです。 特定のシナリオで、設計上の意図、特定の入力イベントの処理が必要とは限りません。 そのを登録するようなシナリオはハンドラー `handledEventsToo` として `true` が適切です。 日常的に行いますされません。 処理される場合でも、すべてのイベントに応答ハンドラーを呼び出すと、独自のアプリケーション イベント処理ロジックが複雑になります。 ハンドラーのロジックが大きな場合は、パフォーマンスの低下を参照してください可能性があります。 既にいくつかのコントロールは、アプリケーション ロジックで処理するイベントを処理は開発プロセス中に発見した場所の場合の処理済みのイベントのハンドラーのアタッチの使用を予約する必要があります。  
  
 クラスの処理を特定のイベントとコントロールの組み合わせの動作を回避するためのもう 1 つの方法では、そのイベントのプレビューを代わりに使用します。 たとえば場合、 <xref:System.Windows.UIElement.MouseLeftButtonDown> 処理済みとしてマークは、クラスの処理によってこともできますのハンドラーを追加する <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 代わりにします。  
  
 例外を発生させずは、同じイベントに対して同じハンドラーを複数回追加できます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装において考慮する必要があります副作用がある可能性がありますを検討してください。  
  
 通常の"add"アクセサーの実装を提供するこのメソッドを使用する、 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] カスタム ルーティング イベントのイベントのアクセス パターンです。  
  
   
  
## 例  
 次の例で呼び出されるハンドラーを実装する、 <xref:System.Windows.FrameworkElement.Initialized> を使用して、ページ上の名前付きの要素のいずれかに定義されたハンドラーをアタッチするページ上のイベント `handledEventsToo` `true`します。  このハンドラーは、経路上の別の要素が共有イベント データ、ルートの処理中の要素に到達する前に処理済みとしてマークされている場合でも呼び出されるとします。  
  
 [!code-csharp[EventOvwSupport\#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport\#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">ハンドラーに追加されるイベントのルートです。</param>
        <param name="e">ハンドラーの追加に使用されるイベントのデータ。 このメソッドを使用して、 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> ハンドラーを作成するイベント データのプロパティです。</param>
        <summary>指定したハンドラーを追加する <see cref="T:System.Windows.EventRoute" /> 現在の <see cref="T:System.Windows.UIElement" /> イベント ハンドラーのコレクション。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コンテンツ ホスト要素で使用できます \(いずれかを実装するもの <xref:System.Windows.IContentHost> またはいない場合は\) の子要素のハンドラーを追加する、 <xref:System.Windows.EventRoute>です。 通常、これは必要ありません <xref:System.Windows.UIElement>, 、ハンドラーが完了した論理ツリーで見つかったすべての要素を自動的に追加します。 ただし、ここで <xref:System.Windows.ContentElement> と <xref:System.Windows.UIElement> が混在している要素のルートに追加するテンプレートの必要性から得られたの介在するテンプレートのツリー内です。 両方とも <xref:System.Windows.ContentElement> と <xref:System.Windows.UIElement> このメソッドのバージョンをサポートします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグアンドドロップ操作の対象として使用できるかどうかを示す値を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>この要素をドラッグアンドドロップ操作の対象として使用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Drag\-and\-drop operations are not enabled by default, and must be enabled deliberately by setting <xref:System.Windows.UIElement.AllowDrop%2A> to **languageKeyword tag is not supported!!!!**  
. Beyond this basic setting, drag\-and\-drop behavior is entirely implementation specific and is not defined by <xref:System.Windows.UIElement> or any other base element class. Certain controls, for example, <xref:System.Windows.Controls.RichTextBox>, do have a default behavior. For more information on drag and drop, see [Drag and Drop Overview](http://msdn.microsoft.com/ja-jp/1a5b27b0-0ac5-4cdf-86c0-86ac0271fa64).  
  
 <xref:System.Windows.FrameworkElement> overrides the metadata for this dependency property in its implementation. Specifically, <xref:System.Windows.FrameworkElement> designates this property to allow property value inheritance \(<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata\). Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.UIElement.AllowDrop%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned \(again, either in styles, by default values, or a local value\), then the value from the parent element will be assigned to all previously unassigned child elements by the property system. In practice this means that you can specify whether to allow drop operations at the root element, and that value will propagate to all child elements that have not specifically assigned it as `false`.  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement.AllowDropProperty>|  
|Metadata properties set to **languageKeyword tag is not supported!!!!**|None|  
  
   
  
## 例  
 The following markup example sets the <xref:System.Windows.UIElement.AllowDrop%2A> property **languageKeyword tag is not supported!!!!**  
 using an attribute on a <xref:System.Windows.Controls.TextBox>, as well as setting some other related properties that in aggregate enable that <xref:System.Windows.Controls.TextBox> to be the target of a multiline text data object when it is dragged in. For the complete sample, see [Load a Dropped File Sample](http://msdn.microsoft.com/ja-jp/be90d645-dd61-4f53-93bb-87902d086ef7).  
  
 [!code-xml[DragDrop\_DropOpenTextFile\#UIElementAllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/DragDrop_DropOpenTextFile/CS/window1.xaml#uielementallowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.AllowDrop" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、封印され、オーバーライドすることはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">アニメーション化するプロパティの識別子。</param>
        <param name="clock">アニメーションをコントロールして宣言するアニメーション クロック。</param>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用します。 既存のアニメーションは停止され、新しいアニメーションに置き換えられます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 To remove an animation from a property, specify the identifier for that property as **parameterReference tag is not supported!!!!**  
 and specify **parameterReference tag is not supported!!!!**  
 as **languageKeyword tag is not supported!!!!**  
. This removes the animation and the animated property is set to its base value. However, the originally associated animation clock is not stopped. Any other animations assigned to that clock will continue to run.  
  
   
  
## 例  
 In the following example, a <xref:System.Windows.Shapes.Rectangle> `myAnimatedRectangle` has a particular timing animation applied to it by calling <xref:System.Windows.UIElement.ApplyAnimationClock%2A> .  
  
 [!code-csharp[timingbehaviors\_procedural\_snip\#UIElementApplyAnimationClock](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/ClockControllerSpeedRatioExample.cs#uielementapplyanimationclock)]
 [!code-vb[timingbehaviors\_procedural\_snip\#UIElementApplyAnimationClock](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/clockcontrollerspeedratioexample.vb#uielementapplyanimationclock)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">アニメーション化するプロパティ。</param>
        <param name="clock">アニメーションをコントロールして宣言するアニメーション クロック。</param>
        <param name="handoffBehavior">列挙体の値。 既定値は <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> で、既存のアニメーションを停止して新しいアニメーションに置き換えます。</param>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用し、プロパティでアニメーションが既に適用されているときに行われる処理を指定する機能も提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アニメーションのプロパティを削除すると、そのプロパティの識別子を指定する `dp` 指定 `clock` として `null`します。 これにより、アニメーション、削除し、アニメーションのプロパティをベース値に設定します。 ただし、最初に関連付けられているアニメーション クロックは停止されません。 クロックに割り当てられているその他のアニメーションは引き続き実行します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、少なくとも 1 つのタッチをキャプチャするかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 少なくとも 1 つのタッチの場合はこの要素にキャプチャします。それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.AreAnyTouchesCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のすべての子要素には、少なくとも 1 つのタッチがキャプチャされているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素またはそのビジュアル ツリー内のすべての子要素にキャプチャされる場合は、少なくとも 1 つのタッチそれ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別、 <see cref="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" /> 依存関係プロパティ。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上に少なくとも 1 つのタッチが押されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素上には、少なくとも 1 つのタッチが押された場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のすべての子要素の上に少なくとも 1 つのタッチが押されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素またはそのビジュアル ツリー内のすべての子要素の上には、少なくとも 1 つのタッチが押された場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別、 <see cref="P:System.Windows.UIElement.AreAnyTouchesOver" /> 依存関係プロパティ。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arrange">
      <MemberSignature Language="C#" Value="public void Arrange (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Arrange(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">親要素が子要素のために計算した最終的なサイズを示す﻿ <see cref="T:System.Windows.Rect" /> のインスタンス。</param>
        <summary>子要素を配置し、<see cref="T:System.Windows.UIElement" /> のサイズを決定します。 親要素はそれぞれの <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> 実装 \(または WPF フレームワーク レベルの同等実装\) からこのメソッドを呼び出し、レイアウトを再帰的に更新します。 このメソッドは、レイアウト更新の 2 番目のパスを構成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シナリオの動作を派生する WPF フレームワーク レベル要素の <xref:System.Windows.UIElement.Arrange%2A> いない必要があります \(およびできません、シャドウする場合を除き、\) 変更します。 代わりに、オーバーライドする必要があります、 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> クラスで実装します。<xref:System.Windows.FrameworkElement.ArrangeOverride%2A> によって内部的に実装が呼び出される <xref:System.Windows.UIElement.Arrange%2A> デフォルトの WPF フレームワーク レベル レイアウトの操作の一部として。<xref:System.Windows.UIElement.ArrangeCore%2A> 実装を呼び出す必要がありますも <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> 子要素がある場合、各子要素です。  
  
 シナリオの動作を派生する WPF コア レベル要素の <xref:System.Windows.UIElement.Arrange%2A> いない必要があります \(およびできません、シャドウする場合を除き、\) 変更します。 代わりに、オーバーライドする必要があります <xref:System.Windows.UIElement.ArrangeCore%2A> クラスにします。<xref:System.Windows.UIElement.ArrangeCore%2A> によって内部的に実装が呼び出される <xref:System.Windows.UIElement.Arrange%2A> デフォルトの WPF フレームワーク レベル レイアウトの操作の一部として。 ただし、これは WPF フレームワーク レベルのレイアウトと WPF の中核となるレベルにある要素を具体的には派生した場合、大文字と小文字は多くの場合、レイアウト システムを使用している、 <xref:System.Windows.UIElement> 基本要素のクラスです。<xref:System.Windows.UIElement.ArrangeCore%2A> 実装を呼び出す必要がありますも <xref:System.Windows.UIElement.Arrange%2A> 子要素がある場合、各子要素です。 WPF シナリオのコア レベルが使用しないことを意味するメモ、 <xref:System.Windows.FrameworkElement> ために、派生クラスを <xref:System.Windows.FrameworkElement> シール <xref:System.Windows.FrameworkElement.ArrangeCore%2A>します。  
  
 WPF フレームワーク レベル レイアウトの配置で計算 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] から成る、 <xref:System.Windows.UIElement.Measure%2A> を呼び出すと <xref:System.Windows.UIElement.Arrange%2A> を呼び出します。 中に、 <xref:System.Windows.UIElement.Measure%2A> 呼び出し、レイアウト システムが、指定されたを使用して要素のサイズ要件を決定する <xref:System.Windows.Size> \(`availableSize`\) 引数。 中に、 <xref:System.Windows.UIElement.Arrange%2A> レイアウト システムの呼び出しは、サイズを終了し、要素の位置の境界ボックス。  詳細については、次を参照してください。 [レイアウト](http://msdn.microsoft.com/ja-jp/3eecdced-3623-403a-a077-7595453a9221)します。  
  
 `availableSize` 0 から無限大までの任意の数を指定できます。 要素をレイアウトするのには、最小値を返す <xref:System.Windows.Size> を通じて必要な `availableSize` パラメーター。  
  
 常に受信レイアウトが初めてインスタンス化されたときに、 <xref:System.Windows.UIElement.Measure%2A> 前に呼び出す <xref:System.Windows.UIElement.Arrange%2A>します。 ただし、最初のレイアウト パスに受け取ることがあります、 <xref:System.Windows.UIElement.Arrange%2A> せずに呼び出す、 <xref:System.Windows.UIElement.Measure%2A>; これは発生する場合のみに影響を与えるプロパティ <xref:System.Windows.UIElement.Arrange%2A> \(配置\) などが変更された親を受信すると、または、 <xref:System.Windows.UIElement.Arrange%2A> せず、 <xref:System.Windows.UIElement.Measure%2A>です。 A <xref:System.Windows.UIElement.Measure%2A> 呼び出しが自動的に無効になる、 <xref:System.Windows.UIElement.Arrange%2A> 呼び出します。  
  
 レイアウトの更新は、通常、非同期的に \(レイアウト システムによって決定時\) に発生します。 要素は要素のサイズ設定に影響を与えるプロパティの変更をすぐに反映されない可能性があります \(たとえば <xref:System.Windows.FrameworkElement.Width%2A>\)。  
  
> [!NOTE]
>  使用してレイアウトの更新を適用することができます、 <xref:System.Windows.UIElement.UpdateLayout%2A> メソッドです。 ただし、この関数を呼び出すことは推奨されません、通常必要はありませんし、パフォーマンスの低下が発生することができます。 多くの状況で呼び出すことが <xref:System.Windows.UIElement.UpdateLayout%2A> 適切な場合があります、レイアウト システムが既に処理更新します。 レイアウト システムでは、パッケージの一部としてすべての必要な更新プログラムを最適化した方法でレイアウト変更を処理できます。  
  
 レイアウト システムは 1 つずつ無効なレイアウトの 2 つの異なるキュー <xref:System.Windows.UIElement.Measure%2A> とに 1 つずつ <xref:System.Windows.UIElement.Arrange%2A>します。 レイアウトのキューは、ビジュアル ツリーにおける要素の順序に基づいて並べ替えられます。 ツリーの上位にある要素は、親の変更を繰り返すことによって、冗長なレイアウトを回避するために、キューの上部にです。 重複するエントリは、キューから自動的に削除されが既に有効である要素も、キューから自動的に削除します。  
  
 レイアウトを更新するときに、 <xref:System.Windows.UIElement.Measure%2A> キューが最初に、空に続けて、 <xref:System.Windows.UIElement.Arrange%2A> キューです。 内の要素、 <xref:System.Windows.UIElement.Arrange%2A> 内の要素がある場合、キューは配置しないで、 <xref:System.Windows.UIElement.Measure%2A> キューです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected virtual void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">親の末尾の領域。親の要素は要素自体と子を配置するために使用します。</param>
        <summary>WPF コア レベルの配置レイアウト定義のテンプレートを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  このメソッドをオーバーライドする、適切な場合にのみ WPF コア レベルで派生して、WPF フレームワーク レベル レイアウト システムを使用していないと <xref:System.Windows.FrameworkElement> ために、派生クラスを <xref:System.Windows.FrameworkElement> シール <xref:System.Windows.FrameworkElement.ArrangeCore%2A>します。 クラスに固有のレイアウトをオーバーライドする適切なメソッドでは、動作は、配置 WPF フレームワーク レベル レイアウト システムを使用している場合 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>します。  
  
   
  
## 例  
 <xref:System.Windows.UIElement.ArrangeCore%2A> 実装は、サイズを返すには、基本の実装を呼び出す必要がありますしを呼び出す、 <xref:System.Windows.UIElement.Arrange%2A> 各表示子要素のメソッドおよびこれらの操作で返されるサイズを調整 <xref:System.Windows.UIElement.Arrange%2A> 基本実装のサイズを使用した呼び出し。 ロジックの調整の側面を <xref:System.Windows.UIElement.ArrangeCore%2A> 、要素のレイアウト特性によって、実装が異なる場合があります。 次の例をテンプレートに `VisualChildren` ; のコンテンツを列挙するための要素を定義する仮想的なプロパティは、 <xref:System.Windows.UIElement> コンテンツのコレクションを定義していないレベルでは、WPF フレームワーク レベルのアーキテクチャが特定のコントロールまたはコントロールの基本クラスなどの派生要素にコンテンツの動作を延期します。  
  
 [!code-csharp[CorePseudocode\#UIElementArrangeOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementarrangeoverride)]
 [!code-vb[CorePseudocode\#UIElementArrangeOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementarrangeoverride)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If you are developing elements at the WPF core level,you should override this method to give your WPF core-level element a unique arrange layout behavior, or to make proper layout decisions about the child elements of your elements. An override might be necessary if those child elements are not recognizable from a defined pattern such as an <see cref="T:System.Windows.Controls.ItemCollection" />.  
  
 A parent element must call the class-specific <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> on each child element, otherwise those child elements are not rendered.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">依存関係プロパティの識別子として指定されている、アニメーション化するプロパティです。</param>
        <param name="animation">開始するアニメーションのタイムラインになります。</param>
        <summary>この要素で指定したプロパティのアニメーションを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティがアニメーション化するかどうかをチェックするときに注意してください、アニメーションが開始されと見なされるアニメーション化されていない基を超える最初のフレームがレンダリングされるときにアニメーション化します。  
  
 場合、 <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> の `animation` は `null`, 、し、現在のアニメーションが削除され、プロパティの現在の値が保持されています。  
  
 場合全体 `animation` 値は `null`, 、すべてのアニメーションがプロパティから削除され、プロパティ値の基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 そのタイムラインに割り当てられているその他のアニメーションは引き続き実行します。  
  
   
  
## 例  
 次の例は、アニメーションを作成し、割り当てを呼び出して <xref:System.Windows.UIElement.BeginAnimation%2A> を開始します。  
  
 [!code-csharp[timingbehaviors\_procedural\_snip\#BeginAnimation](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#beginanimation)]
 [!code-vb[timingbehaviors\_procedural\_snip\#BeginAnimation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#beginanimation)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">依存関係プロパティの識別子として指定されている、アニメーション化するプロパティです。</param>
        <param name="animation">適用されるアニメーションのタイムラインになります。</param>
        <param name="handoffBehavior">プロパティの値が既に影響を受けている現在の \(実行中\) のアニメーションと新しいアニメーションが対話する方法を指定する列挙型の値。</param>
        <summary>特定の内容を指定するオプションを使用して、この要素に指定されたアニメーション プロパティ アニメーションの場合は、プロパティには既に実行中のアニメーションを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティがアニメーション化するかどうかをチェックするときに注意してください、アニメーションが開始されと見なされるアニメーション化されていない基を超える最初のフレームがレンダリングされるときにアニメーション化します。  
  
 場合、 <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> の `animation` は `null`, 、し、現在のアニメーションが削除され、プロパティの現在の値が保持されています。  
  
 場合全体 `animation` 値は `null`, 、すべてのアニメーションがプロパティから削除され、プロパティ値の基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 そのタイムラインに割り当てられているその他のアニメーションは引き続き実行します。  
  
   
  
## 例  
 次の例は、リソースを呼び出し、続いてから既存のアニメーションを取得するハンドラーを実装 <xref:System.Windows.UIElement.BeginAnimation%2A> とハンドオフ動作を指定します。  
  
 [!code-csharp[BrushesIntroduction\#BeginAnimationHandoff](~/samples/snippets/csharp/VS_Snippets_Wpf/BrushesIntroduction/CSharp/SampleViewer.xaml.cs#beginanimationhandoff)]
 [!code-vb[BrushesIntroduction\#BeginAnimationHandoff](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BrushesIntroduction/visualbasic/sampleviewer.xaml.vb#beginanimationhandoff)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.BitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に描画された内容に直接適用するビットマップ効果を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>適用するビットマップ効果。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Media.Effects.BitmapEffect> そのため、抽象型は、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 使用するの実装の派生クラスには <xref:System.Windows.Media.Effects.BitmapEffect>, など <xref:System.Windows.Media.Effects.OuterGlowBitmapEffect>します。 派生したクラスが実装されている 1 つはシーケンシャルを使用すると、複数のいずれかを指定するコレクション型 <xref:System.Windows.Media.Effects.BitmapEffect>, 、入れ子になったタグ構文を使用します。  
  
 既存のクラスの派生しない <xref:System.Windows.Media.Effects.BitmapEffect> 型コンバーターをサポートしているため、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] このプロパティに使用する構文は、プロパティ要素構文では一般にします。  
  
<a name="dependencyPropertyInfo_BitmapEffect"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.BitmapEffectProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、ビットマップ効果を使用して <xref:System.Windows.Media.Effects.BlurBitmapEffect>します。  
  
 [!code-csharp[EffectsGallery\_snip\#CodeBehindBlurCodeBehindExampleInline](~/samples/snippets/csharp/VS_Snippets_Wpf/EffectsGallery_snip/CSharp/blurcodebehindexample.xaml.cs#codebehindblurcodebehindexampleinline)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.BitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に描画された内容に直接適用するビットマップ効果用の入力ソースを取得または設定します。  これは依存関係プロパティです。</summary>
        <value>ビットマップ効果のソース。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="dependencyPropertyInfo_BitmapEffectInput"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.BitmapEffectInputProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInputProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapEffectInputProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapEffectInputProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.BitmapEffectInputProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.BitmapEffectInput" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapEffectProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapEffectProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.BitmapEffectProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.BitmapEffect" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.CacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定のキャッシュされた表現、 <see cref="T:System.Windows.UIElement" />です。</summary>
        <value>A <see cref="T:System.Windows.Media.CacheMode" /> のキャッシュされた表現を保持する、 <see cref="T:System.Windows.UIElement" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定、 <xref:System.Windows.UIElement.CacheMode%2A> プロパティを表示するにはコンテンツのパフォーマンスを向上させる必要がある場合。 詳細については、「<xref:System.Windows.Media.BitmapCache>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Media3D.Viewport2DVisual3D.CacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="CacheModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.CacheModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.CacheMode" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureMouse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にマウスのキャプチャを強制しようとします。</summary>
        <returns>
          <see langword="true" /> マウスが正常にキャプチャされた場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キャプチャされる要素を有効にする必要があります。 確認するかどうか <xref:System.Windows.UIElement.IsEnabled%2A> は `true` を呼び出す前に <xref:System.Windows.UIElement.CaptureMouse%2A>します。  
  
 呼び出す場合 <xref:System.Windows.UIElement.CaptureMouse%2A> 返します `true`, 、し <xref:System.Windows.UIElement.IsMouseCaptured%2A> も `true`です。  
  
 呼び出す場合 <xref:System.Windows.UIElement.CaptureMouse%2A> を返します `true`, 、 <xref:System.Windows.UIElement.GotMouseCapture> と <xref:System.Windows.UIElement.IsMouseCapturedChanged> イベントが発生すると <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=fullName> 要素としてデータを報告するイベントの場所、 <xref:System.Windows.UIElement.CaptureMouse%2A> メソッドが呼び出されます。 キャプチャを強制する場合は、既存のキャプチャを妨げることがあります: 特にのマウスでドラッグ アンド ドロップに関連するキャプチャします。  
  
 すべての要素からマウスのキャプチャをクリアするを呼び出す <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=fullName> で、 `element` として指定されたパラメーター `null`します。  
  
   
  
## 例  
 次の例では、1 組のマウスと入力のキーの組み合わせの場合、マウスをキャプチャする \(およびキャプチャ解除\) するハンドラーを実装し、3 D モデルを表示するための特別なモードを有効にします。  
  
 [!code-csharp[CubeAnimation\#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[CubeAnimation\#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureStylus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>強制的にこの要素にスタイラスをキャプチャしようとします。</summary>
        <returns>
          <see langword="true" /> スタイラスが正常にキャプチャされた場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装を常に基になる既定のスタイラス デバイスに基づいて `true`します。 ただし、入力システムのデバイスの実装を提供する入力デバイスを拡張する場合は、異なる結果を返す可能性のある代替のスタイラス デバイスの実装を含む、システムを作成することです。  
  
 スタイラスをキャプチャする要素は、スタイラスがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このメソッドを呼び出す、基になる静的 <xref:System.Windows.Input.Stylus> メソッド <xref:System.Windows.Input.Stylus.Capture%2A>します。 実際のキャプチャの動作は、アクティブなスタイラス デバイスの実装によって実装されます。  
  
 キャプチャされる要素を有効にする必要があります。 確認するかどうか <xref:System.Windows.UIElement.IsEnabled%2A> は `true` を呼び出す前に返す <xref:System.Windows.UIElement.CaptureStylus%2A>します。  
  
 呼び出す場合 <xref:System.Windows.UIElement.CaptureStylus%2A> 返します `true`, 、<xref:System.Windows.UIElement.IsStylusCaptured%2A> も `true`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">キャプチャするデバイスです。</param>
        <summary>この要素に強制的にタッチをキャプチャしようとします。</summary>
        <returns>
          <see langword="true" /> この要素に指定したタッチがキャプチャされている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.CaptureTouch%2A> 戻ります `false` 場合、 <xref:System.Windows.Input.TouchDevice> 別の要素にキャプチャされています。  
  
 場合 <xref:System.Windows.UIElement.CaptureTouch%2A> 返します `true`, 、 <xref:System.Windows.UIElement.GotTouchCapture> イベントが発生します。  
  
 解放するにはこの要素から 1 つのタッチのキャプチャを使用して、 <xref:System.Windows.UIElement.ReleaseTouchCapture%2A> メソッドを解放する、タッチ デバイスを指定します。 解放するにはこの要素からすべてのタッチを使用して、 <xref:System.Windows.UIElement.ReleaseAllTouchCaptures%2A> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素内容の輪郭の定義に使用するジオメトリを取得または設定します。  これは依存関係プロパティです。</summary>
        <value>クリッピング領域のサイズ設定に使用するジオメトリ。 既定値は null <see cref="T:System.Windows.Media.Geometry" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Elements outside the geometry will be visually clipped in the rendered layout. The geometry does not have to be rectangular.  
  
<a name="dependencyPropertyInfo_Clip"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement.ClipProperty>|  
|Metadata properties set to **languageKeyword tag is not supported!!!!**|None|  
  
   
  
## 例  
 This example shows how to define a framework element's<xref:System.Windows.UIElement.Clip%2A>region. To define a clip, use a <xref:System.Windows.Media.Geometry> \(for example, an <xref:System.Windows.Media.EllipseGeometry>to set the element's <xref:System.Windows.UIElement.Clip%2A>property. Only the area that is within the region of the geometry will be visible.  
  
 The following example shows an <xref:System.Windows.Controls.Image>element without a defined clip region. Because no clip region is defined, the entire image is displayed.  
  
 [!code-xml[ClipPathExample\#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#2)]  
  
 978702d9-3929-48c6-aa09-c2a68b34fef0  
Image with No Clip Region  
  
 In the next example, an identical Image is created, except that it has a defined clip region. Only the part of the image that is within the area the <xref:System.Windows.Media.EllipseGeometry>will be displayed.  
  
 [!code-xml[ClipPathExample\#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#4)]  
  
 68fd09a1-032d-43c8-b3b6-f7bc1ac2c87c  
Image with an Elliptical Clip Region  
  
 The following example shows how animate a framework element's <xref:System.Windows.UIElement.Clip%2A> region. In this example, an <xref:System.Windows.Media.EllipseGeometry> is used to define an elliptical clip region for an <xref:System.Windows.Controls.Image> element. A <xref:System.Windows.Media.Animation.PointAnimation> animates the ellipse geometry's <xref:System.Windows.Media.EllipseGeometry.Center%2A> property from \(0, 0\) to \(200, 150\). The animation starts playing after the image is loaded and repeats indefinitely.  
  
 [!code-xml[ClipPathExample\#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#5)]  
  
 For the full sample, see the [Clip Region Sample](http://msdn.microsoft.com/ja-jp/83043a0b-f824-445f-9675-103280c5ca67).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="ClipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ClipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.Clip" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipToBounds">
      <MemberSignature Language="C#" Value="public bool ClipToBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClipToBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.ClipToBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親要素のサイズに合わせるために、この要素の内容 \(またはこの要素の子要素の内容\) を切り取るかどうかを示す値を取得または設定します。   これは依存関係プロパティです。</summary>
        <value>コンテンツをクリップする必要がある場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 For child elements, <xref:System.Windows.UIElement.ClipToBounds%2A> has different effects on layout behaviors depending on whether the height and width of the parent element are being determined by <xref:System.Windows.FrameworkElement.Height%2A> \/ <xref:System.Windows.FrameworkElement.Width%2A> or <xref:System.Windows.FrameworkElement.MaxHeight%2A> \/ <xref:System.Windows.FrameworkElement.MaxWidth%2A>. <xref:System.Windows.FrameworkElement.MaxHeight%2A> \/ <xref:System.Windows.FrameworkElement.MaxWidth%2A> of the parent element are always respected regardless of the value of <xref:System.Windows.UIElement.ClipToBounds%2A> and the effective clipping will always clip the content based on these maximums. The parent's <xref:System.Windows.FrameworkElement.Height%2A> \/ <xref:System.Windows.FrameworkElement.Width%2A> settings will not clip the content when <xref:System.Windows.UIElement.ClipToBounds%2A> is **languageKeyword tag is not supported!!!!**  
, but will clip the content if <xref:System.Windows.UIElement.ClipToBounds%2A> is **languageKeyword tag is not supported!!!!**  
.  
  
 Note that defaulting to **languageKeyword tag is not supported!!!!**  
 is the general behavior as implemented in the <xref:System.Windows.UIElement> class. It is possible for any given element that derives from <xref:System.Windows.UIElement> to override the dependency property metadata for this property in that instance to default to **languageKeyword tag is not supported!!!!**  
 instead. Several existing derived classes override this metadata and\/or adjust the dependency property default value.  
  
 <xref:System.Windows.Controls.InkCanvas>, <xref:System.Windows.Controls.InkPresenter>, and <xref:System.Windows.Controls.Primitives.Popup> each override the default value to be `true`.  
  
 <xref:System.Windows.FrameworkElement> overrides the metadata for this dependency property. Specifically, <xref:System.Windows.FrameworkElement> designates this property to allow property value inheritance \(<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata\). Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.UIElement.ClipToBounds%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned \(again, either in styles, by default values, or a locally value\), then the value from the parent element will be assigned to all unassigned child elements by the property system. In practice this means that you can specify whether to allow clip to bounds at the root element, and that value will propagate to all child elements that have not specifically assigned it as `false`.  
  
<a name="dependencyPropertyInfo_ClipToBounds"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement.ClipToBoundsProperty>|  
|Metadata properties set to **languageKeyword tag is not supported!!!!**|None|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="ClipToBoundsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClipToBoundsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClipToBoundsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ClipToBoundsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.ClipToBounds" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コレクションを取得 <see cref="T:System.Windows.Input.CommandBinding" /> この要素に関連付けられているオブジェクト。 A <see cref="T:System.Windows.Input.CommandBinding" /> この要素のコマンドの処理を有効にし、コマンド、そのイベントでは、この要素にアタッチされたハンドラー間のリンケージを宣言します。</summary>
        <value>すべてのコレクション <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 別の一般的な方法を設定する、 <xref:System.Windows.UIElement.CommandBindings%2A> コレクションは、使用する <xref:System.Windows.Input.CommandManager> メソッド プログラムを使用しています。  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## XAML プロパティ要素の使用  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  
  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## XAML 値  
 *oneOrMoreCommandBindings*  
 1 つまたは複数 <xref:System.Windows.Input.CommandBinding> 要素。 これらの各、 <xref:System.Windows.Input.CommandBinding.Command%2A> 属性既知のコマンドに設定され、に対して属性が設定、 <xref:System.Windows.Input.CommandBinding.CanExecute> と <xref:System.Windows.Input.CommandBinding.Executed> ハンドラーの実装です。 詳細については、「<xref:System.Windows.Input.CommandBinding>」を参照してください。  
  
   
  
## 例  
 次の例では追加、 <xref:System.Windows.Input.CommandBinding> マークアップを使用して、ウィンドウにします。 において [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], 、 <xref:System.Windows.Input.CommandBindingCollection> マークアップには、要素として宣言されていないプロパティには、型によっては、コレクション オブジェクトが推論され、1 つまたは複数のプロパティ要素を格納する <xref:System.Windows.Input.CommandBinding> 要素。  
  
 [!code-xml[commandWithHandler\#CommandHandlerCommandBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml#commandhandlercommandbinding)]  
  
 詳細については、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] コレクションは、構文を参照してください [XAML 構文の詳細](http://msdn.microsoft.com/ja-jp/67cce290-ca26-4c41-a797-b68aabc45479)します。  
  
 次の例は、本質的には、同じことをコードで実行します。  
  
 [!code-csharp[CommandHandlerProcedural\#CommandHandlerBindingInit](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandHandlerProcedural/CSharp/Window1.xaml.cs#commandhandlerbindinginit)]
 [!code-vb[CommandHandlerProcedural\#CommandHandlerBindingInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandHandlerProcedural/visualbasic/window1.xaml.vb#commandhandlerbindinginit)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="DesiredSize">
      <MemberSignature Language="C#" Value="public System.Windows.Size DesiredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size DesiredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.DesiredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト処理の測定パスの実行中に、この要素が計算したサイズを取得します。</summary>
        <value>計算されたサイズ。これが、配置パスの目的のサイズになります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The value returned by this property will only be a valid measurement if the value of the <xref:System.Windows.UIElement.IsMeasureValid%2A> property is **languageKeyword tag is not supported!!!!**  
.  
  
 <xref:System.Windows.UIElement.DesiredSize%2A> is typically checked as one of the measurement factors when you implement layout behavior overrides such as <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>, <xref:System.Windows.FrameworkElement.MeasureOverride%2A>, or <xref:System.Windows.UIElement.OnRender%2A> \(in the <xref:System.Windows.UIElement.OnRender%2A> case, you might check <xref:System.Windows.UIElement.RenderSize%2A> instead, but this depends on your implementation\). Depending on the scenario, <xref:System.Windows.UIElement.DesiredSize%2A> might be fully respected by your implementation logic, constraints on <xref:System.Windows.UIElement.DesiredSize%2A> might be applied, and such constraints might also change other characteristics of either the parent element or child element. For example, a control that supports scrollable regions \(but chooses not to derive from the WPF framework\-level controls that already enable scrollable regions\) could compare available size to <xref:System.Windows.UIElement.DesiredSize%2A>. The control could then set an internal state that enabled scrollbars in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] for that control. Or, <xref:System.Windows.UIElement.DesiredSize%2A> could potentially also be ignored in certain scenarios.  
  
   
  
## 例  
 The following example shows <xref:System.Windows.UIElement.DesiredSize%2A> as part of a <xref:System.Windows.FrameworkElement.MeasureOverride%2A> implementation. Notice how <xref:System.Windows.UIElement.Measure%2A> is called immediately prior to obtaining <xref:System.Windows.UIElement.DesiredSize%2A>. This assures that <xref:System.Windows.UIElement.DesiredSize%2A> holds a legitimate value.  
  
 [!code-cpp[PlotPanel\#2](~/samples/snippets/cpp/VS_Snippets_Wpf/PlotPanel/CPP/PlotPanel.cpp#2)]
 [!code-csharp[PlotPanel\#2](~/samples/snippets/csharp/VS_Snippets_Wpf/PlotPanel/CSharp/PlotPanel.cs#2)]
 [!code-vb[PlotPanel\#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PlotPanel/VisualBasic/PlotPanel.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName> attached event for this class, so that <xref:System.Windows.UIElement.DragEnter?displayProperty=fullName> is part of the class members list when <xref:System.Windows.UIElement> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.UIElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName> attached event and receive the same event data instance.  
  
<a name="routedEventInfo_DragEnter"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement.DragEnterEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.UIElement.PreviewDragEnter>.  
  
-   Override <xref:System.Windows.UIElement.OnDragEnter%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
        <altmember cref="E:System.Windows.UIElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.DragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName> attached event for this class so that <xref:System.Windows.UIElement.DragLeave?displayProperty=fullName> is part of the class members list when <xref:System.Windows.UIElement> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.UIElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName> attached event and receive the same event data instance.  
  
<a name="routedEventInfo_DragLeave"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement.DragLeaveEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.  
  
-   Override <xref:System.Windows.UIElement.OnDragLeave%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
        <altmember cref="E:System.Windows.UIElement.DragOver" />
        <altmember cref="E:System.Windows.UIElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.DragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event occurs even if the drag originates in the element bounds. If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.UIElement.DragEnter> and related preview events.  
  
 This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=fullName> attached event for this class so that <xref:System.Windows.UIElement.DragOver?displayProperty=fullName> is part of the class members list when <xref:System.Windows.UIElement> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.UIElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=fullName> attached event and receive the same event data instance.  
  
<a name="routedEventInfo_DragOver"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement.DragOverEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.  
  
-   Override <xref:System.Windows.UIElement.OnDragOver%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
        <altmember cref="E:System.Windows.UIElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.DragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.Drop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=fullName> attached event for this class so that <xref:System.Windows.UIElement.Drop?displayProperty=fullName> is part of the class members list when <xref:System.Windows.UIElement> is inherited as a base element. Event handlers that are attached to the <xref:System.Windows.UIElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=fullName> attached event and receive the same event data instance.  
  
<a name="routedEventInfo_Drop"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.UIElement.DropEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   The corresponding tunneling event is <xref:System.Windows.UIElement.PreviewDrop>.  
  
-   Override <xref:System.Windows.UIElement.OnDrop%2A> to implement class handling for this event in derived classes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragOver" />
        <altmember cref="E:System.Windows.UIElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.Drop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Routed event identifiers are created when routed events are registered. These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event. You can use these identifiers to add class handlers.  
  
 For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Effect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定に適用するビットマップ効果、 <see cref="T:System.Windows.UIElement" />です。 これは依存関係プロパティです。</summary>
        <value>
          <see cref="T:System.Windows.Media.Effects.Effect" /> ビットマップ効果を表します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Windows.UIElement.Effect%2A> にビットマップ効果を適用するプロパティ、 <xref:System.Windows.UIElement>です。  
  
<a name="dependencyPropertyInfo_Effect"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.EffectProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の XAML は、カスタムに割り当てる方法を示しています。 <xref:System.Windows.Media.Effects.ShaderEffect> に、 <xref:System.Windows.UIElement.Effect%2A> プロパティです。  
  
 [!code-xml[System.Windows.Media.Effects.ShaderEffect\#1000](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Media.Effects.ShaderEffect/CS/Window1.xaml#1000)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="EffectProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EffectProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EffectProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.EffectProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.Effect" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にフォーカスを設定しようとします。</summary>
        <returns>
          <see langword="true" /> この要素にキーボード フォーカスと論理フォーカスが設定されている場合 <see langword="false" /> 論理フォーカスは、この要素に設定された場合のみ、またはこのメソッドの呼び出しに変更にフォーカスが強制実行されません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスを <xref:System.Windows.UIElement.Focusable%2A> と <xref:System.Windows.UIElement.IsEnabled%2A> 両方 `true`します。  
  
 でも要素の場合は特定のツリー内でのフォーカスを取得できる、有効な場合は、イベント処理、フォーカスのある、許可しないことによって、プレビューのフォーカス イベントに応答 \(複合コントロールなど\) ためこのメソッドは `false`です。  
  
 一般にフォーカスが 2 つの異なる概念によって制御されます。 キーボード フォーカスと論理フォーカスは、常に同じではありません。  詳細については、次を参照してください。 [フォーカス概要](http://msdn.microsoft.com/ja-jp/0230c4eb-0c8a-462b-ac4b-ae3e511659f4) または [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
 呼び出す場合 <xref:System.Windows.UIElement.Focus%2A> 返します `true`, 、<xref:System.Windows.UIElement.IsKeyboardFocused%2A> と <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> も `true`です。  
  
 関連するプロパティがない場合 `true`, を呼び出したときに、  <xref:System.Windows.UIElement.Focus%2A>, 、1 つ以上の次のイベントが次の順序で発生します: <xref:System.Windows.UIElement.PreviewLostKeyboardFocus>, 、<xref:System.Windows.UIElement.PreviewGotKeyboardFocus> \(ソースは新しいフォーカス ターゲット\)、 <xref:System.Windows.UIElement.IsKeyboardFocusedChanged>, 、<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>, 、<xref:System.Windows.UIElement.LostKeyboardFocus>, 、<xref:System.Windows.UIElement.GotKeyboardFocus> \(ソースは新しいフォーカス ターゲット\)。  
  
 この呼び出しを成功させるためには、アプリケーションの他の要素は、以前にフォーカスがあるに必要です。  
  
   
  
## 例  
 次の例では、フォーカスを設定、 <xref:System.Windows.Controls.TextBox> によって参照される <xref:System.Windows.FrameworkElement.Name%2A>, 、内でカーソルの位置を調整し、 <xref:System.Windows.Controls.TextBox>です。  
  
 [!code-csharp[TextBox\_CursorToEnd\#UIElementFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBox_CursorToEnd/CSharp/Window1.xaml.cs#uielementfocus)]
 [!code-vb[TextBox\_CursorToEnd\#UIElementFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBox_CursorToEnd/VisualBasic/Window1.xaml.vb#uielementfocus)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Focusable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素がフォーカスを得ることができるかどうかを示す値を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>要素がフォーカス可能な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> ですが、「解説」をご覧ください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスがある要素だけでは、キーボード入力を受け取ります。  
  
 <xref:System.Windows.UIElement.Focusable%2A> [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] 何が実際には、依存関係プロパティのプロパティ アクセサー。 この特定の依存関係プロパティでは、コントロールでは特に、派生した要素のクラスで設定が異なります見かけ上の「既定」値が非常によくあります。 これは、2 つの方法のいずれかで一般的に発生します。  
  
-   特定の派生クラスで依存関係プロパティが継承されますが、派生したクラスのオーバーライドの依存関係プロパティのメタデータとプロパティの既定値を変更します。  
  
-   スタイルまたはテンプレートは、その依存関係プロパティの値を異なる方法で設定を含む要素に適用されます。  
  
 などの明らかな「既定」の <xref:System.Windows.UIElement.Focusable%2A> の <xref:System.Windows.Controls.Button> コントロールする `true`, 場合でも、 <xref:System.Windows.Controls.Button> 継承 <xref:System.Windows.UIElement.Focusable%2A> として、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] プロパティから直接 <xref:System.Windows.UIElement>します。 これは、適用されているメタデータの値のため、 <xref:System.Windows.UIElement.Focusable%2A> の静的コンス トラクター内で依存関係プロパティのオーバーライドが、 <xref:System.Windows.Controls.Control> 基本クラスで、間に配置 <xref:System.Windows.Controls.Button> と <xref:System.Windows.UIElement> クラス階層です。  
  
 によって継承される <xref:System.Windows.Controls.Control> またはその派生クラスでは、 <xref:System.Windows.Controls.Control> にするには、このプロパティの既定値を再定義 `true`します。  
  
 によって継承される <xref:System.Windows.Controls.Label> \(これは、 <xref:System.Windows.Controls.Control> 派生クラス\)、既定値がもう一度再定義する `false`です。  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.FocusableProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次のコード例は、特定のカスタム コントロールを設定するためのコントロール テンプレートを示しています。 <xref:System.Windows.UIElement.Focusable%2A> `false` テンプレート内の要素のいずれかにします。  
  
 [!code-xml[RichTextBox\_NoScrollViewer\#\_ControlTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBox_NoScrollViewer/CS/window1.xaml#_controltemplate)]
 [!code-xml[RichTextBox\_NoScrollViewer\#\_ControlTemplate](~/samples/snippets/xaml/VS_Snippets_Wpf/RichTextBox_NoScrollViewer/xaml/window1.xaml#_controltemplate)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When deriving from <see cref="T:System.Windows.UIElement" /> directly (as opposed to from <see cref="T:System.Windows.Controls.Control" />), consider whether you wish your element to be focusable, because by default the element will not be focusable. If you wish your element to be focusable, override the metadata for this property within your type's static constructor as follows:  
  
 [!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
 [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
 where <paramref name="myElement" /> should be the class name of the type that you are overriding the metadata value on.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.FocusableChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.Focusable" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.Focusable" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">確認する依存関係プロパティ。</param>
        <summary>この要素の、指定したプロパティの基本プロパティ値を返します。実行中または停止済みのアニメーションでアニメーション化された値は無視されます。</summary>
        <returns>指定した依存関係プロパティにアニメーションが添付されていないような場合のプロパティ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティのアニメーションが添付されていない場合、 <xref:System.Windows.UIElement.GetAnimationBaseValue%2A> に戻り値は常に、 <xref:System.Windows.DependencyObject.GetValue%2A> の値を返します。 添付されたアニメーションがある場合は、可能なすべてのアニメーションが開始などの値を派生し、停止の値は無視され、プロパティ値が他のすべての可能な入力に基づいて決定します。 詳細については、次を参照してください。 [依存関係プロパティの値の優先順位](http://msdn.microsoft.com/ja-jp/1fbada8e-4867-4ed1-8d97-62c07dad7ebc)します。  
  
   
  
## 例  
 次の例は、アニメーションの基本値を報告するハンドラーを実装 <xref:System.Windows.FrameworkElement.Width%2A> プロパティを <xref:System.Windows.Controls.Button>, 、トランス フォームの基本値とします。  
  
 [!code-csharp[timingbehaviors\_procedural\_snip\#GetAnimationBaseValue](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#getanimationbasevalue)]
 [!code-vb[timingbehaviors\_procedural\_snip\#GetAnimationBaseValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#getanimationbasevalue)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">要素によって提供される使用可能なサイズ。</param>
        <summary>
          <see cref="P:System.Windows.UIElement.ClipToBounds" /> が <see langword="true" /> に設定される場合にクリップされる領域を表す代替クリッピング ジオメトリを返します。</summary>
        <returns>潜在的なクリッピング ジオメトリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装は正当な値を返しますが、使用しない、 `layoutSlotSize` パラメーターが計算されます。 値を使用する代わりに <xref:System.Windows.UIElement.RenderSize%2A>します。  
  
 このメソッドはオーバーライドが大幅にすぐに派生して <xref:System.Windows.FrameworkElement> クラス、および <xref:System.Windows.FrameworkElement> 一般的な WPF フレームワーク レベルの要素に対してより高度な動作が生成されるオーバーライドします。 詳細については、「<xref:System.Windows.FrameworkElement.GetLayoutClip%2A?displayProperty=fullName>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetUIParentCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、別の方法を返す ユーザー インターフェイス (UI) ビジュアル親が存在しない場合、この要素の親です。</summary>
        <returns>派生クラスの実装が代替親レポートに接続している場合のオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの既定の仮想実装 `null`します。<xref:System.Windows.FrameworkElement> 実用的な実装を提供します。  
  
 別の親は、要素が別の親の構造体を作成することで、そのイベントは、標準の親にビジュアル ツリーをルーティングの標準的なパターンから逸脱した方法でルーティングまたはプレビュー ルーティング戦略の下位方向へ場所の場合、イベントのルーティングに使用されます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素を対象とするドラッグ アンド ドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.GiveFeedback> イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。 視覚的なフィードバックは、ドラッグ アンド ドロップ操作が、プロセスを強化します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.UIElement.GiveFeedback> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.GiveFeedback> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.GiveFeedbackEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewGiveFeedback>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnGiveFeedback%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.GiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスがメソッド呼び出しを使用して強制的に意図的に直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 ここでは、要素にキーボード フォーカスが残り、このシナリオで、 <xref:System.Windows.UIElement.Focus%2A> メソッドはまだ論理フォーカスを取得します。  
  
 このイベントのより正確な解釈がその it 発生する状況の値、 <xref:System.Windows.UIElement.IsFocused%2A> からルート内の要素のプロパティが変更された `false` に `true`します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを受け取る要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを得られる実際の要素を特定のイベント データ。  
  
<a name="routedEventInfo_GotFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.GotFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnGotFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.GotFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.IsKeyboardFocusedChanged> 要素のフォーカスの状態を保持するプロパティの状態の変更を追跡するようなイベント <xref:System.Windows.UIElement.GotKeyboardFocus> イベントは、多くの同じ状況で発生します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際にアタッチされている要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスがある実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.UIElement.GotKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.GotKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.GotKeyboardFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewGotKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnGotKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.GotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotMouseCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウスをキャプチャする要素は、境界外にマウス ポインターがあって、マウス入力を受け取ります。 マウスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャしは、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャされたします。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> 、イベントをマウスを持つ実際の要素を特定のデータをキャプチャします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.UIElement.GotMouseCapture> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.GotMouseCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.GotMouseCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnGotMouseCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.GotMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotStylusCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスをキャプチャする要素は、ポインターがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスでは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャを保持します。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> 、イベント データがキャプチャを持つ実際の要素を特定します。  
  
 このイベントは、このクラスにアタッチされるイベントのエイリアスを作成できるように <xref:System.Windows.UIElement.GotStylusCapture> 一部であるクラスのメンバー一覧をいつ <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.GotStylusCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.GotStylusCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnGotStylusCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.GotStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotTouchCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、タッチがキャプチャされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.GotTouchCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnGotTouchCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.GotTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、アニメーション化されたプロパティが設定されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素は、アニメーションのプロパティのいずれかに接続されている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返します `true` \(ロック、常に実行されている\) のアニメーションの永続的なまたは特定のタイムラインのアニメーションです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasEffectiveKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual bool HasEffectiveKeyboardFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEffectiveKeyboardFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.HasEffectiveKeyboardFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.UIElement" /> にフォーカスがあるかどうかを示す値を取得します。</summary>
        <value>
          <see cref="T:System.Windows.UIElement" /> にフォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Subclasses can override this property to specify when the element has keyboard focus.  This is useful when your <xref:System.Windows.UIElement> contains elements that can have keyboard focus and you want your element to report that it has focus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">実行するヒット テストについて、初期ヒット ポイントも含めて、記述します。</param>
        <summary>実装して <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /> base を指定する要素のヒット テスト動作 \(返す <see cref="T:System.Windows.Media.GeometryHitTestResult" />\)。</summary>
        <returns>評価されたジオメトリを含むテストの結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 元の仮想メソッドを参照してください <xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=fullName> についてはさらにこのメソッドをオーバーライドするクラスを派生する場合。 注意いくつかの特定のコントロール \(<xref:System.Windows.Controls.TextBlock>, など\) は個別の実装は、この 1 つをオーバーライドします。  
  
 このメソッドは、アプリケーション コードから呼び出されるものでありません。 このメソッドは、\(マウス ポインターがたとえばが要素上\) かどうかは、入力システムのさまざまな側面によって公開される内部のヒット テストの動作をサポートします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">実行するヒット テストについて、初期ヒット ポイントも含めて、記述します。</param>
        <summary>
          <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" /> を実装して、要素のヒット テストの基本動作を提供します \(<see cref="T:System.Windows.Media.HitTestResult" /> を返します\)。</summary>
        <returns>評価されたポイントを含む、テストの結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 元の仮想メソッドを参照してください <xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=fullName> についてはさらにこのメソッドをオーバーライドするクラスを派生する場合。 注意してくださいいくつかの特定のコントロール \(<xref:System.Windows.Controls.TextBlock>, など\)、オーバーライドの実装にが <xref:System.Windows.UIElement.HitTestCore%2A> で定義されている <xref:System.Windows.UIElement>します。  
  
 このメソッドは、アプリケーション コードから呼び出されるものでありません。 このメソッドは、\(マウス ポインターがたとえばが要素上\) かどうかは、入力システムのさまざまな側面によって公開される内部のヒット テストの動作をサポートします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関連付けられている入力のバインディングのコレクションを取得します。</summary>
        <value>入力バインディングのコレクションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 入力バインディングは、コマンドを入力デバイスのバインディングをサポートします。 たとえば、 <xref:System.Windows.Input.MouseBinding> 入力マウス デバイスに固有のプロパティを含むバインディングを実装します。  
  
 入力バインディングとバインディングのインスタンスを宣言するだけでなく、型に関連する、入力バインディングのコレクションが含まれます。  
  
 関連するプロパティ、 <xref:System.Windows.UIElement.CommandBindings%2A>, 、コマンドのショートカット キーのコレクションを保持します。 これは、プロセスは停止コマンドの処理 \- 既知のコマンドに関連付けられているアクションの次のレベルを表しているという点で入力バインディングとは異なります。  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## XAML プロパティ要素の使用  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  
  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## XAML 値  
 *oneOrMoreInputBindings*  
 1 つまたは複数 <xref:System.Windows.Input.InputBinding> 要素 \(通常、 <xref:System.Windows.Input.KeyBinding> または <xref:System.Windows.Input.MouseBinding> 派生クラス\)。 これらの各が予期、 <xref:System.Windows.Input.InputBinding.Command%2A> と <xref:System.Windows.Input.InputBinding.Gesture%2A> 属性が設定されます。  
  
   
  
## 例  
 次の例では、このプロパティを設定で、 <xref:System.Windows.Window>, を 1 つの <xref:System.Windows.Input.KeyBinding>です。  
  
 [!code-xml[CommandingOverviewSnippets\#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 詳細については、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] コレクションは、構文を参照してください [XAML 構文の詳細](http://msdn.microsoft.com/ja-jp/67cce290-ca26-4c41-a797-b68aabc45479)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="InputHitTest">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement InputHitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.IInputElement InputHitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">オフセットは、この要素内で調整します。</param>
        <summary>現在の要素の原点に対する、指定した座標位置にある現在の要素内の入力要素を返します。</summary>
        <returns>指定された位置にある子要素です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.IInputElement> その型が共通のインターフェイスの両方であるために、戻り値の型として返される <xref:System.Windows.UIElement> と <xref:System.Windows.ContentElement>です。 戻り値の型を適切にキャストまたはインターフェイスのインスタンスで定義されている特定のメンバーを使用することができますし、 <xref:System.Windows.IInputElement> インターフェイスです。  
  
 このメソッドは、通常、アプリケーション コードからは呼び出されません。 このメソッドを呼び出すことは、大量の既にマウス デバイス ロジックを再作成するなど、提供されている低レベルの入力機能を再実装する場合に適切なはのみです。  
  
 <xref:System.Windows.IContentHost> コントラクト、 <xref:System.Windows.IContentHost.InputHitTest%2A> を明示的に実装するいくつかの要素を選択する同じシグネチャを持つメソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateArrange">
      <MemberSignature Language="C#" Value="public void InvalidateArrange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateArrange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateArrange" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要素の配置状態 \(レイアウト\) を無効にします。 無効にした後、要素のレイアウトが更新されます。更新は、<see cref="M:System.Windows.UIElement.UpdateLayout" /> によって強制されない限り非同期に行われます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出しを頻繁に <xref:System.Windows.UIElement.InvalidateArrange%2A> または特にに <xref:System.Windows.UIElement.UpdateLayout%2A> 大幅なパフォーマンスへの影響です。 したがって、他の後続の呼び出しの正確なレイアウト状態が絶対に必要とされないかぎり、このメソッドを呼び出す [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] コードにします。 高度なシナリオを呼び出すことができます <xref:System.Windows.UIElement.InvalidateArrange%2A> を作成するかどうかは、 <xref:System.Windows.PropertyChangedCallback> に含まれていない依存関係プロパティの <xref:System.Windows.Freezable> または <xref:System.Windows.FrameworkElement> が変更されたときに、レイアウトの配置パスをまだに作用するクラスを派生します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateMeasure">
      <MemberSignature Language="C#" Value="public void InvalidateMeasure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateMeasure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateMeasure" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要素の測定状態 \(レイアウト\) を無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 また呼び出しでこのメソッドを呼び出す <xref:System.Windows.UIElement.InvalidateArrange%2A> 内部的を呼び出す必要はありません <xref:System.Windows.UIElement.InvalidateMeasure%2A> と <xref:System.Windows.UIElement.InvalidateArrange%2A> を連続しています。 無効化、要素が作成されますしない限り、非同期的に発生するレイアウト更新 <xref:System.Windows.UIElement.UpdateLayout%2A> 同期レイアウトの変更を強制的に呼び出されます。  
  
 WPF フレームワーク レベル レイアウト システムは、要素のビジュアル ツリー内の変更の処理を行い、レイアウト システムが必要な場合にこのメソッドの同等機能を呼び出す最も一般的なレイアウトの無効化の場合。 直接操作する要素のツリーまたはのようなシナリオを高度なレイアウトの完全な実装を作成する場合にのみ、このメソッドを呼び出す必要があります。 このような高度なシナリオの 1 つは、作成するかどうかは、 <xref:System.Windows.PropertyChangedCallback> に含まれていない依存関係プロパティの <xref:System.Windows.Freezable> または <xref:System.Windows.FrameworkElement> が変更されたときに、レイアウトの測定のパスをまだに影響を与えるクラスを派生します。  
  
 呼び出しを頻繁に <xref:System.Windows.UIElement.InvalidateMeasure%2A> または特にに <xref:System.Windows.UIElement.UpdateLayout%2A> 大幅なパフォーマンスへの影響です。 したがって、他の後続の呼び出しの正確なレイアウト状態が絶対に必要とされないかぎり、このメソッドを呼び出す [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] コードにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateVisual">
      <MemberSignature Language="C#" Value="public void InvalidateVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateVisual() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateVisual" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要素の描画を無効にして、新しい完全なレイアウト パスを強制します。 レイアウト サイクルが完了した後に、<see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" /> が呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す <xref:System.Windows.UIElement.InvalidateArrange%2A> 内部的にします。  
  
 一般に、このメソッドは、アプリケーション コードからは呼び出されません。 WPF フレームワーク レベル レイアウト システムは、要素のビジュアル ツリー内の変更の処理、必要な場合にこのメソッドの同等機能を呼び出すことは既にします。 このメソッドを呼び出すことは、高度なシナリオでのみ必要があります。 このような高度なシナリオの 1 つは、作成するかどうかは、 <xref:System.Windows.PropertyChangedCallback> に含まれていない依存関係プロパティの <xref:System.Windows.Freezable> または <xref:System.Windows.FrameworkElement> が変更されたときに、レイアウトをまだに作用するクラスを派生します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.InvalidateArrange" />
      </Docs>
    </Member>
    <Member MemberName="IsArrangeValid">
      <MemberSignature Language="C#" Value="public bool IsArrangeValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArrangeValid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsArrangeValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素のレイアウトの子要素の位置と計算されたサイズが有効かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> サイズとレイアウトの位置が有効な場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 配置を呼び出すことによって無効化を強制する <xref:System.Windows.UIElement.InvalidateArrange%2A> この要素 \(またはその親\) にします。 これはフラグ タイミングでレイアウト システムが決定の再構成のレイアウトです。 またはを即時に呼び出す <xref:System.Windows.UIElement.UpdateLayout%2A> できても、これは、それ以上の無効化に保留されていないことが確実である場合にのみ実行してありますが、\(多数の強制が不必要に更新は、パフォーマンスへの影響を持ちます\)。  
  
 <xref:System.Windows.UIElement.IsArrangeValid%2A> ことはできません `true` しない限り、 <xref:System.Windows.UIElement.IsMeasureValid%2A> も `true` \(レイアウト プロセスで配置することはできません有効な計測項目は最初に有効ななし\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.InvalidateArrange" />
        <altmember cref="P:System.Windows.UIElement.IsMeasureValid" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が ユーザー インターフェイス (UI) で有効かどうかを示す値を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>コンポーネントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クラスに固有の実装によってこのプロパティは影響を受けることに注意してください <xref:System.Windows.UIElement.IsEnabledCore%2A> 実行時に多くの場合、特定の要素にします。 したがって、ここで表示されている既定値がありますいない効果的です。 たとえば、 <xref:System.Windows.Controls.Primitives.ScrollBar> は <xref:System.Windows.UIElement.IsEnabled%2A> `false` スクロール バーをサポートする必要がないと判断には、ときにします。  この値を設定しようとしても可能性があるによってオーバーライドされますによって返される値 <xref:System.Windows.UIElement.IsEnabledCore%2A>です。  
  
 有効になっていない要素は、ヒット テストやフォーカスに参加していないと、そのため、入力イベントのソースはできません。  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsEnabledProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例ことを示していますハンドラー 1 つのボタンで実行されるは設定時に <xref:System.Windows.UIElement.IsEnabled%2A> `false` 別の名前付きのボタン上 `b1`します。  
  
 [!code-csharp[RoutedEventAddRemoveHandler\#Handler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventAddRemoveHandler/CSharp/default.xaml.cs#handler)]
 [!code-vb[RoutedEventAddRemoveHandler\#Handler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventAddRemoveHandler/VisualBasic/default.xaml.vb#handler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsEnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsEnabledChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement.IsEnabled" /> プロパティでこの要素を変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>戻り値になる値を取得 <see cref="P:System.Windows.UIElement.IsEnabled" /> 派生クラスです。</summary>
        <value>コンポーネントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled. (If the parent is not enabled, the child element cannot be effectively enabled in practical [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.  
  
 The <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> class provides an existing override implementation of this property. This override determines whether the content inside the content presentation area exceeds the available area. If the content does exceed the area, the scrollbar portion is enabled. Otherwise, the scrollbar is not enabled.</para>
        </block>
        <altmember cref="E:System.Windows.UIElement.IsEnabledChanged" />
        <altmember cref="P:System.Windows.UIElement.IsEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsEnabled" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に論理フォーカスがあるかどうかを判断する値を取得します。  これは依存関係プロパティです。</summary>
        <value>この要素に論理フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーションは、複数のフォーカス区分をなど\] メニューの内容と、アプリケーションの残りの部分の間に、論理フォーカスはキーボード フォーカスと異なる場合があります。 このシナリオでは、アプリケーションの UI の 1 つの要素にキーボード フォーカスが設定できるだけ、ただし、他のフォーカス区分の特定の要素がありますも保持する論理フォーカスします。 論理フォーカスの詳細については、次を参照してください。 [フォーカス概要](http://msdn.microsoft.com/ja-jp/0230c4eb-0c8a-462b-ac4b-ae3e511659f4)します。  
  
 \(これは読み取り専用\)、このプロパティを設定してフォーカスを設定しないとします。 このプロパティの一般的な使用方法がの依存関係プロパティとして使用するには、 <xref:System.Windows.Setter> または <xref:System.Windows.EventTrigger>です。 フォーカスを設定するプログラムを使用して、 <xref:System.Windows.UIElement.Focus%2A>です。 ユーザーによる操作やマウスのキャプチャの動作を含む可能性、コントロールの実装で、フォーカスを設定もできます。  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsFocusedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例にフォーカスがあるときに、コントロールの背景を変更するコード ハンドラーです。  
  
 [!code-csharp[PopupSimple\#IsFocused](~/samples/snippets/csharp/VS_Snippets_Wpf/PopupSimple/CSharp/Window1.xaml.cs#isfocused)]  
  
 配置には、これと同じ効果を実現するために一般的な方法、 <xref:System.Windows.Trigger> で、 <xref:System.Windows.Style> コントロールのこのアプローチ分離コードを含む特定のイベントの処理は必要ありませんし、デザイナー大きいに対するアクセスの対話型、およびグラフィカル性質、 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]です。 例については、「[How to: Create an Outer Glow Effect](http://msdn.microsoft.com/ja-jp/a2ccf19a-d0dc-4e3c-88e3-95d7f7d765b1)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisible">
      <MemberSignature Language="C#" Value="public bool IsHitTestVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHitTestVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsHitTestVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が、表示される内容のある部分からのヒット テストの結果として返されるかどうかを宣言する値を取得または設定します。 これは依存関係プロパティです。</summary>
        <value>少なくとも 1 つの点からヒット テストの結果としてこの要素が返される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティで有効な値は、論理ツリー内のヒット テスト可能な要素の相対位置が反映されます。 たとえば、要素の子要素にある要素が表示されているテストをヒットしません、子のプロパティの有効な値のまま `false`, 場合でも、その値をローカルに設定しようとしています。 この理由は、設定しないことが重要 <xref:System.Windows.UIElement.IsHitTestVisible%2A> に `false` 複合コントロールの任意の入力を必要なまたはそのコントロールでヒット テストしない限り、します。 ヒット テストの詳細については、次を参照してください。 [ビジュアル層でテスト ヒット](http://msdn.microsoft.com/ja-jp/b1a64b61-14be-4d75-b89a-5c67bebb2c7b)します。  
  
<a name="dependencyPropertyInfo_IsHitTestVisible"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsHitTestVisibleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsHitTestVisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsHitTestVisibleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement.IsHitTestVisible" /> この要素に依存関係プロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHitTestVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHitTestVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsHitTestVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsHitTestVisible" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Input Method Editor \(IME\) などの入力方式システムがこの要素への入力の処理に対して有効になっているかどうかを示す値を取得します。</summary>
        <value>入力方式がアクティブである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 基礎となる添付プロパティの既定値は <see langword="true;" /> ですが、この値は実行時の入力方式の実際の状態の影響を受けます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 添付プロパティによって返される値を返します <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=fullName> 現在有効な入力方法 \(キーボード、音声、およびその他の入力デバイス\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがあるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>この要素にキーボード フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスに関連するイベントは、このプロパティの値への変更を伴うことができます。  
  
 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> でよく使われるクラスのイベント ハンドラー内でその他の入力に関連するイベントのインスタンス要素は既にキーボード フォーカス、またはイベントとキーボード イベントで組み合わせて発生時のマウスを決定するかを決定します。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsKeyboardFocusedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotFocus" />
        <altmember cref="E:System.Windows.UIElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsKeyboardFocusedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement.IsKeyboardFocused" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsKeyboardFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キーボード フォーカスがその要素またはそのビジュアル ツリーの子要素内の任意の場所にあるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>キーボード フォーカスがその要素またはその子要素にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの値に対する変更で通常発生、 <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged> イベント、派生クラスがオーバーライドされない限り、 <xref:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged%2A> を抑制する状況、イベントです。  
  
 このプロパティを直接設定しないが、要素にフォーカスを設定するにを呼び出して <xref:System.Windows.UIElement.Focus%2A>, を作成したりして、 <xref:System.Windows.UIElement.MoveFocus%2A> 要求します。 このプロパティの値を変更するこれらのメソッド呼び出しのいずれかの可能性があります。  
  
 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> 通常内で使用されるクラスのイベント ハンドラーの他の入力に関連するイベントのインスタンス要素は既にキーボード フォーカス、またはイベントとキーボード イベントで組み合わせて発生時のマウスを決定するかを決定します。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsKeyboardFocusWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsKeyboardFocusWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsManipulationEnabled">
      <MemberSignature Language="C#" Value="public bool IsManipulationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsManipulationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsManipulationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これで、操作イベントが有効にするかどうかを示す値を取得または <see cref="T:System.Windows.UIElement" />です。</summary>
        <value>
          <see langword="true" /> この操作イベントが有効になっている場合 <see cref="T:System.Windows.UIElement" />。 そうしないと、 <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティにする場合は true、 <xref:System.Windows.UIElement> を受信する、 <xref:System.Windows.UIElement.ManipulationStarting>, 、<xref:System.Windows.UIElement.ManipulationStarted>, 、<xref:System.Windows.UIElement.ManipulationDelta>, 、<xref:System.Windows.UIElement.ManipulationInertiaStarting>, 、<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>, と <xref:System.Windows.UIElement.ManipulationCompleted> イベントです。 操作の詳細については、次を参照してください。、 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  操作に応答するアプリケーションの例は、次を参照してください。 [チュートリアル: 初めてのタッチ アプリケーションの作成](http://msdn.microsoft.com/ja-jp/d69e602e-9a25-4e24-950b-e89eaa2a906b)します。  
  
   
  
## 例  
 次の例では、赤い四角形を持つアプリケーションを作成します。<xref:System.Windows.UIElement.IsManipulationEnabled%2A> 四角形のプロパティが true に設定され、アプリケーションのウィンドウをサブスクライブする、 <xref:System.Windows.UIElement.ManipulationStarting>, 、<xref:System.Windows.UIElement.ManipulationDelta>, 、および <xref:System.Windows.UIElement.ManipulationInertiaStarting> イベントです。 この例のサンプルが大きくの一部である [チュートリアル: 初めてのタッチ アプリケーションの作成](http://msdn.microsoft.com/ja-jp/d69e602e-9a25-4e24-950b-e89eaa2a906b)します。  
  
 [!code-xml[BasicManipulation\#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsManipulationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsManipulationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsManipulationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsManipulationEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsManipulationEnabled" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMeasureValid">
      <MemberSignature Language="C#" Value="public bool IsMeasureValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMeasureValid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMeasureValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト メジャーによって返される現在のサイズが有効かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> メジャーを渡す場合レイアウトでは有効かつ最新の値が返されますそれ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 測定および配置を呼び出すことによって無効化を強制する <xref:System.Windows.UIElement.InvalidateMeasure%2A> この要素 \(または、ビジュアル ツリーの任意の親要素\)。 これにより、レイアウト再構成されるように、非同期的にレイアウト システムによって決定時に発生します。 またへの直接の呼び出しを行う <xref:System.Windows.UIElement.UpdateLayout%2A>します。 ただし、のみ呼び出します <xref:System.Windows.UIElement.UpdateLayout%2A> あるかどうかはそれ以上の無効化に保留されていないこと \(不必要に強制的な更新プログラムの数が多いはパフォーマンスの結果になります\)。  
  
 場合 <xref:System.Windows.UIElement.IsMeasureValid%2A> は `false`, 、<xref:System.Windows.UIElement.IsArrangeValid%2A> 必要もあります `false` \(レイアウト プロセスの強制のロジックで配置することはできません有効な計測項目は最初に有効ななし\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.UpdateLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にマウスがキャプチャされるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>要素にマウスのキャプチャがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウスの状態のキャプチャ プロセスでのドラッグ アンド ドロップの操作に関連しています。  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsMouseCapturedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、マウスのキャプチャの状態を切り替えます要素にマウスが既にキャプチャされているかどうかに基づいてします。  
  
 マウスをキャプチャする場合は、他の場所でその要素にマウスのキャプチャが設定されています。 要素にマウスのキャプチャがある場合を呼び出してクリア <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=fullName> null 入力します。  
  
 [!code-csharp[MouseSnippetSample\#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseSnippetSample/CSharp/Window1.xaml.cs#ismousecaptured)]
 [!code-vb[MouseSnippetSample\#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseSnippetSample/visualbasic/window1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
        <altmember cref="E:System.Windows.UIElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.UIElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseCapturedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement.IsMouseCaptured" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsMouseCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはビジュアル ツリー内の子要素がマウスのキャプチャを保持するかどうかを決定する値を取得します。 これは依存関係プロパティです。</summary>
        <value>この要素または格納されている要素がマウス キャプチャを持つ場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsMouseCaptureWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" /> この要素に変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターの位置がヒット テストの結果に対応し、要素の合成を考慮に入れる必要があるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>マウス ポインターがヒット テストと同じ要素の結果上にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり <xref:System.Windows.UIElement.IsMouseOver%2A>, 、のみ、このプロパティは `true` マウス ポインターがリテラルの要素の上にある場合などは、ヒット テストとして。 マウス ポインターが代わりに子要素にある場合は、具体的には要素のより深いテンプレートおよび複合の一部である要素をこのプロパティはなります `false`します。 コントロールは複合方法がわかっていない限り、\(たとえば、このプロパティを使用したカスタム コントロール テンプレートで定義したコントロールの\) このプロパティは、予期しない結果を返す場合があります。 コントロールをいないオーサリングするほとんどのシナリオを使用して <xref:System.Windows.UIElement.IsMouseOver%2A> 代わりにします。  
  
 この要素によって、マウスがキャプチャされていて、このプロパティは、 `true` のキャプチャ時に、このプロパティを返し続けます `true` マウスのキャプチャが失われ、ポインターはその境界から出るまでです。  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsMouseDirectlyOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素 \(ビジュアル ツリー内の子要素を含む\) の上にあるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>マウス ポインターが要素またはその子要素の上にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 通常、コントロールに合成できるため、すべてのコントロール \(ビジュアル ツリー\) 内のさまざまな要素が含まれるコントロールに対してマウスの状態を報告です。 たとえば、 <xref:System.Windows.Controls.ListBox> スタイルのコントロールがレポート <xref:System.Windows.UIElement.IsMouseOver%2A> として `true` 場合は、geometry 上にマウスが任意の場所も含めて <xref:System.Windows.Controls.ListBoxItem>します。  
  
 類似しています"IsMouseOverChanged"イベントが存在しないがいくつかのようなイベントを行います。 たとえば、処理 <xref:System.Windows.UIElement.MouseEnter>, 、<xref:System.Windows.UIElement.MouseMove>, 、および <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>です。  
  
 この要素がマウスをキャプチャする場合に、このプロパティが残ります `true` マウスのキャプチャが失われ、マウス ポインターが要素の境界を離れるまでです。  
  
 一部のコントロールは、意図的に、マウスに直接関係しない特定の操作上にマウス ポインターをキャプチャします。 これにより、 <xref:System.Windows.UIElement.IsMouseOver%2A> される `true` マウスが移動がない場合でもです。  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsMouseOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、このプロパティを参照のプロパティの型として、 <xref:System.Windows.Trigger>, \< Style.Triggers \> ブロックの一部です。 マウスがコントロール上にある場合は、コントロールのテキストが青になり、カーソルが手の形になります。  
  
 [!code-xml[ListViewCheckBox\#Trigger](~/samples/snippets/csharp/VS_Snippets_Wpf/ListViewCheckBox/CS/window1.xaml#trigger)]
 [!code-xml[ListViewCheckBox\#Trigger](~/samples/snippets/xaml/VS_Snippets_Wpf/ListViewCheckBox/xaml/window1.xaml#trigger)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsMouseOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素によってスタイラスがキャプチャされるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>要素にスタイラスのキャプチャがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsStylusCapturedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureStylus" />
        <altmember cref="E:System.Windows.UIElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.UIElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusCapturedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement.IsStylusCaptured" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsStylusCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素、または要素の境界とそのビジュアル ツリー内の要素がスタイラス キャプチャを保持するかどうかを示す値を取得します。 これは依存関係プロパティです。</summary>
        <value>この要素または格納されている要素がスタイラスのキャプチャを持つ場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://msdn.microsoft.com/ja-jp/63f1d71f-03d8-4d83-a174-e3dc7c57bad0) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsStylusCaptureWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureStylus" />
        <altmember cref="P:System.Windows.UIElement.IsStylusCaptured" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>スタイラス ポインターがヒット テストの結果と同じ要素上にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり <xref:System.Windows.UIElement.IsStylusOver%2A>, 、このプロパティはのみ `true` スタイラスが要素上にある場合。 スタイラスの代わりに、子要素または要素のより深い複合 \(ビジュアル ツリー\) の一部である要素を場合、このプロパティになります `false`します。  
  
 コントロールは複合方法がわかっていない限り、\(たとえば、このプロパティを使用したカスタム コントロール テンプレートで定義したコントロールの\) このプロパティは、予期しない結果を返す場合があります。 コントロールをいないオーサリングするほとんどのシナリオを使用して <xref:System.Windows.UIElement.IsStylusOver%2A> 代わりにします。  
  
 この要素は、スタイラスをキャプチャすると、このプロパティは、 `true` のキャプチャ時に、このプロパティの値 `true` スタイラスをキャプチャが失われ、スタイラスがその境界から出るまでです。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsStylusDirectlyOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスのカーソルがこの要素 \(子ビジュアル要素を含む\) の上にあるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>スタイラスのカーソルが要素またはその子要素の上にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この要素にスタイラスをキャプチャがある場合は、このプロパティは返す引き続き `true` スタイラスをキャプチャは失われ、ポインターがその範囲外になるまでです。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsStylusOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsStylusOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が ユーザー インターフェイス (UI) に表示されるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>要素が表示される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 決定、 <xref:System.Windows.UIElement.IsVisible%2A> 値はレイアウトのすべての要因を考慮します。 これに対し、 <xref:System.Windows.UIElement.Visibility%2A>, 、表示と非表示に要素をプログラムで作成するよう設定可能なプロパティのみを示します。  
  
 要素、 <xref:System.Windows.UIElement.IsVisible%2A> は `false` いない入力イベント \(またはコマンド\) に参加で操作を実行しないメジャーのいずれかに影響を与えるまたは配置レイアウトのパス、フォーカスを設定していない、タブ シーケンス、およびヒット テストでは報告されません。 します。 これに対して、要素、 <xref:System.Windows.UIElement.IsEnabled%2A> は `false` イベントおよびコマンド、およびヒット テストには参加してこれにフォーカスを設定します。  
  
<a name="dependencyPropertyInfo_IsVisible"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.IsVisibleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsVisibleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときの値、 <see cref="P:System.Windows.UIElement.IsVisible" /> この要素にプロパティが変更されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素がレイアウト システムの値以外の理由でレンダリングされていない場合、このイベントは発生しませんが、 <xref:System.Windows.UIElement.IsVisible%2A> プロパティです。 たとえば、要素には必要ビジュアルが関連付けられていない場合があります。  
  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.IsVisible" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.KeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがある状態でキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーの処理は、コマンドの実行とテキストの合成などの他のプラットフォーム機能と対話します。<xref:System.Windows.UIElement.KeyDown> イベントは、下位レベルのテキストの入力イベントの特定のコントロールで期待どおりに動作しません。 これは、一部のコントロールがコントロールの複合か、テキストの高レベルのバージョンを提供するクラスの処理が入力処理および関連するイベントです。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName> 添付このクラスでイベントように <xref:System.Windows.UIElement.KeyDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.KeyDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_KeyDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.KeyDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewKeyDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnKeyDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.KeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.KeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがあるときにキーが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName> 添付このクラスでイベントように  <xref:System.Windows.UIElement.KeyUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.KeyUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_KeyUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.KeyUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewKeyUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnKeyUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.KeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler LayoutUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LayoutUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LayoutUpdated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>さまざまな視覚要素のレイアウトに現在関連付けられているときに発生 <see cref="T:System.Windows.Threading.Dispatcher" /> 変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 レイアウトの更新は、プロパティの変更、ウィンドウのサイズ変更、または明示的なユーザー要求の結果として発生します。  
  
 このメンバーは、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] イベントは、ルーティングされたイベントではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッド呼び出しを使用して意図的にフォーカスを外しているにもかかわらず、直前のキーボード フォーカスが異なるスコープ内に存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 シナリオではこのことがキーボード フォーカスは、要素を <xref:System.Windows.UIElement.Focus%2A> メソッドはまだ論理フォーカスを取得します。  
  
 このイベントのより正確な解釈がその it 発生する状況の値、 <xref:System.Windows.UIElement.IsFocused%2A> からルート内の要素のプロパティが変更される `true` に `false`します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを得られる実際の要素を特定のイベント データ。  
  
<a name="routedEventInfo_LostFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.LostFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnLostFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.LostFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.LostKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.LostKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.LostKeyboardFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewLostKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnLostKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.LostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostMouseCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素がマウスをキャプチャは、境界外のポインターがあってもマウス入力を受け取ります。 マウスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> キャプチャを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.LostMouseCapture> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.LostMouseCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.LostMouseCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnLostMouseCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.LostMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostStylusCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスをキャプチャする要素は、ポインターがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.LostStylusCapture> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.LostStylusCapture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.LostStylusCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnLostStylusCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.LostStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostTouchCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素は、タッチのキャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.LostTouchCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnLostTouchCapture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.LostTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作が境界に到達したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_ManipulationBoundaryFeedback"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationBoundaryFeedbackEventArgs>です。|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationBoundaryFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; ManipulationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationCompletedEventArgs&gt; ManipulationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作と慣性のときに発生、 <see cref="T:System.Windows.UIElement" /> オブジェクトが完了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントを使用すると、完了すると、操作に関する情報を取得します。  たとえば、使用、 <xref:System.Windows.Input.ManipulationCompletedEventArgs.TotalManipulation%2A?displayProperty=fullName> 総量操作の位置を決定するプロパティを変更します。  
  
 操作の詳細については、次を参照してください。、 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  操作に応答するアプリケーションの例は、次を参照してください。 [チュートリアル: 初めてのタッチ アプリケーションの作成](http://msdn.microsoft.com/ja-jp/d69e602e-9a25-4e24-950b-e89eaa2a906b)します。  
  
<a name="routedEventInfo_ManipulationCompleted"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.ManipulationCompletedEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationCompletedEventArgs>です。|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationCompletedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationCompletedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationCompletedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationCompletedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.ManipulationCompleted" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationDelta">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; ManipulationDelta;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationDeltaEventArgs&gt; ManipulationDelta" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationDelta" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力デバイス操作中の位置が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.ManipulationDelta>イベントは、ときに、ユーザーがドラッグ指が画面上で操作中および再度慣性の発生時に複数回を発生します。  使用することができます、<xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A>慣性中に、イベントが発生しているかどうかを確認するプロパティです。  
  
 上にある要素<xref:System.Windows.UIElement.ManipulationDelta>イベントが影響を受けません任意の方法でイベントが発生したときに発生します。  操作される要素にロジックを提供する必要があります。<xref:System.Windows.Input.ManipulationDeltaEventArgs.CumulativeManipulation%2A>と<xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A>のプロパティの型は<xref:System.Windows.Input.ManipulationDelta>操作の位置の変更に関するデータを含む、移動、サイズ変更、またはオブジェクトの回転として解釈されます。  その情報を操作するのには、要素に適用します。  
  
 操作の詳細については、次を参照してください。、[入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)です。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル: 初めて、タッチ アプリケーションの作成](http://msdn.microsoft.com/ja-jp/d69e602e-9a25-4e24-950b-e89eaa2a906b)です。  
  
<a name="routedEventInfo_ManipulationDelta"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.ManipulationDeltaEvent>|  
|ルーティング方法|バブリング|  
|Delegate|<xref:System.EventHandler%601>型の<xref:System.Windows.Input.ManipulationDeltaEventArgs>します。|  
  
   
  
## 例  
 次の例は、イベント ハンドラーを<xref:System.Windows.UIElement.ManipulationDelta>イベント。 この例では、<xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A>プロパティを移動、サイズ変更、および回転を<xref:System.Windows.Shapes.Rectangle>です。  例も確認するかどうか、<xref:System.Windows.UIElement.ManipulationDelta>慣性とウィンドウの端を四角形がかどうかに触れることの間にイベントが発生しました。  このような場合に当てはまる場合、アプリケーションを四角形がアプリケーションの表示領域を終了するを防ぐために操作を停止します。 この例のサンプルが大きくの一部である[チュートリアル: 初めて、タッチ アプリケーションの作成](http://msdn.microsoft.com/ja-jp/d69e602e-9a25-4e24-950b-e89eaa2a906b)です。  
  
 [!code-csharp[BasicManipulation\#ManipulationDelta](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationdelta)]
 [!code-vb[BasicManipulation\#ManipulationDelta](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationdelta)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationDeltaEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationDeltaEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationDeltaEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationDeltaEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.ManipulationDelta" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationInertiaStarting" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力デバイスとの接続を失ったときに発生、 <see cref="T:System.Windows.UIElement" /> 操作と慣性の中にオブジェクトを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.ManipulationInertiaStarting> イベント、ユーザーが操作中にすべての画面で指を離したときに発生します。 たとえば、"ユーザー"をスロー、 <xref:System.Windows.UIElement> 、ユーザーがタッチ、サーフェイスにわたって、 <xref:System.Windows.UIElement> アクションを開始するには短距離の画面上で指を移動して離します、 <xref:System.Windows.UIElement>です。 慣性が開始される要素を離したときに、 <xref:System.Windows.UIElement.ManipulationInertiaStarting> イベントが発生します。<xref:System.Windows.UIElement> を受信するが引き続き <xref:System.Windows.UIElement.ManipulationDelta> 慣性が要素で発生していることを通知するイベントです。  
  
 このイベントを使用して、慣性の動作を指定することができます。  たとえば、慣性が開始されるときに使用される初期速度を設定できます。  必要な減速を設定するか、目的の配置を設定しても、慣性の量を指定できます。  これらの値 \(変換、拡張、または回転\) 操作の種類ごとに個別に設定できます。  詳細については、「<xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>」を参照してください。  
  
 操作の詳細については、次を参照してください。、 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  操作に応答するアプリケーションの例は、次を参照してください。 [チュートリアル: 初めてのタッチ アプリケーションの作成](http://msdn.microsoft.com/ja-jp/d69e602e-9a25-4e24-950b-e89eaa2a906b)します。  
  
<a name="routedEventInfo_ManipulationInertiaStarting"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.ManipulationInertiaStartingEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>です。|  
  
   
  
## 例  
 例を次に、 <xref:System.Windows.UIElement.ManipulationInertiaStarting> イベント ハンドラーおよび平行移動、拡大、および回転慣性中に使用されるため、必要な減速を設定します。 この例のサンプルが大きくの一部である [チュートリアル: 初めてのタッチ アプリケーションの作成](http://msdn.microsoft.com/ja-jp/d69e602e-9a25-4e24-950b-e89eaa2a906b)します。  
  
 [!code-csharp[BasicManipulation\#ManipulationInertiaStarting](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationinertiastarting)]
 [!code-vb[BasicManipulation\#ManipulationInertiaStarting](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationinertiastarting)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationInertiaStartingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationInertiaStartingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationInertiaStartingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationInertiaStartingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStarted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; ManipulationStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationStartedEventArgs&gt; ManipulationStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationStarted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力デバイスの操作を開始すると発生、 <see cref="T:System.Windows.UIElement" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.ManipulationStarted> イベントが発生した後、 <xref:System.Windows.UIElement.ManipulationStarting> イベントです。  使用して、次を行うことができます、 <xref:System.Windows.Input.ManipulationStartedEventArgs>:  
  
-   使用して操作の位置に関連する要素の取得、 <xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationContainer%2A> プロパティです。  
  
-   使用して、操作の始点を取得、 <xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationOrigin%2A> プロパティです。  
  
-   呼び出して、操作を取り消す、 <xref:System.Windows.Input.ManipulationStartedEventArgs.Complete%2A> メソッドです。  
  
 操作の詳細については、次を参照してください。、 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  操作に応答するアプリケーションの例は、次を参照してください。 [チュートリアル: 初めてのタッチ アプリケーションの作成](http://msdn.microsoft.com/ja-jp/d69e602e-9a25-4e24-950b-e89eaa2a906b)します。  
  
<a name="routedEventInfo_ManipulationStarted"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.ManipulationStartedEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationStartedEventArgs>です。|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStartedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationStartedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationStartedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationStartedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.ManipulationStarted" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStarting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; ManipulationStarting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationStartingEventArgs&gt; ManipulationStarting" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationStarting" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作プロセッサが最初に作成したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.ManipulationStarting> イベントを持つ要素で発生する、 <xref:System.Windows.UIElement.IsManipulationEnabled%2A> プロパティに設定 `true` ときに、ユーザーが指を置きにします。 既定では、後続の操作イベントを持つ要素を基準とした操作の位置をレポート <xref:System.Windows.UIElement.IsManipulationEnabled%2A> 設定 `true`します。  位置を設定して別の要素に対応する必要があることを指定する、 <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> プロパティです。 たとえば、要素の親を基準に操作を行うことができます。  
  
 イベント ハンドラーでは、次を実行することもできます <xref:System.Windows.UIElement.ManipulationStarting>:。  
  
-   ユーザーに設定して、操作を実行する 1 つ以上の指が必要かどうかが指定されて、 <xref:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled%2A?displayProperty=fullName> プロパティです。  
  
-   操作の種類を有効に設定して指定、 <xref:System.Windows.Input.ManipulationStartingEventArgs.Mode%2A?displayProperty=fullName> プロパティを <xref:System.Windows.Input.ManipulationModes> 列挙します。  
  
-   1 本指の回転の中心を指定するには、 <xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=fullName> プロパティです。  
  
-   呼び出して、操作を取り消す、 <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A?displayProperty=fullName> メソッドです。  
  
 操作の詳細については、次を参照してください。、 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  操作に応答するアプリケーションの例は、次を参照してください。 [チュートリアル: 初めてのタッチ アプリケーションの作成](http://msdn.microsoft.com/ja-jp/d69e602e-9a25-4e24-950b-e89eaa2a906b)します。  
  
<a name="routedEventInfo_ManipulationStarting"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.ManipulationStartingEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationStartingEventArgs>です。|  
  
   
  
## 例  
 次の例では、対応するイベント ハンドラー、 <xref:System.Windows.UIElement.ManipulationStarting> イベントとセット、 <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> 操作イベントを受け取るための操作の座標は、親要素に相対的な親要素にします。  この例のサンプルが大きくの一部である [チュートリアル: 初めてのタッチ アプリケーションの作成](http://msdn.microsoft.com/ja-jp/d69e602e-9a25-4e24-950b-e89eaa2a906b)します。  
  
 [!code-csharp[BasicManipulation\#ManipulationStarting](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationstarting)]
 [!code-vb[BasicManipulation\#ManipulationStarting](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationstarting)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStartingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationStartingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationStartingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationStartingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.ManipulationStarting" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Measure">
      <MemberSignature Language="C#" Value="public void Measure (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Measure(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">親要素が子要素を割り当てることができる使用可能な領域。 子要素は使用可能な空間よりも大きな空間を要求できます。現在の要素のコンテンツ モデルでスクロールが可能な場合、指定されたサイズに対応できる可能性があります。</param>
        <summary>
          <see cref="T:System.Windows.UIElement" /> の <see cref="P:System.Windows.UIElement.DesiredSize" /> を更新します。 親要素は、独自の <see cref="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" /> 実装からこのメソッドを呼び出し、レイアウトを再帰的に更新します。 このメソッドの呼び出しは、レイアウト更新の最初のパス \(「メジャー」パス\) となります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 レイアウトの配置で計算 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] から成ります、 <xref:System.Windows.UIElement.Measure%2A> を呼び出すと、 <xref:System.Windows.UIElement.Arrange%2A> を呼び出します。 中に、 <xref:System.Windows.UIElement.Measure%2A> 要素の呼び出しを使用してそのサイズ要件を決定する、 `availableSize` 入力します。 中に、 <xref:System.Windows.UIElement.Arrange%2A> 要素のサイズの呼び出しが終了します。  
  
 `availableSize` 無限にゼロから任意の数を指定できます。 レイアウトに参加している要素は、最小値を返す必要があります <xref:System.Windows.Size> が必要とする指定された `availableSize`します。  
  
 常に受信レイアウトが初めてインスタンス化されたときに、 <xref:System.Windows.UIElement.Measure%2A> 前に呼び出す <xref:System.Windows.UIElement.Arrange%2A>します。 ただし、最初のレイアウト パスに受け取ることがあります、 <xref:System.Windows.UIElement.Arrange%2A> せずに呼び出す、 <xref:System.Windows.UIElement.Measure%2A>; これは発生する場合のみに影響を与えるプロパティ <xref:System.Windows.UIElement.Arrange%2A> \(配置\) などが変更された親を受信すると、または、 <xref:System.Windows.UIElement.Arrange%2A> せず、 <xref:System.Windows.UIElement.Measure%2A>です。 A <xref:System.Windows.UIElement.Measure%2A> 呼び出しが自動的に無効になる、 <xref:System.Windows.UIElement.Arrange%2A> 呼び出します。  
  
 レイアウトの更新は、あらゆるレイアウトの変更のメイン スレッドが待機していないように、非同期的に発生します。 分離コードのプロパティの値のチェックを使用して要素のクエリを実行しても、そのサイズ変更またはレイアウトの特性と対話するプロパティの変更がすぐに反映可能性がありますされない \(、 <xref:System.Windows.FrameworkElement.Width%2A> プロパティなど\)。  
  
> [!NOTE]
>  使用してレイアウトの更新を適用することができます、 <xref:System.Windows.UIElement.UpdateLayout%2A> メソッドです。 ただし、このメソッドを呼び出すことは通常必要はありません、パフォーマンスの低下が発生することができます。  
  
 レイアウト システムは 1 つずつ無効なレイアウトの 2 つの異なるキュー <xref:System.Windows.UIElement.Measure%2A> とに 1 つずつ <xref:System.Windows.UIElement.Arrange%2A>します。 レイアウト キューはレイアウトを実行する要素のビジュアル ツリーにおける要素の順序に基づいて並べ替えられますツリーの上位の要素は、親の変更を繰り返すことによって、冗長なレイアウトを避けるために、キューの上部にです。 重複したエントリは、キューから自動的に削除され、レイアウト検証は既に要素も、キューから自動的に削除します。  
  
 レイアウトを更新するときに、 <xref:System.Windows.UIElement.Measure%2A> キューが最初に、空に続けて、 <xref:System.Windows.UIElement.Arrange%2A> キューです。 内の要素、 <xref:System.Windows.UIElement.Arrange%2A> 内の要素がある場合、キューは配置しないで、 <xref:System.Windows.UIElement.Measure%2A> キューです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">親要素が子に割り当てることが利用可能なサイズです。</param>
        <summary>派生クラスでオーバーライドされた場合は、任意の子要素の内容のサイズも考慮して、この要素を適切にサイズ変更の測定のロジックを提供します。</summary>
        <returns>レイアウト内のこの要素の必要なサイズ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素を派生する方が一般的である <xref:System.Windows.FrameworkElement> なく <xref:System.Windows.UIElement>です。 派生する場合 <xref:System.Windows.FrameworkElement>, に注意してくださいのオーバーライド <xref:System.Windows.UIElement.MeasureCore%2A> に <xref:System.Windows.FrameworkElement> シール、 <xref:System.Windows.UIElement.MeasureCore%2A> メソッドです。 だけをオーバーライドするため、 <xref:System.Windows.UIElement.MeasureCore%2A> から派生する場合は、レイアウトのメジャーの特性を変更するための手段として <xref:System.Windows.UIElement> を含まない継承によって <xref:System.Windows.FrameworkElement>します。 これがある場合、独自の実装を作成しようとしている場合、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] コア レベルです。 それ以外の場合から派生する場合 <xref:System.Windows.FrameworkElement>, 、メジャーの動作の実装のテンプレートは、 <xref:System.Windows.FrameworkElement> の実装。<xref:System.Windows.FrameworkElement.MeasureOverride%2A>します。  
  
 子要素を持つ親要素を呼び出す必要があります <xref:System.Windows.UIElement.Measure%2A> にそれぞれの子では、それ以外の場合これらの子要素またはされていないサイズ配置しがレイアウトから効果的に表示されなくなります。  
  
   
  
## 例  
 一般的なオーバーライド <xref:System.Windows.UIElement.MeasureCore%2A> おおよそこのパターンに従います \(という名前の組み込みコレクションがない `VisualChildren`; `VisualChildren` 、要素を保持任意の子コレクションを表すプレース ホルダーは、\)。  
  
 [!code-csharp[CorePseudocode\#UIElementMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementmeasureoverride)]
 [!code-vb[CorePseudocode\#UIElementMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementmeasureoverride)]  
  
-   呼び出す必要があります <xref:System.Windows.UIElement.Measure%2A> 各子要素にします。  
  
-   実装がの間での測定の情報をキャッシュする一般に、 <xref:System.Windows.UIElement.MeasureCore%2A> と <xref:System.Windows.UIElement.ArrangeCore%2A> メソッドの呼び出しで同じ要素。  
  
-   基本実装を呼び出す <xref:System.Windows.UIElement.MeasureCore%2A> 必須ではありませんが、適切なは、基本の実装は、目的のレイアウト機能を提供している場合があります。  
  
-   呼び出す <xref:System.Windows.UIElement.Measure%2A> 子要素に合格するはず同じであるか `availableSize` 親、または領域のサブセットでは、レイアウトの種類によっては、親要素をサポートしています。 たとえば、要素に固有の枠線または埋め込み、スクロール バー、またはカスタム コントロールの領域を削除するでしょう。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Implementations must be able to process a value provided for <paramref name="availableSize" /> that is infinite. An infinite value indicates no requested constraints, and effectively defers measurement choice to the parent element, through recursive Measure calls.  
  
 Implementations can consider the value provided for <paramref name="availableSize" /> to be a soft constraint. The child element might specify a larger size, even if other aspects of application code were able to determine the current actual size of the parent element. The large size request is a convention that indicates that the child element is querying whether your parent element can support content scrolling within a content display region.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.MouseDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.MouseDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement.MouseDown> イベントは、多くの場合、いずれかと共に <xref:System.Windows.UIElement.MouseLeftButtonDown> または <xref:System.Windows.UIElement.MouseRightButtonDown>, 、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。<xref:System.Windows.UIElement.MouseLeftButtonDown><xref:System.Windows.UIElement.MouseRightButtonDown> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.UIElement.MouseLeftButtonDown> または <xref:System.Windows.UIElement.MouseRightButtonDown>です。  
  
> [!IMPORTANT]
>  一部のコントロールには、固有のクラスのマウス ボタンのイベント処理があります。 イベントをマウスの左ボタンは、クラス、コントロールの処理が最も可能性の高いイベントです。 クラスの多くの場合、処理が、基になるをマーク <xref:System.Windows.Input.Mouse> クラス イベントを処理します。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンスのハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。  
  
 前の「重要」に説明されている問題を解決し、それでも <xref:System.Windows.UIElement.MouseDown> クラスによるこれらソリューションのいずれかの処理を含む派生クラスでイベントをマウスの左ボタンのイベント。  
  
-   ハンドラーのアタッチ、 <xref:System.Windows.UIElement.PreviewMouseDown> コントロールによって処理済みとマークされていないイベント。 これはプレビュー イベントであるため、ルート ルートから始まり、コントロールまでトンネルに注意してください。  
  
-   呼び出して、コントロールのハンドラーを手続き的登録 <xref:System.Windows.UIElement.AddHandler%2A> ハンドラーにルーティングされたイベント データの処理としてマークされている場合でも、イベントをリッスンできる署名オプションを選択します。  
  
<a name="routedEventInfo_MouseDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.MouseDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewMouseDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnMouseDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.MouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.MouseEnter> 直接イベント ルーティング方法の処理を使用しているです。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、ルーティング イベントの動作のスタイルでイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.UIElement.MouseEnter> マウス ポインターがこのイベントをさらに、要素の境界に入った時点を追跡するレポート文字どおり、 <xref:System.Windows.UIElement.IsMouseOver%2A> からプロパティ値が変更 `false` に `true` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.MouseEnter> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.MouseEnter> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 A <xref:System.Windows.Controls.Button> \(またはその <xref:System.Windows.Controls.Primitives.ButtonBase> 派生クラス\) のネイティブの処理が、 <xref:System.Windows.UIElement.KeyDown> 、ボタンにフォーカスし、space キーが押されたときにイベントです。 ネイティブ処理を発生させます、 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントのソースとして、ボタンともに移動するマウス ポインターが表示されない場合でも、マウスをキャプチャします。 マウスのキャプチャの結果として、 <xref:System.Windows.UIElement.MouseEnter> ソースとしてボタンでもイベントが発生します。 通常、要素がマウスをキャプチャし、 <xref:System.Windows.UIElement.MouseEnter> が発生しただけでなく <xref:System.Windows.UIElement.GotMouseCapture> および他のコントロール固有イベント可能性があります。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.MouseEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnMouseEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.MouseEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.MouseLeave> 直接イベント ルーティング方法の処理を使用しているです。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、ルーティング イベントの動作のスタイルでイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.UIElement.MouseLeave> マウスが離れると、要素にある場合、このイベントは、複数のトラックが文字どおり報告された、 <xref:System.Windows.UIElement.IsMouseOver%2A> からプロパティ値が変更 `true` に `false` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.MouseLeave> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.MouseLeave> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.MouseLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnMouseLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.MouseLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeftButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、次の要素ツリーを通じてバブル ルーティングするよう、実際には直接ルーティングされたイベントが発生し、要素ツリーに沿った各が再度発生する <xref:System.Windows.UIElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement.MouseLeftButtonDown> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。 場合によってクラス ハンドラーが生成されるイベントに関する情報もなど <xref:System.Windows.Controls.Control.MouseDoubleClick>します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement>します。  
  
> [!IMPORTANT]
>  一部のコントロール クラスには、固有のクラスのマウス ボタンのイベント処理があります。 イベントをマウスの左ボタンは、クラス、コントロールの処理が最も可能性の高いイベントです。 クラスの多くの場合、処理が、基になるをマーク <xref:System.Windows.Input.Mouse> クラス イベントを処理します。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンスのハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。  
  
 前の「重要」に説明されている問題を解決し、それでも <xref:System.Windows.UIElement.MouseLeftButtonDown> クラスによるこれらソリューションのいずれかの処理を含む派生クラスでイベントをマウスの左ボタンのイベント。  
  
-   ハンドラーのアタッチ、 <xref:System.Windows.UIElement.PreviewMouseDown> コントロールによって処理済みとマークされていないイベント。 これはプレビュー イベントであるため、ルート ルートから始まり、コントロールまでトンネルに注意してください。  
  
-   呼び出して、コントロールのハンドラーを手続き的登録 <xref:System.Windows.UIElement.AddHandler%2A> ハンドラーにルーティングされたイベント データの処理としてマークされている場合でも、イベントをリッスンできる署名オプションを選択します。  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.MouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeftButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、次の要素ツリーをバブル ルーティングするよう、実際には直接ルーティングされたイベントが発生し、要素ツリーに沿った各が再度発生する <xref:System.Windows.UIElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement.MouseLeftButtonUp> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.MouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.MouseMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.MouseMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.MouseMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewMouseMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnMouseMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.MouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseRightButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、次の要素ツリーを通じてバブル ルーティングするよう、実際には直接ルーティングされたイベントが発生し、要素ツリーに沿った各が再度発生する <xref:System.Windows.UIElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement.MouseRightButtonDown> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。 場合によってクラス ハンドラーが生成されるイベントに関する情報もなど <xref:System.Windows.Controls.Control.MouseDoubleClick>します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement>します。  
  
 右側のボタンのマウス イベントは、アプリケーション シナリオでネイティブ処理を頻繁にあります。 たとえば、マウスの右ボタンを押すがコンテキスト メニューを表示します。 参照してください [ContextMenu の概要](http://msdn.microsoft.com/ja-jp/16909c42-799a-4561-91e0-7d69dcfeea91)します。  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.MouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.MouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseRightButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、次の要素ツリーを通じてバブル ルーティングするよう、実際には直接ルーティングされたイベントが発生し、要素ツリーに沿った各が再度発生する <xref:System.Windows.UIElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement.MouseRightButtonUp> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.MouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnMouseRightButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.MouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.MouseUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.MouseUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement.MouseUp> イベントは、多くの場合、いずれかと共に <xref:System.Windows.UIElement.MouseLeftButtonUp> または <xref:System.Windows.UIElement.MouseRightButtonUp>, 、2 つの標準のマウス ボタンのいずれかのリリースに対応します。<xref:System.Windows.UIElement.MouseLeftButtonUp><xref:System.Windows.UIElement.MouseRightButtonUp> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.UIElement.MouseLeftButtonUp> または <xref:System.Windows.UIElement.MouseRightButtonUp>です。  
  
<a name="routedEventInfo_MouseUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.MouseUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewMouseUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnMouseUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.MouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。そのため、表示された場合、 <xref:System.Windows.UIElement.MouseWheel> フォーカスがあるか、キャプチャした要素からのイベント、マウス ポインターのほう別の要素上です。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.MouseWheel> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.MouseWheel> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.MouseWheelEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewMouseWheel>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnMouseWheel%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.MouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">走査の各要求を視覚的に移動するには、既存のタブ オーダーまたは、方向を走査するモードにはいずれかを示すプロパティが含まれています。</param>
        <summary>この要素から別の要素にフォーカスを移動しようとします。 フォーカスを移動する方向は、この要素のビジュアルの親の組織内で解釈されますが、ガイダンスの方向を指定します。</summary>
        <returns>
          <see langword="true" /> 要求の検査が実行された場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの戻り値を確認してください。 戻り値 `false` 走査の各要求はラップする要求していないと、走査は、コントロールの構成で定義されているタブ ストップが実行されて、返される可能性があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected virtual void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">アクセス キー イベントをイベント データ。 イベント データ レポートがどのキーが呼び出され、を示すかどうか、 <see cref="T:System.Windows.Input.AccessKeyManager" /> も、これらのイベントの送信を制御するオブジェクトはその他の要素にこのアクセス キーの呼び出しを送信します。</param>
        <summary>呼び出されるときは、この要素に有効なアクセス キーのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 実際の AccessKey イベントが存在しない、 <xref:System.Windows.UIElement> クラス、またはその他のハンドラーをアタッチすることができますか。 専用マネージャー クラスを使用して、イベントの代わりに、発生元が <xref:System.Windows.Input.AccessKeyManager>, 、入力モデル全体に適用されるアクセス キーを検索するすべての入力を後に処理します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The default implementation of this method in <see cref="T:System.Windows.UIElement" /> sets keyboard focus to this element (by calling <see cref="M:System.Windows.UIElement.Focus" />). Implementations should perpetuate this behavior if they are focusable, because it is an expected behavior for accessibility scenarios. Note that the base implementation does nothing with the passed event data and raises no further event; it just sets the focus.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnChildDesiredSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChildDesiredSizeChanged (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChildDesiredSizeChanged(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">サイズが変更される子要素。</param>
        <summary>子要素がサイズ変更されると、レイアウトの動作をサポートしています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは通常、アプリケーション コードで呼び出されません。 公開されるため、独自のレイアウトが無効な可能性のある状態でのクラスで、派生した要素を確認します。 クラスでは、子要素にサイズ変更に基づき、レイアウト パスの処理時間を最小限に抑えるの最適化を試みることもなります。 例は、要素を実装するクラスを派生<xref:System.Windows.UIElement.OnChildDesiredSizeChanged%2A>は、<xref:System.Windows.Controls.Grid>コントロール。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The <see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" /> method has the default implementation of calling <see cref="M:System.Windows.UIElement.InvalidateMeasure" /> on itself. A typical implementation would be: do whatever optimization your own element supports, and then typically call base <see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" /> from at least one of the code branches (the one that indicated "dirty" state per your own measure caching logic).  
  
 This method is only called in the layout processing if it was the child itself that originated the size changes. Otherwise, if the parent element initiates the <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> pass, according to the layout system rules, the parent is recalculating layout already. The layout system processes layout in the order of child-to-parent, so no return to parent element sizing from the child element layout calls is necessary.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnCreateAutomationPeer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>特定のクラスを返す <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> の実装、 Windows Presentation Foundation (WPF) インフラストラクチャです。</summary>
        <returns>型固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The implementation of this method is typically to call the constructor of a specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.  
  
 All <see cref="T:System.Windows.UIElement" /> derived classes should implement this method in order to provide their own specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations to the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure. For details on implementing this pattern, see <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragLeave" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragOver" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.RoutedEventArgs" />。 このイベント データは、<see cref="E:System.Windows.UIElement.GotFocus" /> イベントの識別子を格納する必要があります。</param>
        <summary>提供されたイベント データを使用して、<see cref="E:System.Windows.UIElement.GotFocus" /> ルーティング イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、仮想がイベントを発生させる既定の実装です。  
  
 これを \* メソッドの実装の目的は、イベントが発生して、この同じメソッドの実装が内部的に呼び出され、イベントを発生させるときに、 <xref:System.Windows.UIElement.IsFocused%2A> プロパティ値が変更されます。<xref:System.Windows.UIElement.OnGotFocus%2A> 実装が異なるその他の [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] に \* のみそのイベントのクラス処理を追加する便利な手段を提供の実装です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation. Otherwise, the <see cref="E:System.Windows.UIElement.GotFocus" /> event is not raised during typical user operations that ordinarily set focus to this element. If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.UIElement.Focusable" /> to <see langword="false" />.</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
        <altmember cref="E:System.Windows.UIElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.GotTouchCapture" /> タッチがこの要素にキャプチャされるときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnGotTouchCapture%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnGotTouchCapture%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.GotTouchCapture> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnGotTouchCapture%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> 依存関係プロパティが変更されました。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement.IsKeyboardFocusedChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、  <xref:System.Windows.UIElement.IsKeyboardFocusedChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素によって、<see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> イベントが発生する直前に呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> 依存関係プロパティが変更されました。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、 <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement.IsMouseCapturedChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.UIElement.IsMouseCaptured%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement.IsMouseCapturedChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、 <xref:System.Windows.UIElement.IsMouseCapturedChanged> イベントはルーティングされたイベントは使用されませんそのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This virtual method is raised when the value of the <see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /> dependency property changes its value. The virtual method is raised first and can manipulate the event data as necessary. Then the <see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance. Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.  
  
 This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation. You may call base either before or after your special handling, depending on your requirements.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.UIElement.IsMouseDirectlyOver%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged> 同じイベント データ インスタンスをイベントが発生します。 注意して、 <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged> イベントは、ルーティングされたイベントではありません。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.IsStylusCapturedChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.UIElement.IsStylusCaptured%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement.IsStylusCapturedChanged> 同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティングされたイベントではないことを確認します。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" /> イベントがこの要素で発生すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.UIElement.IsStylusCaptureWithin%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement.IsStylusCaptureWithinChanged> 同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティングされたイベントではないことを確認します。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この仮想メソッドが発生したときの値、 <xref:System.Windows.UIElement.IsStylusDirectlyOver%2A> 依存関係プロパティの値が変更されます。 仮想メソッドでは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、 <xref:System.Windows.UIElement.IsStylusDirectlyOverChanged> 同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティングされたイベントではないことを確認します。 したがってクラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーボード操作は、専用の入力マネージャーによって処理されます。 たとえば、入力とコマンド バインドのキー入力に依存しているその他のプログラミング機能は、一般的なキーストロークとして公開される前にキーストロークを処理することがあります。 これらの入力システムの機能、イベントを処理し、としてマークする場合は、 <xref:System.Windows.UIElement.OnKeyDown%2A> は呼び出されません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーボード操作は、専用の入力マネージャーによって処理されます。 たとえば、入力とコマンド バインドのキー入力に依存しているその他のプログラミング機能は、一般的なキーストロークとして公開される前にキーストロークを処理することがあります。 これらの入力システムの機能、イベントを処理し、としてマークする場合は、 <xref:System.Windows.UIElement.OnKeyUp%2A> は呼び出されません。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。 このイベント データには、<see cref="E:System.Windows.UIElement.LostFocus" /> イベントの識別子が含まれている必要があります。</param>
        <summary>渡されたイベント データを使用して、<see cref="E:System.Windows.UIElement.LostFocus" /> ルーティング イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、仮想がイベントを発生させる既定の実装です。  
  
 これを \* メソッドの実装の目的は、イベントが発生して、この同じメソッドの実装が内部的に呼び出され、イベントを発生させるときに、 <xref:System.Windows.UIElement.IsFocused%2A> プロパティ値が変更されます。 この実装が異なるその他の [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] に \* のみそのイベントのクラス処理を追加する便利な手段を提供の実装です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation. Otherwise, the <see cref="E:System.Windows.UIElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element. If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.UIElement.Focusable" /> to <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.LostTouchCapture" /> タッチのキャプチャを失ったときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnLostTouchCapture%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnLostTouchCapture%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.LostTouchCapture> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnLostTouchCapture%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary>ときに呼び出されます、 <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> イベントが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> イベントです。 必ず、 <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A> がイベントを受け取るようにする基本クラスの基本クラスのメソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationCompleted (System.Windows.Input.ManipulationCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationCompleted(class System.Windows.Input.ManipulationCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary>ときに呼び出されます、 <see cref="E:System.Windows.UIElement.ManipulationCompleted" /> イベントが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnManipulationCompleted%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnManipulationCompleted%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.ManipulationCompleted> イベントです。 必ず、 <xref:System.Windows.UIElement.OnManipulationCompleted%2A> がイベントを受け取るようにする基本クラスの基本クラスのメソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationDelta">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationDelta (System.Windows.Input.ManipulationDeltaEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationDelta(class System.Windows.Input.ManipulationDeltaEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationDeltaEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary>ときに呼び出されます、 <see cref="E:System.Windows.UIElement.ManipulationDelta" /> イベントが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnManipulationDelta%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnManipulationDelta%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.ManipulationDelta> イベントです。 必ず、 <xref:System.Windows.UIElement.OnManipulationDelta%2A> がイベントを受け取るようにする基本クラスの基本クラスのメソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationInertiaStarting (System.Windows.Input.ManipulationInertiaStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationInertiaStarting(class System.Windows.Input.ManipulationInertiaStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationInertiaStartingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary>ときに呼び出されます、 <see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /> イベントが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.ManipulationInertiaStarting> イベントです。 必ず、 <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A> がイベントを受け取るようにする基本クラスの基本クラスのメソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarted">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationStarted (System.Windows.Input.ManipulationStartedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationStarted(class System.Windows.Input.ManipulationStartedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary>ときに呼び出されます、 <see cref="E:System.Windows.UIElement.ManipulationStarted" /> イベントが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnManipulationStarted%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnManipulationStarted%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.ManipulationStarted> イベントです。 必ず、 <xref:System.Windows.UIElement.OnManipulationStarted%2A> がイベントを受け取るようにする基本クラスの基本クラスのメソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarting">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationStarting (System.Windows.Input.ManipulationStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationStarting(class System.Windows.Input.ManipulationStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Input.ManipulationStartingEventArgs" /> イベント データを格納します。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.ManipulationStarting" /> 操作プロセッサは最初、するときに発生するルーティングされたイベントを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnManipulationStarting%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnManipulationStarting%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.ManipulationStarting> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnManipulationStarting%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、押されたマウス ボタンおよび処理済み状態に関する詳細を報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.UIElement.OnMouseDown%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.UIElement.MouseLeftButtonDown> と <xref:System.Windows.UIElement.MouseRightButtonDown>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.UIElement.OnMouseDown%2A>, 、下にはアクションのすべての可能なマウス ボタンのクラス処理を考慮できるという意味です。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、直接ルーティング方法と、ルーティングされたイベント。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 添付イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、直接ルーティング方法と、ルーティングされたイベント。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>この要素上でハンドルされない <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> ルーティング イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.MouseLeftButtonDown> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.UIElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement.MouseLeftButtonDown>します。 マークすることができますが、 <xref:System.Windows.UIElement.MouseLeftButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement> リッスン <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement> をオーバーライドして <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Button> させ <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> 、派生クラスで基本クラスの実装を呼び出さずにただし、このオーバーライドを無効に、 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.MouseLeftButtonUp> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.UIElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement.MouseLeftButtonUp>します。 マークすることができますが、 <xref:System.Windows.UIElement.MouseLeftButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement> リッスン <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement> をオーバーライドして <xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.MouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.MouseRightButtonDown> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.UIElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement.MouseRightButtonDown>します。 マークすることができますが、 <xref:System.Windows.UIElement.MouseRightButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement> リッスン <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement> をオーバーライドして <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Control> させ <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A> 呼び出しベースにしていることがなく、派生クラスで、このオーバーライドを無効に含まれている、管理上のコンテキスト\] メニューの \[サービスの <xref:System.Windows.Controls.Control> の既定の動作です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.MouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.MouseRightButtonUp> イベントは、バブルのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> 基になるイベント バブル ルートである各 <xref:System.Windows.UIElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement.MouseRightButtonUp>します。 マークすることができますが、 <xref:System.Windows.UIElement.MouseRightButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement> リッスン <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement> をオーバーライドして <xref:System.Windows.UIElement.OnMouseRightButtonUp%2A>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウス ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.UIElement.OnMouseUp%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.UIElement.MouseLeftButtonUp> と <xref:System.Windows.UIElement.MouseRightButtonUp>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.UIElement.OnMouseUp%2A>, 、クラス処理をすべての可能なマウスのボタンの操作を考慮できることが示すされます。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>未処理の<see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 添付ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.UIElement.OnPreviewMouseDown%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> と <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.UIElement.OnPreviewMouseDown%2A>, 、下にはアクションのすべての可能なマウス ボタンのクラス処理を考慮できるという意味です。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.UIElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>します。 マークすることができますが、 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement> をオーバーライドして <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Button> させ <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A> 、派生クラスで基本クラスの実装を呼び出さずにただし、このオーバーライドを無効に、 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.UIElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>します。 マークすることができますが、 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement> をオーバーライドして <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.UIElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement.MouseRightButtonDown>します。 マークすることができますが、 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement> をオーバーライドして <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するのには、このメソッドをオーバーライドできます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すも期待するマウス イベントの既定の入力処理を無効に呼び出しに失敗 <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>します。 派生した、 <xref:System.Windows.Controls.Control> させ <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A> 呼び出しベースにしていることがなく、派生クラスで、このオーバーライドを無効に含まれている、管理上のコンテキスト\] メニューの \[サービスの <xref:System.Windows.Controls.Control> の既定の動作です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> イベントは、トンネリングのルートで伝送に見えますが、実際に間接的な方法で転送します。<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 基になるイベントに、トンネル ルートとは、 <xref:System.Windows.UIElement> ルートが直接ルーティングされたイベントを発生させると同じ処理を使用、イベントに沿った <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>します。 マークすることができますが、 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素は永続化されません。 イベント インスタンスの全般的なハンドラーを防ぐために処理済みとしてマークする、\(を指定しなかったもの `handledEventsToo`\) が呼び出されているからです。  
  
 一般的なマウスのイベント処理の既定の実装 <xref:System.Windows.UIElement> リッスン <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> し、適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターでの代替クラス ハンドラーを登録 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>します。 マウスの処理の動作を変更することはできません <xref:System.Windows.UIElement> をオーバーライドして <xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。 入力などのマウス ボタンの動作に依存しており、コマンド バインディングでは、その他のプログラミング機能は、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントを処理するには、 <xref:System.Windows.UIElement.OnPreviewMouseUp%2A> は呼び出されません。  
  
 次のイベントが可能性のある影響このクラスのハンドラーを使用して、イベントを処理済みとしてマークする場合: <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> と <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>です。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> を受信します。  
  
 このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を渡します。 クラスの処理でイベントを処理すると、サブイベントのインスタンスのハンドラーは呼び出されずに明示的に使用する場合を除き、 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> と `handledEventsToo` `true` ハンドラーをアタッチするためにします。  クラスのハンドラーもは呼び出されませんにこれらのクラスのハンドラーが登録されていない限り、 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して署名 `handledEventsToo` `true`します。  処理することにより <xref:System.Windows.UIElement.OnPreviewMouseUp%2A>, 、クラス処理をすべての可能なマウスのボタンの操作を考慮できることが示すされます。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントも仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切なことを検討してください。  
  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。 プレビュー イベントが具体的には、別のシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.UIElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.PreviewTouchDown" /> タッチがこの要素を押したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.PreviewTouchDown> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.PreviewTouchMove" /> タッチがこの要素内に移動したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.PreviewTouchMove> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.PreviewTouchUp" /> タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.PreviewTouchUp> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnRender">
      <MemberSignature Language="C#" Value="protected virtual void OnRender (System.Windows.Media.DrawingContext drawingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRender(class System.Windows.Media.DrawingContext drawingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawingContext" Type="System.Windows.Media.DrawingContext" />
      </Parameters>
      <Docs>
        <param name="drawingContext">特定の要素の描画の手順です。 このコンテキストは、レイアウト システムで提供されています。</param>
        <summary>派生クラスでオーバーライドされると、レイアウト システムの指示で行われるレンダリング操作に参加します。 この要素の表示に関する指示は、このメソッドが呼び出されるときに、直接は使用されませんし、代わりにでは保持されます後非同期で使用できるレイアウトと描画します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッド既定の実装ではない、 <xref:System.Windows.UIElement> クラスです。  
  
   
  
## 例  
 次のコード例では、パネルの派生クラスの実装を示します。  
  
 [!code-csharp[LightWeightCustomPanel\#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LightWeightCustomPanel/CSharp/OffsetPanel.cs#1)]
 [!code-vb[LightWeightCustomPanel\#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LightWeightCustomPanel/visualbasic/offsetpanel.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The <see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" /> method can be overridden to add further graphical elements (not previously defined in a logical tree) to a rendered element, such as effects or adorners. A <see cref="T:System.Windows.Media.DrawingContext" /> object is passed as an argument, which provides methods for drawing shapes, text, images or videos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRenderSizeChanged (System.Windows.SizeChangedInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="info">パッケージ化されたパラメーター \(<see cref="T:System.Windows.SizeChangedInfo" />\)。これには、新旧のサイズと、どのディメンションが実際に変更されたかが含まれます。</param>
        <summary>派生クラスでオーバーライドされると、レイアウト システムの指示で行われるレンダリング操作に参加します。 レイアウトの更新の結果として要素の <see cref="P:System.Windows.UIElement.RenderSize" /> が変化した場合、このメソッドはレイアウトが更新されてからレンダリングが行われるまでの間に呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 一般的な WPF フレームワーク レベル要素からオーバーライドの実装を使用して <xref:System.Windows.FrameworkElement>します。<xref:System.Windows.FrameworkElement> 実装無効にし、 <xref:System.Windows.FrameworkElement.Width%2A> と <xref:System.Windows.FrameworkElement.Height%2A> プロパティとレイアウトを再構築の基礎のハンドル。 オーバーライドする <xref:System.Windows.UIElement.OnRenderSizeChanged%2A> で、 <xref:System.Windows.UIElement> いる要素の実装は WPF フレームワーク レベルの実装を使用しては意図的に、要素必要があります処理のレイアウト ロジックより直接的通常置換レイアウト システムを記述して、レベルが含まれます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation. You may call base either before or after your special handling, depending on your requirements.  
  
 The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. Marking the event as handled is still useful for preventing typical instance handlers \(those that do not specify **parameterReference tag is not supported!!!!**  
\) from being invoked.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。 呼び出すことが基本の特別な処理の前後どちらでも、要件に応じて。  
  
 このメソッドの目的は、のような [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 標準的なインスタンス ハンドラーを防止するために今なお役立ちますが、イベントを処理済みとしてマーク \(が指定されていないもの `handledEventsToo`\) が呼び出されているからです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  
  
 The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  
  
 Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>ハンドルされない <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 添付イベントがそのルート上でこのクラスから派生した要素に到達すると、呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 添付イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、既定の実装ではありません。 継承の中間クラスでは、このメソッドを実装があるため、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的がに似ていますが、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] でのイベント パターン \* 方法: このメソッドは、インスタンス ハンドラーではなくクラスのハンドラーを確立することによって派生クラスから一致するイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティングされたイベントです。 On のメソッドの実装パターンは、ルーティングされたイベントは、必ずしもハンドラーを呼び出す要素ではない子要素によって生成できるためにルーティングされたイベントに異なります。 そのため、実装では、イベント データのソースのプロパティを点検する必要があります。 ほとんどの場合、イベントが再発生しないでください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを <xref:System.Windows.EventManager.RegisterClassHandler%2A>, の派生クラス <xref:System.Windows.UIElement> イベントがイベントのルートの途中受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラスの処理が適切では 1 つのシナリオでは、イベント データを操作し、ルーティングされたイベントを処理済みとしてマークします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.TouchDown" /> タッチがこの要素の内部を押したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnTouchDown%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnTouchDown%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.TouchDown> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnTouchDown%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.TouchEnter" /> ルーティングされたイベントから、タッチに移動したときに発生するこの要素の境界内に外部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnTouchEnter%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnTouchEnter%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.TouchEnter> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnTouchEnter%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.TouchLeave" /> からタッチを移動するときに発生するルーティングされたイベントのこの境界の外側に内部 <see cref="T:System.Windows.UIElement" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnTouchLeave%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnTouchLeave%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.TouchLeave> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnTouchLeave%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.TouchMove" /> タッチがこの要素内に移動したときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnTouchMove%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnTouchMove%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.TouchMove> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnTouchMove%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>クラスの処理を提供、 <see cref="E:System.Windows.UIElement.TouchUp" /> タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.OnTouchUp%2A> メソッドが既定の実装を持ちません。 オーバーライド <xref:System.Windows.UIElement.OnTouchUp%2A> を処理する派生クラスで、 <xref:System.Windows.UIElement.TouchUp> イベントです。 必ず、基本クラスの <xref:System.Windows.UIElement.OnTouchUp%2A> を基本クラス メソッドがイベントを受け取る。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">以前の親です。 これは、として提供されること <see langword="null" /> 場合、 <see cref="T:System.Windows.DependencyObject" /> 親要素は既にありませんでした。</param>
        <summary>ときに呼び出さこれの親要素 <see cref="T:System.Windows.UIElement" /> 基になる visual 親に、変更を報告します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If you override this method, always call the base implementation. The default base implementation performs some internal maintenance of reverse-inherited property state. Failing to call the base implementation will invalidate this state.  
  
 This method overrides <see cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />. <see cref="T:System.Windows.FrameworkElement" /> and <see cref="T:System.Windows.Window" /> both also override the <see cref="T:System.Windows.UIElement" /> implementation of <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />, and <see cref="T:System.Windows.Window" /> seals it.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.UIElement" /> を ユーザー インターフェイス (UI) に表示する際に、その全体に適用される不透明度率を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>不透明度率。 既定の不透明度は 1.0 です。 予期される値は 0 0 ～ 1.0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 1.0 の既定値はこの依存関係プロパティの初期メタデータによって提供される既定値、 <xref:System.Windows.UIElement> クラスです。 他の派生クラスは、クラス コンス トラクター内からのメタデータをオーバーライドすることでこの既定値を変更可能性のある可能性があります。  
  
 値 <xref:System.Windows.UIElement.Opacity%2A> 要素は表示もしない限り、実際のレイアウトには適用されません \(<xref:System.Windows.UIElement.IsVisible%2A> は `true`\)。  
  
 <xref:System.Windows.UIElement.Opacity%2A> 適用されて親要素から要素ツリーの下位に子要素が入れ子になったの不透明度の設定は個々 の子要素のプロパティの値に示されている表示効果。 たとえば場合不透明度を 50% \(0.5\) は、リストが、そのリスト項目のいずれかの独自の不透明度が 20% \(0.2\) に設定、そのリスト アイテムの表示されている net の不透明度はレンダリングされます 10% \(0.1\) の場合と同様リスト項目のプロパティ値が <xref:System.Windows.UIElement.Opacity%2A> プロパティも 0.2 が照会されたときにします。  
  
 宣言または評価された不透明度が 0 の場合でも要素はまだ入力イベント、およびコマンドに参加しているしがフォーカスを取得できる可能性があります。 この側面は便利ですが、透明な要素を基になるオブジェクトのマスクの不透明度 0 オブジェクト \(shape\) などを使用するインスタンスにすることはできます。 不透明度 0 のオブジェクトには、すべての入力イベントを基になる領域の処理、処理できます。 ただし、 `Background` または `Fill` オブジェクトまたは図形の必要がありますに設定する値がある場合でも <xref:System.Windows.Media.Brushes.Transparent%2A>, 、それ以外の場合のヒット テストが有効でないと、イベントが受信されません。  
  
<a name="dependencyPropertyInfo_Opacity"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.OpacityProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.OpacityMask" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.OpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の描画されるコンテンツのアルファ チャネル マスクに適用される <see cref="T:System.Windows.Media.Brush" /> 実装として、不透明マスクを取得または設定します。  これは依存関係プロパティです。</summary>
        <value>不透明マスクに使用するブラシ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティがアルファ チャネルの値は、指定された内容を使用してのみ <xref:System.Windows.Media.Brush>します。 その他のチャネル、 <xref:System.Windows.Media.Brush>\(赤、緑、または青\) のコンテンツをレンダリングが無視されます。  
  
 最も一般的な <xref:System.Windows.Media.Brush> この目的は、 <xref:System.Windows.Media.ImageBrush>, 、マスク、画像を表示などのさまざまな使用できます。 定義されている、 <xref:System.Windows.Media.Brush> \(など <xref:System.Windows.Media.LinearGradientBrush>\) 使用することができます。  
  
 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], 、このプロパティの値は、の各実装に固有であるインライン構文を使用できる、 <xref:System.Windows.Media.Brush> 抽象クラスです。 詳細については、次を参照してください。 [純色、グラデーションの概要でペイント](http://msdn.microsoft.com/ja-jp/f5b182f3-c5c7-4cbe-9f2f-65e690d08255)します。  
  
<a name="dependencyPropertyInfo_OpacityMask"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.OpacityMaskProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次のマークアップの例、 <xref:System.Windows.Media.ImageBrush> 別に適用される不透明度マスク <xref:System.Windows.Controls.Image>します。  
  
 [!code-xml[OpacityMasksExample\#UIElementOpacityMask](~/samples/snippets/csharp/VS_Snippets_Wpf/OpacityMasksExample/CS/ImageBrushExample.xaml#uielementopacitymask)]
 [!code-xml[OpacityMasksExample\#UIElementOpacityMask](~/samples/snippets/xaml/VS_Snippets_Wpf/OpacityMasksExample/XAML/ImageBrushExample.xaml#uielementopacitymask)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Opacity" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMaskProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OpacityMaskProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OpacityMaskProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.OpacityMaskProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.OpacityMask" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpacityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OpacityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OpacityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.OpacityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.Opacity" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistId">
      <MemberSignature Language="C#" Value="public int PersistId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PersistId" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.PersistId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("PersistId is an obsolete property and may be removed in a future release.  The value of this property is not defined.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素を一意に識別する値を取得します。</summary>
        <value>この要素の一意の識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.PersistId%2A> 各要素を一意に識別します。 要素は同じ <xref:System.Windows.UIElement.PersistId%2A> たびに同じ [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] \(バイナリ表現を含む\) が読み込まれます。 この識別子は、内部の読み込み、解析およびシリアル化の要件に使用されます。 アプリケーション コードで使用することはありません。  
  
 このプロパティへのリレーションシップを持たない、 <xref:System.Object.GetHashCode%2A> 、特定のインスタンスの結果。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">要求されたフォーカスの移動の方向です。</param>
        <summary>派生クラスでオーバーライドされた場合は、実際にその要素にフォーカスを移動せず指定したフォーカスの移動の方向のフォーカスを受け取る要素を返します。</summary>
        <returns>要素がフォーカスを受け取った場合 <see cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> が実際に呼び出されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このクラスでは、このメソッドの既定の実装が完了していないと、常に返します `null`します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewDragEnter> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewDragEnter> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewDragEnterEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.DragEnter>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewDragEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewDragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewDragLeave> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewDragLeave> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewDragLeaveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.DragLeave>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewDragLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewDragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewDragOver> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewDragOver> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewDragOverEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.DragOver>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewDragOver%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewDragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDrop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewDrop> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewDrop> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewDropEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.Drop>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewDrop%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewDrop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewGiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作が開始されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.PreviewGiveFeedback> イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewGiveFeedback> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewGiveFeedback> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewGiveFeedbackEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.GiveFeedback>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewGiveFeedback%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewGiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、ルーティングのトンネリングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際にアタッチされている要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスがある実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewGotKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewGotKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewGotKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.GotKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewGotKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewKeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがある状態でキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーの処理は、コマンドの実行とテキストの合成などの他のプラットフォーム機能と対話します。<xref:System.Windows.UIElement.KeyDown> イベントは、下位レベルのテキストの入力イベントの特定のコントロールで期待どおりに動作しません。 これは、一部のコントロールがコントロールの複合か、テキストの高レベルのバージョンを提供するクラスの処理が入力処理および関連するイベントです。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewKeyDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewKeyDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewKeyDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.KeyDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewKeyDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewKeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewKeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがあるときにキーが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーの処理は、コマンドの実行とテキストの合成などの他のプラットフォーム機能と対話します。<xref:System.Windows.UIElement.KeyUp> イベントは、下位レベルのテキストの入力イベントの特定のコントロールで期待どおりに動作しません。 これは、一部のコントロールがコントロールの複合か、テキストの高レベルのバージョンを提供するクラスの処理が入力処理および関連するイベントです。 詳細については、個々 のコントロールのマニュアルを確認します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewKeyUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewKeyUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewKeyUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.KeyUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewKeyUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewKeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、ルーティングのトンネリングを使用しているために、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている、要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A> フォーカスを失った実際の要素を特定のイベント データ。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewLostKeyboardFocus> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewLostKeyboardFocus> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewLostKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.LostKeyboardFocus>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewLostKeyboardFocus%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewMouseDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewMouseDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement.PreviewMouseDown> イベントは、多くの場合、いずれかと共に <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> または <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>, 、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown><xref:System.Windows.UIElement.PreviewMouseRightButtonDown> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> または <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>です。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewMouseDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.MouseDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewMouseDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewMouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、次の要素ツリーを通じてトンネリング ルーティングするよう、実際には直接ルーティングされたイベントが発生し、要素ツリーに沿った各が再度発生する <xref:System.Windows.UIElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。 場合によってクラス ハンドラーが生成されるイベントに関する情報もなど <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、次の要素ツリーを通じてトンネリング ルーティングするよう、実際には直接ルーティングされたイベントが発生し、要素ツリーに沿った各が再度発生する <xref:System.Windows.UIElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントが発生した両方要素境界内にマウス ポインターが最初に入ると、マウス ポインターが要素の境界内に残っているときに移動するともとします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewMouseMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewMouseMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewMouseMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.MouseMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewMouseMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewMouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseRightButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、次の要素ツリーを通じてトンネリング ルーティングするよう、実際には直接ルーティングされたイベントが発生し、要素ツリーに沿った各が再度発生する <xref:System.Windows.UIElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。 場合によってクラス ハンドラーが生成されるイベントに関する情報もなど <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>します。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewMouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、次の要素ツリーを通じてトンネリング ルーティングするよう、実際には直接ルーティングされたイベントが発生し、要素ツリーに沿った各が再度発生する <xref:System.Windows.UIElement>です。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベント ルート上の各要素によって処理されるアタッチされるイベントはイベントです。  
  
 このイベントのイベント データは、基になるイベントのデータを公開 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントです。 そのイベントがイベントのルートに沿って処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります <xref:System.Windows.UIElement.AddHandler%2A>, 、イベント リスナーをするために、処理済みとしてマークされているイベントを処理するオプションを使用します。 マークした場合 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> 、処理は本質的にマークして <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 経路では、さらにすべてのリスナーに対して処理され、すべての関連するイベントです。  
  
 概念的には、このイベントと考える \(とその他のマウス ボタンのイベントの <xref:System.Windows.UIElement>\) マウス"service"である \(によって提供されるサービス定義で、 <xref:System.Windows.Input.Mouse> クラス\)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 \(左から右アップダウン\) を確認する必要がないという利便性を追加します。 非標準のボタンの状態の確認などの高度なシナリオを使用する必要があります、 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 上、 <xref:System.Windows.Input.Mouse> のものではなくクラス <xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewMouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewMouseUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewMouseUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement.PreviewMouseUp> イベントは、多くの場合、いずれかと共に <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> または <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>, 、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp><xref:System.Windows.UIElement.PreviewMouseRightButtonUp> ルーティングされたイベントもしています、直接ルーティング イベントは適切なボタンに固有のイベントが発生したときに、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> イベント ルート上には、この要素に到達します。 「解説」を参照してください <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> または <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>です。  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewMouseUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.MouseUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewMouseUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewMouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。そのため、フォーカスがあるか、キャプチャした要素からこのイベントを受信する場合、マウス ポインターのほう別の要素上です。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewMouseMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewMouseMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewMouseWheelEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.MouseWheel>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewMouseWheel%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewMouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewQueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.PreviewQueryContinueDrag> イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作をキャンセルする必要があるかどうかを宣言します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewQueryContinueDrag> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewQueryContinueDrag> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewQueryContinueDragEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.QueryContinueDrag>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewQueryContinueDrag%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewStylusButtonDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewStylusButtonDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Touch Input Support in Windows Vista](http://msdn.microsoft.com/ja-jp/63f1d71f-03d8-4d83-a174-e3dc7c57bad0) と [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewStylusButtonDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.StylusButtonDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewStylusButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewStylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewStylusButtonUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewStylusButtonUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewStylusButtonUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.StylusButtonUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewStylusButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewStylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewStylusDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewStylusDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewStylusDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.StylusDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewStylusDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewStylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusInAirMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewStylusInAirMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewStylusInAirMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewStylusInAirMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.StylusInAirMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewStylusInAirMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusInRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewStylusInRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewStylusInRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewStylusInRangeEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.StylusInRange>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewStylusInRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewStylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素上にある間にスタイラスが移動すると発生します。 このイベントを発生させるためには、デジタイザーによって検出されている間にスタイラスが移動する必要があります。それ以外の場合には、代わりに <see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /> が発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewStylusMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewStylusMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewStylusMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.StylusMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewStylusMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewStylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusOutOfRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがデジタイザーから離れすぎているために検出されないときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewStylusOutOfRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewStylusOutOfRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewStylusOutOfRangeEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.StylusOutOfRange>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewStylusOutOfRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusSystemGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスのジェスチャについては、次を参照してください。 <xref:System.Windows.Input.SystemGesture>します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewStylusSystemGesture> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewStylusSystemGesture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewStylusSystemGestureEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.StylusSystemGesture>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewStylusSystemGesture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewStylusDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewStylusDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewStylusUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.StylusUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewStylusUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewStylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.PreviewTextInput> イベントは、コンポーネントまたはデバイスに依存しない方法でテキストの入力を待機するアプリケーションを使用します。 キーボードの主要な手段は、 <xref:System.Windows.UIElement.PreviewTextInput>; が、音声認識、手書き認識、およびその他の入力デバイスも <xref:System.Windows.UIElement.PreviewTextInput>です。  
  
 キーの組み合わせのため、既定のキーボードまたは入力方式エディターを通じて\-複数のキー イベントが 1 つだけのテキスト入力イベントを発生させる可能性があります。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.PreviewTextInput> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.PreviewTextInput> イベントは、基になるに関連付けられている <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewTextInputEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.TextInput>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewTextInput%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewTextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、 <xref:System.Windows.UIElement.PreviewTouchDown> と <xref:System.Windows.UIElement.TouchDown> 指が画面をタッチし、移動するまでのイベントが発生しません。 画面に指を押すと、により、キーを押して移動せず保持しているとの動作を保持する <xref:System.Windows.Input.Stylus>です。 プレス アンド ホールド動作では、マウスの右クリックに相当します。  
  
 発生する、 <xref:System.Windows.UIElement.PreviewTouchDown> と <xref:System.Windows.UIElement.TouchDown> 指が、画面をタッチするとすぐに発生するイベントの設定、 <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName> 添付プロパティを `false` この要素のです。  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewTouchDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.TouchDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewTouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewTouchMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.TouchMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewTouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.PreviewTouchUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するバブル イベントが <xref:System.Windows.UIElement.TouchUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.PreviewTouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.QueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.QueryContinueDrag> イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作をキャンセルする必要があるかどうかを決定します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.QueryContinueDrag> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.QueryContinueDrag> イベントは、基になるに関連付けられている <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.QueryContinueDragEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewQueryContinueDrag>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnQueryContinueDrag%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.QueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.QueryCursor" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カーソルの表示が要求されると発生します。 このイベントは、マウス ポインターが別の位置へ移動するたびに要素上で発生します。したがって、場合によってはカーソル オブジェクトを移動先の位置に基づいて変更する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.QueryCursor> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.QueryCursor> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 このイベントの名前によって参照されているカーソルは、必ずしも \(挿入ポイントとも呼ばれ\) テキストのカーソルではありません。 代わりに、いくつかの可能な入力に関連するデバイスまたはの概念に関連する画面に表示されるグラフィカルな表示を宣言するオブジェクトは、このコンテキストでのカーソル [!INCLUDE[TLA2#tla_win](~/includes/tla2sharptla-win-md.md)] プログラミングします。 そのオブジェクトがによって表される、 <xref:System.Windows.Input.Cursor> クラス [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]します。[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 入力システムでは、マウス ポインターの画面上の位置を表す場合は、このカーソルを変更することができます。 定義済みの値を使用して、 <xref:System.Windows.Input.Cursors> 列挙型、またはするには、画像ファイルとしてカスタムのカーソルを宣言できます。  
  
 リッスン、 <xref:System.Windows.UIElement.QueryCursor> イベントは、カーソルの管理のための効率的な手法ではありません。 各要素がで独自のカーソル動作を定義する代わりに、 <xref:System.Windows.FrameworkContentElement.Cursor%2A> と <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>です。 ブラウザー リダイレクトにのみ依存 <xref:System.Windows.UIElement.QueryCursor> WPF フレームワーク レベルの基本要素を使用していないかで異常な場合に、カーソルの動作を定義する要素ごとの単位ではニーズに合わないかどうか。 応答でのカーソルの動作の実装の詳細については <xref:System.Windows.UIElement.QueryCursor>, を参照してください <xref:System.Windows.Input.QueryCursorEventHandler>します。  
  
<a name="routedEventInfo_QueryCursor"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.QueryCursorEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnQueryCursor%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.QueryCursor" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納し、発生するイベントを識別する <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>特定のルーティング イベントを発生させます。 発生する <see cref="T:System.Windows.RoutedEvent" /> は、提供された <see cref="T:System.Windows.RoutedEventArgs" /> インスタンス内で識別されます \(そのイベント データの <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティとして\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `e` パラメーターは、ルーティングされたイベントのすべてのデータの共通の基本型として型指定された、ただし、イベント データを与えるために、生成されたイベントに対して使用可能な最も限定のイベント データの種類として必要があります。 <xref:System.Windows.RoutedEventArgs> 派生クラスでは、特定のイベントが発生したときに特定の実際のデータ プロパティが含まれています。  
  
 <xref:System.Windows.RoutedEventArgs> イベントの状態のプロパティだけではありません。ルーティングされたイベントを発生させるも特定します。 このイベントの発生パターンと、ルーティングされたイベント データの両方とは異なる [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] イベントに関連するプロパティを通常だけが含まれるイベントおよびデータのクラスです。  
  
   
  
## 例  
 次の例は、イベント データを作成、イベント識別子をデータに追加し、カスタム ルーティング イベントを発生させるイベント データ インスタンスを使用します。  
  
 [!code-csharp[RoutedEventCustom\#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom\#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseAllTouchCaptures" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素からすべてのキャプチャされたタッチ デバイスを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseMouseCapture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素には、キャプチャが保持されている場合は、マウスのキャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この要素がキャプチャを保持していない場合は、このメソッドを呼び出しても効果はありません。 値を確認してください <xref:System.Windows.UIElement.IsMouseCaptured%2A> このメソッドを呼び出す前にします。  
  
   
  
## 例  
 次の例は、並列の例に <xref:System.Windows.UIElement.CaptureMouse%2A>: マウスのキャプチャのリリースまでのマウス ボタンを処理し、マウスを移動するを再度有効にします。  
  
 [!code-csharp[CubeAnimation\#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[CubeAnimation\#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseStylusCapture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素には、キャプチャが保持されている場合は、スタイラス デバイスのキャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この要素がキャプチャを保持していない場合は、このメソッドを呼び出しても効果はありません。 値を確認してください <xref:System.Windows.UIElement.IsStylusCaptured%2A> このメソッドを呼び出す前にします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">解放するデバイスです。</param>
        <summary>この要素から指定されたタッチ デバイスを解放しようとしています。</summary>
        <returns>
          <see langword="true" /> タッチ デバイスが解放された場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドラーが添付されているルーティング イベントの識別子。</param>
        <param name="handler">この要素のイベント ハンドラー コレクションから削除する特定のハンドラー実装。</param>
        <summary>指定したルーティング イベント ハンドラーをこの要素から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これを使用するための最も一般的なシナリオ [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] を実装する場合は、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] カスタム ルーティング イベントのハンドラーの"remove"ロジックを実装するときに特に関連付けられている「ラッパー」イベント、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] レベルです。 これを次の例「解説」のセクションでは、このシナリオを示しています。  
  
 このメソッドを呼び出しても何も起こりませんメソッド呼び出しの入力パラメーターに一致する基準で登録されたハンドラーが存在しない場合。  
  
 複数のイベント ハンドラーのストアが削除される最初のハンドラーにのみ、条件に一致する 1 つのハンドラーがアタッチされます。 この動作は [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] の動作、 `-=` 演算子。  
  
 どちらも `routedEvent` も `handler` あります `null`します。 いずれかの値として入力しようとしています。 `null` 、例外が発生します。  
  
 このメソッドは無視、 `handledEventsToo` 場合は、ハンドラーが最初に提供されるパラメーターについては、追加、 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 処理済みのイベントの処理を有効に署名します。 ハンドラーのいずれかの種類が削除されます。  
  
   
  
## 例  
 次の例では使用 <xref:System.Windows.UIElement.RemoveHandler%2A> イベント ラッパー定義の一部として。  
  
 [!code-csharp[RoutedEventCustom\#AddRemoveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
 [!code-vb[RoutedEventCustom\#AddRemoveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="RenderSize">
      <MemberSignature Language="C#" Value="public System.Windows.Size RenderSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size RenderSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の最終的な描画サイズを取得します \(または、設定します。設定については「解説」を参照してください\)。</summary>
        <value>この要素の描画のサイズ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  このプロパティは、のいずれかを設定しないでください [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] またはコードでは、WPF フレームワーク レベル レイアウト システムを使用する場合。 ほぼすべての一般的なアプリケーション シナリオでは、このレイアウト システムを使用します。 レイアウト システムがサイズの設定に従いません、 <xref:System.Windows.UIElement.RenderSize%2A> プロパティを直接します。<xref:System.Windows.UIElement.RenderSize%2A> プロパティが宣言される特定の WPF コア レベルのサポートなどの一般的なレイアウト プロトコルを意図的に回避するケースのブリッジを有効にする場合にのみ書き込み可能な <xref:System.Windows.Documents.Adorner> クラスです。  
  
 レイアウト システム内で該当する表示サイズの上書きなどをチェックするため、このプロパティを使用できます <xref:System.Windows.UIElement.OnRender%2A> または <xref:System.Windows.UIElement.GetLayoutClip%2A>です。  
  
 一般的なシナリオの処理、 <xref:System.Windows.FrameworkElement.SizeChanged> クラス ハンドラーでイベントをオーバーライドまたは <xref:System.Windows.UIElement.OnRenderSizeChanged%2A> イベントです。  
  
<a name="xamlTextUsage_RenderSize"></a>   
## XAML テキストの使用方法  
   
  
## 例  
 次の例は、カスタムの装飾が使用する方法を示しています、 <xref:System.Windows.UIElement.RenderSize%2A> 値を作成しの一部として、装飾を定義する四角形の画像のサイズを変更するためにその <xref:System.Windows.UIElement.OnRender%2A>実装します。  
  
 [!code-csharp[AdornersMiscCode\#UIElementDesiredSize](~/samples/snippets/csharp/VS_Snippets_Wpf/AdornersMiscCode/CSharp/Window1.xaml.cs#uielementdesiredsize)]
 [!code-vb[AdornersMiscCode\#UIElementDesiredSize](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AdornersMiscCode/visualbasic/window1.xaml.vb#uielementdesiredsize)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.UpdateLayout" />
      </Docs>
    </Member>
    <Member MemberName="RenderTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform RenderTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform RenderTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の描画位置に影響する変換情報を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>必要な描画変換の詳細を記述します。 既定値は、<see cref="P:System.Windows.Media.Transform.Identity" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 描画変換はレイアウト サイズを再生成またはサイズの情報を表示できません。 レンダリングの変換は通常アニメーション化するか、一時的な効果を要素に適用するためのものです。 されているものと、または部分に目を描画する負荷に重点を置いたときに、要素が拡大表示など、 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]です。  
  
<a name="dependencyPropertyInfo_RenderTransform"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.RenderTransformProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformOrigin">
      <MemberSignature Language="C#" Value="public System.Windows.Point RenderTransformOrigin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Point RenderTransformOrigin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderTransformOrigin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.RenderTransform" /> によって宣言されるすべての使用可能な表示変換の中心点を、要素の境界からの相対位置で取得または設定します。  これは依存関係プロパティです。</summary>
        <value>描画変換を宣言する値。 既定値は座標が \(0, 0\) の <see cref="T:System.Windows.Point" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.RenderTransformOrigin%2A> やや非標準の使用、 <xref:System.Windows.Point> の値を構造体、 <xref:System.Windows.Point> 座標系内の絶対位置を表していません。 代わりに、0 ~ 1 の範囲の値は、それぞれの x、y 軸の現在の要素の範囲の要素として解釈されます。 たとえば、\(0.5,0.5\) が、要素上に中央揃えにする描画変換を \(1, 1\) またはれる描画変換下部にある要素の右下隅です。<xref:System.Double.NaN> 指定できる値はありません。  
  
 0 と 1 の外の値もが受け入れられ、その他の独創的な変換の効果になります。 たとえば、設定した場合 <xref:System.Windows.UIElement.RenderTransformOrigin%2A> \(5,5\) を適用し、 <xref:System.Windows.Media.RotateTransform>, 、要素自体の境界外も回転の点になります。 変換には、要素は、右下を超える発信される大きな円の周囲をスピンします。 原点その親要素内のどこかにいる場合があり、可能性がある可能性があるフレームまたはビューから。 負のポイント値は似ていますが、これらは左の境界を超えます。  
  
 表示のレイアウトには影響しませんの変換と通常はアニメーション化するか、要素に一時的な効果を適用に使用します。  
  
<a name="xamlAttributeUsage_RenderTransformOrigin"></a>   
## XAML 属性の使用方法  
  
```  
<object RenderTransformOrigin="xOrigin, yOrigin"/>  
```  
  
<a name="xamlPropertyElementUsage_RenderTransformOrigin"></a>   
## XAML プロパティ要素の使用  
  
```  
<object>  
  <object.RenderTransformOrigin>  
    <Point X="xOrigin" Y="yOrigin"/>  
  </object.RenderTransformOrigin>  
</object>  
```  
  
<a name="xamlValues_RenderTransformOrigin"></a>   
## XAML 値  
 *xOrigin*  
 左右の余白の係数。 これは通常、0 ~ 1 の値として指定されます。 「解説」を参照してください。  
  
 *も*  
 垂直方向の中心点の係数。 これは通常、0 ~ 1 の値として指定されます。 「解説」を参照してください。  
  
<a name="dependencyPropertyInfo_RenderTransformOrigin"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.RenderTransformOriginProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例のコード内の要素を作成して、適用、 <xref:System.Windows.UIElement.RenderTransformOrigin%2A>, を適用してから、  <xref:System.Windows.UIElement.RenderTransform%2A>です。  
  
 [!code-csharp[transformanimations\_snip\#UIElementRenderTransformOrigin](~/samples/snippets/csharp/VS_Snippets_Wpf/transformanimations_snip/CSharp/RotateAboutCenterExample.cs#uielementrendertransformorigin)]
 [!code-vb[transformanimations\_snip\#UIElementRenderTransformOrigin](~/samples/snippets/visualbasic/VS_Snippets_Wpf/transformanimations_snip/visualbasic/rotateaboutcenterexample.vb#uielementrendertransformorigin)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.RenderTransform" />
      </Docs>
    </Member>
    <Member MemberName="RenderTransformOriginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderTransformOriginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderTransformOriginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.RenderTransformOriginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.RenderTransformOrigin" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.RenderTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.RenderTransform" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ShouldSerializeCommandBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスでの内容をシリアル化する必要かどうかを返す、 <see cref="P:System.Windows.UIElement.CommandBindings" /> このクラスのインスタンスのプロパティです。</summary>
        <returns>
          <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.UIElement.CommandBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるには `true` 場合 <xref:System.Windows.UIElement.CommandBindings%2A> ローカルに設定します。  
  
 これは、 `ShouldSerialize` ために、メソッドが提供される、 <xref:System.Windows.UIElement.CommandBindings%2A> プロパティには、単純な既定値はありません。 このメソッドは、プロパティが既定値から変更されたかどうかを示します。 デザイナーを開発または独自コントロールを組み込むことを開発する場合に通常、このメソッドが呼び出す、 <xref:System.Windows.UIElement>です。  
  
 詳細については、「[ShouldSerialize and Reset Methods](http://msdn.microsoft.com/ja-jp/7b6c5e00-3771-46b4-9142-5a80d5864a5e)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ShouldSerializeInputBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスでの内容をシリアル化する必要かどうかを返す、 <see cref="P:System.Windows.UIElement.InputBindings" /> このクラスのインスタンスのプロパティです。</summary>
        <returns>
          <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.UIElement.InputBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるには `true` 場合 <xref:System.Windows.UIElement.InputBindings%2A> ローカルに設定します。  
  
 これは、 `ShouldSerialize` ために、メソッドが提供される、 <xref:System.Windows.UIElement.InputBindings%2A> プロパティには、単純な既定値はありません。 このメソッドは、プロパティが既定値から変更されたかどうかを示します。 デザイナーを開発または独自コントロールを組み込むことを開発する場合に通常、このメソッドが呼び出す、 <xref:System.Windows.UIElement>です。  
  
 詳細については、「[ShouldSerialize and Reset Methods](http://msdn.microsoft.com/ja-jp/7b6c5e00-3771-46b4-9142-5a80d5864a5e)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixels">
      <MemberSignature Language="C#" Value="public bool SnapsToDevicePixels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SnapsToDevicePixels" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.SnapsToDevicePixels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素のレンダリングがレンダリング中にデバイスに固有のピクセルの設定を使用するかどうかを決定する値を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>デバイスのピクセルに従って要素を描画する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。<see cref="T:System.Windows.UIElement" /> で宣言された既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを設定できます `true` ピクセルを有効にする、ルート要素をスナップ UI 全体を表示します。 96 より大きい値で動作するデバイスの [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)], 、ピクセル スナップ レンダリングには、単体の実線の近くのアンチエイリアシング visual 成果物が最小限に抑えることができます。  
  
 によって継承される <xref:System.Windows.FrameworkElement> 可能性のあるすべての派生クラス、または <xref:System.Windows.FrameworkElement> を設定するには、この依存関係プロパティのメタデータをオーバーライド、 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> メタデータ プロパティを `true`します。 サブツリーの最も外側の要素だけを指定する必要があることは、これが実現 <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> として `true`, 、そのサブツリーのすべての子要素を報告し、 <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> として `true` とが、 <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> 視覚効果を適用します。  
  
<a name="dependencyPropertyInfo_SnapsToDevicePixels"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.SnapsToDevicePixelsProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixelsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SnapsToDevicePixelsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SnapsToDevicePixelsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.SnapsToDevicePixelsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.SnapsToDevicePixels" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.StylusButtonDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.StylusButtonDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusButtonDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewStylusButtonDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnStylusButtonDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.StylusButtonUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.StylusButtonUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusButtonUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewStylusButtonUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnStylusButtonUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.StylusDown> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.StylusDown> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewStylusDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnStylusDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.StylusEnter> 直接イベント ルーティング方法の処理を使用しているです。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、ルーティング イベントの動作のスタイルでイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.UIElement.StylusEnter> スタイラスがこのイベントをさらに、要素の境界に入った時点を追跡するレポート文字どおり、 <xref:System.Windows.UIElement.IsStylusOver%2A> からプロパティ値が変更 `false` に `true` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.StylusEnter> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.StylusEnter> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnStylusEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusInAirMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.StylusInAirMove> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.StylusInAirMove> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusInAirMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewStylusInAirMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnStylusInAirMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusInRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.StylusInRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.StylusInRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusInRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusInRangeEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewStylusInRange>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnStylusInRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスが要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.UIElement.StylusLeave> 直接イベント ルーティング方法の処理を使用しているです。 ルートは直接ルーティング イベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、ルーティング イベントの動作のスタイルでイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.UIElement.StylusLeave> スタイラスから削除すると、このイベント要素の境界の詳細のトラックが文字どおり報告された、 <xref:System.Windows.UIElement.IsStylusOver%2A> からプロパティ値が変更 `true` に `false` この要素にします。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.StylusLeave> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.StylusLeave> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnStylusLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素上を移動すると発生します。 このイベントを発生させるには、デジタイザー上でスタイラスを移動する必要があります。 それ以外の場合は、代わりに <see cref="E:System.Windows.UIElement.StylusInAirMove" /> が発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName>添付イベントが、このクラスに対してように<xref:System.Windows.UIElement.StylusMove>一部である、クラスのメンバーのリスト<xref:System.Windows.UIElement>基本要素として継承します。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)です。  
  
<a name="routedEventInfo_StylusMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusMoveEvent>|  
|ルーティング方法|バブリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネリング イベントが<xref:System.Windows.UIElement.PreviewStylusMove>です。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusOutOfRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスが検出可能になるにはデジタイザーから離れすぎているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.StylusOutOfRange> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.StylusOutOfRange> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusOutOfRangeEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewStylusOutOfRange>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnStylusOutOfRange%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusPlugIns">
      <MemberSignature Language="C#" Value="protected System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.StylusPlugIns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPlugIns.StylusPlugInCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関連付けられているすべてのスタイラス プラグイン \(カスタマイズ\) オブジェクトのコレクションを取得します。</summary>
        <value>スタイラス プラグインの特殊なコレクションとしてのコレクションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコレクションに追加するコントロールの例としては <xref:System.Windows.Controls.InkCanvas>です。 <xref:System.Windows.Controls.InkCanvas> 追加、 <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> これにより、コレクションのアイテムとして、 <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> スタイラスからの入力との対話およびスタイラス イベント駆動型への応答で一意の表示を生成します。  
  
 カスタム プラグインの作成の詳細については、受信およびスタイラスからの入力の解釈を参照してください。 [スタイラスからの入力をインターセプトする](http://msdn.microsoft.com/ja-jp/791bb2f0-4e5c-4569-ac3c-211996808d44)します。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> をインスタンス化し、それを追加、 <xref:System.Windows.UIElement.StylusPlugIns%2A> コントロールを処理するカスタムのインクのコレクション。  
  
 [!code-csharp[StylusPluginSamples\#3](~/samples/snippets/csharp/VS_Snippets_Wpf/StylusPluginSamples/CSharp/StylusControl.cs#3)]
 [!code-vb[StylusPluginSamples\#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StylusPluginSamples/VisualBasic/StylusControl.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.StylusPlugIns.DynamicRenderer" />
        <altmember cref="T:System.Windows.Controls.InkCanvas" />
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusSystemGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタイラスのジェスチャの詳細については、次を参照してください。 <xref:System.Windows.Input.SystemGesture>します。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.StylusSystemGesture> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.StylusSystemGesture> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusSystemGestureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewStylusSystemGesture>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnStylusSystemGesture%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.StylusUp> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.StylusUp> イベントは、基になるに関連付けられている <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラスからの入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [入力概要](http://msdn.microsoft.com/ja-jp/ee5258b7-6567-415a-9b1c-c0cbe46e79ef)します。  
  
<a name="routedEventInfo_StylusUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.StylusUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewStylusUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnStylusUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.StylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  このイベントは、複合コントロールの内部の実装で処理されるに既にマーク可能性があります。 以下の解説を参照してください。  
  
 <xref:System.Windows.UIElement.TextInput> イベントは、複合コントロールの内部実装によって処理済みとして既にマークことがあります。 など、 <xref:System.Windows.Controls.TextBox> 複合コントロールは、ここで、 <xref:System.Windows.UIElement.TextInput> ; 内の合成処理として、イベントは既に設定されています。 コントロールは、この操作するため、コントロールがいくつかの種類のコントロールに特別な意味を持つものとして、方向キーなどの入力を解釈する必要があります。 使用する場合 <xref:System.Windows.UIElement.PreviewTextInput> テキスト入力用のハンドラーをアタッチする、イベントとしてより良い結果が表示される場合があります。 この手法は、コントロールの複合が済みとマークされたこのイベントを処理し、ハンドラーがイベントの経路上のイベントを受信できないように、ほとんどの場合を回避できます。  
  
 <xref:System.Windows.UIElement.TextInput> イベントは、コンポーネントまたはデバイスに依存しない方法でテキストの入力を待機するアプリケーションを使用します。 キーボードの主要な手段は、 <xref:System.Windows.UIElement.TextInput>, 、音声認識、手書き認識、およびその他の入力デバイス上げることもできますが、 <xref:System.Windows.UIElement.TextInput>です。  
  
 キーの組み合わせのため、既定のキーボードまたは入力方式エディターを通じて\-複数のキー イベントが 1 つのテキスト入力イベントを発生させる可能性があります。  
  
 このイベントは、のエイリアスを作成、 <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName> イベントをこのクラスは、接続されているように <xref:System.Windows.UIElement.TextInput> 一部であるクラスのメンバーのリスト <xref:System.Windows.UIElement> 基本要素として継承します。 イベント ハンドラーに関連付けられている、 <xref:System.Windows.UIElement.TextInput> イベントは、基になるに関連付けられている <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName> 添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_TextInput"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.TextInputEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewTextInput>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnTextInput%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.TextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、 <xref:System.Windows.UIElement.PreviewTouchDown> と <xref:System.Windows.UIElement.TouchDown> 指が画面をタッチし、移動するまでのイベントが発生しません。 画面に指を押すと、により、キーを押して移動せず保持しているとの動作を保持する <xref:System.Windows.Input.Stylus>です。 プレス アンド ホールド動作では、マウスの右クリックに相当します。  
  
 発生する、 <xref:System.Windows.UIElement.PreviewTouchDown> と <xref:System.Windows.UIElement.TouchDown> 指が、画面をタッチするとすぐに発生するイベントの設定、 <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName> 添付プロパティを `false` この要素のです。  
  
<a name="routedEventInfo_TouchDown"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.TouchDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewTouchDown>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnTouchDown%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.TouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがから移動すると発生外部からこの要素の範囲内です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは発生常にこの要素にタッチ デバイスがキャプチャされるかどうか。  
  
<a name="routedEventInfo_TouchEnter"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.TouchEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnTouchEnter%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.TouchEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキャプチャされているすべてのタッチ デバイスを取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素にキャプチャされているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ビジュアル ツリーで、この要素にキャプチャされているすべてのタッチ デバイスまたはすべての子要素を取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上にあるすべてのタッチ デバイスを取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素上にあるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ビジュアル ツリーで、この要素上にあるすべてのタッチ デバイスまたはすべての子要素を取得します。</summary>
        <value>列挙体 <see cref="T:System.Windows.Input.TouchDevice" /> この要素またはそのビジュアル ツリー内のすべての子要素の上にあるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがから移動すると発生するこの要素の範囲外の内部です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは発生常にこの要素にタッチ デバイスがキャプチャされるかどうか。  
  
<a name="routedEventInfo_TouchLeave"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.TouchLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   オーバーライド <xref:System.Windows.UIElement.OnTouchLeave%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.TouchLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_TouchMove"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.TouchMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewTouchMove>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnTouchMove%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.TouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
<a name="routedEventInfo_TouchUp"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.TouchUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>です。|  
  
-   対応するトンネル イベントは、 <xref:System.Windows.UIElement.PreviewTouchUp>です。  
  
-   オーバーライド <xref:System.Windows.UIElement.OnTouchUp%2A> クラスの派生クラスでは、このイベントの処理を実装します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.UIElement.TouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslatePoint">
      <MemberSignature Language="C#" Value="public System.Windows.Point TranslatePoint (System.Windows.Point point, System.Windows.UIElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point TranslatePoint(valuetype System.Windows.Point point, class System.Windows.UIElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="relativeTo" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="point">この要素に相対的なポイント値。</param>
        <param name="relativeTo">指定したポイントに変換する要素。</param>
        <summary>この要素に相対的なポイントを、指定した要素に対する相対座標に変換します。</summary>
        <returns>元の要素ではなく変換先の要素に相対的なポイント値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 渡す `null` の `relativeTo` を許可したり、この要素が属する論理ツリーのルート要素に相対的な座標があることを示します。  
  
 このメソッドは、変換に使用テスト ポイントの値をヒットします。 このメソッドを呼び出すことは主にコントロールを作成するし、下のレベルの入力を処理する必要があります。 既存のコントロールを使用している場合は、通常、完成したコントロールが正しく変換済みのヒット テストの結果を報告すると見なすできます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Uid">
      <MemberSignature Language="C#" Value="public string Uid { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Uid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Uid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の一意の識別子 \(ローカライズ用\) を設定または取得します。 これは依存関係プロパティです。</summary>
        <value>この要素の一意識別子である文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 取得するデザイナーで使用される、 `x:Uid` 値 \(を参照してください [WPF のグローバリゼーションおよびローカリゼーションの概要](http://msdn.microsoft.com/ja-jp/56e5a5c8-6c96-4d19-b8e1-a5be1dc564af) の詳細\)。  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.UidProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UidProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UidProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UidProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.UidProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.Uid" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateLayout">
      <MemberSignature Language="C#" Value="public void UpdateLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.UpdateLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素のすべてのビジュアルな子要素がレイアウトに正常に更新されるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 持つ要素は、このメソッドを呼び出すと <xref:System.Windows.UIElement.IsMeasureValid%2A>`false` または <xref:System.Windows.UIElement.IsArrangeValid%2A>`false` 特定の要素を呼び出す <xref:System.Windows.UIElement.MeasureCore%2A> と <xref:System.Windows.UIElement.ArrangeCore%2A> メソッドで、強制的にレイアウトを更新して、すべての計算されたサイズが検証されます。  
  
 このメソッドを呼び出しても何も起こりませんレイアウトは変更されない場合、またはレイアウトの配置も測定の状態が無効です。 ただし、レイアウトがいずれかの点で有効な場合、 <xref:System.Windows.UIElement.UpdateLayout%2A> 呼び出しが全体のレイアウトを再実行します。 そのため、呼び出しを避ける必要があります <xref:System.Windows.UIElement.UpdateLayout%2A> 要素ツリーで、マイナー変更のたびにします。 レイアウト システムはすべての子要素が有効になるまでのルートに対する変更を遅らせる重み付け手法を使用して、パフォーマンスや通貨のバランスを取るアルゴリズムを使用して、遅延方式で要素のレイアウトを実行します。 のみを呼び出す必要があります <xref:System.Windows.UIElement.UpdateLayout%2A> 更新済みのサイズや位置、どうしても必要なかどうか、および制御し、影響を与えますレイアウトのプロパティに対するすべての変更が完了した後にのみことを確認します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Visibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility Visibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility Visibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Visibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の ユーザー インターフェイス (UI) 可視性を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>列挙体の値。 既定値は <see cref="F:System.Windows.Visibility.Visible" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの設定の値に影響を与えます <xref:System.Windows.UIElement.IsVisible%2A>, が発生する可能性がさらに、 <xref:System.Windows.UIElement.IsVisibleChanged> イベントです。 ただし、 <xref:System.Windows.UIElement.IsVisible%2A> がその他の要因に影響を与える、それを含む親の可視性の設定のインスタンス。  
  
 要素、 <xref:System.Windows.UIElement.Visibility%2A> は <xref:System.Windows.Visibility.Visible> 入力のイベント \(またはコマンド\) に参加していない、レイアウトのメジャーまたは配置のいずれかのパスには影響しません、タブ シーケンス、およびヒット テストでは報告されません。  
  
 によって継承される <xref:System.Windows.Window> またはその派生クラスでは、 <xref:System.Windows.Window> にするには、このプロパティの既定値を再定義 <xref:System.Windows.Visibility.Collapsed>します。 これは、最初に作成されたレイアウトの測定パスが未実行の効果 <xref:System.Windows.Window>, 、および <xref:System.Windows.UIElement.RenderSize%2A> \(0, 0\) を返します。 詳細については、「<xref:System.Windows.Window>」を参照してください。<xref:System.Windows.Controls.Primitives.Popup> また、既定値に再定義 <xref:System.Windows.Visibility.Collapsed>, のと同様の動作を <xref:System.Windows.Controls.Primitives.Popup> とその派生クラスです。  
  
<a name="dependencyPropertyInfo_Visibility"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.UIElement.VisibilityProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、相互に排他的なユーザー インターフェイスのペアであることを目的とした 2 つのさまざまな名前付きのボタンを参照するハンドラーを実装します。 ボタンに関連付けられている実際のプログラム ロジックを実行する前に、ボタン自体に設定されて <xref:System.Windows.Visibility.Hidden?displayProperty=fullName>, 、ペアの他のボタンに設定されていると <xref:System.Windows.Visibility.Visible?displayProperty=fullName>です。  
  
 [!code-csharp[MediaElement\_snip\#UIElementVisibility](~/samples/snippets/csharp/VS_Snippets_Wpf/MediaElement_snip/CSharp/PlaybackExample.cs#uielementvisibility)]
 [!code-vb[MediaElement\_snip\#UIElementVisibility](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MediaElement_snip/VB/PlaybackExample.vb#uielementvisibility)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsVisible" />
        <altmember cref="T:System.Windows.Visibility" />
      </Docs>
    </Member>
    <Member MemberName="VisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.VisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.UIElement.Visibility" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したルーティング イベントのためのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素で指定したプロパティのアニメーションを開始します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="HitTestCore">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>実装して <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /> 要素のヒット テスト動作の情報を指定します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>