<Type Name="Application" FullName="System.Windows.Application">
  <TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>カプセル化、 Windows Presentation Foundation (WPF) アプリケーションです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application> カプセル化するクラスは、 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] たとえば、次のアプリケーション固有の機能。  
  
-   **Application Lifetime**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.  
  
-   **アプリケーション スコープ ウィンドウ、プロパティ、およびリソース管理**: <xref:System.Windows.Application.FindResource%2A>, 、<xref:System.Windows.Application.GetContentStream%2A>, 、<xref:System.Windows.Application.GetResourceStream%2A>, 、<xref:System.Windows.Application.LoadComponent%2A>, 、<xref:System.Windows.Application.MainWindow%2A>, 、<xref:System.Windows.Application.Properties%2A>, 、<xref:System.Windows.Application.Resources%2A>, 、<xref:System.Windows.Application.StartupUri%2A>, 、<xref:System.Windows.Application.Windows%2A>です。  
  
-   **コマンド ライン パラメーターおよび終了コード処理**: <xref:System.Windows.Application.Startup?displayProperty=fullName>, 、<xref:System.Windows.Application.Exit?displayProperty=fullName>, 、<xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName>です。  
  
-   **Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.  
  
 <xref:System.Windows.Application> そのウィンドウ、プロパティ、およびリソースのスコープのサービスへの共有アクセスを提供するシングルトン パターンを実装します。 その結果、1 つだけ、 <xref:System.Windows.Application> クラスごとに作成できる <xref:System.AppDomain>です。  
  
 実装することができます、 <xref:System.Windows.Application> マークアップ、マークアップおよび分離コード、またはコードを使用します。 場合 <xref:System.Windows.Application> として、マークアップ ファイルを構成する必要がありますマークアップまたはマークアップおよび分離コード、かどうかは、マークアップを伴う、実装、 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` 項目。  
  
> [!NOTE]
>  スタンドアロンのアプリケーションが必要ない、 <xref:System.Windows.Application> オブジェクト; カスタムを実装することは `static` エントリ ポイント メソッド \(`Main`\) のインスタンスを作成せずにウィンドウを開く <xref:System.Windows.Application>します。 ただし、 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] を必要とする <xref:System.Windows.Application> オブジェクトです。  
  
   
  
## 例  
 次の例は、標準的なアプリケーションは、どのようにマークアップのみを使用して定義します。  
  
 [!code-xml[ApplicationSnippets\#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 コードのみを使用して標準的なアプリケーションを定義する方法を例を示します。  
  
 [!code-csharp[ApplicationSnippets\#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets\#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 次の例は、標準的なアプリケーションのマークアップおよび分離コードの組み合わせを使用して定義します。  
  
 [!code-xml[ApplicationSnippets\#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets\#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets\#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック <see langword="static" /> \(<see langword="Shared" /> Visual Basic では\) この型のメンバーは、スレッド セーフであります。 さらに、 <see cref="M:System.Windows.Application.FindResource(System.Object)" /> と <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> メソッドおよび <see cref="P:System.Windows.Application.Properties" /> と <see cref="P:System.Windows.Application.Resources" /> プロパティは、スレッド セーフであります。</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Application" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 1 つだけ、 <xref:System.Windows.Application> クラスごとに作成できる <xref:System.AppDomain>, 1 セットのアプリケーション スコープのウィンドウ、プロパティ、およびリソースのデータへの共有アクセスを確実にします。 その結果、既定のコンス トラクターの <xref:System.Windows.Application> クラスを検出するかどうかの初期化中のインスタンスの最初のインスタンス、 <xref:System.AppDomain>でない場合は、 <xref:System.InvalidOperationException> がスローされます。  
  
 <xref:System.Windows.Application> 現在のオブジェクト <xref:System.AppDomain> 静的から公開される <xref:System.Windows.Application.Current%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">2 つ以上のインスタンス、 <see cref="T:System.Windows.Application" /> ごとにクラスを作成 <see cref="T:System.AppDomain" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがフォア グラウンドのアプリケーションになったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] を 1 つまたは複数の開いているウィンドウを持つアプリケーションがアクティブ化される \(フォア グラウンドのアプリケーションになります\)、windows のいずれかが有効な場合、最初に、アプリケーションが起動されるため、または、windows のいずれかが有効な場合、アプリケーションがアクティブな間: 具体的には、アクティブ化を行う場合。  
  
-   アプリケーションでは、最初のウィンドウが開きます。  
  
-   ユーザーは、ALT \+ TAB キーを使用するか、タスク マネージャーを使用して、アプリケーションに切り替えます。  
  
-   ユーザーは、アプリケーションで windows のいずれかのタスク バー ボタンをクリックします。  
  
 アクティブ化するときを検出するために必要とするアプリケーションが処理できる、 <xref:System.Windows.Application.Activated> イベントです。  
  
 アプリケーションが初めてアクティブになった後に非アクティブ化し、その有効期間中に何度も再アクティブ化する可能性があります。 どちらも処理できる場合は、アプリケーションの動作や状態は、そのアクティブ化の状態に依存する <xref:System.Windows.Application.Activated> と <xref:System.Windows.Application.Deactivated> のイベントをアクティブ化状態を確認します。  
  
 アプリケーションがアクティブになると <xref:System.Windows.Application.Activated> は発生しませんもう一度、アプリケーションがアクティブな間に、アプリケーション内でウィンドウの数がアクティブ化に関係なく、アプリケーションが非アクティブ化までです。  
  
 <xref:System.Windows.Application.Activated> に対しては発生しません [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]します。  
  
   
  
## 例  
 次の例では、スタンドアロンのアプリケーションがアクティブにし、非アクティブ化を検出する方法を示します。  
  
 [!code-xml[ApplicationActivationSnippets\#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets\#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets\#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Windows.Application" /> 現在のオブジェクト <see cref="T:System.AppDomain" />します。</summary>
        <value>
          <see cref="T:System.Windows.Application" /> 現在のオブジェクト <see cref="T:System.AppDomain" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application> あたり\-<xref:System.AppDomain> シングルトンを実装する型、静的な <xref:System.Windows.Application.Current%2A> への共有アクセスを提供するプロパティ、 <xref:System.Windows.Application> 現在のインスタンス <xref:System.AppDomain>します。 この設計によって管理されるその状態を保証する <xref:System.Windows.Application>, 、共有リソースや状態は、単一の共有の場所から入手できます。  
  
 このプロパティは、スレッド セーフであるは任意のスレッドから使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションでは、フォア グラウンドのアプリケーションが停止したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] を 1 つまたは複数の開いているウィンドウを持つアプリケーションは、\(フォア グラウンドのアプリケーションを停止\) を非アクティブにユーザーが、次を実行します。  
  
-   ALT \+ タブを使用して、またはタスク マネージャーを使用して別のアプリケーションに切り替えます。  
  
-   別のアプリケーションでのウィンドウのタスク バー ボタンをクリックします。  
  
 非アクティブ化が処理できるかを検出するために必要とするアプリケーション、 <xref:System.Windows.Application.Deactivated> イベントです。  
  
 アプリケーションが初めてアクティブになった後に非アクティブ化し、その有効期間中に何度も再アクティブ化する可能性があります。 両方処理できる場合は、アプリケーションの動作や状態は、そのアクティブ化の状態に依存する <xref:System.Windows.Application.Deactivated> と <xref:System.Windows.Application.Activated> のイベントにどのような状態を確認します。  
  
 <xref:System.Windows.Application.Deactivated> に対しては発生しません [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]します。  
  
   
  
## 例  
 次の例では、スタンドアロン アプリケーションが非アクティブ化され、アクティブ化を検出する方法を示します。  
  
 [!code-xml[ApplicationActivationSnippets\#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets\#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets\#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外は、アプリケーションによってスローされたが、処理されない場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、 [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] 未処理の例外をキャッチ、\(元に通知できます例外\)\] ダイアログ ボックスで、例外のユーザーに通知、およびアプリケーションを自動的にシャット ダウンします。  
  
 ただし、処理、アプリケーションを一元的な場所からカスタムのハンドルされない例外の処理を実行する場合は、 <xref:System.Windows.Application.DispatcherUnhandledException>です。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> によって発生した、 <xref:System.Windows.Application> はメイン UI スレッドで実行されているコードで処理されない例外はごとにします。  
  
 例外が処理されない場合のいずれかのバック グラウンド [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] スレッド \(に独自のスレッド <xref:System.Windows.Threading.Dispatcher>\) またはバック グラウンド ワーカー スレッド \(ことがなく、スレッド、 <xref:System.Windows.Threading.Dispatcher>\)、主に、例外は転送されません [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] スレッドです。 その結果、 <xref:System.Windows.Application.DispatcherUnhandledException> は発生しません。 このような場合は、次を行うコードを記述する必要があります。  
  
1.  バック グラウンド スレッドで例外を処理します。  
  
2.  これらの例外に、メインのディスパッチ [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] スレッドです。  
  
3.  メインの再スローして [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] を許可するための処理なくスレッド <xref:System.Windows.Application.DispatcherUnhandledException> が発生します。  
  
 詳細については、次を参照してください。、 [スレッド モデル](http://msdn.microsoft.com/ja-jp/02d8fd00-8d7c-4604-874c-58e40786770b) の概要です。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> 渡されるイベント ハンドラー、 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> 、例外に関するコンテキスト情報を含む引数を含みます。  
  
-   例外 \(<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>\)。  
  
-   <xref:System.Windows.Threading.Dispatcher> 出所から \(<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>\)。  
  
 この情報を使用すると、例外が回復可能かどうかどうかを確認します。 回復可能な例外があります、 <xref:System.IO.FileNotFoundException>, など、回復不能な例外が生じる可能性があります、 <xref:System.StackOverflowException>, などです。  
  
 ハンドルされない例外を処理すると <xref:System.Windows.Application.DispatcherUnhandledException>, 、したくないと [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 処理を継続するには、設定する必要があります、 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> プロパティを `true`します。  
  
 その他のイベントとは異なりを <xref:System.Windows.Application> 発生すると、 <xref:System.Windows.Application.DispatcherUnhandledException> しませんが、対応する保護されていない \(OnDispatcherUnhandledException\) の仮想実装します。 その結果、クラスから派生した <xref:System.Windows.Application> を持つイベント ハンドラーは常に登録する必要があります <xref:System.Windows.Application.DispatcherUnhandledException> 未処理の例外を処理します。  
  
   
  
## 例  
 次の例では、処理することにより、未処理の例外を処理する方法、 <xref:System.Windows.Application.DispatcherUnhandledException> イベントです。  
  
 [!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]
 [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  
[!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]
[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがシャット ダウンし、キャンセルできません直前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーションがシャット ダウンする理由として、次のいずれか。  
  
-   <xref:System.Windows.Application.Shutdown%2A> のメソッド、 <xref:System.Windows.Application> で明示的にまたは決定されるオブジェクトが呼び出される、 <xref:System.Windows.Application.ShutdownMode%2A> プロパティです。  
  
-   ユーザーは、ログオフまたはシャット ダウンによって、セッションを終了します。  
  
 処理することにより、アプリケーションのシャット ダウンが発生したときに検出することができます、 <xref:System.Windows.Application.Exit> イベント、および必要に応じて、追加の処理を実行します。  
  
 処理することも <xref:System.Windows.Application.Exit> を検査またはアプリケーションの終了コードを変更するときに呼び出す必要はありません <xref:System.Windows.Application.Shutdown%2A> 明示的にします。 終了コードの公開元である、 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> のプロパティ、 <xref:System.Windows.ExitEventArgs> に渡される引数、 <xref:System.Windows.Application.Exit> イベント ハンドラーです。 アプリケーションの実行が停止、終了コードは後続の処理機能、オペレーティング システムに渡されます。  
  
 アプリケーションが処理する場合、 <xref:System.Windows.Application.SessionEnding> イベント、後でそれを取り消すと <xref:System.Windows.Application.Exit> は発生しませんし、アプリケーションは、によって配布されたシャット ダウン モードで実行を続けます。  
  
 終了コードから設定できる、 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], 値は無視されますが、します。  
  
 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], 、<xref:System.Windows.Application.Exit> は、次の状況で発生します。  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] から移動します。  
  
-   [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)], ときに、ホストしているタブ、 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] が閉じられます。  
  
-   ブラウザーが終了したとき。  
  
 常の値、 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> プロパティは無視されます。  
  
   
  
## 例  
 次の例について説明する方法。  
  
-   処理、 <xref:System.Windows.Application.Exit> イベントです。  
  
-   検査し、更新、 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> のプロパティ、 <xref:System.Windows.ExitEventArgs>です。  
  
-   分離ストレージ内のアプリケーション ログにエントリを記述します。  
  
-   分離ストレージにアプリケーションの状態を保持します。  
  
 [!code-xml[ApplicationExitSnippets\#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets\#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets\#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">検索するリソースの名前。</param>
        <summary>検索、 ユーザー インターフェイス (UI) リソースなど、 <see cref="T:System.Windows.Style" /> または <see cref="T:System.Windows.Media.Brush" />, し、指定したキーとがスローされます、要求されたリソースが見つからない場合に例外 \(を参照してください [XAML リソース](http://msdn.microsoft.com/ja-jp/91580b89-a0a8-4889-aecb-fddf8e63175f)\)。</summary>
        <returns>要求されたリソース オブジェクト。 要求されたリソースが見つからない場合、 <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.FindResource%2A> アプリケーション スコープのリソースを指定されたリソースでは、まずします。 アプリケーション スコープのリソースは、によって管理される <xref:System.Windows.Application>, から公開されると、 <xref:System.Windows.Application.Resources%2A> プロパティです。 指定されたリソースは、アプリケーション スコープのリソースのセット内で見つからない場合 <xref:System.Windows.Application.FindResource%2A> 、\[次へは、システム リソースを検索します。 システム リソース、ユーザーが定義されているシェル リソースは、色、フォント、およびシェルの構成が含まれます。 これらは、 <xref:System.Windows.SystemColors>, 、<xref:System.Windows.SystemFonts>, 、および <xref:System.Windows.SystemParameters> 型それぞれ、静的なプロパティです。 使用する <xref:System.Windows.Application.FindResource%2A> を取得するには、これらの型もリソース キー プロパティを公開に渡されるように設計された <xref:System.Windows.Application.FindResource%2A>。 たとえば、 <xref:System.Windows.SystemParameters.IconWidthKey%2A>です。  
  
 <xref:System.Windows.Application.FindResource%2A> オブジェクトを返すリソースがある場合は適切な型に返される値をキャストする必要があります。  
  
> [!IMPORTANT]
>  キーが見つからないことがこのメソッドを呼び出した場合、例外がスローされます。 通話に起因する例外を処理しないようにする場合 <xref:System.Windows.Application.FindResource%2A>, を呼び出す <xref:System.Windows.Application.TryFindResource%2A> 代わりに、 <xref:System.Windows.Application.TryFindResource%2A> 返します、 `null` 要求されたリソースが見つからないし、例外がスローされなかったときに参照します。  
  
 このメソッドはスレッド セーフであるため、任意のスレッドから呼び出すことができます。  
  
   
  
## 例  
 次の例は、使用する方法を示しています。 <xref:System.Windows.Application.FindResource%2A> のリソースを見つけると、処理する <xref:System.Windows.ResourceReferenceKeyNotFoundException> リソースが見つからない場合。  
  
 [!code-csharp[ApplicationFindResourceSnippets\#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets\#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">リソースが見つかりません。</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのナビゲーターがコンテンツのフラグメントへのナビゲーションを開始すると発生ナビゲーションがすぐに発生した理由は、目的のフラグメントが現在のコンテンツまたはソースの後に場合 XAML 目的のフラグメントが別のコンテンツがある場合、コンテンツが読み込まれています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ナビゲーターは、いずれか、 <xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>です。  
  
 「<xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">相対 <see cref="T:System.Uri" /> ルース リソースにマップされます。</param>
        <summary>指定した位置にあるコンテンツ データ ファイルのリソース ストリームを返す <see cref="T:System.Uri" /> \(を参照してください [WPF アプリケーションのリソース、コンテンツ、およびデータ ファイル](http://msdn.microsoft.com/ja-jp/7ad2943b-3961-41d3-8fc6-1582d43f5d99)\)。</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> 、指定した位置にあるコンテンツ データ ファイルを含む <see cref="T:System.Uri" />します。 ルース リソースが見つからない場合は、null が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドはスレッド セーフではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> が null です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> は絶対 <see cref="T:System.Uri" />します。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" /> Cookie が作成された場所を指定します。</param>
        <summary>指定された位置の cookie を取得、 <see cref="T:System.Uri" />です。</summary>
        <returns>A <see cref="T:System.String" /> cookie が存在する場合は、値、それ以外の場合、 <see cref="T:System.ComponentModel.Win32Exception" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.GetCookie%2A> 指定されたクッキーを取得 <xref:System.Uri>します。 Cookie を取得できない場合、 <xref:System.ComponentModel.Win32Exception> がスローされます。 名前\/値ペアの一覧に cookie 文字列を解析するコードを記述する必要があります。  
  
 Cookie の概要については [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], を参照してください [ナビゲーションの概要](http://msdn.microsoft.com/ja-jp/86ad2143-606a-4e34-bf7e-51a2594248b8)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">A Win32 によってエラーが発生した、 <see langword="InternetGetCookie" /> 関数 \(によって呼び出されます <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />\) 指定されたクッキーを取得中に問題が発生した場合。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for getting the cookie for a file\-based <see cref="T:System.Uri" />. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for getting the cookie for a non\-file\-based <see cref="T:System.Uri" />. Associated enumeration: <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">
          <see cref="T:System.Uri" /> 起点のサイトにあるルース リソースにマップされます。</param>
        <summary>指定した位置にある発信元サイトのデータ ファイルのリソース ストリームを返す <see cref="T:System.Uri" /> \(を参照してください [WPF アプリケーションのリソース、コンテンツ、およびデータ ファイル](http://msdn.microsoft.com/ja-jp/7ad2943b-3961-41d3-8fc6-1582d43f5d99)\)。</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> リソース ストリームを指定した位置にある発信元サイトのデータ ファイルを格納 <see cref="T:System.Uri" />します。 ルース リソースが見つからない場合 <see langword="null" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドはスレッド セーフではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> が null です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> ないか、相対パスが絶対値ではなく、または、 <c>pack://siteoforigin:,,,/</c> フォームです。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">
          <see cref="T:System.Uri" /> 埋め込みリソースにマップされます。</param>
        <summary>リソース データ ファイルに指定した位置にあるリソース ストリームを返す <see cref="T:System.Uri" /> \(を参照してください [WPF アプリケーションのリソース、コンテンツ、およびデータ ファイル](http://msdn.microsoft.com/ja-jp/7ad2943b-3961-41d3-8fc6-1582d43f5d99)\)。</summary>
        <returns>A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> リソース ストリームを指定した位置にあるリソースのデータ ファイルを格納 <see cref="T:System.Uri" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドはスレッド セーフではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> が null です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> ないか、相対パスが絶対値ではなく、または、 <c>pack://application:,,,/</c> フォームです。</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> が見つかりません。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのナビゲーターが移動先のコンテンツが読み込まれ、解析されて、レンダリングが開始されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ナビゲーターは、いずれか、 <xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>です。  
  
 「<xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>」を参照してください。  
  
> [!NOTE]
>  などの移動、コンテンツに対するイベントをリッスン、 <xref:System.Windows.FrameworkElement.Loaded>でイベントを <xref:System.Windows.Controls.Page> 移動のコンテンツのプロパティにアクセスする前にします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>読み込み、 XAML 、指定した位置にあるファイル Uniform Resource Identifier (URI)します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] ファイルは、アプリケーション コード ファイルを使用できます \(として構成されている、 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] ページ上のアイテム\) やアプリケーション データ ファイル \(リソース ファイル、コンテンツ ファイル、またはサイトの発信元ファイル; を参照してください [WPF アプリケーションのリソース、コンテンツ、およびデータ ファイル](http://msdn.microsoft.com/ja-jp/7ad2943b-3961-41d3-8fc6-1582d43f5d99)\)。  
  
> [!NOTE]
>  このメソッドはスレッド セーフではありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">A <see cref="T:System.Uri" /> 相対パスにマップされる XAML ファイルです。</param>
        <summary>読み込み、 XAML 、指定した位置にあるファイル Uniform Resource Identifier (URI), のルート要素で指定されたオブジェクトのインスタンスに変換し、 XAML ファイルです。</summary>
        <returns>XAML ファイルで指定したルート要素のインスタンスが読み込まれます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 戻り値のルート要素と同じ型に明示的に変換する必要があります、 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ファイルです。  
  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] ファイルは、アプリケーション コード ファイルを使用できます \(として構成されている、 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] ページ上のアイテム\) やアプリケーション データ ファイル \(リソース ファイル、コンテンツ ファイル、またはサイトの発信元ファイル; を参照してください [WPF アプリケーションのリソース、コンテンツ、およびデータ ファイル](http://msdn.microsoft.com/ja-jp/7ad2943b-3961-41d3-8fc6-1582d43f5d99)\)。  
  
> [!NOTE]
>  このメソッドはスレッド セーフではありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> が null です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> は絶対 URIします。</exception>
        <exception cref="T:System.Exception">ファイルがない、 XAML ファイルです。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">XAML ファイルのルート要素と同じ型のオブジェクト。</param>
        <param name="resourceLocator">相対 XAML ファイルにマップする <see cref="T:System.Uri" />。</param>
        <summary>指定した Uniform Resource Identifier (URI) にある XAML ファイルを読み込んで、XAML ファイルのルート要素で指定したオブジェクトのインスタンスに変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] file can be an application code file \(configured as an [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] Page item\) or an application data file \(a resource file, content file, or site\-of\-origin file; see [WPF Application Resource, Content, and Data Files](http://msdn.microsoft.com/ja-jp/7ad2943b-3961-41d3-8fc6-1582d43f5d99)\).  
  
> [!NOTE]
>  This method is not thread\-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> が null です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> は絶対 URI です。</exception>
        <exception cref="T:System.Exception">
          <paramref name="component" /> は、XAML ファイルのルート要素に一致しない型です。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアプリケーションのメイン ウィンドウを設定します。</summary>
        <value>A <see cref="T:System.Windows.Window" /> アプリケーションのメイン ウィンドウとして指定されています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.MainWindow%2A> 最初への参照が自動的に設定 <xref:System.Windows.Window> でインスタンス化するオブジェクト、 <xref:System.AppDomain>です。  
  
 設定して、別のメイン ウィンドウを指定できます <xref:System.Windows.Application.MainWindow%2A> 別の割り当て <xref:System.Windows.Application.Windows%2A> オブジェクトを <xref:System.Windows.Application.MainWindow%2A> プロパティです。  
  
 場合、 <xref:System.Windows.Application.ShutdownMode%2A> のプロパティ、 <xref:System.Windows.Application> に設定されているオブジェクト <xref:System.Windows.ShutdownMode.OnMainWindowClose>, 、メイン ウィンドウを閉じると、アプリケーションをシャット ダウンします。  
  
 設定するには、 <xref:System.Windows.Application.MainWindow%2A> プロパティから [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], アプリケーションのメイン ウィンドウは、設定によって生成されるウィンドウではない場合は、 <xref:System.Windows.Application.StartupUri%2A> プロパティ [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]します。 2 つの制限、 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] アプローチは。  
  
-   どちらかを指定することができます、 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]\-のみ <xref:System.Windows.Window> または [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]\-のみ <xref:System.Windows.Navigation.NavigationWindow> メイン ウィンドウとします。  
  
-   設定する必要があります、 <xref:System.Windows.UIElement.Visibility%2A> ウィンドウのプロパティを入力すると、それ以外の場合に表示されません。  
  
 最初に参照 <xref:System.Windows.Window> インスタンス化するオブジェクトが最初の項目としても追加されて、 <xref:System.Windows.Application.Windows%2A> コレクションです。 場合 <xref:System.Windows.Application.MainWindow%2A> 別への参照に設定した場合は、 <xref:System.Windows.Window>, で項目の順序の中に、メイン ウィンドウへの参照を持つ項目の位置が変更される <xref:System.Windows.Application.Windows%2A> は変わりません。 そのため、常に使用 <xref:System.Windows.Application.MainWindow%2A> の最初の項目ではなく、メイン ウィンドウを参照する <xref:System.Windows.Application.Windows%2A>です。  
  
> [!NOTE]
>  メイン ウィンドウの場合、 <xref:System.Windows.Navigation.NavigationWindow>, へのアクセスを必要と <xref:System.Windows.Navigation.NavigationWindow> 、メンバーの値をキャストする必要が <xref:System.Windows.Application.MainWindow%2A> に <xref:System.Windows.Navigation.NavigationWindow>します。  
>   
>  このプロパティは、作成したスレッドからのみ使用可能な <xref:System.Windows.Application> オブジェクトです。  
  
   
  
## 例  
 次の例では、アプリケーションのメイン ウィンドウを検索する方法を示します。  
  
 [!code-csharp[ApplicationMainWindowSnippets\#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets\#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 次の例は、設定する方法を示します <xref:System.Windows.Application.MainWindow%2A> を使用して [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]します。  
  
 [!code-xml[ApplicationMainWindowSnippets\#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 次の例では、インスタンス化する方法、 <xref:System.Windows.Application.MainWindow%2A> アプリケーションの起動時にコードにします。  
  
 [!code-csharp[HOWTOWindowManagementSnippets\#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets\#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Application.MainWindow" /> など、ブラウザーでホストされているアプリケーションから設定されている、 XAML ブラウザー アプリケーション (XBAP)です。</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完了していない、読み込みは、アプリケーションのナビゲーターが移動先のコンテンツが見つかると場合に、発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ナビゲーターは、いずれか、 <xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>です。  
  
 「<xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しいナビゲーションがアプリケーションのナビゲーターによって要求されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ナビゲーターは、いずれか、 <xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>です。  
  
 「<xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求されたコンテンツにアプリケーションのナビゲーターが移動するときにエラーが発生したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ナビゲーターは、いずれか、 <xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>です。  
  
 「<xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ナビゲーションの進行状況に関する情報を提供するアプリケーションでのナビゲーターによって管理されているダウンロード中に定期的に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ナビゲーターは、いずれか、 <xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>です。  
  
 「<xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときに、 <see langword="StopLoading" /> アプリケーションのナビゲーターのメソッドを呼び出して、または現在のナビゲーションが進行中にナビゲーターによってで新しいナビゲーションが要求された場合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ナビゲーターは、いずれか、 <xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>です。  
  
 「<xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.Activated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnActivated%2A> は、<xref:System.Windows.Application.Activated> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnActivated%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnActivated%2A> 基本クラスの場合は <xref:System.Windows.Application.Activated> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.Deactivated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnDeactivated%2A> は、<xref:System.Windows.Application.Deactivated> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnDeactivated%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnDeactivated%2A> 基本クラスの場合は <xref:System.Windows.Application.Deactivated> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.ExitEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.Exit" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnExit%2A> は、<xref:System.Windows.Application.Exit> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先、 <xref:System.Windows.Application.OnExit%2A> メソッドです。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnExit%2A> 基本クラスの場合は <xref:System.Windows.Application.Exit> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.FragmentNavigation" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> は、<xref:System.Windows.Application.FragmentNavigation> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnFragmentNavigation%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnFragmentNavigation%2A> 基本クラスの場合は <xref:System.Windows.Application.FragmentNavigation> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.LoadCompleted" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnLoadCompleted%2A> は、<xref:System.Windows.Application.LoadCompleted> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnLoadCompleted%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnLoadCompleted%2A> 基本クラスの場合は <xref:System.Windows.Application.LoadCompleted> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.Navigated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnNavigated%2A> は、<xref:System.Windows.Application.Navigated> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnNavigated%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnNavigated%2A> 基本クラスの場合は <xref:System.Windows.Application.Navigated> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.Navigating" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnNavigating%2A> は、<xref:System.Windows.Application.Navigating> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnNavigating%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnNavigating%2A> 基本クラスの場合は <xref:System.Windows.Application.Navigating> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.NavigationFailed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnNavigationFailed%2A> は、<xref:System.Windows.Application.NavigationFailed> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnNavigationFailed%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnNavigationFailed%2A> 基本クラスの場合は <xref:System.Windows.Application.NavigationFailed> を発生させる必要があります。  
  
   
  
## 例  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.NavigationProgress" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnNavigationProgress%2A> は、<xref:System.Windows.Application.NavigationProgress> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnNavigationProgress%2A>します。 オーバーライドされたメソッドを明示的に呼び出す必要があります <xref:System.Windows.Application.OnNavigationProgress%2A> 基本クラスの場合は <xref:System.Windows.Application.NavigationProgress> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.NavigationStopped" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnNavigationStopped%2A> は、<xref:System.Windows.Application.NavigationStopped> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnNavigationStopped%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnNavigationStopped%2A> 基本クラスの場合は <xref:System.Windows.Application.NavigationStopped> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.SessionEndingCancelEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.SessionEnding" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnSessionEnding%2A> は、<xref:System.Windows.Application.SessionEnding> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnSessionEnding%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnSessionEnding%2A> 基本クラスの場合は <xref:System.Windows.Application.SessionEnding> を発生させる必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.StartupEventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Application.Startup" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.OnStartup%2A> は、<xref:System.Windows.Application.Startup> イベントを発生させます。  
  
 派生した型 <xref:System.Windows.Application> よりも優先 <xref:System.Windows.Application.OnStartup%2A>します。 オーバーライドされたメソッドを呼び出す必要があります <xref:System.Windows.Application.OnStartup%2A> 基本クラスの場合、 <xref:System.Windows.Application.Startup> イベントが発生する必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション スコープのプロパティのコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Collections.IDictionary" /> アプリケーション スコープのプロパティを格納します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application> 使用してディクショナリを公開する <xref:System.Windows.Application.Properties%2A> そこにアプリケーション スコープのプロパティを格納することができます。 これにより、すべてのコードでの間で状態を共有する、 <xref:System.AppDomain> スレッド セーフである的に、状態コードを記述する必要はありません。  
  
 プロパティに格納されて <xref:System.Windows.Application.Properties%2A> 返される適切な型に変換する必要があります。  
  
 <xref:System.Windows.Application.Properties%2A> プロパティは任意のスレッドから使用できるは、スレッド セーフであります。  
  
   
  
## 例  
 作成して、アプリケーション スコープのプロパティを使用して使用方法の例を次に <xref:System.Windows.Application.Properties%2A>します。  
  
 [!code-xml[ApplicationPropertiesSnippets\#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets\#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets\#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets\#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets\#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 <see cref="T:System.Reflection.Assembly" /> 、パックを提供する Uniform Resource Identifier (URI) 内のリソースの WPF アプリケーションです。</summary>
        <value>参照、 <see cref="T:System.Reflection.Assembly" /> 、パックを提供する Uniform Resource Identifier (URI) 内のリソースの WPF アプリケーションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] から返される値によって識別される入力アセンブリに対して実行時にリソースが解決された、 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> メソッドです。  
  
 エントリはによって返されるアセンブリ <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 次場合があります。  
  
-   既定のアプリケーション ドメインで実行可能アセンブリ。  
  
-   最初のアセンブリを呼び出すことによって実行される <xref:System.AppDomain.ExecuteAssembly%2A>します。  
  
 ただし、次の場合に、 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリは、入力アセンブリへの参照を取得できません。  
  
-   アンマネージ \(ネイティブ\) アプリケーション ホスト、 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリ。  
  
-   マネージ アプリケーション ホストの数が、 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 以外の方法を使用して、新しいアプリケーション ドメインに読み込むことによってアセンブリ <xref:System.AppDomain.ExecuteAssembly%2A>します。  
  
 このような場合の両方で <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 返します `null`, 、および [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリのリソースを解決することはできません。 このような場合は、 <xref:System.Windows.Application.ResourceAssembly%2A> 1 度だけで、リソースの解決に使用するアセンブリへの参照を設定できます。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> できますのみ 1 回設定した後、リソース アセンブリが変更される可能性は高くありませんので、 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリは読み込まれます。  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> 場合を設定することはできません、 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリは、入力アセンブリを検出できます — されているときに、 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> アセンブリへの参照を返しますのではなく `null`です。  
  
 このプロパティは、スレッド セーフであるは任意のスレッドから使用できます。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A WPF アプリケーションには、入力アセンブリまたは <see cref="P:System.Windows.Application.ResourceAssembly" /> は既に設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはスタイルやブラシなどのアプリケーション スコープのリソースのコレクションを設定します。</summary>
        <value>A <see cref="T:System.Windows.ResourceDictionary" /> 0 個以上のアプリケーション スコープのリソースを含むオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.Resources%2A> プロパティは、windows とアプリケーションの要素間でリソースを共有するために使用できます。 さらに、 <xref:System.Windows.Application.Resources%2A> は次の順序で走査リソースの検索パスのプロパティが含まれています。  
  
1.  Elements  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=fullName>  
  
4.  システム  
  
 その結果、 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 要素は、アプリケーション スコープのリソースにバインドできます。 さらに、リソースが変更された場合、リソース システム、により、その要素の変更を反映するこれらのリソースにバインドされているプロパティが自動的に更新します。  
  
 アプリケーション スコープのリソースは、アプリケーション間で一貫性のあるテーマをサポートする簡単な方法を提供します。 テーマを簡単に作成することができます [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] を使用して、 `Application.Resources` タグ。 ただし、アプリケーションは、多数のテーマ要素を含むことが、複数のテーマをサポートしている場合ありますいずれかを使用してそれらを管理しやすい <xref:System.Windows.ResourceDictionary> 各テーマのインスタンス。 これにより、新しいテーマを適用して適切なリソースのプロパティを設定して <xref:System.Windows.ResourceDictionary>します。  
  
 2 つの考慮事項を使用する場合がある <xref:System.Windows.Application.Resources%2A>です。 まず、ディクショナリ *キー* は、オブジェクトを設定およびプロパティの値 \(文字列を使用する場合、キーが大文字小文字を区別であることに注意してください\) を取得するときに正確に同じオブジェクト インスタンスを使用する必要があるためです。 2 番目、ディクショナリ *値* オブジェクトは、プロパティ値を取得するときに、値を目的の型に変換する必要があります。  
  
 <xref:System.Windows.Application.Resources%2A> スレッド セーフであるは、任意のスレッドから使用します。  
  
   
  
## 例  
 この例は、使用する方法を示しています。 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] アプリケーション スコープのリソースを視覚的な一貫性のある外観を作成するとします。  
  
 [!code-xml[ApplicationResourcesSnippets\#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
 [!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml1)]  
[!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml2)]  
  
 次の例では、コードと XAML でアプリケーションのリソースを設定する方法を示します。  
  
 [!code-csharp[HOWTOApplicationModelSnippets\#SetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets\#SetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xml[HOWTOApplicationModelSnippets\#SetApplicationScopeResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml#setapplicationscoperesourcexaml)]  
  
 次の例では、コードで、アプリケーション リソースを取得する方法を示します。  
  
 [!code-csharp[HOWTOApplicationModelSnippets\#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets\#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開始、 Windows Presentation Foundation (WPF) アプリケーションです。</summary>
        <returns>
          <see cref="T:System.Int32" /> アプリケーションが終了するときに、オペレーティング システムに返されるアプリケーションの終了コード。 既定では終了コード値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.Run%2A> 開始するために呼び出される、 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アプリケーションです。 定義した場合、 <xref:System.Windows.Application> マークアップ、またはマークアップおよび分離コードを使用して <xref:System.Windows.Application.Run%2A> 暗黙的に呼び出されます。 ただし、定義した場合、 <xref:System.Windows.Application> コードを使用して、次のように明示的に呼び出す必要が <xref:System.Windows.Application.Run%2A>です。  
  
 <xref:System.Windows.Application.Run%2A> が呼び出されると、 <xref:System.Windows.Application> 新しいアタッチ <xref:System.Windows.Threading.Dispatcher> インスタンスを [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] スレッドです。 次に、 <xref:System.Windows.Threading.Dispatcher> オブジェクトの <xref:System.Windows.Threading.Dispatcher.Run%2A> メソッドが呼び出される windows メッセージを処理するメッセージ ポンプを起動します。 最後に、 <xref:System.Windows.Threading.Dispatcher> オブジェクトの呼び出し、 <xref:System.Windows.Application> オブジェクトの <xref:System.Windows.Application.OnStartup%2A> メソッドを <xref:System.Windows.Application.Startup> イベントです。 その結果、アプリケーションの実行モデルを処理する時間によって確立されている <xref:System.Windows.Application.Startup>, 、アプリケーションが実行されている時点です。  
  
 アプリケーションの停止時に実行中 <xref:System.Windows.Application.Shutdown%2A> が呼び出されます。 の値、 <xref:System.Windows.Application.ShutdownMode%2A> プロパティは、タイミングを決定 <xref:System.Windows.Application.Shutdown%2A> が呼び出され、自動的に行われますか、明示的にする必要があるかどうかを呼び出すことです。  
  
 <xref:System.Windows.Application.Run%2A> 作成したスレッドからのみ呼び出すことができる、 <xref:System.Windows.Application> オブジェクトです。 また、 <xref:System.Windows.Application.Run%2A> から呼び出すことができない、 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]です。  
  
   
  
## 例  
 次の例では、カスタムを使用するアプリケーション <xref:System.Windows.Application> 明示的に呼び出す必要がありますので、 <xref:System.Windows.Application.Run%2A>です。  
  
 [!code-csharp[ApplicationRunSnippets\#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets\#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Application.Run" /> ブラウザーによってホストされるアプリケーションから呼び出されます \(たとえば、 XAML ブラウザー アプリケーション (XBAP)\)。</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">A <see cref="T:System.Windows.Window" /> は、アプリケーションの起動時に自動的と起動します。</param>
        <summary>開始、 Windows Presentation Foundation (WPF) アプリケーション指定のウィンドウを開きます。</summary>
        <returns>
          <see cref="T:System.Int32" /> アプリケーションが終了するときに、オペレーティング システムに返されるアプリケーションの終了コード。 既定では終了コード値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを拡張、 <xref:System.Windows.Application.Run%2A> 、アプリケーションの実行開始後に、指定したウィンドウを開くにはメソッドです。  
  
 コードを定義する場合は、 <xref:System.Windows.Application> 実行開始時にウィンドウが開きますが、明示的に呼び出す <xref:System.Windows.Application.Run%2A>します。  
  
 作成する場合、 <xref:System.Windows.Application> マークアップ、またはマークアップおよび分離コードを使用して、できる自動的にウィンドウを開く中に、次の手法のいずれかを使用します。  
  
-   設定することによって宣言によって、 <xref:System.Windows.Application.StartupUri%2A>です。  
  
-   処理することにより、プログラムで <xref:System.Windows.Application.Startup>します。  
  
   
  
## 例  
 次の例をインスタンス化する手動で作成された静的なエントリ ポイント メソッドを使用してアプリケーションを示しています <xref:System.Windows.Application>, を呼び出す前に <xref:System.Windows.Application.Run%2A>します。  
  
 [!code-csharp[ApplicationRunOL1Snippets\#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets\#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Application.Run" /> ブラウザーによってホストされるアプリケーションから呼び出されます \(たとえば、 XAML ブラウザー アプリケーション (XBAP)\)。</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが終了したときに発生、 Windows セッション ログオフするか、オペレーティング システムのシャット ダウンします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、アプリケーションのシャット ダウン、 [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] ユーザーのログオフまたはシャット ダウンされると発生するセッションが終了します。 この場合、 [!INCLUDE[TLA2#tla_mswin](~/includes/tla2sharptla-mswin-md.md)] をシャット ダウンする各アプリケーションを確認します。 ただしは、アプリケーションがシャット ダウンこのエラーが発生する準備ができていない可能性があります。 たとえば、アプリケーションには、実行時間の長い操作の途中では、不整合な状態でデータがあります。 このような場合は、セッションの終了を防ぐことが望まれる場合があり、セッションを終了させるかどうかを決定するオプションをユーザーに許可するが望ましい場合があります。  
  
 処理することにより、セッションが終了したときに検出することができます、 <xref:System.Windows.Application.SessionEnding> イベントです。 アプリケーションをセッションの終了を防ぐ必要がある場合、 <xref:System.Windows.SessionEndingCancelEventArgs> イベント ハンドラーに渡される引数を公開、 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> を設定した `true` \(既定値は `false`\)。  
  
 場合 <xref:System.Windows.Application.SessionEnding> が、処理されない、またはキャンセルすることがなく、処理は <xref:System.Windows.Application.Shutdown%2A> と呼びますと <xref:System.Windows.Application.Exit> イベントが発生します。  
  
 詳細については、セッションが終了する理由を取得するアプリケーションを確認できます <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, の 1 つである、 <xref:System.Windows.ReasonSessionEnding> 値 \(<xref:System.Windows.ReasonSessionEnding.Logoff> と <xref:System.Windows.ReasonSessionEnding.Shutdown>\)。  
  
 <xref:System.Windows.Application.SessionEnding> コンソール アプリケーションでは発生しません。  
  
 <xref:System.Windows.Application.SessionEnding> 作成したスレッドでのみが発生した、 <xref:System.Windows.Application> オブジェクトです。  
  
 <xref:System.Windows.Application.SessionEnding> に対しては発生しません [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]します。  
  
   
  
## 例  
 次の例では、処理、 <xref:System.Windows.Application.SessionEnding> イベントしてユーザーをキャンセルできるようにします。  
  
 [!code-xml[ApplicationSessionEndingSnippets\#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets\#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets\#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" /> クッキーの作成対象となる場所を指定します。</param>
        <param name="value">
          <see cref="T:System.String" /> Cookie データが含まれています。</param>
        <summary>指定された位置のクッキーを作成、 <see cref="T:System.Uri" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Cookie とは、アプリケーションのセッション \(セッション cookie\) や \(永続的な cookie\) のアプリケーション セッション全体で、クライアント コンピューターにアプリケーションによって格納できるデータの任意の部分です。 Cookie の両方の種類を作成するにを呼び出して <xref:System.Windows.Application.SetCookie%2A>します。  
  
 通常、cookie データは、次の形式で名前\/値ペアの形式をとります。  
  
 `Name=Value`  
  
 この形式の文字列を渡す <xref:System.Windows.Application.SetCookie%2A>, 、と共に、 <xref:System.Uri> の cookie を設定する場所 \(通常は、アプリケーション ドメイン\)。  
  
 Cookie とは、セッションの cookie や永続的な cookie が cookie の文字列をするかどうかに依存するかどうかに渡す <xref:System.Windows.Application.SetCookie%2A> 有効期限日が含まれています。 セッション cookie の文字列では、有効期限は含まれません。 永続的な cookie の文字列は、次の形式である必要があります。  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 現在の永続的な cookie が格納されている [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] 有効期限が切れる、その場合は、削除されるまで、インストールのインターネット一時ファイル フォルダー。 アプリケーションから永続的な cookie を削除するには、その有効期限を過去の日付\/時刻値に設定します。  
  
 Cookie の概要については [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], を参照してください [ナビゲーションの概要](http://msdn.microsoft.com/ja-jp/86ad2143-606a-4e34-bf7e-51a2594248b8)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">A Win32 によってエラーが発生した、 <see langword="InternetSetCookie" /> 関数 \(によって呼び出されます <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />\) 指定されたクッキーを作成する際に問題が発生した場合。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for getting the cookie for a file\-based <see cref="T:System.Uri" />. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for getting the cookie for a non\-file\-based <see cref="T:System.Uri" />. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションをシャット ダウンします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.Shutdown%2A> が呼び出されると、アプリケーションが実行を停止します。 処理できる、 <xref:System.Windows.Application.Exit> アプリケーションが実行を停止しようとする、適切な処理を実行する場合を検出するイベントです。  
  
 <xref:System.Windows.Application.Shutdown%2A> によって暗黙的に呼び出される [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] 次の状況で。  
  
-   <xref:System.Windows.Application.ShutdownMode%2A> に設定されている <xref:System.Windows.ShutdownMode.OnLastWindowClose>します。  
  
-   ときに、 <xref:System.Windows.Application.ShutdownMode%2A> に設定されている <xref:System.Windows.ShutdownMode.OnMainWindowClose>します。  
  
-   ユーザーがセッションを終了して、 <xref:System.Windows.Application.SessionEnding> イベントが処理されない、またはキャンセルせずに、処理します。  
  
 呼び出す <xref:System.Windows.Application.Shutdown%2A> シャット ダウン、アプリケーションを明示的にによりに関係なく、 <xref:System.Windows.Application.ShutdownMode%2A> 設定します。 ただし場合、 <xref:System.Windows.Application.ShutdownMode%2A> に設定されている <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, 、呼び出す必要があります <xref:System.Windows.Application.Shutdown%2A> 、アプリケーションをシャット ダウンします。  
  
> [!IMPORTANT]
>  ときに <xref:System.Windows.Application.Shutdown%2A> が呼び出されると、アプリケーションが停止したかどうかに関係なく、 <xref:System.Windows.Window.Closing> 、開いているウィンドウのイベントをキャンセルします。  
  
 このメソッドは、作成したスレッドからのみ呼び出すことができる、 <xref:System.Windows.Application> オブジェクトです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">for permission to use all windows and user input events without restriction. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">アプリケーションの整数の終了コード。 既定の終了コードは 0 です。</param>
        <summary>オペレーティング システムに指定の終了コードを返すアプリケーションをシャット ダウンします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 処理できる、 <xref:System.Windows.Application.Exit> 終了コードを設定するイベントです。 ただし、明示的に呼び出す場合 <xref:System.Windows.Application.Shutdown%2A>, 、および処理する <xref:System.Windows.Application.Exit> だけで呼び出すことができます、終了コードを設定する <xref:System.Windows.Application.Shutdown%2A> 代わりにします。  
  
 このメソッドは、作成したスレッドからのみ呼び出すことができる、 <xref:System.Windows.Application> オブジェクトです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">for permission to use all windows and user input events without restriction. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の原因となる状態、 <see cref="M:System.Windows.Application.Shutdown" /> メソッドが呼び出されます。</summary>
        <value>
          <see cref="T:System.Windows.ShutdownMode" /> 列挙値。 既定値は <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーションが停止される場合にのみを実行している、 <xref:System.Windows.Application.Shutdown%2A> アプリケーションのメソッドが呼び出されます。 暗黙的または明示的の値で指定したとおりに、シャット ダウンが発生することが、 <xref:System.Windows.Application.ShutdownMode%2A> プロパティです。  
  
 設定した場合 <xref:System.Windows.Application.ShutdownMode%2A> に <xref:System.Windows.ShutdownMode.OnLastWindowClose>, 、[!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] を暗黙的に呼び出す <xref:System.Windows.Application.Shutdown%2A> アプリケーションの最後のウィンドウが閉じたときに、メイン ウィンドウとして、現在インスタンス化されたウィンドウが設定されている場合でも \(を参照してください <xref:System.Windows.Application.MainWindow%2A>\)。  
  
 A <xref:System.Windows.Application.ShutdownMode%2A> の <xref:System.Windows.ShutdownMode.OnMainWindowClose> により [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)]、暗黙的に呼び出す <xref:System.Windows.Application.Shutdown%2A> ときに、 <xref:System.Windows.Application.MainWindow%2A> 場合でも、現在開いている他のウィンドウを閉じます。  
  
 一部のアプリケーションの有効期間は、メイン ウィンドウまたは最後のウィンドウが閉じると、またはできない可能性があります windows に依存するすべてのときに依存していない場合があります。 このようなシナリオは、設定する必要があります、 <xref:System.Windows.Application.ShutdownMode%2A> プロパティを <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, がありますが、明示的な <xref:System.Windows.Application.Shutdown%2A> アプリケーションを停止するメソッドの呼び出しです。 それ以外の場合、アプリケーションは引き続きバック グラウンドで実行されます。  
  
 <xref:System.Windows.Application.ShutdownMode%2A> 宣言によって構成できます [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] またはコードからプログラムを使用しています。  
  
 このプロパティは、作成したスレッドからのみ使用可能な <xref:System.Windows.Application> オブジェクトです。  
  
   
  
## 例  
 次の例は、構成する方法を示しています。 <xref:System.Windows.Application.ShutdownMode%2A> を指定するアプリケーションを明示的に閉じる必要があります。  
  
 [!code-xml[ApplicationShutdownModeSnippets\#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときに、 <see cref="M:System.Windows.Application.Run" /> のメソッド、 <see cref="T:System.Windows.Application" /> オブジェクトが呼び出されるとします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 標準的な [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] など、開始時に、アプリケーションは、さまざまな初期化タスクを実行可能性があります。  
  
-   コマンド ライン パラメーターを処理しています。  
  
-   メイン ウィンドウを開いています。  
  
-   アプリケーション スコープのリソースを初期化しています。  
  
-   アプリケーション スコープのプロパティを初期化しています。  
  
 メイン ウィンドウとアプリケーション スコープのリソースを使用して宣言によって指定できます [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] \(<xref:System.Windows.Application.StartupUri%2A> と <xref:System.Windows.Application.Resources%2A>, 、それぞれ\)。 場合によっては、ただし、リソースや、アプリケーションのメイン ウィンドウのみォェホローロ  プログラムを使用して実行時にします。 さらに、アプリケーション スコープのプロパティとコマンド ライン パラメーターのみするプログラムにより使用できます。 プログラムによる初期化を処理することにより実行できます、 <xref:System.Windows.Application.Startup> を次を含む、イベント。  
  
-   提供されているコマンド ライン パラメーター取得および処理、 <xref:System.Windows.StartupEventArgs.Args%2A> のプロパティ、 <xref:System.Windows.StartupEventArgs> クラスに渡される、 <xref:System.Windows.Application.Startup> イベント ハンドラーです。  
  
-   使用して、アプリケーション スコープのリソースを初期化、 <xref:System.Windows.Application.Resources%2A> プロパティです。  
  
-   使用して、アプリケーション スコープのプロパティを初期化、 <xref:System.Windows.Application.Properties%2A> プロパティです。  
  
-   インスタンスを作成し、1 つ \(以上\) のウィンドウを表示します。  
  
> [!NOTE]
>  呼び出して、静的なコマンド ライン パラメーターを取得することも <xref:System.Environment.GetCommandLineArgs%2A> のメソッド、 <xref:System.Environment> オブジェクトです。 ただし、 <xref:System.Environment.GetCommandLineArgs%2A> を実行する完全な信頼が必要です。  
  
 設定した場合 <xref:System.Windows.Application.StartupUri%2A> を使用して [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], 、作成されるメイン ウィンドウからは使用できないか、 <xref:System.Windows.Application.MainWindow%2A> プロパティまたは <xref:System.Windows.Application.Windows%2A> のプロパティ、 <xref:System.Windows.Application> 後までオブジェクト、 <xref:System.Windows.Application.Startup> イベントを処理します。 新しいウィンドウ オブジェクトを手動で作成する必要がある起動中にメイン ウィンドウへのアクセスを必要がある場合、 <xref:System.Windows.Application.Startup> イベント ハンドラーです。  
  
> [!NOTE]
>  アプリケーションで使用する場合 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> 資格情報ポリシーを指定するには、設定する必要があります <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> 後 <xref:System.Windows.Application.Startup> が発生した場合、それ以外の場合 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 既定内部ポリシーに直接後設定、 <xref:System.Windows.Application.Startup> イベントが発生しました。  
  
 渡されるコマンドライン引数、 <xref:System.Windows.Application.Startup> イベント ハンドラーと同じではない、 [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] クエリ文字列パラメーターに渡される、 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]です。  
  
   
  
## 例  
 次の例では、取得およびスタンドアロン アプリケーションからコマンド ライン オプションを処理する方法を示します。 場合、 **\/StartMinimized** コマンド ライン パラメーターが指定されて、最小化された状態でアプリケーションがメイン ウィンドウを開きます。  
  
 [!code-xml[ApplicationStartupSnippets\#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets\#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets\#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] 取得し、で起動されているため、コマンドライン引数を処理できない [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] 展開 \(を参照してください [WPF アプリケーション \(WPF\) を展開する](http://msdn.microsoft.com/ja-jp/12cadca0-b32c-4064-9a56-e6a306dcc76d)\)。 ただし、取得し、起動に使用する Url のクエリ文字列パラメーターを処理できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 UI をアプリケーションの起動時に自動的に表示します。</summary>
        <value>A <see cref="T:System.Uri" /> を参照する、 UI は、アプリケーションの起動時に自動的に開きます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用する <xref:System.Windows.Application.StartupUri%2A> 負荷が自動的に、 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] リソース アプリケーションの起動時にします。  
  
 次の表は、種類の [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 読み込むことができるリソースやに開かれるウィンドウの種類として設定できます。 これらのリソース アプリケーションの種類、 <xref:System.Windows.Application.StartupUri%2A>です。  
  
|型|ウィンドウ|\[アプリケーションの種類\]|  
|-------|-----------|---------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|スタンドアロンのみ|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|スタンドアロンのみ|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|スタンドアロン\/ブラウザーでホストされます。|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|スタンドアロン\/ブラウザーでホストされます。|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|スタンドアロン\/ブラウザーでホストされます。|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|スタンドアロン\/ブラウザーでホストされます。|  
  
 通常は、設定、 <xref:System.Windows.Application.StartupUri%2A> プロパティで、宣言によって [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]します。 ただし、設定 <xref:System.Windows.Application.StartupUri%2A> プログラムを使用してからこのような <xref:System.Windows.Application.Startup> ことのみを読み込むために必要なアプリケーションの場合に役立つイベント ハンドラー [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 実行時にリソースです。 たとえば、アプリケーションが場合は、そのリソースを読み込むための実行時まで待機可能性がありますの名前、 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] リソースが構成ファイルに格納されています。  
  
 設定するかどうか <xref:System.Windows.Application.StartupUri%2A> 宣言またはプログラムによって、対応する [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] までリソースが読み込まれていない後、 <xref:System.Windows.Application.Startup> イベントが処理されます。 その結果、しなくても済むアクセス、結果ウィンドウから、 <xref:System.Windows.Application.Windows%2A> プロパティまたは <xref:System.Windows.Application.MainWindow%2A> プロパティを処理するとき <xref:System.Windows.Application.Startup>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Windows.Application.StartupUri" /> 値は null に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">要求されたアンビエント プロパティの名前。</param>
        <summary>指定されたアンビエント プロパティは、現在のスコープで利用可能なかどうかを照会します。</summary>
        <returns>
          <see langword="true" /> 要求されたアンビエント プロパティがある場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Windows.Application> のインスタンスが <xref:System.Windows.Markup.IQueryAmbient> インターフェイスにキャストされる場合にのみ、使用できます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">検索するリソースの名前。</param>
        <summary>指定したリソースを検索します。</summary>
        <returns>要求されたリソース オブジェクト。 要求されたリソースが見つからない場合は null 参照が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Application.TryFindResource%2A> アプリケーション スコープのリソースを指定されたリソースでは、まずします。 アプリケーション スコープのリソースは、によって管理される <xref:System.Windows.Application>, から公開されると、 <xref:System.Windows.Application.Resources%2A> プロパティです。 指定されたリソースは、アプリケーション スコープのリソースのセット内で見つからない場合 <xref:System.Windows.Application.TryFindResource%2A> 、\[次へは、システム リソースを検索します。 システム リソース、ユーザーが定義されているシェル リソースは、色、フォント、およびシェルの構成が含まれます。 これらは、 <xref:System.Windows.SystemColors>, 、<xref:System.Windows.SystemFonts>, 、および <xref:System.Windows.SystemParameters> 型それぞれ、静的なプロパティです。 使用する <xref:System.Windows.Application.TryFindResource%2A> を取得するには、これらの型もリソース キー プロパティを公開に渡されるように設計された <xref:System.Windows.Application.TryFindResource%2A>。 たとえば、 <xref:System.Windows.SystemParameters.IconWidthKey%2A>です。  
  
 <xref:System.Windows.Application.TryFindResource%2A> オブジェクトを返すリソースがある場合は適切な型に返される値をキャストする必要があります。  
  
 このメソッドはスレッド セーフであるため、任意のスレッドから呼び出すことができます。  
  
   
  
## 例  
 次の例は、使用する方法を示しています。 <xref:System.Windows.Application.TryFindResource%2A> リソースを取得します。  
  
 [!code-xml[ApplicationTryFindResourceSnippets\#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションでインスタンス化されたウィンドウを取得します。</summary>
        <value>A <see cref="T:System.Windows.WindowCollection" /> 、現在のすべてのウィンドウ オブジェクトへの参照を含む <see cref="T:System.AppDomain" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Windows.Window> に参照が自動的に追加 <xref:System.Windows.Application.Windows%2A> でウィンドウがインスタンス化するとすぐに、 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] スレッド、ワーカー スレッドが追加されないによって作成される windows です。 A <xref:System.Windows.Window> 参照が自動的に削除した後、 <xref:System.Windows.Window.Closing> イベントが処理されたとする前にその <xref:System.Windows.Window.Closed> イベントが発生します。  
  
 既定では、最初の項目を追加する、 <xref:System.Windows.Application.Windows%2A> プロパティが、 <xref:System.Windows.Application.MainWindow%2A>です。  
  
 このプロパティは、作成したスレッドからのみ使用可能な <xref:System.Windows.Application> オブジェクトです。  
  
   
  
## 例  
 次の例では、列挙、 <xref:System.Windows.Application.Windows%2A> に共通する最上位レベルの Windows メニューを作成するプロパティ [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] のようなアプリケーション [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], のような複数のインスタンスのシングル ドキュメント インターフェイス \(SDI\) アプリケーションまたは [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)]です。  
  
 [!code-csharp[ApplicationWindowsSnippets\#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets\#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xml[ApplicationWindowsSnippets\#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始、 Windows Presentation Foundation (WPF) アプリケーションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーションをシャット ダウンします。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>