<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>メッセージ キュー サーバーでは、キューへのアクセスを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 メッセージ キュー テクノロジでは、異なるタイミングで実行されているアプリケーションが異種ネットワークおよびが一時的にオフラインであるシステム間で通信できるようにします。 アプリケーションは、送信、受信、またはキューからの \(削除せずに読み取る\) メッセージをピークします。 メッセージ キューのオプションのコンポーネントは、 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] と Windows NT では、個別にインストールする必要があります。  
  
 <xref:System.Messaging.MessageQueue> クラスは、メッセージ キューのラッパーです。 使用して、メッセージ キューの複数のバージョンがある、 <xref:System.Messaging.MessageQueue> クラスは、若干異なる動作になり、オペレーティング システムに応じて使用しています。 メッセージ キューの各バージョンの特定の機能については、MSDN のプラットフォーム SDK ではメッセージ キューで新規」トピックを参照してください。  
  
 <xref:System.Messaging.MessageQueue> クラスには、メッセージ キューのキューへの参照が用意されています。 パスを指定する、 <xref:System.Messaging.MessageQueue.%23ctor%2A> するか、既存のリソースに接続するためのコンス トラクターは、サーバーで新しいキューを作成することができます。 呼び出す <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 、<xref:System.Messaging.MessageQueue.Peek%2A>, 、または <xref:System.Messaging.MessageQueue.Receive%2A>, の新しいインスタンスを関連付ける必要があります、 <xref:System.Messaging.MessageQueue> 既存のキューでのクラスです。 キューのプロパティなどを操作する時点で、 <xref:System.Messaging.MessageQueue.Category%2A> と <xref:System.Messaging.MessageQueue.Label%2A>です。  
  
 <xref:System.Messaging.MessageQueue> 2 種類のメッセージの取得のサポート: 同期および非同期です。 同期メソッド <xref:System.Messaging.MessageQueue.Peek%2A> と <xref:System.Messaging.MessageQueue.Receive%2A>, 、新しいメッセージがキューに到達するための指定した時間間隔を待機するプロセスのスレッドが発生します。 非同期のメソッドでは、 <xref:System.Messaging.MessageQueue.BeginPeek%2A> と <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 、メイン アプリケーション タスクをキューにメッセージが到着するまでに、別のスレッドで続行を許可します。 これらのメソッドは、スレッド間で情報を伝達するコールバック オブジェクトと状態のオブジェクトを使用して動作します。  
  
 新しいインスタンスを作成するときに、 <xref:System.Messaging.MessageQueue> クラスでは、新しいメッセージ キューのキューを作成しません。 代わりに、使用、 <xref:System.Messaging.MessageQueue.Create%28System.String%29>, 、<xref:System.Messaging.MessageQueue.Delete%28System.String%29>, 、および <xref:System.Messaging.MessageQueue.Purge%2A> をサーバー上のキューを管理する方法です。  
  
 異なり <xref:System.Messaging.MessageQueue.Purge%2A>, 、<xref:System.Messaging.MessageQueue.Create%28System.String%29> と <xref:System.Messaging.MessageQueue.Delete%28System.String%29> は `static` ための新しいインスタンスを作成しなくても、それらを呼び出すことが、メンバー、 <xref:System.Messaging.MessageQueue> クラスです。  
  
 設定することができます、 <xref:System.Messaging.MessageQueue> オブジェクトの <xref:System.Messaging.MessageQueue.Path%2A> 3 つの名前のいずれかのプロパティ: フレンドリ名、 <xref:System.Messaging.MessageQueue.FormatName%2A>, 、または <xref:System.Messaging.MessageQueue.Label%2A>です。 キューのによって定義される表示名 <xref:System.Messaging.MessageQueue.MachineName%2A> と <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティは <xref:System.Messaging.MessageQueue.MachineName%2A>\\[MessageQueue](assetId:///P:System.Messaging.MessageQueue.QueueName?qualifyHint=False&autoUpgrade=True) パブリック キューのと <xref:System.Messaging.MessageQueue.MachineName%2A>\\`Private$`\\[MessageQueue](assetId:///P:System.Messaging.MessageQueue.QueueName?qualifyHint=False&autoUpgrade=True) プライベート キューのです。<xref:System.Messaging.MessageQueue.FormatName%2A> プロパティは、メッセージ キューへのオフライン アクセスを使用します。 キューを使用する最後に、 <xref:System.Messaging.MessageQueue.Label%2A> 、キューを設定するプロパティ <xref:System.Messaging.MessageQueue.Path%2A>します。  
  
 インスタンスの初期プロパティ値の一覧については <xref:System.Messaging.MessageQueue>, を参照してください、 <xref:System.Messaging.MessageQueue.%23ctor%2A> コンス トラクターです。  
  
   
  
## 例  
 次のコード例を新規作成 <xref:System.Messaging.MessageQueue> オブジェクトのさまざまなパス名の構文型を使用します。 各ケースでは、パスを持つが、コンス トラクターで定義されているキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 次のコード例は、キューにメッセージを送信しと呼ばれるアプリケーションに固有のクラスを使用して、キューからメッセージを受信 `Order`します。  
  
 [!code-cpp[MessageQueue.Receive\_noparms\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive\_noparms\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive\_noparms\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>のみ、 <see cref="M:System.Messaging.MessageQueue.GetAllMessages" />メソッドがスレッド セーフであります。</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。 既定のコンス トラクターでは、新しいインスタンスを初期化、インスタンスの設定する必要があります <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティ インスタンスを使用する前にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して、新しいインスタンスを作成する、 <xref:System.Messaging.MessageQueue> メッセージ キュー サーバーのキューにすぐに関連付けられていないクラス。 このインスタンスを使用する前にする必要がありますに接続する既存のメッセージ キューのキューを設定して、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティです。 また、設定、 <xref:System.Messaging.MessageQueue> への参照、 <xref:System.Messaging.MessageQueue.Create%28System.String%29> メソッドの戻り値、新しいメッセージ キューのキューを作成できます。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> コンス トラクターの新しいインスタンスをインスタンス化、 <xref:System.Messaging.MessageQueue> クラスは新しいメッセージ キューのキューを作成することはできません。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。 <xref:System.Messaging.MessageQueue>します。  
  
|プロパティ|初期値|  
|-----------|---------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|既定のコンス トラクターによって設定された値、 <xref:System.Messaging.DefaultPropertiesToSend> クラスです。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|既定のコンス トラクターによって設定された値、 <xref:System.Messaging.MessagePropertyFilter> クラスです。 すべてのフィルター値に設定されます `true`します。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## 例  
 次のコード例が、新たに作成 <xref:System.Messaging.MessageQueue>します。  
  
 [!code-csharp[MessageQueue\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">これによって参照されるキューの場所 <see cref="T:System.Messaging.MessageQueue" />します。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Messaging.MessageQueue" /> 指定したパスにあるメッセージ キューのキューを参照するクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しいリンク付けするときに、このオーバー ロードを使用して <xref:System.Messaging.MessageQueue> 特定メッセージ キューのキュー、パス、形式名またはラベルが分かっているインスタンス。 キューを参照する最初のアプリケーションへの排他アクセスを許可する場合は、設定する必要があります、 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> プロパティを `true` または読み取りアクセスの制限パラメーターを渡すコンス トラクターを使用します。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> コンス トラクターの新しいインスタンスをインスタンス化、 <xref:System.Messaging.MessageQueue> クラスは新しいメッセージ キューのキューを作成することはできません。 メッセージ キューで新しいキューを作成するには、使用 <xref:System.Messaging.MessageQueue.Create%28System.String%29>します。  
  
 構文、 `path` パラメーターに依存するキューの種類、参照、次の表に示すようにします。  
  
|キューの種類|構文|  
|------------|--------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 また、使用することができます、 <xref:System.Messaging.MessageQueue.FormatName%2A> または <xref:System.Messaging.MessageQueue.Label%2A> を次の表に示すように、キューのパスを記述します。  
  
|参照|構文|例|  
|--------|--------|-------|  
|形式名|`FormatName:` \[ *形式名* \]|`FormatName:Public=` 5A5F7535\-AE9A\-41d4\-935C\-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|ラベル|`Label:` \[ *label* \]|`Label:` とき|  
  
 オフラインで作業するには、コンス トラクターのパス名の構文いない形式名の構文を使用する必要があります。 それ以外の場合、プライマリ ドメイン コント ローラーが形式の名前に、パスを解決するのには使用できないため、例外がスローされます。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。 <xref:System.Messaging.MessageQueue>します。 これらの値はメッセージ キューイング キューのプロパティで指定されたパスに基づいて、 `path` パラメーター。  
  
|プロパティ|初期値|  
|-----------|---------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|既定のコンス トラクターによって設定された値、 <xref:System.Messaging.DefaultPropertiesToSend> クラスです。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, 、メッセージ キューのキューのプライバシー レベルの設定が"Body"; である場合それ以外の場合、 `false`です。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|メッセージ キューのキューのコンピューター名のプロパティの値。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|既定のコンス トラクターによって設定された値、 <xref:System.Messaging.MessagePropertyFilter> クラスです。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, 、コンス トラクターによって設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, 、コンス トラクターによって設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, 、メッセージ キュー オブジェクトの履歴設定が有効の場合それ以外の場合、 `false`です。|  
  
   
  
## 例  
 次のコード例を新規作成 <xref:System.Messaging.MessageQueue> オブジェクトのさまざまなパス名の構文型を使用します。 各ケースでは、パスを持つが、コンス トラクターで定義されているキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが正しくない可能性がある設定されていないためです。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">これによって参照されるキューの場所 <see cref="T:System.Messaging.MessageQueue" />, 、こと"です。"ローカル コンピューターのです。 このパラメーターの正しい構文の詳細については、「解説」セクションを参照してください。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> キューにアクセスする最初のアプリケーションに対する排他的読み取りアクセスを許可するにはそれ以外の場合、 <see langword="false" />です。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Messaging.MessageQueue" /> 指定されたパスに指定された読み取りアクセスの制限で、メッセージ キューのキューを参照するクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しいリンク付けするときに、このオーバー ロードを使用して <xref:System.Messaging.MessageQueue> 特定メッセージ キューのキュー、パス、形式名またはラベルが分かっているにします。 キューを参照する最初のアプリケーションへの排他アクセスを許可する場合は、設定、 `sharedModeDenyReceive` パラメーターを `true`します。 それ以外の場合、 `sharedModeDenyReceive` に `false` かのみを持つコンス トラクターを使用して、 `path` パラメーター。  
  
 設定 `sharedModeDenyReceive` に `true` 他のアプリケーションも含め、メッセージ キューのキューにアクセスするすべてのオブジェクトに影響を与えます。 パラメーターの影響は、このアプリケーションに限定されません。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> コンス トラクターの新しいインスタンスを作成する、 <xref:System.Messaging.MessageQueue> クラスは新しいメッセージ キューのキューを作成することはできません。 メッセージ キューで新しいキューを作成するには、使用 <xref:System.Messaging.MessageQueue.Create%28System.String%29>します。  
  
 構文、 `path` パラメーターは、キューの種類によって異なります。  
  
|キューの種類|構文|  
|------------|--------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 また、キューのパスを記述するのに形式名またはメッセージ キューのキューのラベルを使用することができます。  
  
|参照|構文|例|  
|--------|--------|-------|  
|形式名|`FormatName:` \[ *形式名* \]|`FormatName:Public=` 5A5F7535\-AE9A\-41d4\-935C\-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|ラベル|`Label:` \[ *label* \]|`Label:` とき|  
  
 オフラインで作業するには、表示名の構文ではなく、形式名の構文を使用する必要があります。 それ以外の場合、プライマリ ドメイン コント ローラー \(Active Directory が常駐している\) が形式の名前に、パスを解決するのには使用できないため、例外がスローされます。  
  
 場合、 <xref:System.Messaging.MessageQueue> でキューを開く、 `sharedModeDenyReceive` パラメーターを設定する `true`, 、 <xref:System.Messaging.MessageQueue> 、後で、キューからの読み取りを試みますが生成されること、 <xref:System.Messaging.MessageQueueException> 共有違反があったためです。 A <xref:System.Messaging.MessageQueueException> 場合にもスロー、 <xref:System.Messaging.MessageQueue> ときに、別の排他モードでキューにアクセスしようとしています。 <xref:System.Messaging.MessageQueue> 既にキューに非排他的なアクセスしています。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。 <xref:System.Messaging.MessageQueue>します。 これらの値はメッセージ キューのキューのプロパティで指定されたパスに基づいて、 `path` パラメーター。  
  
|プロパティ|初期値|  
|-----------|---------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`。|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>。|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|既定のコンス トラクターによって設定された値、 <xref:System.Messaging.DefaultPropertiesToSend> クラスです。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, 、メッセージ キューのキューのプライバシー レベルの設定が"Body"; である場合それ以外の場合、 `false`です。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>。|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>。|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|メッセージ キューのキューのコンピューター名のプロパティの値。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|既定のコンス トラクターによって設定された値、 <xref:System.Messaging.MessagePropertyFilter> クラスです。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, 、コンス トラクターによって設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, 、コンス トラクターによって設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`sharedModeDenyReceive` パラメーターの値。|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, 、メッセージ キュー オブジェクトの履歴設定が有効の場合それ以外の場合、 `false`です。|  
  
   
  
## 例  
 次のコード例が、新たに作成 <xref:System.Messaging.MessageQueue> 排他アクセスでのパスを設定し、キューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.ctor\_PathSharedModeDenyReceive\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor\_PathSharedModeDenyReceive\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor\_PathSharedModeDenyReceive\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが正しくない可能性がある設定されていないためです。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">これによって参照されるキューの場所 <see cref="T:System.Messaging.MessageQueue" />, 、こと"です。"ローカル コンピューターのです。</param>
        <param name="accessMode">
          <see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか 1 つ。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">これによって参照されるキューの場所 <see cref="T:System.Messaging.MessageQueue" />, 、こと"です。"ローカル コンピューターのです。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> キューにアクセスする最初のアプリケーションに対する排他的読み取りアクセスを許可するにはそれ以外の場合、 <see langword="false" />です。</param>
        <param name="enableCache">
          <see langword="true" /> 作成して、接続キャッシュを使用するにはそれ以外の場合、 <see langword="false" />です。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例が、新たに作成 <xref:System.Messaging.MessageQueue> 排他的読み取りアクセスおよび接続キャッシュを有効にします。  
  
 [!code-cpp[MessageQueue4\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">これによって参照されるキューの場所 <see cref="T:System.Messaging.MessageQueue" />, 、こと"です。"ローカル コンピューターのです。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> キューにアクセスする最初のアプリケーションに対する排他的読み取りアクセスを許可するにはそれ以外の場合、 <see langword="false" />です。</param>
        <param name="enableCache">
          <see langword="true" /> 作成して、接続キャッシュを使用するにはそれ以外の場合、 <see langword="false" />です。</param>
        <param name="accessMode">
          <see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのアクセス モードを示す値を取得します。</summary>
        <value>
          <see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キューの既定のアクセス モードは `QueueAccessMode.SendAndReceive`, 設定しない限り、それ以外の場合、コンス トラクターを呼び出すときに、します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューが認証されたメッセージのみを受け入れるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> キューが受け入れる場合は、認証済みメッセージのみです。それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メッセージの認証は、メッセージの整合性を確保し、メッセージの送信者を確認する方法を提供します。 認証を要求するには、送信元アプリケーションは、メッセージの認証レベルを設定します。  
  
 設定すると <xref:System.Messaging.MessageQueue.Authenticate%2A> に `true`, 、限定するだけでなく、この、サーバー上のキューへのアクセス <xref:System.Messaging.MessageQueue> インスタンス。 すべてのクライアントが同じメッセージ キューのキューの操作の影響があります。  
  
 認証されたメッセージのみを受け取るキューでは、認証されていないメッセージを拒否します。 メッセージが拒否通知を要求するには、送信元アプリケーションを設定できます、 <xref:System.Messaging.Message.AcknowledgeType%2A> 、メッセージのプロパティです。 その他のメッセージが拒否を示す値が存在しないので、送信元アプリケーション失われる可能性がメッセージ配信不能キューに送信されることを要求しない限りです。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.Authenticate%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはメッセージ キューは、ネットワーク経由でのパブリック キューのメッセージのルーティングを使用して基本の優先順位を設定します。</summary>
        <value>\(パブリック\) のキューに送信されるすべてのメッセージの 1 つの基本優先順位。 既定値は 0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メッセージ キューの基本優先順位は、ネットワークを介してやり取りする際にキューを処理するメッセージを転送方法を指定します。 設定することができます、 <xref:System.Messaging.MessageQueue.BasePriority%2A> を他のキューに送信されたよりも、指定されたキューに送信されるすべてのメッセージを上または下の優先度を与えるにはプロパティです。 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスは、変更によって影響をします。  
  
 メッセージ キューの <xref:System.Messaging.MessageQueue.BasePriority%2A> に関係のない、 <xref:System.Messaging.Message.Priority%2A> 、受信メッセージがキューに配置は、順序を指定すると、メッセージのプロパティです。  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> だけをパブリック キューのパスを含む、形式名を使用して指定が適用されます。 専用キューの基本優先順位がゼロ \(0\) では常にします。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.BasePriority%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">基本の優先順位は、無効な値に設定されました。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>タイムアウトがない非同期的ピーク操作を開始します。 メッセージが、キューで使用可能になるまで、操作は完了しません。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> ポストされた非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期処理で使用する <xref:System.Messaging.MessageQueue.BeginPeek%2A> を発生させる、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント メッセージは、キューで使用可能になったとき。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。<xref:System.Messaging.MessageQueue.BeginPeek%2A> 非同期的ピーク操作を開始します。 <xref:System.Messaging.MessageQueue> を介してのさせると、通知は、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント、メッセージがキューに到着するとします。<xref:System.Messaging.MessageQueue> を呼び出して、メッセージにアクセスできます <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> またはを使用して、結果を取得することによって、 <xref:System.Messaging.PeekCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドは、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は非同期で呼び出す実行の現在のスレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。  
  
 非同期操作が完了すると、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> 通知の受信を保持するイベント ハンドラーでもう一度です。  
  
 <xref:System.IAsyncResult> を <xref:System.Messaging.MessageQueue.BeginPeek%2A> を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます <xref:System.IAsyncResult> 、操作の有効期間全体で一般的に使用しないまでが <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> と呼びます。 ただし、いくつかの非同期操作を開始する場合を行う、 <xref:System.IAsyncResult> 配列内の値し、すべての操作またはすべて操作が完了するまで待機するかどうかを指定します。 この場合は、使用する、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> のプロパティ、 <xref:System.IAsyncResult> 、完了した操作を識別するためにします。  
  
 場合 <xref:System.Messaging.MessageQueue.CanRead%2A> は `false`, 、完了イベントは発生しませんが、呼び出し時に、例外がスローされます <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、名前付きイベント ハンドラーを作成 `MyPeekCompleted`, に結び付けます、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント ハンドラー デリゲート、および呼び出し <xref:System.Messaging.MessageQueue.BeginPeek%2A> パスに配置されているキューに非同期的ピーク操作を開始する". \\myQueue"です。 ときに、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントは、例では、メッセージをピークし、その本体を画面に書き込みます。 例では、 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 新しい非同期的ピーク操作を開始するには、もう一度です。  
  
 [!code-cpp[MessageQueue.BeginPeek\_noparms\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek\_noparms\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek\_noparms\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <summary>指定したタイムアウト、非同期操作を開始します。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> ポストされた非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期処理で使用する <xref:System.Messaging.MessageQueue.BeginPeek%2A> を発生させる、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント メッセージがキュー内、または指定した時間間隔が経過したときに利用可能になるとします。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。<xref:System.Messaging.MessageQueue.BeginPeek%2A> 非同期的ピーク操作を開始します。 <xref:System.Messaging.MessageQueue> を介してのさせると、通知は、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント、メッセージがキューに到着するとします。<xref:System.Messaging.MessageQueue> を呼び出して、メッセージにアクセスできます <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> またはを使用して、結果を取得することによって、 <xref:System.Messaging.PeekCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドは、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は非同期で呼び出す実行の現在のスレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。  
  
 非同期操作が完了すると、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> 通知の受信を保持するイベント ハンドラーでもう一度です。  
  
 <xref:System.IAsyncResult> を <xref:System.Messaging.MessageQueue.BeginPeek%2A> を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます <xref:System.IAsyncResult> 、操作の有効期間全体で一般的に使用しないまでが <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> と呼びます。 ただし、いくつかの非同期操作を開始する場合を行う、 <xref:System.IAsyncResult> 配列内の値し、すべての操作またはすべて操作が完了するまで待機するかどうかを指定します。 この場合は、使用する、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> のプロパティ、 <xref:System.IAsyncResult> 、完了した操作を識別するためにします。  
  
 このオーバー ロードでは、タイムアウトを指定します。 によって指定される間隔がある場合、 `timeout` 期限が切れたときは、このコンポーネントが発生、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントです。 メッセージが存在しないため、後続の呼び出しに <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> は例外をスローします。  
  
 場合 <xref:System.Messaging.MessageQueue.CanRead%2A> は `false`, 、完了イベントは発生しませんが、呼び出し時に、例外がスローされます <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、キューのパスを使用して、非同期的ピーク操作を作成"します。 \\myQueue"です。 イベント ハンドラーを作成して `MyPeekCompleted`, に接続し、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント ハンドラー デリゲート。<xref:System.Messaging.MessageQueue.BeginPeek%2A> 非同期的ピーク操作を開始する 1 分のタイムアウトを指定して呼び出されます。 ときに、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生した、またはタイムアウトに達すると、1 つ存在する場合、その本文が画面に書き込まれるメッセージを取得します。<xref:System.Messaging.MessageQueue.BeginPeek%2A> 同じタイムアウトを指定して、新しい非同期的ピーク操作を開始するを再び呼び出しています。  
  
 [!code-cpp[MessageQueue.BeginPeek\_timeout\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek\_timeout\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek\_timeout\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を格納するアプリケーションで指定された状態オブジェクト。</param>
        <summary>指定したタイムアウトと操作の有効期間を通じて関連付けられている情報を提供する指定の状態オブジェクトを持つ非同期的ピーク操作を開始します。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> ポストされた非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期処理で使用する <xref:System.Messaging.MessageQueue.BeginPeek%2A> を発生させる、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント メッセージがキュー内、または指定した時間間隔が経過したときに利用可能になるとします。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 操作の有効期間全体を通じて保持されるが、操作に情報を関連付けるには、このオーバー ロードを使用します。 この情報にアクセスを見る、イベント ハンドラー、 <xref:System.IAsyncResult.AsyncState%2A> のプロパティ、 <xref:System.IAsyncResult> 操作に関連付けられています。  
  
 使用する <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。<xref:System.Messaging.MessageQueue.BeginPeek%2A> 非同期的ピーク操作を開始します。 <xref:System.Messaging.MessageQueue> を介してのさせると、通知は、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント、メッセージがキューに到着するとします。<xref:System.Messaging.MessageQueue> を呼び出して、メッセージにアクセスできます <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> またはを使用して、結果を取得することによって、 <xref:System.Messaging.PeekCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドは、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は非同期で呼び出す実行の現在のスレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。  
  
 非同期操作が完了すると、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> 通知の受信を保持するイベント ハンドラーでもう一度です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返します、 <xref:System.IAsyncResult> メソッドを開始する非同期操作を識別します。 これを行うこともできます <xref:System.IAsyncResult> 、操作の有効期間全体で一般的に使用しないまでが <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> と呼びます。 ただし、いくつかの非同期操作を開始する場合を行う、 <xref:System.IAsyncResult> 配列内の値し、すべての操作またはすべて操作が完了するまで待機するかどうかを指定します。 この場合は、使用する、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> のプロパティ、 <xref:System.IAsyncResult> 、完了した操作を識別するためにします。  
  
 このオーバー ロードは、タイムアウトと、状態オブジェクトを指定します。 によって指定される間隔がある場合、 `timeout` 期限が切れたときは、このコンポーネントが発生、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントです。 メッセージが存在しないため、後続の呼び出しに <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> は例外をスローします。  
  
 状態オブジェクトは、操作と状態情報を関連付けます。 呼び出す場合など <xref:System.Messaging.MessageQueue.BeginPeek%2A> 複数の操作の開始を複数回、定義された個別の状態オブジェクトを使用して各操作を識別できます。 このシナリオの図解は、「使用例」を参照してください。  
  
 プロセスのスレッド間で情報を渡すため、状態オブジェクトを使用することもできます。 スレッドの開始が、コールバックが非同期のシナリオでは別のスレッドでは、状態オブジェクトがマーシャ リングされ、イベントからの情報と共に返されます。  
  
 場合 <xref:System.Messaging.MessageQueue.CanRead%2A> は `false`, 、完了イベントは発生しませんが、呼び出し時に、例外がスローされます <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、キューのパスを使用して、非同期的ピーク操作を作成"します。 \\myQueue"です。 イベント ハンドラーを作成して `MyPeekCompleted`, に接続し、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント ハンドラー デリゲート。<xref:System.Messaging.MessageQueue.BeginPeek%2A> 呼び出される 1 分のタイムアウトを指定しています。 各呼び出し <xref:System.Messaging.MessageQueue.BeginPeek%2A> がその特定の操作を識別する一意の関連付けられた整数。 ときに、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生したか、タイムアウトが期限切れメッセージが 1 つが存在する場合が取得され、その本体と操作に固有の整数識別子が画面に書き込まれます。<xref:System.Messaging.MessageQueue.BeginPeek%2A> 同じタイムアウトと完了操作の関連付けられた整数値で新しい非同期的ピーク操作を開始するを再び呼び出しています。  
  
 [!code-cpp[MessageQueue.BeginPeek\_TimeSpanStateObject\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek\_TimeSpanStateObject\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek\_TimeSpanStateObject\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を格納するアプリケーションで指定された状態オブジェクト。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 非同期操作完了の通知を受信します。</param>
        <summary>指定したタイムアウトと操作の有効期間を通じて関連付けられている情報を提供する指定の状態オブジェクトを持つ非同期的ピーク操作を開始します。 このオーバー ロードは通知を受信、コールバックを通じて操作のイベント ハンドラーの id。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> ポストされた非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して、コールバック パラメーターで指定されたコールバックが呼び出される直接メッセージがキュー内、または指定した時間間隔が経過すると利用可能になったとき <xref:System.Messaging.MessageQueue.PeekCompleted> イベントは発生しません。 他のオーバー ロード <xref:System.Messaging.MessageQueue.BeginPeek%2A> を発生させるには、このコンポーネントに依存して、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントです。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドは、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は非同期で呼び出す実行の現在のスレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。  
  
 非同期操作が完了すると、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> 通知の受信を保持するイベント ハンドラーでもう一度です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返します、 <xref:System.IAsyncResult> メソッドを開始する非同期操作を識別します。 これを行うこともできます <xref:System.IAsyncResult> 、操作の有効期間全体で一般的に使用しないまでが <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> と呼びます。 ただし、いくつかの非同期操作を開始する場合を行う、 <xref:System.IAsyncResult> 配列内の値し、すべての操作またはすべて操作が完了するまで待機するかどうかを指定します。 この場合は、使用する、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> のプロパティ、 <xref:System.IAsyncResult> 、完了した操作を識別するためにします。  
  
 状態オブジェクトは、操作と状態情報を関連付けます。 呼び出す場合など <xref:System.Messaging.MessageQueue.BeginPeek%2A> 複数の操作の開始を複数回、定義された個別の状態オブジェクトを使用して各操作を識別できます。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、非同期的ピーク操作を作成します。 コード例が送信、ローカル メッセージ キューにメッセージを順に呼び出して <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, を渡すことで: 10 秒のタイムアウト値はその特定のメッセージとの新しいインスタンスを識別する一意の整数 <xref:System.AsyncCallback> イベント ハンドラーを識別する `MyPeekCompleted`です。 ときに、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントは、イベント ハンドラーは、メッセージをピークし、画面にメッセージ本文とメッセージ id を整数を書き込みます。  
  
 [!code-cpp[MessageQueueBeginPeek\#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek\#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> メッセージ キュー内の特定の位置を保持します。</param>
        <param name="action">
          <see cref="T:System.Messaging.PeekAction" /> 値のいずれか。 キューでは、現在のメッセージまたは次のメッセージをピークするかどうかを示します。</param>
        <param name="state">非同期操作に関連付けられている情報を格納するアプリケーションで指定された状態オブジェクト。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 非同期操作完了の通知を受け取る。</param>
        <summary>指定したタイムアウトを持つ、指定されたカーソル、ピーク処理、および指定の状態オブジェクトを使用する非同期的ピーク操作を開始します。 状態オブジェクトは、操作の有効期間内の関連情報を提供します。 このオーバー ロードは通知を受信、コールバックを通じて操作のイベント ハンドラーの id。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> ポストされた非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用すると、コールバック パラメーターで指定されたコールバックが呼び出されて直接メッセージがキュー内、または指定した時間間隔が経過したときに利用可能になったとき。<xref:System.Messaging.MessageQueue.PeekCompleted> イベントは発生しません。 他のオーバー ロード <xref:System.Messaging.MessageQueue.BeginPeek%2A> を発生させるには、このコンポーネントに依存して、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントです。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドは、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> は非同期で呼び出す実行の現在のスレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。  
  
 非同期操作が完了すると、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> 通知の受信を保持するイベント ハンドラーでもう一度です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返します、 <xref:System.IAsyncResult> メソッドによって開始される非同期操作を識別します。 これを行うこともできます <xref:System.IAsyncResult> 、操作の有効期間全体で一般的に使用しないまでが <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> と呼びます。 ただし、いくつかの非同期操作を開始する場合を行う、 <xref:System.IAsyncResult> 配列内の値し、すべての操作またはすべて操作が完了するまで待機するかどうかを指定します。 ここでは、使用して、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> のプロパティ、 <xref:System.IAsyncResult> 、完了した操作を識別するためにします。  
  
 状態オブジェクトは、操作と状態情報を関連付けます。 呼び出す場合など <xref:System.Messaging.MessageQueue.BeginPeek%2A> 複数の操作の開始を複数回、定義された個別の状態オブジェクトを使用して各操作を識別できます。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">以外の値 <see langword="PeekAction.Current" /> または <see langword="PeekAction.Next" /> が指定されました、 <paramref name="action" /> パラメーター。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>非同期の受信タイムアウトがない操作です。 メッセージが、キューで使用可能になるまで、操作は完了しません。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> ポストされた非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期処理で使用する <xref:System.Messaging.MessageQueue.BeginReceive%2A> を発生させる、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント メッセージがキューから削除されるとします。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。<xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期の受信操作です。 <xref:System.Messaging.MessageQueue> を介してのさせると、通知は、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント、メッセージがキューに到着するとします。<xref:System.Messaging.MessageQueue> を呼び出して、メッセージにアクセスできます <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> メソッドは、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は非同期で呼び出す実行の現在のスレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドです。  
  
 非同期操作が完了すると、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> 通知の受信を保持するイベント ハンドラーでもう一度です。  
  
 <xref:System.IAsyncResult> を <xref:System.Messaging.MessageQueue.BeginReceive%2A> を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます <xref:System.IAsyncResult> 、操作の有効期間全体で一般的に使用しないまでが <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> と呼びます。 ただし、いくつかの非同期操作を開始する場合を行う、 <xref:System.IAsyncResult> 配列内の値し、すべての操作またはすべて操作が完了するまで待機するかどうかを指定します。 この場合は、使用する、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> のプロパティ、 <xref:System.IAsyncResult> 、完了した操作を識別するためにします。  
  
 場合 <xref:System.Messaging.MessageQueue.CanRead%2A> は `false`, 、完了イベントは発生しませんが、呼び出し時に、例外がスローされます <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>します。  
  
 非同期呼び出しを使用しないで <xref:System.Messaging.MessageQueue.BeginReceive%2A> トランザクションを使用します。 トランザクションの非同期操作を実行する場合は、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 、トランザクション、および \(同期\) <xref:System.Messaging.MessageQueue.Receive%2A> を作成するイベント ハンドラー内でのピーク操作のメソッドです。 イベント ハンドラーには次の c\# コードに示すように機能が含まれます。  
  
```  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、非同期要求をチェインします。 それは、"myQueue"と呼ばれる、ローカル コンピューター上のキューがあると仮定します。`Main` 関数によって処理される非同期操作を開始する、 `MyReceiveCompleted` ルーチンです。`MyReceiveCompleted` 現在のメッセージを処理しでは、新しい非同期操作を受信します。  
  
 [!code-cpp[MessageQueue.BeginReceive\_noparms\_combined\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive\_noparms\_combined\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive\_noparms\_combined\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 次のコード例では、非同期要求をキューします。 呼び出し <xref:System.Messaging.MessageQueue.BeginReceive%2A> を使用して、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> の戻り値にします。`Main` ルーチンがのすべての非同期操作を終了する前に完了するまで待機します。  
  
 [!code-cpp[MessageQueue.BeginReceive\_noparms\_combined\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive\_noparms\_combined\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive\_noparms\_combined\#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <summary>非同期の受信操作を指定したタイムアウトを持ちます。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> ポストされた非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期処理で使用する <xref:System.Messaging.MessageQueue.BeginReceive%2A> を発生させる、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント メッセージがキュー内、または指定した時間間隔が経過したときに利用可能になるとします。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。<xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期の受信操作です。 <xref:System.Messaging.MessageQueue> を介してのさせると、通知は、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント、メッセージがキューに到着するとします。<xref:System.Messaging.MessageQueue> を呼び出して、メッセージにアクセスできます <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> を使用して、結果を取得するか、 <xref:System.Messaging.ReceiveCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> メソッドは、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は非同期で呼び出す実行の現在のスレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドです。  
  
 非同期操作が完了すると、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> 通知の受信を保持するイベント ハンドラーでもう一度です。  
  
 場合 <xref:System.Messaging.MessageQueue.CanRead%2A> は `false`, 、完了イベントは発生しませんが、呼び出し時に、例外がスローされます <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>します。  
  
 <xref:System.IAsyncResult> を <xref:System.Messaging.MessageQueue.BeginReceive%2A> を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます <xref:System.IAsyncResult> 、操作の有効期間全体で一般的に使用しないまでが <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> と呼びます。 ただし、いくつかの非同期操作を開始する場合を行う、 <xref:System.IAsyncResult> 配列内の値し、すべての操作またはすべて操作が完了するまで待機するかどうかを指定します。 この場合は、使用する、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> のプロパティ、 <xref:System.IAsyncResult> 、完了した操作を識別するためにします。  
  
 このオーバー ロードでは、タイムアウトを指定します。 によって指定される間隔がある場合、 `timeout` 期限が切れたときは、このコンポーネントが発生、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントです。 メッセージが存在しないため、後続の呼び出しに <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> は例外をスローします。  
  
 非同期呼び出しを使用しないで <xref:System.Messaging.MessageQueue.BeginReceive%2A> トランザクションを使用します。 トランザクションの非同期操作を実行する場合は、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 、トランザクション、および \(同期\) <xref:System.Messaging.MessageQueue.Receive%2A> を作成するイベント ハンドラー内でのピーク操作のメソッドです。 イベント ハンドラーには次の c\# コードに示すように機能が含まれます。  
  
```  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例を作成、非同期操作を受信します。 イベント ハンドラーを作成するコード例 `MyReceiveCompleted`, 、それにアタッチし、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント ハンドラー デリゲート。 コード例が送信、ローカル メッセージ キューにメッセージを順に呼び出して <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, を渡すことで、10 秒のタイムアウト値。 ときに、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントは、イベント ハンドラーは、メッセージを受信し、画面にメッセージ本文を書き込みます。  
  
 [!code-cpp[MessageQueueBeginReceive1\#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1\#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが正しくない可能性がある、負の数を表すためです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を格納するアプリケーションで指定された状態オブジェクト。</param>
        <summary>非同期の受信操作を指定したタイムアウトがあり、操作の有効期間を通じて関連付けられている情報を提供する指定の状態オブジェクト。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> ポストされた非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期処理で使用する <xref:System.Messaging.MessageQueue.BeginReceive%2A> を発生させる、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント メッセージがキュー内、または指定した時間間隔が経過したときに利用可能になるとします。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 操作の有効期間全体を通じて保持されるが、操作に情報を関連付けるには、このオーバー ロードを使用します。 イベント ハンドラーを見てこの情報を検出できます、 <xref:System.IAsyncResult.AsyncState%2A> のプロパティ、 <xref:System.IAsyncResult> 操作に関連付けられています。  
  
 使用する <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。<xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期の受信操作です。 <xref:System.Messaging.MessageQueue> を介してのさせると、通知は、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント、メッセージがキューに到着するとします。<xref:System.Messaging.MessageQueue> を呼び出して、メッセージにアクセスできます <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> を使用して、結果を取得するか、 <xref:System.Messaging.ReceiveCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> メソッドは、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は非同期で呼び出す実行の現在のスレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドです。  
  
 非同期操作が完了すると、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> 通知の受信を保持するイベント ハンドラーでもう一度です。  
  
 <xref:System.IAsyncResult> を <xref:System.Messaging.MessageQueue.BeginReceive%2A> を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます <xref:System.IAsyncResult> 、操作の有効期間全体で一般的に使用しないまでが <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> と呼びます。 ただし、いくつかの非同期操作を開始する場合を行う、 <xref:System.IAsyncResult> 配列内の値し、すべての操作またはすべて操作が完了するまで待機するかどうかを指定します。 この場合は、使用する、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> のプロパティ、 <xref:System.IAsyncResult> 、完了した操作を識別するためにします。  
  
 このオーバー ロードは、タイムアウトと、状態オブジェクトを指定します。 によって指定される間隔がある場合、 `timeout` 期限が切れたときは、このコンポーネントが発生、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントです。 メッセージが存在しないため、後続の呼び出しに <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> は例外をスローします。  
  
 状態オブジェクトは、操作と状態情報を関連付けます。 呼び出す場合など <xref:System.Messaging.MessageQueue.BeginReceive%2A> 複数の操作の開始を複数回、定義された個別の状態オブジェクトを使用して各操作を識別できます。  
  
 プロセスのスレッド間で情報を渡すため、状態オブジェクトを使用することもできます。 スレッドの開始が、コールバックが非同期のシナリオでは別のスレッドでは、状態オブジェクトがマーシャ リングされ、イベントからの情報と共に返されます。  
  
 非同期呼び出しを使用しないで <xref:System.Messaging.MessageQueue.BeginReceive%2A> トランザクションを使用します。 トランザクションの非同期操作を実行する場合は、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 、トランザクション、および \(同期\) <xref:System.Messaging.MessageQueue.Receive%2A> を作成するイベント ハンドラー内でのピーク操作のメソッドです。 イベント ハンドラーには次の c\# コードに示すように機能が含まれます。  
  
```  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例を作成、非同期操作を受信します。 イベント ハンドラーを作成するコード例 `MyReceiveCompleted`, 、それにアタッチし、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント ハンドラー デリゲート。 コード例が送信、ローカル メッセージ キューにメッセージを順に呼び出して <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, を渡すことで、10 秒、特定のメッセージを識別する一意の整数のタイムアウト値。 ときに、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントは、イベント ハンドラーは、メッセージを受信し、画面にメッセージ本文と整数型のメッセージ識別子を出力します。  
  
 [!code-cpp[MessageQueueBeginReceive2\#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2\#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を格納するアプリケーションで指定された状態オブジェクト。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 非同期操作完了の通知を受信します。</param>
        <summary>非同期の受信操作を指定したタイムアウトがあり、操作の有効期間を通じて関連付けられている情報を提供する指定の状態オブジェクト。 このオーバー ロードは通知を受信、コールバックを通じて操作のイベント ハンドラーの id。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> ポストされた非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して、コールバック パラメーターで指定されたコールバックが呼び出される直接メッセージがキュー内、または指定した時間間隔が経過すると利用可能になったとき <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントは発生しません。 他のオーバー ロード <xref:System.Messaging.MessageQueue.BeginReceive%2A> を発生させるには、このコンポーネントに依存して、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントです。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。<xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期の受信操作です。 <xref:System.Messaging.MessageQueue> を介してのさせると、通知は、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント、メッセージがキューに到着するとします。<xref:System.Messaging.MessageQueue> を呼び出して、メッセージにアクセスできます <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> を使用して、結果を取得するか、 <xref:System.Messaging.ReceiveCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> メソッドは、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は非同期で呼び出す実行の現在のスレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドです。  
  
 非同期操作が完了すると、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> 通知の受信を保持するイベント ハンドラーでもう一度です。  
  
 <xref:System.IAsyncResult> を <xref:System.Messaging.MessageQueue.BeginReceive%2A> を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます <xref:System.IAsyncResult> 、操作の有効期間全体で一般的に使用しないまでが <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> と呼びます。 ただし、いくつかの非同期操作を開始する場合を行う、 <xref:System.IAsyncResult> 配列内の値し、すべての操作またはすべて操作が完了するまで待機するかどうかを指定します。 この場合は、使用する、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> のプロパティ、 <xref:System.IAsyncResult> 、完了した操作を識別するためにします。  
  
 状態オブジェクトは、操作と状態情報を関連付けます。 呼び出す場合など <xref:System.Messaging.MessageQueue.BeginReceive%2A> 複数の操作の開始を複数回、定義された個別の状態オブジェクトを使用して各操作を識別できます。  
  
 プロセスのスレッド間で情報を渡すため、状態オブジェクトを使用することもできます。 スレッドの開始が、コールバックが非同期のシナリオでは別のスレッドでは、状態オブジェクトがマーシャ リングされ、イベントからの情報と共に返されます。  
  
 非同期呼び出しを使用しないで <xref:System.Messaging.MessageQueue.BeginReceive%2A> トランザクションを使用します。 トランザクションの非同期操作を実行する場合は、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 、トランザクション、および \(同期\) <xref:System.Messaging.MessageQueue.Receive%2A> を作成するイベント ハンドラー内でのピーク操作のメソッドです。 イベント ハンドラーには次の c\# コードに示すように機能が含まれます。  
  
```  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例を作成、非同期操作を受信します。 コード例が送信、ローカル メッセージ キューにメッセージを順に呼び出して <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, を渡すことで: 10 秒のタイムアウト値はその特定のメッセージとの新しいインスタンスを識別する一意の整数 <xref:System.AsyncCallback> イベント ハンドラーを識別する `MyReceiveCompleted`です。 ときに、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントは、イベント ハンドラーは、メッセージを受信し、画面にメッセージ本文と整数型のメッセージ識別子を出力します。  
  
 [!code-cpp[MessageQueueBeginReceive3\#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3\#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> メッセージ キュー内の特定の位置を保持します。</param>
        <param name="state">非同期操作に関連付けられている情報を格納するアプリケーションで指定された状態オブジェクト。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 非同期操作完了の通知を受け取る。</param>
        <summary>非同期の受信操作を指定したタイムアウトを備え、指定されたカーソルと、指定された状態オブジェクトを使用します。 状態オブジェクトは、操作の有効期間内の関連情報を提供します。 このオーバー ロードは通知を受信、コールバックを通じて操作のイベント ハンドラーの id。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> ポストされた非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して、コールバック パラメーターで指定されたコールバックが呼び出される直接メッセージがキュー内、または指定した時間間隔が経過すると利用可能になったとき <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントは発生しません。 他のオーバー ロード <xref:System.Messaging.MessageQueue.BeginReceive%2A> を発生させるには、このコンポーネントに依存して、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントです。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。<xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期の受信操作です。 <xref:System.Messaging.MessageQueue> を介してのさせると、通知は、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント、メッセージがキューに到着するとします。<xref:System.Messaging.MessageQueue> を呼び出して、メッセージにアクセスできます <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> を使用して、結果を取得するか、 <xref:System.Messaging.ReceiveCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> メソッドは、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> は非同期で呼び出す実行の現在のスレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドです。  
  
 非同期操作が完了すると、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A> または <xref:System.Messaging.MessageQueue.BeginReceive%2A> 通知の受信を保持するイベント ハンドラーでもう一度です。  
  
 <xref:System.IAsyncResult> を <xref:System.Messaging.MessageQueue.BeginReceive%2A> を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます <xref:System.IAsyncResult> 、操作の有効期間全体で一般的に使用しないまでが <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> と呼びます。 ただし、いくつかの非同期操作を開始する場合を行う、 <xref:System.IAsyncResult> 配列内の値し、すべての操作またはすべて操作が完了するまで待機するかどうかを指定します。 ここでは、使用して、 <xref:System.IAsyncResult.AsyncWaitHandle%2A> のプロパティ、 <xref:System.IAsyncResult> 、完了した操作を識別するためにします。  
  
 状態オブジェクトは、操作と状態情報を関連付けます。 呼び出す場合など <xref:System.Messaging.MessageQueue.BeginReceive%2A> 複数の操作の開始を複数回、定義された個別の状態オブジェクトを使用して各操作を識別できます。  
  
 プロセスのスレッド間で情報を渡すため、状態オブジェクトを使用することもできます。 スレッドの開始が、コールバックが非同期のシナリオでは別のスレッドでは、状態オブジェクトがマーシャ リングされ、イベントからの情報と共に返されます。  
  
 非同期呼び出しを使用しないで <xref:System.Messaging.MessageQueue.BeginReceive%2A> トランザクションを使用します。 トランザクションの非同期操作を実行する場合は、呼び出す <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 、トランザクション、および \(同期\) <xref:System.Messaging.MessageQueue.Receive%2A> を作成するイベント ハンドラー内でのピーク操作のメソッドです。 イベント ハンドラーには次の c\# コードに示すように機能が含まれます。  
  
```  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Messaging.MessageQueue" /> 読み取ることができます。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Messaging.MessageQueue" /> が存在して、アプリケーションからそれを読み取ることができますそれ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.CanRead%2A> アプリケーションがピークまたはキューからメッセージを受信できるかどうかを示します。 場合 <xref:System.Messaging.MessageQueue.CanRead%2A> は `true`, 、 <xref:System.Messaging.MessageQueue> 受信したり、キューからメッセージをピークします。 それ以外の場合、そのことはできません。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> `false` キューが排他的読み取りアクセスで開かれている場合 \(非排他アクセスを許可し、これを開いている場合、または <xref:System.Messaging.MessageQueue> への排他アクセスを要求\)、またはアプリケーションにアクセスする十分な権限があるない場合。 アプリケーションがキューから読み取る場合と <xref:System.Messaging.MessageQueue.CanRead%2A> は `false`, 、アクセスが拒否されました。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例には、メッセージ キューの値が表示されます。 <xref:System.Messaging.MessageQueue.CanRead%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Messaging.MessageQueue" /> に書き込むことができます。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Messaging.MessageQueue" /> が存在して、アプリケーションの書き込み可能にします。 それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> アプリケーションがキューにメッセージを送信できるかどうかを示します。 場合 <xref:System.Messaging.MessageQueue.CanWrite%2A> は `true`, 、 <xref:System.Messaging.MessageQueue> キューにメッセージを送信することができます。 それ以外の場合、そのことはできません。  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> `false` キューが排他的な書き込みアクセスで開かれている場合 \(非排他アクセスを許可し、これを開いている場合、または <xref:System.Messaging.MessageQueue> への排他アクセスを要求\)、またはアプリケーションにアクセスする十分な権限があるない場合。 アプリケーションがキューへの書き込みを試みる場合と <xref:System.Messaging.MessageQueue.CanWrite%2A> は `false`, 、アクセスが拒否されました。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例には、メッセージ キューの値が表示されます。 <xref:System.Messaging.MessageQueue.CanWrite%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューのカテゴリを設定します。</summary>
        <value>A <see cref="T:System.Guid" /> により、アプリケーションはキューを分類するキュー カテゴリ \(メッセージ キューの種類 id\) を表します。 既定値は、<see langword="Guid.empty" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キューのカテゴリは、アプリケーションのキューを分類できます。 たとえば、1 つのカテゴリとすべての受注キューを別に課金のすべてのキューを配置できます。  
  
 <xref:System.Messaging.MessageQueue.Category%2A> プロパティ \(ある読み取り\/書き込み\)、メッセージ キューの種類の ID プロパティへのアクセスを提供するを介してアクセスできる、 **キューのプロパティ** コンピューターの管理コンソール\] ダイアログ ボックス。 新しいカテゴリを定義することができます。 使用できますが <xref:System.Guid.NewGuid%2A> すべてにわたって一意であるカテゴリの値を作成する <xref:System.Guid> フィールドでは、このようなアクションが必要ではありません。 カテゴリの値はからではなく他のすべての他のカテゴリ別にする必要がある <xref:System.Guid> 値。 たとえば、あるを割り当てると、 <xref:System.Messaging.MessageQueue.Category%2A> のいずれかのキューおよび {00000000\-0000\-0000\-0000\-000000000002} として設定、 <xref:System.Messaging.MessageQueue.Category%2A> 別のセットのです。  
  
 設定する必要はありません、 <xref:System.Messaging.MessageQueue.Category%2A>です。 値として `null` を指定できます。  
  
 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスは、変更によって影響をします。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.Category%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">キューのカテゴリは、無効な値に設定されました。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>接続のキャッシュをクリアします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すと <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, 、キャッシュに格納されている形式名が削除され、開かれ、キャッシュに格納されているハンドルが閉じられます。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> を呼び出すコード例を次に示します。  
  
 [!code-csharp[MessageQueue\#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>によって割り当てられているすべてのリソース、 <see cref="T:System.Messaging.MessageQueue" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.Close%2A> 関連付けられているすべてのリソースを解放する <xref:System.Messaging.MessageQueue>, 、該当する場合、共有のリソースを含みます。 システムを再度取得これらのリソースに自動的に引き続き使用でき、たとえば呼び出すしている場合、 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> メソッドを次の c\# コードのようにします。  
  
```  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 呼び出すと <xref:System.Messaging.MessageQueue.Close%2A>, すべて <xref:System.Messaging.MessageQueue> メッセージ キューのキューに直接アクセスするプロパティが解除されます。<xref:System.Messaging.MessageQueue.Path%2A>, 、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, 、<xref:System.Messaging.MessageQueue.Formatter%2A>, 、および <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> すべてとものになります。  
  
 <xref:System.Messaging.MessageQueue.Close%2A> 常にではありません解放、読み取りと書き込みハンドルをキューに、共有されるためです。 いることを確認するには、次の手順のいずれかを行う <xref:System.Messaging.MessageQueue.Close%2A> キューへの読み取りと書き込みハンドルを解放します。  
  
-   作成、 <xref:System.Messaging.MessageQueue> 排他アクセスでします。 そのために呼び出す、 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> または <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> コンス トラクター、およびセット、 `sharedModeDenyReceive` パラメーターを `true`します。  
  
-   作成、 <xref:System.Messaging.MessageQueue> 接続キャッシュを無効にします。 そのために呼び出す、 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> コンス トラクターと、 `enableConnectionCache` パラメーターを `false`します。  
  
-   接続のキャッシュを無効にします。 これを行うには、設定、 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> プロパティを `false`します。  
  
 呼び出す必要があります <xref:System.Messaging.MessageQueue.Close%2A> メッセージ キュー サーバー上のキューを削除する前に、キューのです。 それ以外の場合、キューに送信されたメッセージは、例外をスローまたは配信不能キューに配置します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、メッセージ キューのキューを閉じます。  
  
 [!code-cpp[MessageQueue.Close\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">作成するキューのパス。</param>
        <summary>指定されたパスには、メッセージ キューの非トランザクション キューを作成します。</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueue" /> 新しいキューを表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用すると、メッセージ キューの非トランザクション キューを作成できます。  
  
 新しいインスタンスを作成する、 <xref:System.Messaging.MessageQueue> クラスのアプリケーションで、既存のキューにバインドは、使用、 <xref:System.Messaging.MessageQueue.%23ctor%2A> コンス トラクターです。 メッセージ キューで新しいキューを作成するには、呼び出す <xref:System.Messaging.MessageQueue.Create%28System.String%29>します。  
  
 構文、 `path` パラメーターに依存するキューの種類、参照、次の表に示すようにします。  
  
|キューの種類|構文|  
|------------|--------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用する"です。"ローカル コンピューターのです。 構文の詳細を参照してください、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例では、パブリック キューと専用キューを作成します。 選択したキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Create\_path\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create\_path\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create\_path\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> パラメーターは <see langword="null" /> または空の文字列 \(""\) です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューは、指定したパスに既に存在します。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">作成するキューのパス。</param>
        <param name="transactional">
          <see langword="true" /> トランザクション キューを作成するには <see langword="false" /> 非トランザクション キューを作成します。</param>
        <summary>指定されたパスには、トランザクションまたは非トランザクション メッセージ キューのキューを作成します。</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueue" /> 新しいキューを表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用すると、メッセージ キューでトランザクション キューを作成します。 非トランザクション キューを作成するには設定して、 `transactional` パラメーターを `false` やの他のオーバー ロードを呼び出して <xref:System.Messaging.MessageQueue.Create%28System.String%29>します。  
  
 新しいインスタンスを作成する、 <xref:System.Messaging.MessageQueue> クラスのアプリケーションで、既存のキューにバインドは、使用、 <xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクターです。 メッセージ キューで新しいキューを作成するには、呼び出す <xref:System.Messaging.MessageQueue.Create%28System.String%29>します。  
  
 構文、 `path` パラメーターに依存するキューの種類、参照、次の表に示すようにします。  
  
|キューの種類|構文|  
|------------|--------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用する"です。"ローカル コンピューターのです。 構文の詳細を参照してください、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例では、パブリックとプライベートのトランザクション キューを作成します。 選択したキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Create\_PathTransactional\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create\_PathTransactional\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create\_PathTransactional\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> パラメーターは <see langword="null" /> または空の文字列 \(""\) です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューは、指定したパスに既に存在します。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新たに作成 <see cref="T:System.Messaging.Cursor" /> の現在のメッセージ キューです。</summary>
        <returns>新しい <see cref="T:System.Messaging.Cursor" /> の現在のメッセージ キューです。 このカーソルは、キューのメッセージを読み取るときに、キュー内の特定の場所を維持するために使用されます。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューのキューが作成された日付と時刻を取得します。</summary>
        <value>A <see cref="T:System.DateTime" /> キューが作成された日時を表します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> メッセージ キュー サーバー上のキューに参照、 <xref:System.Messaging.MessageQueue> インスタンス。  
  
 キューが存在する場合、このプロパティは、キューが存在するサーバーのローカル時間を調整して、キューが作成された時刻を表します。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例には、メッセージ キューの値が表示されます。 <xref:System.Messaging.MessageQueue.CreateTime%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはメッセージに、アプリケーション キューにメッセージを送信するときに、既定で使用されるプロパティの値を設定します。</summary>
        <value>A <see cref="T:System.Messaging.DefaultPropertiesToSend" /> 既定メッセージ キュー メッセージ プロパティの値を含むアプリケーション以外のオブジェクトを送信するときに使用される <see cref="T:System.Messaging.Message" /> キューへのインスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型は任意のオブジェクトを送信する場合 <xref:System.Messaging.Message> 、キューに、 <xref:System.Messaging.MessageQueue> メッセージ キューのメッセージに、オブジェクトを挿入します。 その時点で、 <xref:System.Messaging.MessageQueue> で指定したプロパティの値に、メッセージに適用される、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティです。 逆に、送信する場合、 <xref:System.Messaging.Message> 、キューにこれらのプロパティがまだ指定されて、インスタンスのため <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> は無視されます、 <xref:System.Messaging.Message>です。  
  
 プロパティを設定しても、 <xref:System.Messaging.MessageQueue> オブジェクト、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> キュー自体ではない、キューに送信されるメッセージのプロパティを参照します。  
  
 プロパティの既定値は、次の表に表示されます。  
  
|プロパティ|既定値|  
|-----------|---------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|ゼロ \(0\)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|空の文字列 \(""\)|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、メッセージの優先順位を使用して、メッセージを送信する既定のプロパティを決定します。  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">既定のプロパティ設定できませんでしたする、キューの可能性があるプロパティのいずれかが無効なためです。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">削除するキューの場所。</param>
        <summary>メッセージ キュー サーバーのキューを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 構文、 `path` パラメーターは、キューの種類によって異なります。  
  
|キューの種類|構文|  
|------------|--------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 構文の詳細を参照してください、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティです。  
  
 また、使用することができます、 <xref:System.Messaging.MessageQueue.FormatName%2A> または <xref:System.Messaging.MessageQueue.Label%2A> をキューのパスを記述します。  
  
|参照|構文|  
|--------|--------|  
|形式名|形式名: \[ *形式名* \]|  
|ラベル|ラベル: \[ *ラベル* \]|  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例は、存在する場合に、メッセージ キューのキューを削除します。  
  
 [!code-cpp[MessageQueue.ExistsDelete\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> パラメーターは <see langword="null" /> または空の文字列 \(""\) です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">構文、 <paramref name="path" /> パラメーターが無効です。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうかこの <see cref="T:System.Messaging.MessageQueue" /> メッセージ キューのキューからメッセージを受信排他的にアクセスします。</summary>
        <value>
          <see langword="true" /> この場合 <see cref="T:System.Messaging.MessageQueue" /> ; キューからメッセージを受信する排他的な権限を持つそれ以外の場合、 <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> これによって参照されるキューの共有モードを指定 <xref:System.Messaging.MessageQueue>します。 設定 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> に `true` のみを示すためにこの <xref:System.Messaging.MessageQueue> ピークまたは指定したキューからメッセージを受信へのアクセス権 <xref:System.Messaging.MessageQueue.Path%2A>します。 他 <xref:System.Messaging.MessageQueue> または別のアプリケーションが同じキュー リソース、そのインスタンスに関連付けられたまたはアプリケーションはピークまたはメッセージを受信できませんただしも送信にできます。  
  
 場合 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> は `false`, 、キューは複数のアプリケーションの送信、ピーク、またはメッセージの受信に使用します。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> で使用されていたリソース \(メモリを除く\) を解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Call <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> when you are finished using the <xref:System.Messaging.MessageQueue>. The <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> method leaves the <xref:System.Messaging.MessageQueue> in an unusable state. After calling <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, you must release all references to the <xref:System.Messaging.MessageQueue> so the memory it was occupying can be reclaimed by garbage collection.  
  
 You should call <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> before you release your last reference to the <xref:System.Messaging.MessageQueue>. Otherwise, the resources the <xref:System.Messaging.MessageQueue> is using will not be freed until garbage collection calls the <xref:System.Messaging.MessageQueue> object's destructor.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または接続のキャッシュをアプリケーションで維持するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> 作成して、接続キャッシュを使用するにはそれ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続キャッシュは、読み取りを含めたり、キューへのハンドルを記述する構造体への参照の一覧を示します。<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> は `true`, 、 <xref:System.Messaging.MessageQueue> を呼び出すたびに、キャッシュからのハンドルをそのまま利用 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 、<xref:System.Messaging.MessageQueue.Peek%2A>, 、または <xref:System.Messaging.MessageQueue.Receive%2A>, 、新しいハンドルを開くのではなく。 これにより、パフォーマンスが向上することができます。 接続キャッシュを使用しても影響を受けないように、 <xref:System.Messaging.MessageQueue> ネットワーク トポロジの変更からです。  
  
 場合に、接続キャッシュがいっぱいで、キューへの新しい接続を作成、 <xref:System.Messaging.MessageQueue> 新しい接続では、少なくとも、最近アクセスされた構造体を上書きします。 呼び出して完全キャッシュをクリアできます <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, 、たとえばを前の読み取りし、書き込みハンドルが無効になったとしているキューの形式名が変更された場合。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューが非プライベート \(暗号化されていない\) メッセージを受け入れるかどうかを示す値を設定します。</summary>
        <value>
          <see cref="T:System.Messaging.EncryptionRequired" /> 値のいずれか。 既定値は、<see langword="None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 暗号化が必要なキューに送信されたメッセージを指定する場合は、メッセージの本文のみが暗号化されます。 他のメンバー \(たとえば、 <xref:System.Messaging.Message.Label%2A> と <xref:System.Messaging.Message.SenderId%2A> プロパティ\) 暗号化することはできません。  
  
 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスは、変更によって影響をします。  
  
 プライベート メッセージは、メッセージを暗号化します。 あるキューの暗号化の要件を指定する `None`, 、`Body`, 、または `Optional` を設定して、 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> プロパティ適切にします。<xref:System.Messaging.Message.UseEncryption%2A> メッセージの設定は、キューの暗号化の要件に対応する必要があります。 かどうか、メッセージが暗号化されていないが、キューを指定 `Body`, 、メッセージが暗号化されており、キューを指定または `None`, 、キューにメッセージを拒否します。 送信元アプリケーションは、このイベントに否定受信確認メッセージを要求している場合に、送信元アプリケーションにメッセージの拒否メッセージ キューを示します。 場合、 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> プロパティは、 `true`, 、暗号化に失敗したメッセージが配信不能キューに送信します。 それ以外の場合、メッセージは失われます。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> を完了する非同期操作を識別するそれから最終結果を取得します。</param>
        <summary>指定した非同期的ピーク操作を完了します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> 完了する非同期操作に関連付けられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生すると、 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> によって開始された操作が完了すると、 <xref:System.Messaging.MessageQueue.BeginPeek%2A> を呼び出します。 そのためには <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> メッセージをピークします。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> これにより、タイムアウトを指定することができます、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントをキューにメッセージを表示する前にタイムアウトが発生した場合に発生します。 後続の呼び出しに、キューに到着するメッセージが表示されず、タイムアウトになるとき <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 例外をスローします。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 原因となったメッセージの読み取りに使用される、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生します。  
  
 非同期的にメッセージをピークする続行する場合は、もう一度呼び出せる <xref:System.Messaging.MessageQueue.BeginPeek%2A> 呼び出した後 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、名前付きイベント ハンドラーを作成 `MyPeekCompleted`, に結び付けます、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント ハンドラー デリゲート、および呼び出し <xref:System.Messaging.MessageQueue.BeginPeek%2A> パスに配置されているキューに非同期的ピーク操作を開始する". \\myQueue"です。 ときに、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントは、例では、メッセージをピークし、その本体を画面に書き込みます。 例では、 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 新しい非同期的ピーク操作を開始するには、もう一度です。  
  
 [!code-cpp[MessageQueue.BeginPeek\_noparms\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek\_noparms\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek\_noparms\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">構文、 <paramref name="asyncResult" /> パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> を識別する非同期操作の完了が表示されるそれから最終結果を取得します。</param>
        <summary>指定したが完了する非同期操作が表示されます。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> 完了する非同期操作に関連付けられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生すると、 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> によって開始された操作が完了すると、 <xref:System.Messaging.MessageQueue.BeginReceive%2A> を呼び出します。 そのためには <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> メッセージを受信します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> これにより、タイムアウトを指定することができます、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントをキューにメッセージを表示する前にタイムアウトが発生した場合に発生します。 後続の呼び出しに、キューに到着するメッセージが表示されず、タイムアウトになるとき <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 例外をスローします。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 原因となったメッセージを \(キューから削除する\) を読み取りに使用される、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生します。  
  
 引き続きメッセージを非同期的に受信する場合は、もう一度呼び出せる <xref:System.Messaging.MessageQueue.BeginReceive%2A> 呼び出した後 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、非同期要求をチェインします。 それは、"myQueue"と呼ばれる、ローカル コンピューター上のキューがあると仮定します。`Main` 関数によって処理される非同期操作を開始する、 `MyReceiveCompleted` ルーチンです。`MyReceiveCompleted` 現在のメッセージを処理しでは、新しい非同期操作を受信します。  
  
 [!code-cpp[MessageQueue.BeginReceive\_noparms\_combined\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive\_noparms\_combined\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive\_noparms\_combined\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">構文、 <paramref name="asyncResult" /> パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">検索するキューの場所。</param>
        <summary>メッセージ キューのキューが指定されたパスが存在するかどうかを決定します。</summary>
        <returns>
          <see langword="true" /> 指定したパスにキューが存在する場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> メソッドでは、メッセージ キューのキューが指定されたパスに存在するかどうかを判断します。 指定した形式の名前のキューが存在するかどうかを確認するメソッドが存在しません。 形式名の構文および別のパスの構文の詳細については、次を参照してください、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティです。\)。  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 高価な操作です。 アプリケーション内で必要な場合にのみに使用します。  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 方法がサポートされていません、 <xref:System.Messaging.MessageQueue.FormatName%2A> プレフィックス。  
  
 構文、 `path` パラメーターは、次の表に示すように、キューの種類に依存します。  
  
|キューの種類|構文|  
|------------|--------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> リモート プライベート キューの存在を確認するということはできません。  
  
 構文の詳細を参照してください、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティです。  
  
 また、使用することができます、 <xref:System.Messaging.MessageQueue.Label%2A> をキューのパスを記述します。  
  
|参照|構文|  
|--------|--------|  
|ラベル|ラベル: \[ `label` \]|  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例は、メッセージ キューのキューが存在する場合、してから、削除するかどうかを確認します。  
  
 [!code-cpp[MessageQueue.ExistsDelete\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 構文が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。  
  
 または  
  
 <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> リモート プライベート キューにメソッドが呼び出される</exception>
        <exception cref="T:System.InvalidOperationException">アプリケーションは、キューの存在を確認するときに、形式名の構文を使用します。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューのキューの作成時に生成される一意のキュー名を取得します。</summary>
        <value>ネットワーク上で一意であると、キューの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.FormatName%2A> プロパティには、キューの形式名が含まれています。 メッセージ キューは、どのキューを開くへのアクセス方法を識別するために、形式名を使います。 ほとんどのキューの特性は、形式名とは異なりされませんメッセージ キュー アプリケーション キュー プロパティ管理ツールの \[メッセージ キューからアクセスできないようにします。 形式名は、キューの一意の名前だけがメッセージ キュー、そのキューを作成し、後で、アプリケーションを生成するときに生成されます。  
  
 パス名の構文を使用して、パスを指定するかどうか \(よう `myComputer\myQueue`\) 形式名の構文を使用するには、読み取りまたはキューへの書き込みを行うときではなく、プライマリ ドメイン コント ローラー \(Active Directory を使用\) の変換、 <xref:System.Messaging.MessageQueue.Path%2A> に関連付けられた <xref:System.Messaging.MessageQueue.FormatName%2A> 、キューにアクセスする前にします。 形式名の構文を使用する場合は、アプリケーションはオフラインで作業する必要があります。それ以外の場合、プライマリ ドメイン コント ローラーはパスの変換を実行できません。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例には、メッセージ キューの値が表示されます。 <xref:System.Messaging.MessageQueue.FormatName%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> が設定されていません。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定にオブジェクトをシリアル化またはオブジェクトを読み取り、書き込み、キューにメッセージの本文から逆シリアル化に使用するフォーマッタ。</summary>
        <value>
          <see cref="T:System.Messaging.IMessageFormatter" /> に書き込まれるか、メッセージ本文から読み取るのためのストリームを生成します。 既定値は、<see cref="T:System.Messaging.XmlMessageFormatter" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティには、アプリケーションが読み取りまたは、キューに書き込むときにメッセージを変換するフォーマッタ オブジェクトのインスタンスが含まれています。  
  
 アプリケーションは、キューにメッセージを送信するときに、フォーマッタは、オブジェクトをストリームにシリアル化し、メッセージ本文に挿入します。 キューから読み取る場合、フォーマッタのメッセージにデータを <xref:System.Messaging.Message.Body%2A> のプロパティ、 <xref:System.Messaging.Message>です。  
  
 <xref:System.Messaging.XmlMessageFormatter> 、疎結合ため、同じオブジェクトをこの形式を使用する場合は、送信側と受信側で入力する必要はありません。<xref:System.Messaging.ActiveXMessageFormatter> と <xref:System.Messaging.BinaryMessageFormatter> バイナリ表現にデータをシリアル化します。<xref:System.Messaging.ActiveXMessageFormatter> COM コンポーネントを送受信する際に使用します。  
  
 <xref:System.Messaging.BinaryMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter> よりも高速なスループットを提供、 <xref:System.Messaging.XmlMessageFormatter>です。<xref:System.Messaging.ActiveXMessageFormatter> の Visual Basic 6.0 のメッセージ キュー アプリケーションとの相互運用性を使用します。  
  
 アプリケーション キューにメッセージを送信するときに、 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=fullName> 既定のメッセージ プロパティを使用してそれらのメッセージにのみ適用されます <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>します。 送信する場合、 <xref:System.Messaging.Message> 、キューにメッセージ キューで定義されているフォーマッタを使用、 <xref:System.Messaging.Message.Formatter%2A?displayProperty=fullName> 代わりに、本文をシリアル化するプロパティです。  
  
 <xref:System.Messaging.MessageQueue> クラスは常に使用する <xref:System.Messaging.Message> 受信するか、キューからメッセージをピークします。 使用して、メッセージに逆シリアル化、 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=fullName> プロパティです。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例を使用してメッセージ本文の書式設定を示しています <xref:System.Messaging.BinaryMessageFormatter>します。  
  
 [!code-cpp[MessagingBinaryFormatter\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 次のコード例を使用してメッセージ本文の書式設定を示しています <xref:System.Messaging.XmlMessageFormatter>します。  
  
 [!code-cpp[Message.Body\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キュー内にあるすべてのメッセージを返します。</summary>
        <returns>型の配列 <see cref="T:System.Messaging.Message" /> メッセージ キューのキューに表示される同じ順序で、キュー内のすべてのメッセージを表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> それらのメッセージをキューにメッセージ、可変ではないリンクの静的なスナップショットを返します。 したがって、キュー内のメッセージを変更するのに、配列を使用できません。 \(メッセージを削除する機能\) などのキューと、動的なリアルタイムの対話を実行する場合を呼び出す、 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> メソッドで、キュー内のメッセージの動的な一覧を返します。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> メソッドが呼び出された時に、キュー内のメッセージのコピーを返す、配列では、キューに到着する新しいメッセージまたはキューから削除されたメッセージを反映しません。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> によって除外プロパティのみを取得、 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.GetAllMessages%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2\#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キュー内のメッセージを列挙します。<see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> は使用されなくなりました。<see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> 代わりに使用する必要があります。</summary>
        <returns>A <see cref="T:System.Collections.IEnumerator" /> キュー内のメッセージへの接続を動的に提供します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.GetEnumerator%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2\#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">2 つの上記円記号 \(\\\) なしのキューを格納しているコンピューターの名前。</param>
        <summary>このいるキューが参照されているコンピューターの識別子を取得 <see cref="T:System.Messaging.MessageQueue" /> が配置されています。</summary>
        <returns>A <see cref="T:System.Guid" /> キューが配置されているコンピューターの一意の識別子を表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 その他の 2 つの目的のコンピューターの識別子を使用することができます。 コンピューター ジャーナルを読み、セキュリティ証明書を設定します。 ただし、呼び出すことができない <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> リモート コンピューターのドメイン コント ローラーで、アプリケーションには、ディレクトリ サービスへのアクセスが必要なためオフラインしています。  
  
 コンピューターの識別子 \(またはコンピューターの識別子\) が、 <xref:System.Guid> コンピューターが企業に追加されたときにメッセージ キューを作成します。 メッセージ キューを持つコンピューターの id を組み合わせて、 `Machine` と `Journal` 構文は、コンピューターの履歴の形式の名前を作成するためのキーワード `Machine=<computeridentifier>;Journal`します。 ときにメッセージをジャーナル キューには、システムのキューのコピーを格納するアプリケーションによって生成されるも呼ばれるコンピューターの履歴、 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> プロパティは `true`です。  
  
 ジャーナルには、この構文は、キューの形式名を構築するときにのみ有効です。 パス名の構文が `MachineName`\\`Journal$`します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターを直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> を呼び出すコード例を次に示します。  
  
 [!code-csharp[MessageQueue\#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">コンピューターの識別子取得できませんでした、可能性があるため、ディレクトリ サービスが使用できます。たとえば、オフラインで作業するいるとします。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キュー内のすべてのメッセージの列挙子オブジェクトを作成します。<see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> は使用されなくなりました。<see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> 代わりに使用する必要があります。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" /> キューに格納されているメッセージを保持します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> キュー内のすべてのメッセージの動的な一覧を作成します。 ことができます、キューから削除、列挙子の現在位置にあるメッセージを呼び出して <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> の <xref:System.Messaging.MessageEnumerator> を <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> を返します。  
  
 カーソルは、キューにメッセージの動的リストに関連付けられているため、列挙体は、メッセージが現在のカーソル位置を超える場合、キュー内のメッセージに対して行った変更を反映します。 たとえば、カーソルの現在の位置を越えて配置されている優先順位の低いメッセージは、優先順位の高いメッセージではなくその位置の前に挿入、列挙子は自動的にアクセスします。 ただしを変更できます列挙型、それによって、カーソルを移動、リストの先頭を呼び出して <xref:System.Messaging.MessageEnumerator.Reset%2A> の <xref:System.Messaging.MessageEnumerator>です。  
  
 列挙に含まれるメッセージの順序は、優先順位の低いものの前に優先順位の高いメッセージが表示されるように、キュー内の順序を反映します。  
  
 静的なスナップショットには、動的な接続ではなく、キュー内のメッセージの場合は、呼び出す <xref:System.Messaging.MessageQueue.GetAllMessages%2A>します。 このメソッドの配列を返す <xref:System.Messaging.Message> メソッドが呼び出された時にメッセージを表すオブジェクト。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例はキューにメッセージの動的リストを取得しですべてのメッセージのカウント、 <xref:System.Messaging.Message.Priority%2A> プロパティに設定 <xref:System.Messaging.MessagePriority.Lowest?displayProperty=fullName>します。  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キュー内のすべてのメッセージの列挙子オブジェクトを作成します。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" /> キューに格納されているメッセージを保持します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> キュー内のすべてのメッセージの動的な一覧を作成します。 ことができます、キューから削除、列挙子の現在位置にあるメッセージを呼び出して <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> の <xref:System.Messaging.MessageEnumerator> を <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> を返します。  
  
 カーソルは、キューにメッセージの動的リストに関連付けられているため、列挙体は、メッセージが現在のカーソル位置を超える場合、キュー内のメッセージに対して行った変更を反映します。 たとえば、カーソルの現在の位置を越えて配置されている優先順位の低いメッセージは、優先順位の高いメッセージではなくその位置の前に挿入、列挙子は自動的にアクセスします。 ただしを変更できます列挙型、それによって、カーソルを移動、リストの先頭を呼び出して <xref:System.Messaging.MessageEnumerator.Reset%2A> の <xref:System.Messaging.MessageEnumerator>です。  
  
 列挙に含まれるメッセージの順序は、優先順位の低いものの前に優先順位の高いメッセージが表示されるように、キュー内の順序を反映します。  
  
 静的なスナップショットには、動的な接続ではなく、キュー内のメッセージの場合は、呼び出す <xref:System.Messaging.MessageQueue.GetAllMessages%2A>します。 このメソッドの配列を返す <xref:System.Messaging.Message> メソッドが呼び出された時にメッセージを表すオブジェクト。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを列挙するための順方向専用カーソルのセマンティクスを提供します。</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> 、ネットワーク上のすべてのパブリック メッセージ キューの動的な一覧を提供します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロード <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> は、ネットワーク上にあるすべてのパブリック キューの列挙を返します。  
  
 カーソルが動的リストに関連付けられるために、列挙体には、キューが削除またはカーソルの現在位置を超える追加のキュー リストに対して行った変更が反映されます。 カーソルの現在位置の前にあるキューが追加または削除は反映されません。 たとえば、カーソルの位置より後に追加のキューが、その位置の前に挿入されたものではなく、列挙子は自動的にアクセスします。 ただしを変更できます列挙型、それによって、カーソルを移動、リストの先頭を呼び出して <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> の <xref:System.Messaging.MessageQueueEnumerator>です。  
  
 ネットワークでのキューの定義済みの順序はありません。 列挙子を順序付けしません、たとえば、コンピューター、ラベル、パブリックまたはプライベートの状態、またはその他のアクセス可能な条件でします。  
  
 静的なスナップショット動的それらへの接続ではなく、ネットワーク上のキューの場合は、呼び出す <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> または <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>です。 配列を返す 2 つのメソッドの各 <xref:System.Messaging.MessageQueue> メソッドが呼び出された時点でキューを表すオブジェクト。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターを直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例は、ネットワーク内のすべてのメッセージ キューを反復処理し、各キューのパスを検証します。 最後に、ネットワーク上のパブリック キューの数を表示します。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator\_noparms\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator\_noparms\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator\_noparms\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A <see cref="T:System.Messaging.MessageQueueCriteria" /> を使用可能なメッセージ キューをフィルター処理するための条件が含まれています。</param>
        <summary>指定した条件を満たす、ネットワーク上のすべてのパブリック キューを列挙するための順方向専用カーソルのセマンティクスを提供します。</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> で指定された制限を満たすため、ネットワーク上のパブリック メッセージ キューの動的な一覧を提供する、 <paramref name="criteria" /> パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロード <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> アプリケーション条件で定義された条件を満たすため、ネットワーク上のすべてのパブリック キューの一覧を返します。 含めるには、条件、キューの作成や変更時、コンピューター名、ラベル、カテゴリ、またはこれらの任意の組み合わせを指定することができます。  
  
 カーソルが動的リストに関連付けられるために、列挙体には、カーソルの現在の位置以降に発生するキューに対して行った変更が反映されます。 カーソルの現在位置の前にあるキューへの変更は反映されません。 たとえば、カーソルの位置より後に追加のキューが、その位置の前に挿入されたものではなく、列挙子は自動的にアクセスします。 ただしを変更できます列挙型、それによって、カーソルを移動、リストの先頭を呼び出して <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> の <xref:System.Messaging.MessageQueueEnumerator>です。  
  
 ネットワークでのキューの定義済みの順序はありません。 列挙子を順序付けしません、たとえば、コンピューター、ラベル、パブリックまたはプライベートの状態、またはその他のアクセス可能な条件でします。  
  
 動的それらへの接続ではなく、ネットワーク上のキューの静的なスナップショットをする場合の条件を指定 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 呼び出したり <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>します。 配列を返す 2 つのメソッドの各 <xref:System.Messaging.MessageQueue> メソッドが呼び出された時点でキューを表すオブジェクト。 呼び出す <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, 、<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, 、または <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> の呼び出しと同じ結果を提供 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> のフィルター条件を持つ <xref:System.Messaging.MessageQueue.Category%2A>, 、<xref:System.Messaging.MessageQueue.Label%2A>, 、および <xref:System.Messaging.MessageQueue.MachineName%2A>, 、それぞれします。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターを直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例では、メッセージ キューを反復処理し、"MyComputer"というコンピューター上に存在する最後の日で作成したキューのパスを表示します。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator\_criteria\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator\_criteria\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator\_criteria\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">プライベート キューを取得する対象のコンピューター。</param>
        <summary>指定したコンピューター上のすべてのプライベート キューを取得します。</summary>
        <returns>配列 <see cref="T:System.Messaging.MessageQueue" /> 取得されたプライベート キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 指定したコンピューター上のキューの静的なスナップショットを取得します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> パラメーターは <see langword="null" /> または空の文字列 \(""\) です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>配列 <see cref="T:System.Messaging.MessageQueue" /> を取得したパブリック キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ネットワーク上のすべてのパブリック キューの完全な一覧を確認する場合は、このオーバー ロードを使用します。 など、特定の条件によって、一覧を制限する <xref:System.Messaging.MessageQueue.MachineName%2A>, 、<xref:System.Messaging.MessageQueue.Category%2A>, 、または最終更新時刻は、このメソッドの別のオーバー ロードを使用します。 \(使用する代わりに、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, 、<xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, 、または <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.\)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> キューの静的なスナップショットを取得します。 キューの動的な一覧を操作するには使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターを直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A <see cref="T:System.Messaging.MessageQueueCriteria" /> キューのフィルター処理するための条件を格納しています。</param>
        <summary>指定した条件を満たす、ネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>配列 <see cref="T:System.Messaging.MessageQueue" /> を取得したパブリック キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ラベル、カテゴリ、またはコンピューター名で、ネットワーク上のすべてのパブリック キューをフィルター処理する場合、 <xref:System.Messaging.MessageQueue> クラスには、その機能を提供する特定のメソッドが含まれています \(<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, 、<xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, 、および <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, 、それぞれ\)。 \(たとえば、ラベルとカテゴリの両方を指定するには\) 場合は、これらの条件の 1 つ以上を満たしている、ネットワーク上のすべてのパブリック キューの一覧を取得するのにには、このオーバー ロードを使用します。 以外のメッセージの条件でフィルターすることもする <xref:System.Messaging.MessageQueue.Label%2A>, 、<xref:System.Messaging.MessageQueue.Category%2A>, 、および <xref:System.Messaging.MessageQueue.MachineName%2A>です。 たとえば、このオーバー ロードを使用して、キューの最終更新日時でフィルタ リングします。 新しいインスタンスを作成、 <xref:System.Messaging.MessageQueueCriteria> クラス、インスタンスで、適切なプロパティを設定およびとしてインスタンスを渡して、 `criteria` パラメーター。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> キューの静的なスナップショットを取得します。 キューの動的な一覧を操作するには使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターを直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">A <see cref="T:System.Guid" /> を取得するキューのセットをグループ化します。</param>
        <summary>指定したカテゴリに属しているネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>配列 <see cref="T:System.Messaging.MessageQueue" /> を取得したパブリック キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用してパブリック キューをカテゴリでフィルター処理します。<xref:System.Messaging.MessageQueue.Category%2A> プロパティは、メッセージ キューの種類の ID プロパティ \(ある読み取り\/書き込み\) が特定のキューへのアクセスを提供します。 使用できますが <xref:System.Guid.NewGuid%2A> すべてにわたって一意であるカテゴリの値を作成する <xref:System.Guid> 値必要はありません。 カテゴリの値はからではなく他のすべての他のカテゴリ別にする必要がある <xref:System.Guid> 値。 たとえば、あるを割り当てると、 <xref:System.Messaging.MessageQueue.Category%2A> のいずれかのキューおよび {00000000\-0000\-0000\-0000\-000000000002} として設定、 <xref:System.Messaging.MessageQueue.Category%2A> 別のセットのです。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> キューの静的なスナップショットを取得します。 キューの動的な一覧を操作するには使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>します。 一部として、カテゴリを指定する、 <xref:System.Messaging.MessageQueueCriteria> メソッドに渡します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターを直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">取得するキューのセットをグループ化するラベル。</param>
        <summary>指定したラベルをネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>配列 <see cref="T:System.Messaging.MessageQueue" /> を取得したパブリック キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用すると、パブリック キューのラベルを使用してフィルター処理します。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> キューの静的なスナップショットを取得します。 キューの動的な一覧を操作するには使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>します。 一部として、ラベルを指定することができます、 <xref:System.Messaging.MessageQueueCriteria> メソッドに渡します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターを直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">取得するパブリック キューのセットを格納しているコンピューターの名前。</param>
        <summary>指定したコンピューター上に存在するすべてのパブリック キューを取得します。</summary>
        <returns>配列 <see cref="T:System.Messaging.MessageQueue" /> をコンピューター上のパブリック キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用すると、コンピューターがパブリック キューのフィルター処理します。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> キューの静的なスナップショットを取得します。 キューの動的な一覧を操作するには使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>します。 一部として、コンピューター名を指定することができます、 <xref:System.Messaging.MessageQueueCriteria> メソッドに渡します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターを直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> パラメーターが不適切な構文です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>MSMQ がこの呼び出しの時点 \(スレッド id\) の現在のユーザーに関連付けられているセキュリティ コンテキストを取得します。</summary>
        <returns>A <see cref="T:System.Messaging.SecurityContext" /> セキュリティ コンテキストを格納しているオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのメッセージ キューの一意な識別子を取得します。</summary>
        <value>A <see cref="P:System.Messaging.MessageQueue.Id" /> 、メッセージ キュー アプリケーションによって生成されたメッセージ識別子を表します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メッセージ キューのセット、 <xref:System.Messaging.MessageQueue.Id%2A> キューの作成時にプロパティです。 このプロパティでは、パブリック キューの使用のみです。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例には、メッセージ キューの値が表示されます。 <xref:System.Messaging.MessageQueue.Id%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのサイズの制限が存在しないことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定するときに、このメンバーはよく使用 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> または <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>です。  
  
   
  
## 例  
 以下のコード例では、使用、 <xref:System.Messaging.MessageQueue.InfiniteQueueSize> メンバーです。  
  
 [!code-csharp[MessageQueue\#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ピークまたはメッセージを受信するメソッドにタイムアウトが存在しないことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue> 2 種類のメッセージの取得のサポート: 同期および非同期です。 同期メソッド <xref:System.Messaging.MessageQueue.Peek%2A> と <xref:System.Messaging.MessageQueue.Receive%2A>, 、新しいメッセージがキューに到達するための指定した時間間隔を待機するプロセスのスレッドが発生します。 指定した時間間隔が場合 <xref:System.Messaging.MessageQueue.InfiniteTimeout>, 、新しいメッセージが利用可能になるまで、プロセスのスレッドがブロックされたままです。 これに対して、 <xref:System.Messaging.MessageQueue.BeginPeek%2A> と <xref:System.Messaging.MessageQueue.BeginReceive%2A> \(非同期メソッド\) は、メイン アプリケーション タスクをキューにメッセージが到着するまでに、別のスレッドで続行を許可します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Messaging.MessageQueue.InfiniteTimeout> メンバーです。  
  
 [!code-csharp[MessageQueue\#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューの説明を設定します。</summary>
        <value>メッセージ キューのラベルです。 既定値は、空の文字列 \(""\) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メッセージ キュー ラベルの最大長は、最大 124 文字です。  
  
 <xref:System.Messaging.MessageQueue.Label%2A> プロパティはすべてのキューで一意である必要はありません。 ただし、複数のキューが同じ場合 <xref:System.Messaging.MessageQueue.Label%2A>, 、使用することはできません、 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> にそれらのすべてのメッセージをブロードキャストする方法です。 ラベルの構文を使用する場合、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティ、メッセージを送信するときに、例外がスローされます、 <xref:System.Messaging.MessageQueue.Label%2A> 一意ではありません。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.Label%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ラベルは、無効な値に設定されました。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最後にキューのプロパティが変更された日時を取得します。</summary>
        <value>A <see cref="T:System.DateTime" /> キューのプロパティが最後に変更された日時を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 最終更新時刻は、キューの作成時に含まれています。 および <xref:System.Messaging.MessageQueue> メッセージ キューのキューをなどを変更するプロパティ <xref:System.Messaging.MessageQueue.BasePriority%2A>します。 値、 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> プロパティは、ローカル コンピューターのシステム時刻を表します。  
  
 呼び出す必要があります <xref:System.Messaging.MessageQueue.Refresh%2A> 取得する前に、 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> プロパティです。 それ以外の場合、変更時刻がこれに関連付けられている <xref:System.Messaging.MessageQueue> 最新でない可能性があります。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例には、メッセージ キューの値が表示されます。 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはメッセージ キューのキューがあるコンピューターの名前を設定します。</summary>
        <value>キューがあるコンピューターの名前。 メッセージ キューの既定値は"です。"、ローカル コンピューターです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.MachineName%2A> キューの表示名の構文の統合コンポーネントは、 <xref:System.Messaging.MessageQueue.Path%2A>です。 次の表は、その表示名を使用してキューのパスを識別するために必要な場合に、指定した種類のキューで使用する構文を示します。  
  
|キューの種類|構文|  
|------------|--------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 使用する"です。"を指定する場合は、ローカル コンピューターの、 <xref:System.Messaging.MessageQueue.MachineName%2A>です。 たとえば、コンピューター名のみがこのプロパティの認識 `Server0`します。<xref:System.Messaging.MessageQueue.MachineName%2A> プロパティは、IP アドレスの形式をサポートしていません。  
  
 定義した場合、 <xref:System.Messaging.MessageQueue.Path%2A> の観点で、 <xref:System.Messaging.MessageQueue.MachineName%2A>, 、アプリケーションは、ドメイン コント ローラーはパスの変換に必要なために、オフライン作業中に例外をスローします。 したがって、使用する必要があります、 <xref:System.Messaging.MessageQueue.FormatName%2A> の <xref:System.Messaging.MessageQueue.Path%2A> オフラインで作業する場合は構文です。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, 、<xref:System.Messaging.MessageQueue.Path%2A>, 、および <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティが関連します。 変更する、 <xref:System.Messaging.MessageQueue.MachineName%2A> プロパティと、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティを変更します。 新しいからビルドされる <xref:System.Messaging.MessageQueue.MachineName%2A> と <xref:System.Messaging.MessageQueue.QueueName%2A>です。 変更する、 <xref:System.Messaging.MessageQueue.Path%2A> \(たとえば、形式名の構文を使用する場合など\) をリセット、 <xref:System.Messaging.MessageQueue.MachineName%2A> と <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティを新しいキューを参照してください。 場合、 <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティが空で、 <xref:System.Messaging.MessageQueue.Path%2A> が指定したコンピューターのジャーナル キューに設定します。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.MachineName%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">コンピューターの名前が無効、場合によって、構文が正しくないためです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはジャーナル キューの最大サイズを設定します。</summary>
        <value>ジャーナル キューの最大サイズ。 メッセージ キューの既定値は、制限が存在しないことを指定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> メッセージ キュー ジャーナルの記憶域制限へのアクセスを提供します。 該当する場合にのみである <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> は `true`です。 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスが、変更によって影響を受ける  
  
 履歴キューまたは配信不能キューにメッセージを格納する場合は、不要になったメッセージを削除するキューを定期的に消去する必要があります。 このようなキュー内のメッセージは、キューが存在するコンピューターのメッセージ クォータに対してカウントされます。 \(管理者は、コンピューターのクォータを設定します\)。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最大ジャーナル キューのサイズは、無効な値に設定されました。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューの最大サイズを設定します。</summary>
        <value>キューの最大サイズ。 メッセージ キューの既定値は、制限が存在しないことを指定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 、メッセージ キュー メッセージ記憶域の制限は、管理者が定義する、コンピューターのメッセージ クォータとは別にアクセスできるようにします。 メッセージ クォータの詳細については、次を参照してください。 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>します。  
  
 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスが、変更によって影響を受ける  
  
 キューの最大サイズまたはコンピューターのメッセージ クォータを超えたしようとすると、メッセージが失われる可能性があります。 キューのクォータに達すると、メッセージ キューは否定受信確認メッセージを返すことによって、キューがいっぱいであることを示す送信元アプリケーションの管理キューに通知します。 メッセージ キューは、キュー内のメッセージの合計サイズが制限を下回るまで、否定受信確認応答を送信し続けます。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">キューの最大サイズには、負の値が含まれています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または受信またはメッセージをピークのプロパティ フィルターを設定します。</summary>
        <value>
          <see cref="T:System.Messaging.MessagePropertyFilter" /> キューを一連のプロパティを受信するか各メッセージのピークをフィルター処理するために使用します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このフィルターは、一連のメッセージのプロパティを制限するブール値を <xref:System.Messaging.MessageQueue> を受信するかを対象としてピークします。 ときに、 <xref:System.Messaging.MessageQueue> を受信するメッセージをピークかサーバーのキューからのプロパティのみを取得して、 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 値は `true`です。  
  
 初期プロパティ値を次に示します、 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> プロパティです。 これらの設定を呼び出すことと同じ <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> 上、 <xref:System.Messaging.MessagePropertyFilter>です。  
  
|プロパティ|既定値|  
|-----------|---------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> を受信したメッセージ プロパティを制限します。  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このフィルターでは <see langword="null" />です。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 取得またはキューに関連付けられているマルチキャスト アドレスを設定します。</summary>
        <value>A <see cref="T:System.String" /> \(以下に示す形式\) で有効なマルチキャスト アドレスを格納するか、 <see langword="null" />, 、キューのマルチキャスト アドレスに関連付けられていないことを示します。  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> に非トランザクション キューにメッセージを送信する場合に使用するマルチキャスト アドレスを関連付けるプロパティを使用します。 マルチキャスト アドレスを使用して、トランザクション キューを関連付けることはできません。 送信側アプリケーションでは、マルチキャスト アドレスにメッセージを送信するときに、メッセージ キューと、メッセージのコピーがそのアドレスに関連付けられているすべてのキューに送信します。  
  
 IP マルチキャスト アドレスは、クラス D 範囲 224.0.0.0 から 239.255.255.255 の範囲、1110年に一致する最初の 4 つの上位ビットの設定に対応するのことが必要です。 ただし、この範囲のアドレスの特定の範囲のみ予約されておらず、マルチキャストのメッセージを送信するために使用できます。 マルチキャスト アドレスの予約済みの最新の一覧については、 [Internet Assigned Number Authority \(IANA\) Internet Multicast Addresses](http://go.microsoft.com/fwlink/?linkid=3859) Web ページです。 ポート番号に制限はありません。  
  
 複数のソース コンピューターがマルチキャストのメッセージを送信する、1 つだけのソース コンピュータからメッセージを受信する特定のキューをする場合、各ソース コンピューターはそのメッセージを IP アドレスとポート番号の異なる組み合わせを送信する必要があります。  
  
 マルチキャスト アドレスからのキューの関連付けを解除するには、設定、 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> プロパティを長さ 0 の文字列にします。 設定しないで `null`, になるので、 <xref:System.ArgumentNullException>です。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューのパスを設定します。 設定、 <see cref="P:System.Messaging.MessageQueue.Path" /> により、 <see cref="T:System.Messaging.MessageQueue" /> 新しいキューを指すようです。</summary>
        <value>によって参照されているキュー、 <see cref="T:System.Messaging.MessageQueue" />です。 既定値は異なりますが <see cref="M:System.Messaging.MessageQueue.#ctor" /> コンス トラクターを使用する。 か <see langword="null" /> またはコンス トラクターで指定された <paramref name="path" /> パラメーター。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 構文、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティに依存するキューの種類、ポイントに、次の表に示すようにします。  
  
|キューの種類|構文|  
|------------|--------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 使用する"です。"ローカル コンピューターを表す。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, 、<xref:System.Messaging.MessageQueue.Path%2A>, 、および <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティが関連します。 変更する、 <xref:System.Messaging.MessageQueue.MachineName%2A> プロパティと、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティを変更します。 新しいからビルドされる <xref:System.Messaging.MessageQueue.MachineName%2A> と <xref:System.Messaging.MessageQueue.QueueName%2A>です。 変更する、 <xref:System.Messaging.MessageQueue.Path%2A> \(たとえば、形式名の構文を使用する場合など\) をリセット、 <xref:System.Messaging.MessageQueue.MachineName%2A> と <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティを新しいキューを参照してください。  
  
 また、使用することができます、 <xref:System.Messaging.MessageQueue.FormatName%2A> または <xref:System.Messaging.MessageQueue.Label%2A> を次の表に示すように、キューのパスを記述します。  
  
|参照|構文|例|  
|--------|--------|-------|  
|形式名|`FormatName:` \[ *形式名* \]|`FormatName:Public=` 5A5F7535\-AE9A\-41d4\-935C\-845C2AFF7112|  
|ラベル|`Label:` \[ *label* \]|`Label:` とき|  
  
 ラベルの構文を使用する場合、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティ、メッセージを送信するときに、例外がスローされます、 <xref:System.Messaging.MessageQueue.Label%2A> 一意ではありません。  
  
 オフラインで作業するには、最初のテーブルの表示名の構文ではなく、形式名の構文を使用する必要があります。 それ以外の場合、プライマリ ドメイン コント ローラー \(Active Directory が常駐している\) が形式の名前に、パスを解決するのには使用できないため、例外がスローされます。  
  
 新しいパスを設定し、メッセージ キューを閉じ、すべてのハンドルを解放します。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
> [!NOTE]
>  ワークグループ モードでは、専用キューのみ使用できます。 専用キューの構文を使用してパスを指定する `MachineName`\\`Private$`\\`QueueName`します。  
  
   
  
## 例  
 次のコード例を新規作成 <xref:System.Messaging.MessageQueue> オブジェクトのさまざまなパス名の構文型を使用します。 各ケースでは、パスを持つが、コンス トラクターで定義されているキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">パスが有効ですが、場合によって構文が無効であるためです。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します \(ピークします\) を削除せず、キューの最初のメッセージは、これによって参照される <see cref="T:System.Messaging.MessageQueue" />します。<see cref="M:System.Messaging.MessageQueue.Peek" /> メソッド同期操作であるため、メッセージが利用可能になるまで、現在のスレッドをブロックします。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> キューの最初のメッセージを表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キューをピークするメッセージがキューに到達するまで待機したり、このオーバー ロードを使用します。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドを読み取りますが、削除するキューからの最初のメッセージ。 したがってへの呼び出しを繰り返す <xref:System.Messaging.MessageQueue.Peek%2A> より高い優先度のメッセージがキューに到着すると、同じメッセージを返します。<xref:System.Messaging.MessageQueue.Receive%2A> メソッド、これに対して、読み取り\/最初のメッセージをキューから削除します。 繰り返し呼び出す <xref:System.Messaging.MessageQueue.Receive%2A>, 、したがって、さまざまなメッセージを返します。  
  
 メッセージ キューは、優先順位と到達時刻に応じてキューでメッセージを注文します。 優先順位の高いである場合にのみ、新しいメッセージが古いする前に配置されます。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 このオーバー ロードは、タイムアウトを指定しないので、アプリケーションが無制限に待機する可能性があります。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。 オーバー ロードを使用して、キューに到達するメッセージのタイムアウトを指定する代わりに、 <xref:System.Messaging.MessageQueue.Peek%2A> タイムアウトを指定します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次の例を使用して、 <xref:System.Messaging.MessageQueue.Peek%2A> キュー内のメソッドです。  
  
 最初の例では、アプリケーションは、メッセージがキューで使用できるようになるまでを待機します。 最初の例が; に到着したメッセージをアクセスしていないことに注意してください。単に、メッセージが到着するまで処理が一時停止します。 キューにメッセージが既に存在する、すぐに戻ります。  
  
 2 番目の例では、アプリケーション定義を含むメッセージ `Order` クラスは、キューに送信され、キューからピークします。  
  
 [!code-cpp[MessageQueue.Peek\_noparms\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek\_noparms\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek\_noparms\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 待機キューにメッセージを格納する最大の時刻を示します。</param>
        <summary>返します \(ピークします\) を削除せず、キューの最初のメッセージは、これによって参照される <see cref="T:System.Messaging.MessageQueue" />します。<see cref="M:System.Messaging.MessageQueue.Peek" /> メソッド同期操作であるため、メッセージが利用できるようになるか、指定したタイムアウトが発生するまで、現在のスレッドをブロックします。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> キューの最初のメッセージを表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キューをピークするメッセージがキューに到達するまでの指定した期間を待機したり、このオーバー ロードを使用します。 このメソッドは、キューにメッセージが既に存在するかどうかに直ちに返されます。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドを読み取りますが、削除するキューからの最初のメッセージ。 したがってへの呼び出しを繰り返す <xref:System.Messaging.MessageQueue.Peek%2A> より高い優先度のメッセージがキューに到着すると、同じメッセージを返します。<xref:System.Messaging.MessageQueue.Receive%2A> メソッド、これに対して、読み取り\/最初のメッセージをキューから削除します。 繰り返し呼び出す <xref:System.Messaging.MessageQueue.Receive%2A>, 、したがって、さまざまなメッセージを返します。  
  
 メッセージ キューは、優先順位と到達時刻に応じてキューでメッセージを注文します。 優先順位の高いである場合にのみ、新しいメッセージが古いする前に配置されます。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 指定した期間、またはまで、スレッドはブロックされますいただいたかどうか <xref:System.Messaging.MessageQueue.InfiniteTimeout>します。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、 <xref:System.Messaging.MessageQueue.Peek%2A> 、キューが空かどうかをチェックする 0 のタイムアウトを持つメソッドです。  
  
 [!code-cpp[MessageQueue.Peek\_timeout\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek\_timeout\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek\_timeout\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 待機キューにメッセージを格納する最大の時刻を示します。</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> メッセージ キュー内の特定の位置を保持します。</param>
        <param name="action">
          <see cref="T:System.Messaging.PeekAction" /> 値のいずれか。 キューでは、現在のメッセージまたは次のメッセージをピークするかどうかを示します。</param>
        <summary>指定したカーソルを使用して、キュー内 \(ピーク\) 現在または次のメッセージを削除しないで戻ります。<see cref="M:System.Messaging.MessageQueue.Peek" /> メソッド同期操作であるため、メッセージが利用できるようになるか、指定したタイムアウトが発生するまで、現在のスレッドをブロックします。</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> キューにメッセージを表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キューをピークするメッセージがキューに到達するまでの指定した期間を待機したり、このオーバー ロードを使用します。 このメソッドは、キューにメッセージが既に存在するかどうかに直ちに返されます。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドは、読み取りが、削除するキューからのメッセージ。<xref:System.Messaging.MessageQueue.Receive%2A> メソッド、これに対して、読み取り\/キューからメッセージを削除します。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 指定した期間、またはまでスレッドがブロックされていないかどうか <xref:System.Messaging.MessageQueue.InfiniteTimeout>します。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">以外の値 <see langword="PeekAction.Current" /> または <see langword="PeekAction.Next" /> が指定されました、 <paramref name="action" /> パラメーター。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが無効です。 場合によって <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> をピークするメッセージ。</param>
        <summary>指定された相関識別子と一致して、現在、キューには、指定された関連付け識別子を持つメッセージが存在しない場合、すぐに例外が発生するメッセージをピークします。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.CorrelationId" /> と一致する、 <paramref name="correlationId" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、キューによって参照される、 <xref:System.Messaging.MessageQueue> メッセージが <xref:System.Messaging.Message.CorrelationId%2A> 、指定した一致 `correlationId` パラメーター。 一致するメッセージがない場合、 `correlationID` 、パラメーター、例外がスローされます。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるためにプロパティが使用されます。  
  
 その他の 2 つの方法では、キューのメッセージをピークできます。<xref:System.Messaging.MessageQueue.Peek%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> の一意の識別子を指定することによってメッセージを取得するメソッドを使用します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、キューからオーダーを含むメッセージを送受信します。 元のメッセージが達した場合または明示的に肯定受信確認を要求にキューから取得します。  
  
 [!code-cpp[Message.Acknowledgment\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="correlationId" /> で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> をピークするメッセージ。</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <summary>指定された相関識別子と一致して、キューでは、指定された関連付け識別子を持つメッセージがあるか、タイムアウトが経過するまで待機するメッセージをピークします。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.CorrelationId" /> と一致する、 <paramref name="correlationId" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、キューによって参照される、 <xref:System.Messaging.MessageQueue> メッセージが <xref:System.Messaging.Message.CorrelationId%2A> 、指定した一致 `correlationId` パラメーター。 一致するメッセージがない場合、 `correlationID` パラメーター、および新しいメッセージが到着すると、キュー内で指定された期間内で、 `timeout` 、パラメーター、例外がスローされます。  
  
 `timeout` パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、 <xref:System.Messaging.Message.CorrelationId%2A> と一致している新しいメッセージの `correlationId` パラメーター。 ない場合、このメソッドは、上のタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 そのため、新しいメッセージがタイムアウト期間内に到着引き続き場合、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで、無期限に実行を続行するには、このメソッドの <xref:System.Messaging.Message.CorrelationId%2A> と一致する、 `correlationId` パラメーター。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるためにプロパティが使用されます。  
  
 その他の 2 つの方法では、キューのメッセージをピークできます。<xref:System.Messaging.MessageQueue.Peek%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> の一意の識別子を指定することによってメッセージを取得するメソッドを使用します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2\#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="correlationId" /> キューに存在しないため、タイムアウトが経過する前に到達しませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージが到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> をピークするメッセージ。</param>
        <summary>メッセージ id と一致するメッセージをピークします、 <paramref name="id" /> パラメーター。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.Id" /> と一致する、 <paramref name="id" /> パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 、キューから削除することがなく、読み取る既知のメッセージ識別子を持つメッセージ。 あるため最大で 1 つのメッセージに一致するキューにメッセージの識別子が、メッセージ キュー エンタープライズ全体で一意では、指定した `id` パラメーター。 このオーバー ロードは、現在、キューにメッセージが含まれていない場合に例外をスローします。  
  
 2 つの追加メソッドは、キューのメッセージをピーク: <xref:System.Messaging.MessageQueue.Peek%2A> と <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>です。<xref:System.Messaging.MessageQueue.Peek%2A> メソッドでは、最初のメッセージを返します。 キューに <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2\#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージは含まない <paramref name="id" /> が存在します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> をピークするメッセージ。</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <summary>メッセージ id と一致するメッセージをピークします、 <paramref name="id" /> パラメーター。 キューにメッセージを表示またはタイムアウトが発生するまで待機します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.Id" /> と一致する、 <paramref name="id" /> パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 、キューから削除することがなく、読み取る既知のメッセージ識別子を持つメッセージ。 あるため最大で 1 つのメッセージに一致するキューにメッセージの識別子が、メッセージ キュー エンタープライズ全体で一意では、指定した `id` パラメーター。 このオーバー ロードは、現在、キューにメッセージが含まれていないと、タイムアウトが発生する前に、新しいメッセージが到着しない場合に例外をスローします。  
  
 `timeout` パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、 <xref:System.Messaging.Message.Id%2A> と一致している新しいメッセージの `id` パラメーター。 ない場合、このメソッドは、上のタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 そのため、新しいメッセージがタイムアウト期間内に到着引き続き場合、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで、無期限に実行を続行するには、このメソッドの <xref:System.Messaging.Message.Id%2A> と一致する、 `id` パラメーター。  
  
 2 つの追加メソッドは、キューのメッセージをピーク: <xref:System.Messaging.MessageQueue.Peek%2A> と <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>です。<xref:System.Messaging.MessageQueue.Peek%2A> メソッドでは、最初のメッセージを返します。 キューに <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2\#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="id" /> キューに存在しないためで指定された期間より前に着信しなかった、 <paramref name="timeout" /> パラメーターの有効期限が切れています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> をピークするメッセージ。</param>
        <summary>MSMQ 3.0 で導入されました。 非トランザクション キューから指定した参照 id と一致するメッセージをピークします。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.LookupId" /> と一致する、 <paramref name="lookupId" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キューから削除することがなく既知の参照識別子を持つメッセージを読み取るには、このメソッドを使用します。 このメソッドは、メッセージがキューから削除しない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A> メッセージのプロパティは一意のキューにメッセージが存在するがあるため最大で 1 つのメッセージに一致するキューに、指定した `lookupId` パラメーター。  
  
 指定した参照 id を持つメッセージをキューから削除を使用して、 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> メソッドです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="lookupId" /> で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">いずれか、 <see cref="T:System.Messaging.MessageLookupAction" /> キューにメッセージを読み取る方法を指定する値。 次のいずれかを指定します。  
  
 <see langword="MessageLookupAction.Current" />: 指定されたメッセージがピーク <c>lookupId</c>です。  
  
 <see langword="MessageLookupAction.Next" />: 指定されたメッセージに続くメッセージをピークします <c>lookupId</c>です。  
  
 <see langword="MessageLookupAction.Previous" />: 指定されたメッセージの前のメッセージがピーク <c>lookupId</c>です。  
  
 <see langword="MessageLookupAction.First" />: キューの最初のメッセージをピークします。<c>lookupId</c> パラメーターを 0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />: キュー内の最後のメッセージをピークします。<c>lookupId</c> パラメーターを 0 に設定する必要があります。</param>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> をピークするメッセージまたは 0。 キューの最初と最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <summary>MSMQ 3.0 で導入されました。 特定のキューからメッセージをピークします。 メッセージは、参照識別子で指定することもあれば、前面またはキューの末尾に位置によって指定されることができます。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> によって指定された、 <paramref name="action" /> と <paramref name="lookupId" /> パラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キューから削除することがなく既知の参照識別子を持つメッセージを読み取るには、このメソッドを使用します。 このメソッドは、メッセージがキューから削除しない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A> メッセージのプロパティは一意のキューにメッセージが存在するがあるため最大で 1 つのメッセージに一致するキューに、指定した `lookupId` パラメーター。  
  
 指定した識別子を持つメッセージをキューから削除を使用して、 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> メソッドです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="lookupId" /> で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageLookupAction" /> メンバーです。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューから削除せずにメッセージを読み取るときに発生します。 これは、非同期操作の結果 <see cref="M:System.Messaging.MessageQueue.BeginPeek" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 非同期処理で発生させるために使用、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント メッセージがキューで使用できるとします。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 呼び出しによって開始される操作を完了するために使用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> およびメッセージをピーク時に、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントが発生します。  
  
 <xref:System.Messaging.PeekCompletedEventHandler> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベントをイベント ハンドラーに関連付けるには、デリゲートのインスタンスをイベントに追加します。 デリゲートを削除しない限り、そのイベントが発生すると常にイベント ハンドラーが呼び出されます。 イベント ハンドラー デリゲートの詳細については、次を参照してください。 [NIB: イベントとデリゲート](http://msdn.microsoft.com/ja-jp/d98fd58b-fa4f-4598-8378-addf4355a115)します。  
  
   
  
## 例  
 次のコード例は、名前付きイベント ハンドラーを作成 `MyPeekCompleted`, に結び付けます、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベント ハンドラー デリゲート、および呼び出し <xref:System.Messaging.MessageQueue.BeginPeek%2A> パスに配置されているキューに非同期的ピーク操作を開始する". \\myQueue"です。 ときに、 <xref:System.Messaging.MessageQueue.PeekCompleted> イベントは、例では、メッセージをピークし、その本体を画面に書き込みます。 例では、 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 新しい非同期的ピーク操作を開始するには、もう一度  
  
 [!code-cpp[MessageQueue.BeginPeek\_noparms\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek\_noparms\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek\_noparms\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューに含まれるすべてのメッセージを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キューを削除すると、メッセージ キューに影響を与えるキュー変更フラグ設定、 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> プロパティです。 キューから削除されたメッセージは失われます。配信不能キューまたはジャーナル キューに送信されません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.Purge%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2\#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューを識別するフレンドリ名を設定します。</summary>
        <value>これによって参照されるキューを識別する名前 <see cref="T:System.Messaging.MessageQueue" />します。 値は設定できません <see langword="null" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 組み合わせることができます、 <xref:System.Messaging.MessageQueue.QueueName%2A> で、 <xref:System.Messaging.MessageQueue.MachineName%2A> すると、わかりやすい <xref:System.Messaging.MessageQueue.Path%2A> キューの名前。 フレンドリ名のバリエーションの構文、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティは、次の表に示すように、キューの種類に依存します。  
  
|キューの種類|構文|  
|------------|--------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
  
 使用する"です。"ローカル コンピューターを表す。  
  
 変更する、 <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティに影響、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティです。 設定した場合、 <xref:System.Messaging.MessageQueue.QueueName%2A> が設定されていない、 <xref:System.Messaging.MessageQueue.MachineName%2A> プロパティには、 <xref:System.Messaging.MessageQueue.Path%2A> プロパティになります。 \\`QueueName`します。 それ以外の場合、 <xref:System.Messaging.MessageQueue.Path%2A> なります `MachineName`\\`QueueName`します。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.QueueName%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">キュー名が <see langword="null" />です。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューからメッセージを読み取るために使用するネイティブのハンドルを取得します。</summary>
        <value>ピークして、キューからメッセージの受信に使用するネイティブのキュー オブジェクトへのハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A> ピークおよびキューからメッセージの受信に使用されるメッセージ キュー オブジェクトへのネイティブの Windows ハンドルを提供します。 キューのパスを変更する場合は、ハンドルが閉じられ、新しい値で再度開くされます。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>によって参照されるキューで使用できる最初のメッセージを受信、 <see cref="T:System.Messaging.MessageQueue" />です。 この呼び出しは同期的にし、メッセージが利用するまで、現在の実行スレッドをブロックします。</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> キュー内の最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用すると、キューからメッセージが表示されるか、キューにメッセージがされるまで待ちます。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 、キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出しに対して <xref:System.Messaging.MessageQueue.Receive%2A> キューでは、エラーおよび新しいより高い優先度のメッセージを追跡メッセージを返します。  
  
 キューから削除することがなく、キュー内の最初のメッセージの読み取りを行う、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。<xref:System.Messaging.MessageQueue.Peek%2A> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。  
  
 呼び出しを使用して <xref:System.Messaging.MessageQueue.Receive%2A> が、現在のスレッドがキューに到着するメッセージを待機している間にブロックされてもかまわないとします。 このオーバー ロードから、 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドが無限のタイムアウトを指定する、アプリケーションが無制限に待機する可能性があります。 アプリケーションの処理を続行するメッセージを待機しない場合は、非同期のメソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、キューからメッセージを受信し、画面には、そのメッセージに関する情報を出力します。  
  
 [!code-cpp[MessageQueue.Receive\_noparms\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive\_noparms\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive\_noparms\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>によって参照されるトランザクション キューで使用できる最初のメッセージを受信、 <see cref="T:System.Messaging.MessageQueue" />です。 この呼び出しは同期的にし、メッセージが利用するまで、現在の実行スレッドをブロックします。</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> キュー内の最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して定義されている内部トランザクション コンテキストを使用してトランザクション キューからメッセージを受信、 `transaction` パラメーター、またはキューにメッセージがあるまで待機します。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 、キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出しに対して <xref:System.Messaging.MessageQueue.Receive%2A> はキューに次のメッセージを返します。  
  
 このメソッドがトランザクション キューで呼び出されるためにが受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 キューから削除することがなく、キュー内の最初のメッセージの読み取りを行う、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。<xref:System.Messaging.MessageQueue.Peek%2A> メソッドがメソッドへの後続の呼び出しでは、高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.Peek%2A>します。<xref:System.Messaging.MessageQueue.Peek%2A> キューにメッセージは削除されませんがあるへの呼び出しによってロールバックに何も <xref:System.Messaging.MessageQueueTransaction.Abort%2A>です。  
  
 呼び出しを使用して <xref:System.Messaging.MessageQueue.Receive%2A> が、現在のスレッドがキューに到着するメッセージを待機している間にブロックされてもかまわないとします。 このオーバー ロードから、 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドが無限のタイムアウトを指定する、アプリケーションが無制限に待機する可能性があります。 アプリケーションの処理を続行するメッセージを待機しない場合は、非同期のメソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、ローカル コンピューター上のトランザクション キューに接続し、キューにメッセージを送信します。 注文を含むメッセージを受信します。 非トランザクション キューを検出するをスローし、例外、トランザクションをロールバックします。  
  
 [!code-cpp[MessageQueue.Receive\_transaction\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive\_transaction\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive\_transaction\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。  
  
 または  
  
 キューは非トランザクションです。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">いずれか、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>によって参照されるキューで使用できる最初のメッセージを受信、 <see cref="T:System.Messaging.MessageQueue" />です。 この呼び出しは同期的にし、メッセージが利用するまで、現在の実行スレッドをブロックします。</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> キュー内の最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して定義されたトランザクション コンテキストを使用してキューからメッセージを受信、 `transactionType` パラメーター、またはキューにメッセージがあるまで待機します。  
  
 指定 `Automatic` の `transactionType` パラメーター外部トランザクション コンテキストが既にある場合は、メッセージの受信に使用するスレッドにアタッチします。 指定 `Single` 単一の内部トランザクションとメッセージを受信する場合。 指定できます `None` トランザクションのコンテキスト外でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 、キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出しに対して <xref:System.Messaging.MessageQueue.Receive%2A> はキューに次のメッセージを返します。  
  
 このメソッドがトランザクション キューからメッセージを受信すると呼ばれる場合が受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 キューから削除することがなく、キュー内の最初のメッセージの読み取りを行う、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。<xref:System.Messaging.MessageQueue.Peek%2A> メソッドがメソッドへの後続の呼び出しでは、高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.Peek%2A>します。<xref:System.Messaging.MessageQueue.Peek%2A> キューにメッセージは削除されませんがあるへの呼び出しによってロールバックに何も <xref:System.Messaging.MessageQueueTransaction.Abort%2A>です。  
  
 呼び出しを使用して <xref:System.Messaging.MessageQueue.Receive%2A> が、現在のスレッドがキューに到着するメッセージを待機している間にブロックされてもかまわないとします。 このオーバー ロードから、 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドが無限のタイムアウトを指定する、アプリケーションが無制限に待機する可能性があります。 アプリケーションの処理を続行するメッセージを待機しない場合は、非同期のメソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2\#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーです。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <summary>によって参照されるキューで使用できる最初のメッセージを受信、 <see cref="T:System.Messaging.MessageQueue" /> し、メッセージがキューでは、使用するか、タイムアウトの有効期限が切れるまで待機します。</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> キュー内の最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用すると、メッセージが表示され、キューにメッセージがない場合、一定の時間で返します。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> メソッドを使用して、メッセージの同期読み取り用、キューから削除します。 後続の呼び出しに対して <xref:System.Messaging.MessageQueue.Receive%2A> キューでは、エラーおよび新しいより高い優先度のメッセージを追跡メッセージを返します。  
  
 キューから削除することがなく、キュー内の最初のメッセージの読み取りを行う、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。<xref:System.Messaging.MessageQueue.Peek%2A> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。  
  
 呼び出しを使用して <xref:System.Messaging.MessageQueue.Receive%2A> が、現在のスレッドがキューに到着するメッセージを待機している間にブロックされてもかまわないとします。 指定した期間、またはスレッドでブロックされます値を指定した場合 <xref:System.Messaging.MessageQueue.InfiniteTimeout> の `timeout` パラメーター。 アプリケーションの処理を続行するメッセージを待機しない場合は、非同期のメソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、キューからメッセージを受信し、画面には、そのメッセージに関する情報を出力します。 例には、キューに到着するメッセージを待っている間に最大 5 秒間の実行が一時停止します。  
  
 [!code-cpp[MessageQueue.Receive\_timeout\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive\_timeout\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive\_timeout\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> メッセージ キュー内の特定の位置を保持します。</param>
        <summary>指定されたカーソルを使用して、キューの現在のメッセージを受信します。 メッセージがない場合、このメソッドはできる、メッセージがあるか、タイムアウトが経過するまで待機します。</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> キュー内の最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました  
  
 このオーバー ロードを使用すると、メッセージが表示され、キューにメッセージがない場合、一定の時間で返します。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>によって参照されるトランザクション キューで使用できる最初のメッセージを受信、 <see cref="T:System.Messaging.MessageQueue" /> し、メッセージがキューでは、使用するか、タイムアウトの有効期限が切れるまで待機します。</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> キュー内の最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して定義されている内部トランザクション コンテキストを使用してトランザクション キューからメッセージを受信、 `transaction` パラメーター、およびキューにメッセージがない場合は、指定した期間内の戻り値。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 、キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出しに対して <xref:System.Messaging.MessageQueue.Receive%2A> はキューに次のメッセージを返します。  
  
 このメソッドがトランザクション キューで呼び出されるためにが受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 キューから削除することがなく、キュー内の最初のメッセージの読み取りを行う、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。<xref:System.Messaging.MessageQueue.Peek%2A> メソッドがメソッドへの後続の呼び出しでは、高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.Peek%2A>します。<xref:System.Messaging.MessageQueue.Peek%2A> キューにメッセージは削除されませんがあるへの呼び出しによってロールバックに何も <xref:System.Messaging.MessageQueueTransaction.Abort%2A>です。  
  
 呼び出しを使用して <xref:System.Messaging.MessageQueue.Receive%2A> が、現在のスレッドがキューに到着するメッセージを待機している間にブロックされてもかまわないとします。 指定した期間、またはスレッドでブロックされます値を指定した場合 <xref:System.Messaging.MessageQueue.InfiniteTimeout> の `timeout` パラメーター。 アプリケーションの処理を続行するメッセージを待機しない場合は、非同期のメソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、このメソッドの使用方法を示します。  
  
 [!code-cpp[MessageQueue.Receive\_TimeoutTransaction\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive\_TimeoutTransaction\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive\_TimeoutTransaction\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <param name="transactionType">いずれか、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>によって参照されるキューで使用できる最初のメッセージを受信、 <see cref="T:System.Messaging.MessageQueue" />です。 この呼び出しは同期的にし、メッセージがキューでは、使用するか、タイムアウトの有効期限が切れるまで待機します。</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> キュー内の最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して定義されたトランザクション コンテキストを使用してキューからメッセージを受信、 `transactionType` パラメーター、およびキューにメッセージがない場合の時刻の指定した期間の戻り値。  
  
 指定 `Automatic` の `transactionType` パラメーター外部トランザクション コンテキストが既にある場合は、メッセージの受信に使用するスレッドにアタッチします。 指定 `Single` 単一の内部トランザクションとメッセージを受信する場合。 指定できます `None` トランザクションのコンテキスト外でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 、キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出しに対して <xref:System.Messaging.MessageQueue.Receive%2A> はキューに次のメッセージを返します。  
  
 このメソッドがトランザクション キューからメッセージを受信すると呼ばれる場合が受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 キューから削除することがなく、キュー内の最初のメッセージの読み取りを行う、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。<xref:System.Messaging.MessageQueue.Peek%2A> メソッドがメソッドへの後続の呼び出しでは、高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.Peek%2A>します。<xref:System.Messaging.MessageQueue.Peek%2A> キューにメッセージは削除されませんがあるへの呼び出しによってロールバックに何も <xref:System.Messaging.MessageQueueTransaction.Abort%2A>です。  
  
 呼び出しを使用して <xref:System.Messaging.MessageQueue.Receive%2A> が、現在のスレッドがキューに到着するメッセージを待機している間にブロックされてもかまわないとします。 指定した期間、またはスレッドでブロックされます値を指定した場合 <xref:System.Messaging.MessageQueue.InfiniteTimeout> の `timeout` パラメーター。 アプリケーションの処理を続行するメッセージを待機しない場合は、非同期のメソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、このメソッドの使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2\#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> メッセージ キュー内の特定の位置を保持します。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>指定されたカーソルを使用して、キューの現在のメッセージを受信します。 メッセージがない場合、このメソッドはできる、メッセージがあるか、タイムアウトが経過するまで待機します。</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> キューにメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して定義されている内部トランザクション コンテキストを使用してトランザクション キューからメッセージを受信、 `transaction` パラメーター、およびキューにメッセージがない場合は、指定した期間内の戻り値。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 、キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出しに対して <xref:System.Messaging.MessageQueue.Receive%2A> キューに次のメッセージを返します。  
  
 このメソッドがトランザクション キューで呼び出されるため、トランザクションが中止された場合、キューに受信したメッセージが返されます。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 キューから削除することがなくキュー内のメッセージの読み取りを行う、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.Peek%2A>します。<xref:System.Messaging.MessageQueue.Peek%2A> キューにメッセージは削除されませんへの呼び出しをロールバックするものはありません <xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して <xref:System.Messaging.MessageQueue.Receive%2A> が、現在のスレッドがキューに到着するメッセージを待機している間にブロックされてもかまわないとします。 、または、指定した期間に、スレッドがブロックされている場合は、値を指定した <xref:System.Messaging.MessageQueue.InfiniteTimeout> の、 `timeout` パラメーター。 アプリケーションの処理を続行するメッセージを待機しない場合は、非同期のメソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが無効です。 場合によって <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> メッセージ キュー内の特定の位置を保持します。</param>
        <param name="transactionType">いずれか、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> トランザクション コンテキストがメッセージに関連付けの種類を示す値。</param>
        <summary>指定されたカーソルを使用して、キューの現在のメッセージを受信します。 メッセージがない場合、このメソッドはできる、メッセージがあるか、タイムアウトが経過するまで待機します。</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> キューにメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して定義されたトランザクション コンテキストを使用してキューからメッセージを受信、 `transactionType` パラメーター、およびキューにメッセージがない場合の時刻の指定した期間の戻り値。  
  
 指定 `Automatic` の `transactionType` パラメーター外部トランザクション コンテキストが既にある場合は、メッセージの受信に使用するスレッドにアタッチします。 指定 `Single` 単一の内部トランザクションとメッセージを受信する場合。 指定できます `None` トランザクションのコンテキスト外でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 、キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出しに対して <xref:System.Messaging.MessageQueue.Receive%2A> キューに次のメッセージを返します。  
  
 このメソッドがトランザクション キューからメッセージを受信すると呼ばれる場合は、トランザクションが中止された場合に、キューが受信したメッセージが返されます。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 キューから削除することがなくキュー内のメッセージの読み取りを行う、 <xref:System.Messaging.MessageQueue.Peek%2A> メソッドです。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.Peek%2A>します。<xref:System.Messaging.MessageQueue.Peek%2A> キューにメッセージは削除されませんへの呼び出しをロールバックするものはありません <xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して <xref:System.Messaging.MessageQueue.Receive%2A> が、現在のスレッドがキューに到着するメッセージを待機している間にブロックされてもかまわないとします。 、または、指定した期間に、スレッドがブロックされている場合は、値を指定した <xref:System.Messaging.MessageQueue.InfiniteTimeout> の、 `timeout` パラメーター。 アプリケーションの処理を続行するメッセージを待機しない場合は、非同期のメソッドを使用することを検討してください <xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが無効です。 場合によって <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> 、メッセージを受信するのです。</param>
        <summary>\(非トランザクション キュー\) から指定された相関識別子と一致して、現在、キューには、指定された関連付け識別子を持つメッセージが存在しない場合、すぐに例外が発生するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.CorrelationId" /> と一致する、 <paramref name="correlationId" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは非トランザクション キューで参照して、 <xref:System.Messaging.MessageQueue> メッセージが <xref:System.Messaging.Message.CorrelationId%2A> 、指定した一致 `correlationId` パラメーター。 一致するメッセージがない場合、 `correlationID` 、パラメーター、例外がスローされます。 それ以外の場合、メッセージがキューから削除され、アプリケーションに返されます。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるためにプロパティが使用されます。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> メソッドは、一意の識別子を指定することによってメッセージを取得します。  
  
 キューから削除せずには、指定された関連付け識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、キューからオーダーを含むメッセージを送受信します。 元のメッセージが達した場合または明示的に肯定受信確認を要求にキューから取得します。  
  
 [!code-cpp[Message.Acknowledgment\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="correlationId" /> で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> 、メッセージを受信するのです。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>\(トランザクション キュー\) から指定された相関識別子と一致して、現在、キューには、指定された関連付け識別子を持つメッセージが存在しない場合、すぐに例外が発生するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.CorrelationId" /> と一致する、 <paramref name="correlationId" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドはトランザクション キューで参照して、 <xref:System.Messaging.MessageQueue> メッセージが <xref:System.Messaging.Message.CorrelationId%2A> 、指定した一致 `correlationId` パラメーター。 一致するメッセージがない場合、 `correlationID` 、パラメーター、例外がスローされます。 メッセージがそれ以外の場合、キューから削除し、によって定義された内部トランザクション コンテキストを使用してアプリケーションに返される、 `transaction` パラメーター。  
  
 このメソッドがトランザクション キューで呼び出されるためにが受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューからトランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるためにプロパティが使用されます。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> の一意の識別子を指定することによってメッセージを取得するメソッドを使用します。  
  
 キューから削除せずには、指定された関連付け識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>します。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> キューにメッセージは削除されませんがある場合、トランザクションが中止されたをロールバックするものです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2\#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="correlationId" /> で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> 、メッセージを受信するのです。</param>
        <param name="transactionType">いずれか、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>指定された相関識別子と一致して、現在、キューには、指定された関連付け識別子を持つメッセージが存在しない場合、すぐに例外が発生するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.CorrelationId" /> と一致する、 <paramref name="correlationId" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、キューによって参照される、 <xref:System.Messaging.MessageQueue> メッセージが <xref:System.Messaging.Message.CorrelationId%2A> 、指定した一致 `correlationId` パラメーター。 一致するメッセージがない場合、 `correlationID` 、パラメーター、例外がスローされます。 メッセージがそれ以外の場合、キューから削除し、によって定義されたトランザクション コンテキストを使用してアプリケーションに返される、 `transactionType` パラメーター。  
  
 指定 `Automatic` の `transactionType` パラメーター外部トランザクション コンテキストが既にある場合は、メッセージの受信に使用するスレッドにアタッチします。 指定 `Single` 単一の内部トランザクションとメッセージを受信する場合。 指定できます `None` トランザクションのコンテキスト外でトランザクション キューからメッセージを受信する場合。  
  
 このメソッドがトランザクション キューからメッセージを受信すると呼ばれる場合が受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるためにプロパティが使用されます。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> の一意の識別子を指定することによってメッセージを取得するメソッドを使用します。  
  
 キューから削除せずには、指定された関連付け識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>します。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> キューにメッセージは削除されませんがある場合、トランザクションが中止されたをロールバックするものです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2\#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="correlationId" /> で見つかりませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> 、メッセージを受信するのです。</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <summary>\(非トランザクション キュー\) から指定された相関識別子と一致して、指定された関連付け識別子を持つメッセージがキューでは、利用するか、タイムアウトの有効期限が切れるまで待機するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.CorrelationId" /> と一致する、 <paramref name="correlationId" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは非トランザクション キューで参照して、 <xref:System.Messaging.MessageQueue> メッセージが <xref:System.Messaging.Message.CorrelationId%2A> 、指定した一致 `correlationId` パラメーター。 相関 id を持つメッセージがで指定されたかどうかはこのメソッドはすぐを返します、 `correlationId` パラメーターが、キュー内にします。 それ以外の場合、メソッドでは、新しいメッセージが到着する、指定された期間まで待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが配信されない、例外がスローされます。  
  
 `timeout` パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、 <xref:System.Messaging.Message.CorrelationId%2A> と一致している新しいメッセージの `correlationId` パラメーター。 ない場合、このメソッドは、上のタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 そのため、新しいメッセージがタイムアウト期間内に到着引き続き場合、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで、無期限に実行を続行するには、このメソッドの <xref:System.Messaging.Message.CorrelationId%2A> と一致する、 `correlationId` パラメーター。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるためにプロパティが使用されます。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> の一意の識別子を指定することによってメッセージを取得するメソッドを使用します。  
  
 キューから削除せずには、指定された関連付け識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2\#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ <paramref name="correlationId" /> キューに存在しないため、タイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> 、メッセージを受信するのです。</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>\(トランザクション キュー\) から指定された相関識別子と一致して、キューでは、指定された関連付け識別子を持つメッセージがあるか、タイムアウトが経過するまで待機するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.CorrelationId" /> と一致する、 <paramref name="correlationId" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドはトランザクション キューで参照して、 <xref:System.Messaging.MessageQueue> メッセージが <xref:System.Messaging.Message.CorrelationId%2A> 、指定した一致 `correlationId` パラメーター。 相関 id を持つメッセージがで指定されたかどうかはこのメソッドはすぐを返します、 `correlationId` で定義された内部トランザクション コンテキストを使用して、キュー内のパラメーターは、 `transaction` パラメーター。 それ以外の場合、メソッドでは、新しいメッセージが到着する、指定された期間まで待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが配信されない、例外がスローされます。  
  
 `timeout` パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、 <xref:System.Messaging.Message.CorrelationId%2A> と一致している新しいメッセージの `correlationId` パラメーター。 ない場合、このメソッドは、上のタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 そのため、新しいメッセージがタイムアウト期間内に到着引き続き場合、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで、無期限に実行を続行するには、このメソッドの <xref:System.Messaging.Message.CorrelationId%2A> と一致する、 `correlationId` パラメーター。  
  
 このメソッドがトランザクション キューで呼び出されるためにが受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューからトランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるためにプロパティが使用されます。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> の一意の識別子を指定することによってメッセージを取得するメソッドを使用します。  
  
 キューから削除せずには、指定された関連付け識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>します。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> キューにメッセージは削除されませんがある場合、トランザクションが中止されたをロールバックするものです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2\#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ <paramref name="correlationId" /> キューに存在しないため、タイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> 、メッセージを受信するのです。</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <param name="transactionType">いずれか、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>指定された相関識別子と一致し、指定された関連付け識別子を持つメッセージがキューでは、利用するか、タイムアウトの有効期限が切れるまで待機するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.CorrelationId" /> と一致する、 <paramref name="correlationId" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、キューによって参照される、 <xref:System.Messaging.MessageQueue> メッセージが <xref:System.Messaging.Message.CorrelationId%2A> 、指定した一致 `correlationId` パラメーター。 相関 id を持つメッセージがで指定されたかどうかはこのメソッドはすぐを返します、 `correlationId` で定義されたトランザクション コンテキストを使用して、キュー内のパラメーターは、 `transactionType` パラメーター。 それ以外の場合、メソッドでは、新しいメッセージが到着する、指定された期間まで待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが配信されない、例外がスローされます。  
  
 `timeout` パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、 <xref:System.Messaging.Message.CorrelationId%2A> と一致している新しいメッセージの `correlationId` パラメーター。 ない場合、このメソッドは、上のタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 そのため、新しいメッセージがタイムアウト期間内に到着引き続き場合、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで、無期限に実行を続行するには、このメソッドの <xref:System.Messaging.Message.CorrelationId%2A> と一致する、 `correlationId` パラメーター。 指定 `Automatic` の `transactionType` パラメーター外部トランザクション コンテキストが既にある場合は、メッセージの受信に使用するスレッドにアタッチします。 指定 `Single` 単一の内部トランザクションとメッセージを受信する場合。 指定できます `None` トランザクションのコンテキスト外でトランザクション キューからメッセージを受信する場合。  
  
 このメソッドがトランザクション キューからメッセージを受信すると呼ばれる場合が受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A> に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるためにプロパティが使用されます。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> の一意の識別子を指定することによってメッセージを取得するメソッドを使用します。  
  
 キューから削除せずには、指定された関連付け識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>します。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> キューにメッセージは削除されませんがある場合、トランザクションが中止されたをロールバックするものです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2\#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="correlationId" /> で見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ <paramref name="correlationId" /> キューに存在しないため、タイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> 、メッセージを受信するのです。</param>
        <summary>非トランザクション キューから指定した識別子と一致して、現在、キューには、指定した識別子を持つメッセージが存在しない場合、すぐに例外が発生するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.Id" /> と一致する、 <paramref name="id" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取るし、キューから削除します。 このメソッドは、メッセージがキューから削除しない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.Id%2A> があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定した `id` パラメーター。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2\#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="id" /> で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> 、メッセージを受信するのです。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>\(トランザクション キュー\) から指定した識別子と一致して、現在、キューには、指定した識別子を持つメッセージが存在しない場合、すぐに例外が発生するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.Id" /> と一致する、 <paramref name="id" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既知の識別子を持つメッセージを読み取りで定義された内部トランザクション コンテキストを使用して、キューから削除するこのメソッドを使用して、 `transaction` パラメーター。 このメソッドは例外をスローすぐにメッセージがキューから削除できません。  
  
 <xref:System.Messaging.Message.Id%2A> があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定した `id` パラメーター。  
  
 このメソッドがトランザクション キューで呼び出されるためにが受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドがメソッドへの後続の呼び出しでは、高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>します。<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> キューにメッセージは削除されませんがある場合、トランザクションが中止されたをロールバックするものです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2\#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="id" /> で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> 、メッセージを受信するのです。</param>
        <param name="transactionType">いずれか、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>指定した識別子と一致してすぐに現在、キューには、指定した識別子を持つメッセージが存在しない場合、例外が発生するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.Id" /> と一致する、 <paramref name="id" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取るし、キューから削除します。 このメソッドは、メッセージがキューから削除しない場合は、すぐに例外をスローします。 メッセージがそれ以外の場合、キューから削除し、によって定義されたトランザクション コンテキストを使用してアプリケーションに返される、 `transactionType` パラメーター。  
  
 指定 `Automatic` の `transactionType` パラメーター外部トランザクション コンテキストが既にある場合は、メッセージの受信に使用するスレッドにアタッチします。 指定 `Single` 単一の内部トランザクションとメッセージを受信する場合。 指定できます `None` トランザクションのコンテキスト外でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.Message.Id%2A> があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定した `id` パラメーター。 指定した識別子とメッセージがこれに関連付けられているものではないキュー内にある場合 <xref:System.Messaging.MessageQueue> インスタンス、メッセージが見つかりません。  
  
 このメソッドがトランザクション キューからメッセージを受信すると呼ばれる場合が受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>します。<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> キューにメッセージは削除されませんがある場合、トランザクションが中止されたをロールバックするものです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2\#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="id" /> で見つかりませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> 、メッセージを受信するのです。</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <summary>\(非トランザクション キュー\) から指定した識別子と一致して、指定した識別子とメッセージがキューに利用するか、タイムアウトの有効期限が切れるまで待機するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.Id" /> と一致する、 <paramref name="id" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取るし、キューから削除します。 識別子を持つメッセージが指定されたかどうかはこのメソッドはすぐを返します、 `id` パラメーターが、キュー内にします。 それ以外の場合、メソッドでは、新しいメッセージが到着する、指定された期間まで待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが配信されない、例外がスローされます。  
  
 `timeout` パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、 <xref:System.Messaging.Message.Id%2A> と一致している新しいメッセージの `id` パラメーター。 ない場合、このメソッドは、上のタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 そのため、新しいメッセージがタイムアウト期間内に到着引き続き場合、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで、無期限に実行を続行するには、このメソッドの <xref:System.Messaging.Message.Id%2A> と一致する、 `id` パラメーター。  
  
 <xref:System.Messaging.Message.Id%2A> があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定した `id` パラメーター。  
  
 このオーバー ロードを使用して <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> が、現在のスレッドが新しいメッセージがキュー内で指定されたタイムアウト期間内に到着引き続き限り、ブロックされてもかまわない場合、 `timeout` パラメーター。 スレッドはブロックされますを少なくとも指定した期間、または値を指定した場合 <xref:System.Messaging.MessageQueue.InfiniteTimeout> の `timeout` パラメーター、または新しいメッセージが引き続きで指定されたタイムアウト期間内に、キューに到着する場合、 `timeout` パラメーター。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2\#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ <paramref name="id" /> キューにタイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> 、メッセージを受信するのです。</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>\(トランザクション キュー\) から指定した識別子と一致して、指定した識別子とメッセージがキューに利用するか、タイムアウトの有効期限が切れるまで待機するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.Id" /> と一致する、 <paramref name="id" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既知の識別子を持つメッセージを読み取りで定義された内部トランザクション コンテキストを使用して、キューから削除するこのメソッドを使用して、 `transaction` パラメーター。 識別子を持つメッセージが指定されたかどうかはこのメソッドはすぐを返します、 `id` パラメーターが、キュー内にします。 それ以外の場合、メソッドでは、新しいメッセージが到着する、指定された期間まで待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが配信されない、例外がスローされます。  
  
 `timeout` パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、 <xref:System.Messaging.Message.Id%2A> と一致している新しいメッセージの `id` パラメーター。 ない場合、このメソッドは、上のタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 そのため、新しいメッセージがタイムアウト期間内に到着引き続き場合、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで、無期限に実行を続行するには、このメソッドの <xref:System.Messaging.Message.Id%2A> と一致する、 `id` パラメーター。  
  
 <xref:System.Messaging.Message.Id%2A> があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定した `id` パラメーター。  
  
 このオーバー ロードを使用して <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> が、現在のスレッドが新しいメッセージがキュー内で指定されたタイムアウト期間内に到着引き続き限り、ブロックされてもかまわない場合、 `timeout` パラメーター。 スレッドはブロックされますを少なくとも指定した期間、または値を指定した場合 <xref:System.Messaging.MessageQueue.InfiniteTimeout> の `timeout` パラメーター、または新しいメッセージが引き続きで指定されたタイムアウト期間内に、キューに到着する場合、 `timeout` パラメーター。  
  
 このメソッドがトランザクション キューで呼び出されるためにが受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドがより高い優先度のメッセージが、キューに到着しない限り、以降、メソッドを呼び出すが、同じメッセージを返すように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>します。<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> キューにメッセージは削除されませんがある場合、トランザクションが中止されたをロールバックするものです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2\#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ <paramref name="id" /> キューにタイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> 、メッセージを受信するのです。</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> 新しいメッセージを検査できるようになるまで待機する時刻を示します。</param>
        <param name="transactionType">いずれか、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>指定した識別子と一致し、指定した識別子とメッセージがキューに利用するか、タイムアウトの有効期限が切れるまで待機するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.Id" /> と一致する、 <paramref name="id" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取るし、キューから削除します。 識別子を持つメッセージが指定されたかどうかはこのメソッドはすぐを返します、 `id` で定義されたトランザクション コンテキストを使用して、キュー内のパラメーターは、 `transactionType` パラメーター。 それ以外の場合、メソッドでは、新しいメッセージが到着する、指定された期間まで待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが配信されない、例外がスローされます。  
  
 `timeout` パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、 <xref:System.Messaging.Message.Id%2A> と一致している新しいメッセージの `id` パラメーター。 ない場合、このメソッドは、上のタイムアウト期間を開始し、別の新しいメッセージが到着するまで待機します。 そのため、新しいメッセージがタイムアウト期間内に到着引き続き場合、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで、無期限に実行を続行するには、このメソッドの <xref:System.Messaging.Message.Id%2A> と一致する、 `id` パラメーター。  
  
 指定 `Automatic` の `transactionType` パラメーター外部トランザクション コンテキストが既にある場合は、メッセージの受信に使用するスレッドにアタッチします。 指定 `Single` 単一の内部トランザクションとメッセージを受信する場合。 指定できます `None` トランザクションのコンテキスト外でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.Message.Id%2A> があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定した `id` パラメーター。 指定した識別子とメッセージがこれに関連付けられているものではないキュー内にある場合 <xref:System.Messaging.MessageQueue> インスタンス、メッセージが見つかりません。  
  
 このオーバー ロードを使用して <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> が、現在のスレッドが新しいメッセージがキュー内で指定されたタイムアウト期間内に到着引き続き限り、ブロックされてもかまわない場合、 `timeout` パラメーター。 スレッドはブロックされますを少なくとも指定した期間、または値を指定した場合 <xref:System.Messaging.MessageQueue.InfiniteTimeout> の `timeout` パラメーター、または新しいメッセージが引き続きで指定されたタイムアウト期間内に、キューに到着する場合、 `timeout` パラメーター。  
  
 このメソッドがトランザクション キューからメッセージを受信すると呼ばれる場合が受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 その他の 2 つの方法では、キューからメッセージを受信できます。<xref:System.Messaging.MessageQueue.Receive%2A> メソッドは、キューでは、最初のメッセージを返しますと <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> メソッドを使用して、受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドです。<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> メソッドがメソッドへの後続の呼び出しでは、高い優先度のメッセージが、キューに到着しない限り、同じメッセージが返されるように、キューでは、最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>します。<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> キューにメッセージは削除されませんがある場合、トランザクションが中止されたをロールバックするものです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2\#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、 <paramref name="timeout" /> パラメーターが有効でない可能性がある <paramref name="timeout" /> がより小さい <see cref="F:System.TimeSpan.Zero" /> 以上 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ <paramref name="id" /> キューにタイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーです。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> 、メッセージを受信するのです。</param>
        <summary>MSMQ 3.0 で導入されました。 非トランザクション キューから指定した参照 id と一致するメッセージを受信します。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> が <see cref="P:System.Messaging.Message.LookupId" /> と一致する、 <paramref name="lookupId" /> でパラメーターが渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、既知の参照識別子を持つメッセージを読み取るし、キューから削除します。 このメソッドは、メッセージがキューから削除しない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A> メッセージのプロパティは一意のキューにメッセージが存在するがあるため最大で 1 つのメッセージに一致するキューに、指定した `lookupId` パラメーター。  
  
 キューから削除せずには、指定した参照識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> メソッドです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="lookupId" /> で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">いずれか、 <see cref="T:System.Messaging.MessageLookupAction" /> キューにメッセージを読み取る方法を指定する値。 次のいずれかを指定します。  
  
 <see langword="MessageLookupAction.Current" />: で指定されたメッセージを受信する <c>lookupId</c> され、キューから削除されます。  
  
 <see langword="MessageLookupAction.Next" />: 後で指定されたメッセージのメッセージを受信する <c>lookupId</c> され、キューから削除されます。  
  
 <see langword="MessageLookupAction.Previous" />: で指定されたメッセージの前のメッセージを受信する <c>lookupId</c> され、キューから削除されます。  
  
 <see langword="MessageLookupAction.First" />: キューの最初のメッセージを受信し、キューから削除します。<c>lookupId</c> パラメーターを 0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />: キューの最後のメッセージを受信し、キューから削除します。<c>lookupId</c> パラメーターを 0 に設定する必要があります。</param>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> を受信するメッセージまたは 0。 キューの最初と最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>MSMQ 3.0 で導入されました。 トランザクション キューから特定のメッセージを受信します。 メッセージは、参照識別子で指定することもあれば、前面またはキューの末尾に位置によって指定されることができます。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> によって指定された、 <paramref name="lookupId" /> と <paramref name="action" /> パラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既知の参照識別子を持つメッセージを読み取りで定義されたトランザクション コンテキストを使用して、キューから削除するこのメソッドを使用して、 `transaction` パラメーター。 このメソッドは、メッセージがキューから削除しない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A> メッセージのプロパティは一意のキューにメッセージが存在するがあるため最大で 1 つのメッセージに一致するキューに、指定した `lookupId` パラメーター。  
  
 このメソッドがトランザクション キューで呼び出されるためにが受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> メソッドです。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>します。<xref:System.Messaging.MessageQueue.PeekByLookupId%2A> メッセージ キューから削除されずがある場合、トランザクションが中止されたをロールバックするものです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="lookupId" /> で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。  
  
 または  
  
 キューは非トランザクションです。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageLookupAction" /> メンバーです。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">いずれか、 <see cref="T:System.Messaging.MessageLookupAction" /> キューにメッセージを読み取る方法を指定する値。 次のいずれかを指定します。  
  
 <see langword="MessageLookupAction.Current" />: で指定されたメッセージを受信する <c>lookupId</c> され、キューから削除されます。  
  
 <see langword="MessageLookupAction.Next" />: 後で指定されたメッセージのメッセージを受信する <c>lookupId</c> され、キューから削除されます。  
  
 <see langword="MessageLookupAction.Previous" />: で指定されたメッセージの前のメッセージを受信する <c>lookupId</c> され、キューから削除されます。  
  
 <see langword="MessageLookupAction.First" />: キューの最初のメッセージを受信し、キューから削除します。<c>lookupId</c> パラメーターを 0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />: キューの最後のメッセージを受信し、キューから削除します。<c>lookupId</c> パラメーターを 0 に設定する必要があります。</param>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> を受信するメッセージまたは 0。 キューの最初と最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <param name="transactionType">いずれか、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>MSMQ 3.0 で導入されました。 指定されたトランザクション コンテキストを使用して、キューから特定のメッセージを受信します。 メッセージは、参照識別子で指定することもあれば、前面またはキューの末尾に位置によって指定されることができます。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> によって指定された、 <paramref name="action" /> と <paramref name="lookupId" /> パラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既知の参照識別子を持つメッセージを読み取りで定義されたトランザクション コンテキストを使用して、キューから削除するこのメソッドを使用して、 `transactionType` パラメーター。 このメソッドは、メッセージがキューから削除しない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A> メッセージのプロパティは一意のキューにメッセージが存在するがあるため最大で 1 つのメッセージに一致するキューに、指定した `lookupId` パラメーター。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取りを使用して、 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> メソッドです。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>します。<xref:System.Messaging.MessageQueue.PeekByLookupId%2A> メッセージ キューから削除されずがある場合、トランザクションが中止されたをロールバックするものです。  
  
 指定 `Automatic` の `transactionType` パラメーター外部トランザクション コンテキストが既にある場合は、メッセージの受信に使用するスレッドにアタッチします。 指定 `Single` 単一の内部トランザクションとメッセージを受信する場合。 指定できます `None` トランザクションのコンテキスト外でトランザクション キューからメッセージを受信する場合。  
  
 このメソッドがトランザクション キューからメッセージを受信すると呼ばれる場合が受信したメッセージが返されますをキューにトランザクションが中止された場合。 メッセージは永続的に削除されません、キューからトランザクションがコミットされるまで。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ <paramref name="lookupId" /> で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageLookupAction" /> メンバーです。  
  
 または  
  
 <paramref name="transactionType" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーです。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージがキューから削除されたときに発生します。 このイベントは、非同期操作 <see cref="M:System.Messaging.MessageQueue.BeginReceive" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期処理で発生させるために使用、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント メッセージがキューで使用できるとします。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 呼び出しによって開始される操作を完了するために使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> およびメッセージをピーク時に、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントが発生します。  
  
 <xref:System.Messaging.ReceiveCompletedEventHandler> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベントをイベント ハンドラーに関連付けるには、デリゲートのインスタンスをイベントに追加します。 デリゲートを削除しない限り、そのイベントが発生すると常にイベント ハンドラーが呼び出されます。 イベント ハンドラー デリゲートの詳細については、次を参照してください。 [NIB: イベントとデリゲート](http://msdn.microsoft.com/ja-jp/d98fd58b-fa4f-4598-8378-addf4355a115)します。  
  
   
  
## 例  
 次のコード例は、名前付きイベント ハンドラーを作成 `MyReceiveCompleted`, に結び付けます、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベント ハンドラー デリゲート、および呼び出し <xref:System.Messaging.MessageQueue.BeginReceive%2A> を開始する非同期の受信操作は、パスにあるキューで". \\myQueue"です。 ときに、 <xref:System.Messaging.MessageQueue.ReceiveCompleted> イベントは、例では、メッセージを受信し、その本体を画面に書き込みます。 例では、 <xref:System.Messaging.MessageQueue.BeginReceive%2A> に新しい非同期操作を受信します。  
  
 [!code-cpp[MessageQueue.ReceiveCompleted\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>によって提示されるプロパティを更新し、 <see cref="T:System.Messaging.MessageQueue" /> リソースの現在の状態を反映するようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.Refresh%2A> 同期のプロパティ、 <xref:System.Messaging.MessageQueue> 、関連付けられているメッセージ キュー サーバー リソースです。 場合は、任意のプロパティなど <xref:System.Messaging.MessageQueue.Label%2A> または <xref:System.Messaging.MessageQueue.Category%2A>, 、時間以降、サーバーで変更された、 <xref:System.Messaging.MessageQueue> が作成された <xref:System.Messaging.MessageQueue.Refresh%2A> 更新プログラム、 <xref:System.Messaging.MessageQueue> の最新情報をします。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.Refresh%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2\#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アクセス許可の一覧をオペレーティング システムの既定値にリセットします。 既定の一覧に追加したキューのアクセス許可を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すと <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, 、アクセス許可の一覧をその既定値に戻ります。 一般に、このキューの作成者は、すべてのアクセス許可を付与し、すべてのユーザー、グループを利用、次の権限。  
  
-   キューのプロパティを取得します。  
  
-   キューのアクセス許可を取得します。  
  
-   キューへの書き込みです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.ResetPermissions%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2\#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <summary>オブジェクトをこのによって参照される非トランザクション キューに送信 <see cref="T:System.Messaging.MessageQueue" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 含むメッセージを送信するこのオーバー ロードを使用して、 `obj` パラメーターで参照されるキューを <xref:System.Messaging.MessageQueue>です。 キューに送信するオブジェクトを指定できます、 <xref:System.Messaging.Message> または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、 <xref:System.Messaging.Message>, 、オブジェクトをシリアル化され、メッセージの本文に挿入します。  
  
 このオーバー ロードを使用して、トランザクション キューにメッセージを送信する場合、メッセージが配信不能キューに送信されます。 メッセージを他のメッセージを含むトランザクションの一部にする場合を受け取るオーバー ロードを使用して、 <xref:System.Messaging.MessageQueueTransaction> または <xref:System.Messaging.MessageQueueTransactionType> をパラメーターとして。  
  
 設定しない場合、 <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを呼び出す前に <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 、フォーマッタの既定値、 <xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティが適用される任意のオブジェクト以外の場合、 <xref:System.Messaging.Message>です。 または指定した場合、たとえば、ラベルを使用して、優先度、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバー、これらの値はない型のオブジェクトを含むメッセージに適用 <xref:System.Messaging.Message> ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>, 、プロパティ値を設定、 <xref:System.Messaging.Message> よりも優先 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> とメッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=fullName> キューのプロパティが優先されます <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=fullName> プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、メッセージ キューに接続し、キューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Send\_obj\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send\_obj\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send\_obj\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 次のコード例では、アプリケーション定義は送信 `Order` キューにクラスし、そのキューからメッセージを受信します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>オブジェクトをこのによって参照されるトランザクション キューに送信 <see cref="T:System.Messaging.MessageQueue" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 含むメッセージを送信するこのオーバー ロードを使用して、 `obj` パラメーターによって参照されるトランザクション キューを <xref:System.Messaging.MessageQueue>, で定義された内部トランザクション コンテキストを使用して、 `transaction` パラメーター。 キューに送信するオブジェクトを指定できます、 <xref:System.Messaging.Message> または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、 <xref:System.Messaging.Message>, 、オブジェクトをシリアル化され、メッセージの本文に挿入します。  
  
 このオーバー ロードを使用して非トランザクション キューにメッセージを送信する場合、例外をスローせず、メッセージを配信不能キューに送信可能性があります。  
  
 設定しない場合、 <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを呼び出す前に <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 、フォーマッタの既定値、 <xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティが適用される任意のオブジェクト以外の場合、 <xref:System.Messaging.Message>です。 または指定した場合、たとえば、ラベルを使用して、優先度、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバー、これらの値はない型のオブジェクトを含むメッセージに適用 <xref:System.Messaging.Message> ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>, 、プロパティ値を設定、 <xref:System.Messaging.Message> よりも優先 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> とメッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=fullName> キューのプロパティが優先されます <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=fullName> プロパティです。  
  
 \[Visual Basic\]  
  
 <xref:System.Messaging.MessageQueueTransaction> スレッドのアパートメントに対応する、アパートメント状態の場合これ `STA`, 、複数のスレッドでトランザクションを使用することはできません。 Visual Basic にメイン スレッドの状態を設定する `STA`, を適用する必要がありますので、 <xref:System.MTAThreadAttribute> で、 `Main` サブルーチンです。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 適用する、 <xref:System.MTAThreadAttribute> 次のフラグメントを使用しています。  
  
```  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
```vb  
  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例では、トランザクション キューに文字列を送信し、そのキューからメッセージを受信します。  
  
 [!code-cpp[MessageQueue.Send\_ObjectTransaction\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send\_ObjectTransaction\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send\_ObjectTransaction\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
 または  
  
 メッセージ キュー アプリケーションでは、不正なトランザクションの使用が示されます。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="transactionType">いずれか、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>オブジェクトをこのによって参照されるキューに送信 <see cref="T:System.Messaging.MessageQueue" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 含むメッセージを送信するこのオーバー ロードを使用して、 `obj` パラメーターで参照されるキューを <xref:System.Messaging.MessageQueue>, で定義されたトランザクション コンテキストを使用して、 `transactionType` パラメーター。 指定 `Automatic` の `transactionType` 外部トランザクション コンテキストが既にある場合のパラメーターがメッセージの送信に使用するスレッドにアタッチします。 指定 `Single` 単一の内部トランザクション メッセージを送信する場合。 指定できます `None` トランザクションではないスレッドへトランザクション メッセージを送信する場合。  
  
 キューに送信するオブジェクトを指定できます、 <xref:System.Messaging.Message> または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、 <xref:System.Messaging.Message>, 、オブジェクトをシリアル化され、メッセージの本文に挿入します。  
  
 設定しない場合、 <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを呼び出す前に <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 、フォーマッタの既定値、 <xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティが適用される任意のオブジェクト以外の場合、 <xref:System.Messaging.Message>です。 または指定した場合、たとえば、ラベルを使用して、優先度、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバー、これらの値はない型のオブジェクトを含むメッセージに適用 <xref:System.Messaging.Message> ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>, 、プロパティ値を設定、 <xref:System.Messaging.Message> よりも優先 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> とメッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=fullName> キューのプロパティが優先されます <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=fullName> プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベルです。</param>
        <summary>オブジェクトをこのによって参照される非トランザクション キューに送信 <see cref="T:System.Messaging.MessageQueue" /> し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 含むメッセージを送信するこのオーバー ロードを使用して、 `obj` パラメーターで参照されるキューを <xref:System.Messaging.MessageQueue>です。 このオーバー ロードでは、メッセージを識別する文字列のラベルを指定できます。 キューに送信するオブジェクトを指定できます、 <xref:System.Messaging.Message>, 、構造体、データ オブジェクト、または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、 <xref:System.Messaging.Message>, 、オブジェクトをシリアル化され、メッセージの本文に挿入します。  
  
 メッセージ ラベルは、メッセージ キュー ラベルとは異なりますが、両方はアプリケーションに依存してされていないメッセージ キューの意味を継承します。  
  
 このオーバー ロードを使用して、トランザクション キューにメッセージを送信する場合、メッセージが配信不能キューに送信されます。 メッセージを他のメッセージを含むトランザクションの一部にする場合を受け取るオーバー ロードを使用して、 <xref:System.Messaging.MessageQueueTransaction> または <xref:System.Messaging.MessageQueueTransactionType> をパラメーターとして。  
  
 <xref:System.Messaging.MessageQueue.Path%2A> プロパティをこの <xref:System.Messaging.MessageQueue> メッセージを送信する前に、インスタンスを指定する必要があります。 設定しない場合、 <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを呼び出す前に <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 、フォーマッタの既定値、 <xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティが適用される任意のオブジェクト以外の場合、 <xref:System.Messaging.Message>です。 または指定した場合、たとえば、ラベルを使用して、優先度、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバー、これらの値はない型のオブジェクトを含むメッセージに適用 <xref:System.Messaging.Message> ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>, 、プロパティ値を設定、 <xref:System.Messaging.Message> よりも優先 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> とメッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=fullName> キューのプロパティが優先されます <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=fullName> プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベルです。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>オブジェクトをこのによって参照されるトランザクション キューに送信 <see cref="T:System.Messaging.MessageQueue" /> し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 含むメッセージを送信するこのオーバー ロードを使用して、 `obj` パラメーターによって参照されるトランザクション キューを <xref:System.Messaging.MessageQueue>, で定義された内部トランザクション コンテキストを使用して、 `transaction` パラメーター。 このオーバー ロードでは、メッセージを識別する文字列のラベルを指定できます。 キューに送信するオブジェクトを指定できます、 <xref:System.Messaging.Message>, 、構造体、データ オブジェクト、または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、 <xref:System.Messaging.Message>, 、オブジェクトをシリアル化され、メッセージの本文に挿入します。  
  
 メッセージ ラベルは、メッセージ キュー ラベルとは異なりますが、両方はアプリケーションに依存してされていないメッセージ キューの意味を継承します。  
  
 このオーバー ロードを使用して非トランザクション キューにメッセージを送信する場合、例外をスローせず、メッセージを配信不能キューに送信可能性があります。  
  
 設定しない場合、 <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを呼び出す前に <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 、フォーマッタの既定値、 <xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティが適用される任意のオブジェクト以外の場合、 <xref:System.Messaging.Message>です。 または指定した場合、たとえば、ラベルを使用して、優先度、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバー、これらの値はない型のオブジェクトを含むメッセージに適用 <xref:System.Messaging.Message> ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>, 、プロパティ値を設定、 <xref:System.Messaging.Message> よりも優先 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> とメッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=fullName> キューのプロパティが優先されます <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=fullName> プロパティ  
  
 \[Visual Basic\]  
  
 <xref:System.Messaging.MessageQueueTransaction> スレッドのアパートメントに対応する、アパートメント状態の場合これ `STA`, 、複数のスレッドでトランザクションを使用することはできません。 Visual Basic にメイン スレッドの状態を設定する `STA`, を適用する必要がありますので、 <xref:System.MTAThreadAttribute> で、 `Main` サブルーチンです。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 適用する、 <xref:System.MTAThreadAttribute> 次のフラグメントを使用しています。  
  
```  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
```vb  
  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
 または  
  
 メッセージ キュー アプリケーションには、不正なトランザクションの使用率が示されます。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベルです。</param>
        <param name="transactionType">いずれか、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>オブジェクトをこのによって参照されるキューに送信 <see cref="T:System.Messaging.MessageQueue" /> し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 含むメッセージを送信するこのオーバー ロードを使用して、 `obj` パラメーターで参照されるキューを <xref:System.Messaging.MessageQueue>, で定義されたトランザクション コンテキストを使用して、 `transactionType` パラメーター。 指定 `Automatic` の `transactionType` 外部トランザクション コンテキストが既にある場合のパラメーターがメッセージの送信に使用するスレッドにアタッチします。 指定 `Single` 単一の内部トランザクション メッセージを送信する場合。 指定できます `None` トランザクションではないスレッドへトランザクション メッセージを送信する場合。  
  
 キューに送信するオブジェクトを指定できます、 <xref:System.Messaging.Message> または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、 <xref:System.Messaging.Message>, 、オブジェクトをシリアル化され、メッセージの本文に挿入します。 このオーバー ロードでは、メッセージを識別する文字列のラベルを指定できます。  
  
 メッセージ ラベルは、メッセージ キュー ラベルとは異なりますが、両方はアプリケーションに依存してされていないメッセージ キューの意味を継承します。  
  
 設定しない場合、 <xref:System.Messaging.MessageQueue.Formatter%2A> プロパティを呼び出す前に <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 、フォーマッタの既定値、 <xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> プロパティが適用される任意のオブジェクト以外の場合、 <xref:System.Messaging.Message>です。 または指定した場合、たとえば、ラベルを使用して、優先度、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> メンバー、これらの値はない型のオブジェクトを含むメッセージに適用 <xref:System.Messaging.Message> ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>, 、プロパティ値を設定、 <xref:System.Messaging.Message> よりも優先 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, 、およびメッセージの <xref:System.Messaging.Message.Formatter%2A?displayProperty=fullName> キューのプロパティが優先されます <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=fullName> プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">メッセージ キュー アプリケーションには、不正なトランザクションの使用率が示されます。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターは、のいずれかではない、 <see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">A <see cref="T:System.Messaging.AccessControlList" /> トラスティおよび付与するアクセス許可を指定する 1 つまたは複数のアクセス制御エントリを格納しています。</param>
        <summary>アクセス権をアクセス制御リストの内容に基づいてキューに割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 許可、拒否、またはトラスティとアクセス許可の情報を指定するアクセス制御エントリのコレクションを使用して権限を削除するには、このオーバー ロードを使用します。 これは、たとえばなど、使用、同時に複数のユーザーに権限を付与します。  
  
 構築するときに指定したトラスティ、 `ace` パラメーターには、個々 のユーザー、ユーザーのグループまたはコンピューターを指定できます。 トラスティが個人の場合は、形式を使用して `DOMAIN`\\`user`します。 指定できます"です。"トラスティがローカル コンピューターを表します。  
  
 アクセス許可を割り当てる <xref:System.Messaging.MessageQueue.SetPermissions%2A> 権限を既存のリストに追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロールに備え、キューのプロパティを取得し、アクセス許可を取得して、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 、既存の一覧の一番下に、ユーザーとアクセス許可の情報が追加されます。  
  
 システムは、各検証 <xref:System.Messaging.AccessControlEntry> で、次のイベントのいずれかが発生するまでのシーケンス。  
  
-   アクセス拒否 <xref:System.Messaging.AccessControlEntry> 、スレッドのアクセス トークンに列記されているトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可 <xref:System.Messaging.AccessControlEntry> 項目をスレッドのアクセス トークンを明示的に記載のトラスティは、すべての要求のアクセス権を付与します。  
  
-   すべて <xref:System.Messaging.AccessControlEntry> 項目がチェックされた、1 つ以上まだ要求されたアクセス権を明示的が許可されていない、アクセスが暗黙的に拒否される場合は、です。  
  
 構築する場合、 `dacl` パラメーターを追加する <xref:System.Messaging.AccessControlEntry> インスタンスを <xref:System.Messaging.AccessControlList> コレクションです。 各アクセス制御エントリを作成するときは、ジェネリック、または標準のアクセス権を指定できます。 キューの権限は、次の任意の組み合わせになります。  
  
-   削除  
  
-   セキュリティの読み取り  
  
-   セキュリティを書き込み  
  
-   同期  
  
-   所有者を変更します。  
  
-   読み取り  
  
-   Write  
  
-   実行  
  
-   必須  
  
-   すべて  
  
-   なし  
  
 これらの権限は、ビットごとの OR 演算子を使用して組み合わせることができるビット フラグのセットです。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定  
  
-   キューの所有権を取得します。  
  
-   メッセージを作成します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
<!-- TODO: review snippet reference  [!CODE [The following code example demonstrates the use of this method.](The following code example demonstrates the use of this method.)]  -->  
  
 [!code-cpp[MessageQueue2\#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2\#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">A <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> ユーザー、アクセスの種類、およびアクセス許可の種類を指定します。</param>
        <summary>アクセスのアクセス制御エントリの内容に基づき、キューに対する権限を割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 許可、拒否、またはトラスティと権利の情報を指定するアクセス制御エントリを使用して権限を削除するには、このオーバー ロードを使用します。  
  
 構築するときに指定したトラスティ、 `ace` パラメーターには、個々 のユーザー、ユーザーのグループまたはコンピューターを指定できます。 トラスティが個人の場合は、形式を使用して `DOMAIN`\\`user`します。 指定できます"です。"トラスティがローカル コンピューターを表します。  
  
 アクセス許可を割り当てる <xref:System.Messaging.MessageQueue.SetPermissions%2A> 権限を既存のリストに追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロールに備え、キューのプロパティを取得し、アクセス許可を取得して、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 、既存の一覧の一番下に、ユーザーとアクセス許可の情報が追加されます。  
  
 システムは、各検証 <xref:System.Messaging.AccessControlEntry> で、次のイベントのいずれかが発生するまでのシーケンス。  
  
-   アクセス拒否 <xref:System.Messaging.AccessControlEntry> 、スレッドのアクセス トークンに列記されているトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可 <xref:System.Messaging.AccessControlEntry> 項目をスレッドのアクセス トークンを明示的に記載のトラスティは、すべての要求のアクセス権を付与します。  
  
-   すべて <xref:System.Messaging.AccessControlEntry> 項目がチェックされた、1 つ以上まだ要求されたアクセス権を明示的が許可されていない、アクセスが暗黙的に拒否される場合は、です。  
  
 指定するキューへの権限、 `rights` パラメーターを作成するとき、 <xref:System.Messaging.MessageQueueAccessControlEntry>, 、次の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定  
  
-   キューの所有権を取得します。  
  
-   メッセージを作成します。  
  
 `rights` のコンス トラクターで指定したパラメーター、 `ace` パラメーターは、のフラグ、 <xref:System.Messaging.MessageQueueAccessRights> 列挙します。 ビットごとの演算子を使用して組み合わせることができるビット フラグのセットを表す構築するときに、 `rights` パラメーター。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2\#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">個人、グループ、またはがキューに追加の権利を取得します。</param>
        <param name="rights">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> メッセージ キューのキューに権限のセットを示す、 <c>user</c> に渡されます。</param>
        <summary>コンピューター、グループ、またはユーザー指定のアクセス権を与えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用すると、個々 のユーザーに指定された権限を付与できます。 ユーザーは、個々 のユーザー、ユーザー、グループまたはコンピューターを含む任意の有効なトラスティを指定できます。 ユーザーが個人の場合は、形式を使用して `DOMAIN`\\`user` の `user` パラメーター。 指定できます"です。"用、 `user` 、ローカル コンピューターを表すためのパラメーターです。  
  
 アクセス許可を割り当てる <xref:System.Messaging.MessageQueue.SetPermissions%2A> 権限を既存のリストに追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロールに備え、キューのプロパティを取得し、アクセス許可を取得して、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 、既存の一覧の一番下に、ユーザーとアクセス許可の情報が追加されます。  
  
 システムは、各検証 <xref:System.Messaging.AccessControlEntry> で、次のイベントのいずれかが発生するまでのシーケンス。  
  
-   アクセス拒否 <xref:System.Messaging.AccessControlEntry> 、スレッドのアクセス トークンに列記されているトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可 <xref:System.Messaging.AccessControlEntry> 項目をスレッドのアクセス トークンを明示的に記載のトラスティは、すべての要求のアクセス権を付与します。  
  
-   すべて <xref:System.Messaging.AccessControlEntry> 項目がチェックされた、1 つ以上まだ要求されたアクセス権を明示的が許可されていない、アクセスが暗黙的に拒否される場合は、です。  
  
 指定された、キューの権限、 `rights` パラメーターは、次の任意の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定  
  
-   キューの所有権を取得します。  
  
-   メッセージを作成します。  
  
 <xref:System.Messaging.MessageQueueAccessRights> 列挙型を表しますビットごとの演算子を使用して組み合わせることができるビット フラグのセットを構築する、 `rights` パラメーター。  
  
 このオーバー ロードでのみ権限を付与します。失効または拒否することはできません。 別のオーバー ロードを使用すると、いずれかを明示的に付与する必要があります <xref:System.Messaging.AccessControlEntryType> 以外の `Allow`です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2\#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="user" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">個人、グループ、またはがキューに追加の権利を取得します。</param>
        <param name="rights">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> メッセージ キューのキューに権限のセットを示す、 <c>user</c> に渡されます。</param>
        <param name="entryType">A <see cref="T:System.Messaging.AccessControlEntryType" /> を許可、拒否、またはで指定された権限を取り消すかどうかを指定する、 <c>rights</c> パラメーター。</param>
        <summary>コンピューター、グループ、またはユーザー指定のアクセス権は指定されたアクセス制御の種類と、\(許可、拒否、取り消し、またはセット\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 許可、拒否、または個々 のユーザーに対して指定した権限を削除するには、このオーバー ロードを使用します。 ユーザーは、個々 のユーザー、ユーザー、グループまたはコンピューターを含む任意の有効なトラスティを指定できます。 ユーザーが個人の場合は、形式を使用して `DOMAIN`\\`user` の `user` パラメーター。 指定できます"です。"用、 `user` 、ローカル コンピューターを表すためのパラメーターです。  
  
 アクセス許可を割り当てる <xref:System.Messaging.MessageQueue.SetPermissions%2A> 権限を既存のリストに追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロールに備え、キューのプロパティを取得し、アクセス許可を取得して、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 、既存の一覧の一番下に、ユーザーとアクセス許可の情報が追加されます。  
  
 システムは、各検証 <xref:System.Messaging.AccessControlEntry> で、次のイベントのいずれかが発生するまでのシーケンス。  
  
-   アクセス拒否 <xref:System.Messaging.AccessControlEntry> 、スレッドのアクセス トークンに列記されているトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可 <xref:System.Messaging.AccessControlEntry> 項目をスレッドのアクセス トークンを明示的に記載のトラスティは、すべての要求のアクセス権を付与します。  
  
-   すべて <xref:System.Messaging.AccessControlEntry> 項目がチェックされた、1 つ以上まだ要求されたアクセス権を明示的が許可されていない、アクセスが暗黙的に拒否される場合は、です。  
  
 指定された、キューの権限、 `rights` パラメーターは、次の任意の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定  
  
-   キューの所有権を取得します。  
  
-   メッセージを作成します。  
  
 <xref:System.Messaging.MessageQueueAccessRights> 列挙型を表しますビットごとの演算子を使用して組み合わせることができるビット フラグのセットを構築する、 `rights` パラメーター。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2\#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2\#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトから生じるイベント ハンドラー呼び出しをマーシャ リングを取得または設定、 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> または <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> イベントです。</summary>
        <value>A <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, から生じるイベント ハンドラー呼び出しをマーシャ リング オブジェクトを表す、 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> または <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> イベントです。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Messaging.MessageQueue.ReceiveCompleted> または <xref:System.Messaging.MessageQueue.PeekCompleted> イベントに起因する <xref:System.Messaging.MessageQueue.BeginReceive%2A> または <xref:System.Messaging.MessageQueue.BeginPeek%2A> 要求、それぞれ、特定のスレッドにします。 通常、 <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> これらのコンポーネントは、特定のスレッドにバインドされるため、コントロールまたはフォームの内部の関連するコンポーネントを配置した場合に設定します。  
  
 通常、同期オブジェクトでは、メソッドの呼び出しが 1 つのスレッドにマーシャ リングします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューがトランザクションのみを受け入れるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> キューがトランザクションの一部として送信されたメッセージだけを受け入れる場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 トランザクション メッセージングは単一のトランザクションに関連するメッセージがいくつかの結合を表します。 メッセージを送信するように、トランザクションの一部では、順番にメッセージが配信されることにより、1 回だけ配信し、送信先キューから正常に取得します。  
  
 キューがトランザクションの場合は、トランザクションの一部として送信されるメッセージのみを受け入れます。 非トランザクション メッセージを送信または明示的にトランザクションを使用せずにローカル トランザクション キューから受信した、 <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, 、<xref:System.Messaging.MessageQueueTransaction.Commit%2A>, 、および <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 構文です。 トランザクション キューに非トランザクション メッセージを送信すると場合、このコンポーネント トランザクションを作成単一メッセージ、以外を直接形式名を使用してリモート コンピューター上のキューを参照している場合。 このような状況でメッセージを送信するときに、トランザクション コンテキストを指定しないの 1 つは作成されませんし、メッセージは配信不能キューに送信されます。  
  
 トランザクション キューに非トランザクション メッセージを送信する場合、例外が発生した場合、メッセージをロールバックすることはできません。  
  
 \[Visual Basic\]  
  
 <xref:System.Messaging.MessageQueueTransaction> スレッドのアパートメントに対応する、アパートメント状態の場合これ `STA`, 、複数のスレッドでトランザクションを使用することはできません。 Visual Basic にメイン スレッドの状態を設定する `STA`, を適用する必要がありますので、 <xref:System.MTAThreadAttribute> で、 `Main` サブルーチンです。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 適用する、 <xref:System.MTAThreadAttribute> 次のフラグメントを使用しています。  
  
```  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
```vb  
  
```  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例には、メッセージ キューの値が表示されます。 <xref:System.Messaging.MessageQueue.Transactional%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または受信したメッセージをジャーナル キューにコピーするかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> キューから受信したメッセージのジャーナル キューにコピーする場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メッセージ キュー アプリケーションは、新しいアプリケーションのキューを作成するときに自動的に、同じ場所に関連付けられたジャーナル キューを作成します。 ジャーナル キューは、キューから削除されたメッセージを追跡するために使用されます。 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の <xref:System.Messaging.MessageQueue> インスタンスは、変更によって影響をします。  
  
 ジャーナル キューには、その時間に\-受信タイマーが期限切れ、同期も \(インフォメーション ストアまたは Active Directory\) にメッセージ キュー ディレクトリ サービスを使用して、キューから削除されたメッセージは追跡ため、キューから削除されたメッセージは追跡されません。  
  
 アプリケーションがメッセージをジャーナル キューに送信できません。これらのキューの読み取り専用のアクセスに限定されます。 さらに、メッセージ キュー メッセージを削除しませんジャーナル キューからです。 それを受信するか、キューを削除して、キューを使用してアプリケーションをこれらのメッセージをオフにする必要があります。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## 例  
 次のコード例を取得し、メッセージ キューの値を設定 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> プロパティです。  
  
 [!code-csharp[MessageQueue\#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューにメッセージを送信するために使用するネイティブのハンドルを取得します。</summary>
        <value>キューにメッセージを送信するために使用するネイティブのキュー オブジェクトへのハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A> キューにメッセージを送信するために使用されるメッセージ キュー オブジェクトへのネイティブの Windows ハンドルを提供します。 キューのパスを変更する場合は、ハンドルが閉じられ、新しい値で再度開くされます。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|-----------------|----------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターを直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューでは、書き込みのため使用できません。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>識別子を持つ、指定したメッセージをキューからメッセージを削除しないでメッセージのコピーを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ネットワーク上のパブリック キューの動的な一覧については、列挙子オブジェクトを作成します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>オブジェクトをキューに送信します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 特定のメッセージをキューから受信します。 メッセージは、参照識別子で指定することもあれば、前面またはキューの末尾に位置によって指定されることができます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <summary>キューからメッセージを削除しないで、キュー内の最初のメッセージのコピーを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <summary>非同期の受信操作で、メッセージの受信を開始し、完了したときに、イベント ハンドラーを通知するメッセージがキューに指示します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <summary>メッセージのピークを開始し、完了したときに、イベント ハンドラーを通知するメッセージがキューに指示を非同期的ピーク操作を開始します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された相関識別子と一致するメッセージを受信します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドは、スレッド セーフではありません。</threadsafe>
        <summary>キューでは、キューから削除するには、最初のメッセージを受信します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メッセージ キュー サーバーで指定されたパスには、新しいキューを作成します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のセットにアクセス許可を追加します。 キューのキューのプロパティとメッセージへのアクセス権を持つユーザーを制御します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 特定のキューからメッセージをピークします。 メッセージは、参照識別子で指定することもあれば、前面またはキューの末尾に位置によって指定されることができます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された相関識別子と一致するメッセージをピークします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>キューから削除する特定の識別子に一致するメッセージを受信します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>