<Type Name="WebRequestHandler" FullName="System.Net.Http.WebRequestHandler">
  <TypeSignature Language="C#" Value="public class WebRequestHandler : System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebRequestHandler extends System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.WebRequestHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpClientHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Windows ストア アプリまたはその他の環境を利用できないデスクトップ固有の機能を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 このクラスでは、トランスポート ハンドラーを使用して、 <xref:System.Net.HttpWebRequest> インスタンスのサーバーに HTTP 要求を送信します。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebRequestHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.WebRequestHandler.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Net.Http.WebRequestHandler" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowPipelining">
      <MemberSignature Language="C#" Value="public bool AllowPipelining { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPipelining" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インターネット リソースへの要求をパイプライン処理するかどうかを示す値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Boolean" /> を返します。  
  
 要求をパイプライン処理する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーションを使用して、 <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> プロパティがパイプライン接続に対する設定を示します。<xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> は `true`, 、アプリケーションがそれらをサポートするサーバーへのパイプラインの接続を作成します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.AuthenticationLevel AuthenticationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.AuthenticationLevel AuthenticationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.AuthenticationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または認証し、この要求に対して使用する偽装のレベルを示す値を設定します。</summary>
        <value>
          <see cref="T:System.Net.Security.AuthenticationLevel" /> を返します。  
  
 <see cref="T:System.Net.Security.AuthenticationLevel" /> 値のビットごとの組み合わせ。  既定値は <see cref="F:System.Net.Security.AuthenticationLevel.MutualAuthRequested" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 相互認証では、クライアントとサーバーの両方が、それらの身元を証明する資格情報を提供します。<xref:System.Net.Security.AuthenticationLevel.MutualAuthRequired> と <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequested> は、Kerberos 認証に関連する値です。 Kerberos 認証は、直接サポートすることも、Negotiate セキュリティ プロトコルを使用して実際のセキュリティ プロトコルを選択する場合に使用することもできます。 認証プロトコルの詳細については、「[Internet Authentication](http://msdn.microsoft.com/ja-jp/d342e87c-f672-4660-a513-41a2f2b80c4a)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CachePolicy">
      <MemberSignature Language="C#" Value="public System.Net.Cache.RequestCachePolicy CachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Cache.RequestCachePolicy CachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要求のキャッシュ ポリシーを取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Cache.RequestCachePolicy" /> を返します。  
  
 キャッシュ ポリシーを定義する <see cref="T:System.Net.Cache.RequestCachePolicy" /> オブジェクト。 既定値は、<see cref="P:System.Net.WebRequest.DefaultCachePolicy" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The current cache policy and the presence of the requested resource in the cache determine whether a response can be retrieved from the cache. Using cached responses usually improves application performance, but there is a risk that the response in the cache does not match the response on the server.  
  
 The default cache policy can be specified in the Machine.config configuration file or by setting the <xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A> property.  
  
 A copy of a resource is only added to the cache if the response stream for the resource is retrieved and read to the end of the stream. So another request for the same resource could use a cached copy, depending on the cache policy level for this request.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要求に関連付けられているセキュリティ証明書のコレクションを取得または設定します。</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> を返します。  
  
 この要求に関連付けられているセキュリティ証明書のコレクションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定 100 のアプリケーションが待機時間をミリ秒単位でのデータをアップロードする前に、サーバーから継続します。</summary>
        <value>
          <see cref="T:System.TimeSpan" /> を返します。  
  
 時間をミリ秒単位で、アプリケーションが待機する 100 のデータをアップロードする前に、サーバーから続行します。 既定値は、350 ミリ秒です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求に対する偽装レベルを取得または設定します。</summary>
        <value>
          <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> を返します。  
  
 要求に対する偽装レベル。 既定値は、<see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 偽装レベルは、サーバーがクライアントの資格情報を使用する方法を決定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>応答ヘッダーの許容最大長を取得または設定します。</summary>
        <value>
          <see cref="T:System.Int32" /> を返します。  
  
 応答ヘッダーの長さ \(KB 単位、1 KB \= 1024 バイト\)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 応答ヘッダーの長さには、応答のステータス行と HTTP プロトコルの一部として受信したすべての余分な制御文字が含まれています。 値の\-1 の場合は、応答ヘッダーの制限は適用されません。値 0 は、すべての要求が失敗することを意味します。  
  
 場合、 <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> プロパティが明示的に設定されていないの値に既定値、 <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> プロパティです。  
  
 受信した応答ヘッダーの長さの値を超えるかどうか、 <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> プロパティには、応答にアクセスする場合、例外がスローされます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはへの要求を作成またはサーバーからの応答を読み取るときに、タイムアウトをミリ秒単位で設定します。</summary>
        <value>
          <see cref="T:System.Int32" /> を返します。  
  
 書き込みまたは読み取りがタイムアウトするまでのミリ秒単位の時間。 既定値は、300,000 ミリ秒 \(5 分\) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはサーバー証明書を検証するコールバック メソッドを設定します。</summary>
        <value>
          <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> を返します。  
  
 サーバー証明書を検証するコールバック メソッド。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback%2A> は `null`, 、標準のよく知られた証明機関を使用してサーバー証明書が検証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>高速 NTLM 認証された接続共有を許可するかどうかを示す値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Boolean" /> を返します。  
  
 認証された接続を確立し続ける場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの既定値は `false`, 、それが原因で現在の接続が、要求が完了した後に閉じられます。 新しい要求を発行するたびに、アプリケーションは認証シーケンスを処理しなければです。このプロパティ設定されている場合 `true`, 、認証を行った後、応答を取得するための接続が開いたままです。 このプロパティを設定があることを要求他の場合、 `true` 再認証を行わず、接続を使用することがあります。 つまり、ユーザー A の接続が認証された場合ユーザー B 再利用ことは A の接続。ユーザー A の資格情報に基づいてユーザー B の要求が満たされる  
  
> [!CAUTION]
>  ない管理の脆弱性、システムでこのプロパティに設定する場合に必要があります、認証を受けていない接続を使用するアプリケーションなので `true`します。 アプリケーションが複数のユーザーの要求を送信する場合 \(複数のユーザー アカウントを偽装\) し、依存するリソースを保護する認証にこのプロパティを設定 `true` 以下に示すように、接続グループを使用する場合を除き、します。  
  
 場合に、このメカニズムを有効にすることを検討することも、パフォーマンスの問題が発生し、アプリケーションが統合 Windows 認証を使って Web サーバーで実行します。  
  
 この設定を有効にすると、セキュリティ リスクに対するシステムが開きます。 設定した場合、 <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> プロパティを `true` は次の予防措置を講じてください。  
  
-   だれも接続を避けるため、保護された環境でアプリケーションを実行します。  
  
 バック エンド サーバーを制御する場合別の方法としてお勧め認証の永続化をオフにします。 これほど、パフォーマンスが向上しますが、方が安全です。 詳細については、検索、MSDN ライブラリの「で AuthPersistence [http:\/\/msdn.microsoft.com\/library](http://msdn.microsoft.com/library)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>