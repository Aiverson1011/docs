<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>コード アクセス許可すべての基になる構造を定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission. If a permission object is **languageKeyword tag is not supported!!!!**  
, it is handled the same as a permission object with the state <xref:System.Security.Permissions.PermissionState.None?displayProperty=fullName>.  
  
 The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.  
  
 Inheritors of the <xref:System.Security.CodeAccessPermission> class must be granted full trust to function correctly as permissions extending the security infrastructure. To determine that the inheritors are fully trusted, <xref:System.Security.CodeAccessPermission> issues an <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> for <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence> \= **languageKeyword tag is not supported!!!!**  
 and <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy> \= **languageKeyword tag is not supported!!!!**  
.  
  
   
  
## 例  
 The following code example shows a permission derived from the <xref:System.Security.CodeAccessPermission> class.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">for the ability of inheritors to provide evidence and view and modify policy. Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</permission>
    <block subset="none" type="overrides">
      <para>When you inherit from <see cref="T:System.Security.CodeAccessPermission" />, you must also implement the <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interface.  
  
 The following <see cref="T:System.Security.CodeAccessPermission" /> members must be overridden: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, and <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.  
  
 You must also define a constructor that takes a <see cref="T:System.Security.Permissions.PermissionState" /> as its only parameter.  
  
 You must apply the <see cref="T:System.SerializableAttribute" /> attribute to a class that inherits from <see cref="T:System.Security.CodeAccessPermission" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Security.CodeAccessPermission" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは派生クラスのインスタンスが作成されるたびに、型の状態を初期化するために呼び出されます。 派生クラスのコンス トラクターのコンス トラクターの宣言でこのコンス トラクターを明示的に呼び出すことのできるがこれは通常不要です。ほとんどのコンパイラでは、呼び出しを自動的に生成されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出し側コードが、このメソッドを呼び出すコードを通じて、アクセス許可要求によって保護されているリソースにアクセス可能であるということ、それも、スタックの中で上位に位置する呼び出し側にリソースへのアクセス許可が付与されていない場合でさえそれが可能であることを宣言します。<see cref="M:System.Security.CodeAccessPermission.Assert" /> を使用すると、セキュリティ上の問題が発生することがあります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 通常、呼び出し履歴は、コール スタックのコール スタックの上位にあるメソッドが下にあるメソッドを呼び出すように、拡張として表されます。 呼び出す <xref:System.Security.CodeAccessPermission.Assert%2A> 低い発信元このメソッドを呼び出すコードを越えて呼び出し履歴を先に進むからのコール スタックがスタック ウォークを防止します。 そのため、呼び出しスタックの上位の呼び出し元は、リソースへのアクセスに必要なアクセス許可を持っていない場合でも、引き続きアクセスできますが必要なアクセス許可に対してこのメソッドを呼び出すコードを。 アサーションは、コードを呼び出す場合にのみ <xref:System.Security.CodeAccessPermission.Assert%2A> をアサートしている、アクセス許可のセキュリティ チェックに合格します。  
  
 呼び出し <xref:System.Security.CodeAccessPermission.Assert%2A> は呼び出し元のコードがその呼び出し元に戻るまで有効にします。 1 つだけ <xref:System.Security.CodeAccessPermission.Assert%2A> フレームをアクティブにすることができます。 呼び出そうとすると <xref:System.Security.CodeAccessPermission.Assert%2A> ときに、アクティブな <xref:System.Security.CodeAccessPermission.Assert%2A> フレーム結果内に存在する、 <xref:System.Security.SecurityException>です。 呼び出す <xref:System.Security.CodeAccessPermission.RevertAssert%2A> または <xref:System.Security.CodeAccessPermission.RevertAll%2A> 、アクティブなを削除する <xref:System.Security.CodeAccessPermission.Assert%2A>です。  
  
 <xref:System.Security.CodeAccessPermission.Assert%2A> アクセス許可をその要求は成功しませんのでは与えないでアクセス許可は無視されます。 ただし、コール スタックの下部のコードから呼び出す場合 <xref:System.Security.CodeAccessPermission.Demand%2A> そのアクセス許可、 <xref:System.Security.SecurityException> スタック ウォークが呼び出しを試行していたコードに達した場合にスローされる <xref:System.Security.CodeAccessPermission.Assert%2A>します。 これは、コードを呼び出すため <xref:System.Security.CodeAccessPermission.Assert%2A> が与えられていない、アクセス許可、しようとした場合でも <xref:System.Security.CodeAccessPermission.Assert%2A> ことです。  
  
> [!CAUTION]
>  呼び出すため <xref:System.Security.CodeAccessPermission.Assert%2A> 削除呼び出しチェーンにコードのすべての要件は、指定されたリソースにアクセスする権限を付与する必要がある、誤ってまたは不適切な使用されている場合はセキュリティ上の問題を開くことができます。 したがって、注意して使用する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元のコードに <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /> がありません。  
  
 \-または\-  
  
 現在のフレームにはアクティブな <see cref="M:System.Security.CodeAccessPermission.Assert" /> がすでに存在しています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to call <see cref="M:System.Security.CodeAccessPermission.Assert" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></permission>
        <block subset="none" type="overrides">
          <para>You cannot override this method.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスにより実装されると、現在のアクセス許可オブジェクトの同一のコピーを作成して返します。</summary>
        <returns>現在のアクセス許可オブジェクトのコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A copy of a permission object represents the same access to resources as the original permission object.  
  
   
  
## 例  
 The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Copy%2A> method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You must override this method in a derived class.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出し履歴の上位にあるすべての呼び出し元に、現在のインスタンスによって指定されているアクセス許可が付与されていない場合、実行時に <see cref="T:System.Security.SecurityException" /> を強制します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is typically used by secure libraries to ensure that callers have permission to access a resource. For example, a file class in a secure class library calls <xref:System.Security.CodeAccessPermission.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.  
  
 The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack. <xref:System.Security.CodeAccessPermission.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、現在のインスタンスで指定されたアクセス許可がありません。  
  
 または  
  
 呼び出し履歴の上位にある呼び出し元は、現在のアクセス許可オブジェクトで <see cref="M:System.Security.CodeAccessPermission.Deny" /> を呼び出しました。</exception>
        <block subset="none" type="overrides">
          <para>You cannot override this method.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出し履歴内の上位の呼び出し元が、このメソッドを呼び出すコードを使用して、現在のインスタンスで指定されたリソースにアクセスしないようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  The <xref:System.Security.CodeAccessPermission.Deny%2A> method should be used only to protect resources from accidental access by fully trusted code. It should not be used to protect resources from intentional misuse by untrusted code. For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.Deny%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.Deny%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>. The called method is always higher in the stack. Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack. Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method. In that case, the <xref:System.Security.CodeAccessPermission.Deny%2A> placed on the stack by method `A` \(the calling method\) is never discovered.  
  
 This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.  
  
 <xref:System.Security.CodeAccessPermission.Deny%2A> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <xref:System.Security.CodeAccessPermission.Deny%2A> from being used to access the resource protected by the denied permission. If a method calls <xref:System.Security.CodeAccessPermission.Deny%2A> on a permission, and if a <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.CodeAccessPermission.Deny%2A>.  
  
 The call to <xref:System.Security.CodeAccessPermission.Deny%2A> is effective until the calling code returns to its caller. Only one <xref:System.Security.CodeAccessPermission.Deny%2A> can be active on a frame. An attempt to call <xref:System.Security.CodeAccessPermission.Deny%2A> when an active <xref:System.Security.CodeAccessPermission.Deny%2A> exists on the frame results in a <xref:System.Security.SecurityException>. Call <xref:System.Security.CodeAccessPermission.RevertDeny%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Deny%2A>. <xref:System.Security.CodeAccessPermission.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">現在のフレームにはアクティブな <see cref="M:System.Security.CodeAccessPermission.Deny" /> が既に存在しています。</exception>
        <block subset="none" type="overrides">
          <para>You cannot override this method.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">現在の <see cref="T:System.Security.CodeAccessPermission" /> と比較する <see cref="T:System.Security.CodeAccessPermission" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Security.CodeAccessPermission" /> オブジェクトが、現在の <see cref="T:System.Security.CodeAccessPermission" /> と等しいかどうかを判断します。</summary>
        <returns>指定した <see cref="T:System.Security.CodeAccessPermission" /> オブジェクトが現在の <see cref="T:System.Security.CodeAccessPermission" /> と等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 For more information, see <xref:System.Object.Equals%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem">セキュリティ オブジェクトの再構築に使用する XML エンコード。</param>
        <summary>派生クラスでオーバーライドされると、XML エンコードから指定された状態で、セキュリティ オブジェクトを再構築します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 実装する必要があるセキュリティ オブジェクトを拡張するカスタム コード、 <xref:System.Security.CodeAccessPermission.ToXml%2A> と <xref:System.Security.CodeAccessPermission.FromXml%2A> セキュリティ encodable オブジェクトを作成する方法です。  
  
   
  
## 例  
 次のコード例のオーバーライドを示しています、 <xref:System.Security.CodeAccessPermission.FromXml%2A> メソッドです。 このコード例が示されている例の一部は、 <xref:System.Security.CodeAccessPermission> クラスです。  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission\#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elem" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elem" /> パラメーターには、現在のインスタンスと同じ型のインスタンスの XML エンコードが含まれていません。  
  
 または  
  
 <paramref name="elem" /> パラメーターのバージョン番号は、サポートされていません。</exception>
        <block subset="none" type="overrides">
          <para>You must override this method in a derived class.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ハッシュ アルゴリズムや、ハッシュ テーブルのようなデータ構造での使用に適している、<see cref="T:System.Security.CodeAccessPermission" /> オブジェクトのハッシュ コードを取得します。</summary>
        <returns>現在の <see cref="T:System.Security.CodeAccessPermission" /> オブジェクトのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 同じアクセス許可の 2 つのインスタンスのハッシュ コードが異なる場合があります、したがってハッシュ コード 2 つの比較に使用されていない <xref:System.Security.CodeAccessPermission> オブジェクトです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">現在のアクセス許可との共通部分のあるアクセス許可。 これは、現在のアクセス許可と同じ型であることが必要です。</param>
        <summary>派生クラスで実装される場合、現在のアクセス許可と指定したアクセス許可の積集合であるアクセス許可を作成して返します。</summary>
        <returns>現在のアクセス許可と指定したアクセス許可の共通部分を表す新しいアクセス許可。 積集合が空の場合、この新しいアクセス許可は <see langword="null" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 2 つのアクセス許可の積集合は、両方に共通する操作のセットを表すアクセス許可です。 両方の元のアクセス許可に適合する要求だけでは、交差する位置を渡します。  
  
   
  
## 例  
 次のコード例のオーバーライドを示しています、 <xref:System.Security.CodeAccessPermission.Intersect%2A> メソッドです。 このコード例が示されている例の一部は、 <xref:System.Security.CodeAccessPermission> クラスです。  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> パラメーターは <see langword="null" /> ではなく、現在のアクセス許可と同じクラスのインスタンスでもありません。</exception>
        <block subset="none" type="overrides">
          <para>You must override this method in a derived class.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">サブセット リレーションシップをテストするアクセス許可。 このアクセス許可は、現在のアクセス許可と同じ型であることが必要です。</param>
        <summary>派生クラスによって実装された場合は、現在のアクセス許可が、指定したアクセス許可のサブセットであるかどうかを判断します。</summary>
        <returns>現在のアクセス許可が、指定したアクセス許可のサブセットである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在のアクセス許可は、現在のアクセス許可を指定した権限によって完全に含まれる一連の操作を指定する場合、指定した権限のサブセットです。 たとえば、C:\\example.txt へのアクセスを表すアクセス許可は、C:\\ のアクセスを表すためのアクセス許可のサブセットです。 このメソッドが戻る場合 `true`, 、現在のアクセス許可がない以上へのアクセスが保護されたリソースは、指定した権限を表します。  
  
 次のステートメントを含める必要は `true` のすべての上書き値、 <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> メソッドです。*X*, 、*Y*, 、および *Z* null 参照ではないカスタム コードのアクセス許可オブジェクトを表す *U* 、無制限のコード アクセス許可を表すと *N* で空のアクセス許可を表す、 <xref:System.Security.Permissions.PermissionState> の <xref:System.Security.Permissions.PermissionState.None>です。  
  
-   *X*.IsSubsetOf \(*X*\) を返します `true`します。  
  
-   *X*.IsSubsetOf \(*Y*\) と同じ値を返します *Y*します。IsSubsetOf \(*X*\) 場合にだけ、 *X* と *Y* 権限のセットは変わりません。  
  
-   If *X*.IsSubsetOf \(*Y*\) と *Y*します。IsSubsetOf \(*Z*\) 返す `true`, 、*X*します。IsSubsetOf \(*Z*\) を返します `true`します。  
  
-   *X*.IsSubsetOf \(*U*\) を返します `true`します。  
  
-   *X*.IsSubsetOf \(*N*\) を返します `false`します。  
  
-   *N*.IsSubsetOf \(*X*\) を返します `true`します。  
  
 場合 *X* と *Y* が null 参照は、カスタム コード アクセス許可オブジェクトを表す *X*します。IsSubsetOf \(*Y*\) を返します `true`します。 場合 *Z* が null の場合も、複合設定操作 *X*します。共用体 \(*Y*\)。IsSubsetOf \(*Z*\) も返します `true` null の 2 つの権限の和集合が null のアクセス許可であるためです。  
  
   
  
## 例  
 次のコード例のオーバーライドを示しています、 <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> メソッドです。 このコード例が示されている例の一部は、 <xref:System.Security.CodeAccessPermission> クラスです。  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> パラメーターが <see langword="null" /> でなく、また現在のアクセス許可と同じ型でもありません。</exception>
        <block subset="none" type="overrides">
          <para>You must override this method in a derived class.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出し履歴内の上位の呼び出し元が、このメソッドを呼び出すコードでは一切リソースにアクセスできないようにします。ただし、現在のインスタンスで指定されているリソースは例外です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  <xref:System.Security.CodeAccessPermission.PermitOnly%2A> メソッドは、完全に信頼されたコードによって偶発的なアクセスからリソースを保護する場合にのみ使用する必要があります。 指定しないで意図的な誤用からリソースを保護する信頼されていないコードでします。 たとえば場合、メソッド `A` の問題、 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> アクセス許可と、メソッドを呼び出して `B`, 、メソッド `B` 獲得をオーバーライドできます、 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> を発行して、 <xref:System.Security.CodeAccessPermission.Assert%2A>です。 呼び出されたメソッドは、スタック内の上位は常にします。 そのため場合、メソッド `B` セキュリティ システムの保護されたリソースへのアクセスを試みますがためこれを使用した権限のチェックを開始メソッド `B` 直前の呼び出し元からウォークがあることを確認するスタックを下へない <xref:System.Security.CodeAccessPermission.Deny%2A> または <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 、スタック内の下位です。 メソッド `B`, 、リソースにアクセスしようとするが直ちに停止できるスタック ウォークを使用して、 <xref:System.Security.CodeAccessPermission.Assert%2A> メソッドです。 その場合は、 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> メソッドによって、スタックに配置 `A` \(呼び出し元のメソッド\) が検出されることはありません。  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> ような <xref:System.Security.CodeAccessPermission.Deny%2A>, 両方が発生するスタック ウォークをそれ以外の場合操作が成功したときに失敗することで、します。 その違いは <xref:System.Security.CodeAccessPermission.Deny%2A> が失敗し、スタック ウォークを原因となるアクセス許可を指定が、 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> が失敗するスタック ウォークが発生しない唯一のアクセス許可を指定します。  
  
 指定されたリソースのみにアクセスするコードを使用できることを確認するには、このメソッドを呼び出します。 呼び出し <xref:System.Security.CodeAccessPermission.PermitOnly%2A> は呼び出し元のコードがその呼び出し元に戻るまで有効にします。 1 つだけ <xref:System.Security.CodeAccessPermission.PermitOnly%2A> フレームをアクティブにすることができます。 呼び出そうとすると <xref:System.Security.CodeAccessPermission.PermitOnly%2A> ときに、アクティブな <xref:System.Security.CodeAccessPermission.PermitOnly%2A> フレーム結果内に存在する、 <xref:System.Security.SecurityException>です。 呼び出す <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> または <xref:System.Security.CodeAccessPermission.RevertAll%2A> 、アクティブなを削除する <xref:System.Security.CodeAccessPermission.PermitOnly%2A>です。  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> アクセス許可をその要求は成功しませんのでは与えないでアクセス許可は無視されます。 ただし場合は、コードのコール スタックを後で呼び出し <xref:System.Security.CodeAccessPermission.Demand%2A> そのアクセス許可、 <xref:System.Security.SecurityException> スタック ウォークが呼び出しを試行していたコードに達した場合にスローされる <xref:System.Security.CodeAccessPermission.PermitOnly%2A>します。 これは、コードを呼び出すため <xref:System.Security.CodeAccessPermission.PermitOnly%2A> が与えられていない、アクセス許可、これと呼ばれる場合でも <xref:System.Security.CodeAccessPermission.PermitOnly%2A> そのアクセス許可。 通常、呼び出し履歴は、コール スタックのコール スタックの上位にあるメソッドが下にあるメソッドを呼び出すように、拡張として表されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">現在のフレームにはアクティブな <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> が既に存在しています。</exception>
        <block subset="none" type="overrides">
          <para>You cannot override this method.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のフレームの以前の上書きすべてが削除され、有効ではなくなります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 上書きがない場合 \(<xref:System.Security.CodeAccessPermission.Assert%2A>, 、<xref:System.Security.CodeAccessPermission.Deny%2A>, 、または <xref:System.Security.CodeAccessPermission.PermitOnly%2A>\) 現在のフレーム、 <xref:System.ExecutionEngineException> がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在のフレームには以前の <see cref="M:System.Security.CodeAccessPermission.Assert" />、<see cref="M:System.Security.CodeAccessPermission.Deny" />、または <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> はありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のフレームの以前の <see cref="M:System.Security.CodeAccessPermission.Assert" /> がすべて削除され、使用できなくなります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ある場合ない <xref:System.Security.CodeAccessPermission.Assert%2A> 現在のフレーム、 <xref:System.ExecutionEngineException> がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在のフレームには以前の <see cref="M:System.Security.CodeAccessPermission.Assert" /> はありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のフレームの以前の <see cref="M:System.Security.CodeAccessPermission.Deny" /> がすべて削除され、使用できなくなります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ある場合ない <xref:System.Security.CodeAccessPermission.Deny%2A> 現在のフレーム、 <xref:System.ExecutionEngineException> がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在のフレームの以前の <see cref="M:System.Security.CodeAccessPermission.Deny" /> はありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のフレームの以前の <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> がすべて削除され、有効ではなくなります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ある場合ない <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 現在のフレーム、 <xref:System.ExecutionEngineException> がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在のフレームには以前の <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> はありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のアクセス許可オブジェクトの文字列形式を作成して返します。</summary>
        <returns>現在のアクセス許可オブジェクトの文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、文字列として、アクセス許可を表示する必要がある場合のデバッグに役立ちます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、セキュリティ オブジェクトとその現在の状態の XML エンコーディングを作成します。</summary>
        <returns>状態情報のすべてを含む、セキュリティ オブジェクトの XML エンコーディング。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 実装する必要があるセキュリティ オブジェクトを拡張するカスタム コード、 <xref:System.Security.CodeAccessPermission.ToXml%2A> と <xref:System.Security.CodeAccessPermission.FromXml%2A> セキュリティ encodable オブジェクトを作成する方法です。  
  
   
  
## 例  
 次のコード例のオーバーライドを示しています、 <xref:System.Security.CodeAccessPermission.ToXml%2A> メソッドです。 このコード例が示されている例の一部は、 <xref:System.Security.CodeAccessPermission> クラスです。  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission\#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You must override this method in a derived class.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other">現在のアクセス許可と結合するアクセス許可。 現在のアクセス許可と同じ型である必要があります。</param>
        <summary>派生クラスでオーバーライドされると、現在のアクセス許可と指定されたアクセス許可の和集合であるアクセス許可を作成します。</summary>
        <returns>現在のアクセス許可と指定されたアクセス許可の和集合を表す新しいアクセス許可。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出しの結果 <xref:System.Security.CodeAccessPermission.Union%2A> は現在のアクセス許可と、指定した権限の両方で表されるすべての操作を表す権限。 いずれかのアクセス許可に適合する要求は、その共用体を渡します。  
  
   
  
## 例  
 次のコード例のオーバーライドを示しています、 <xref:System.Security.CodeAccessPermission.Union%2A> メソッドです。 このコード例が示されている例の一部は、 <xref:System.Security.CodeAccessPermission> クラスです。  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission\#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="other" /> パラメーターが <see langword="null" /> ではありません。 このメソッドは、<see langword="null" /> に渡された場合に、このレベルでのみサポートされます。</exception>
        <block subset="none" type="overrides">
          <para>You must override this method in a derived class. You should return a copy of the permission if the value of the <paramref name="other" /> parameter is <see langword="null" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>