<Type Name="DataSet" FullName="System.Data.DataSet">
  <TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>データのメモリ内キャッシュを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Data.DataSet>, which is an in\-memory cache of data retrieved from a data source, is a major component of the ADO.NET architecture. The <xref:System.Data.DataSet> consists of a collection of <xref:System.Data.DataTable> objects that you can relate to each other with <xref:System.Data.DataRelation> objects. You can also enforce data integrity in the <xref:System.Data.DataSet> by using the <xref:System.Data.UniqueConstraint> and <xref:System.Data.ForeignKeyConstraint> objects. For further details about working with <xref:System.Data.DataSet> objects, see [Using DataSets in ADO.NET](http://msdn.microsoft.com/ja-jp/6d4c4b69-8919-4224-8a65-6cca1c61b48f).  
  
 Whereas <xref:System.Data.DataTable> objects contain the data, the <xref:System.Data.DataRelationCollection> allows you to navigate though the table hierarchy. The tables are contained in a <xref:System.Data.DataTableCollection> accessed through the <xref:System.Data.DataSet.Tables%2A> property. When accessing <xref:System.Data.DataTable> objects, note that they are conditionally case sensitive. For example, if one <xref:System.Data.DataTable> is named "mydatatable" and another is named "Mydatatable", a string used to search for one of the tables is regarded as case sensitive. However, if "mydatatable" exists and "Mydatatable" does not, the search string is regarded as case insensitive. For more information about working with <xref:System.Data.DataTable> objects, see [Creating a DataTable](http://msdn.microsoft.com/ja-jp/eecf9d78-60e3-4fdc-8de0-e56c13a89414).  
  
 A <xref:System.Data.DataSet> can read and write data and schema as XML documents. The data and schema can then be transported across HTTP and used by any application, on any platform that is XML\-enabled. You can save the schema as an XML schema with the <xref:System.Data.DataSet.WriteXmlSchema%2A> method, and both schema and data can be saved using the <xref:System.Data.DataSet.WriteXml%2A> method. To read an XML document that includes both schema and data, use the <xref:System.Data.DataSet.ReadXml%2A> method.  
  
 In a typical multiple\-tier implementation, the steps for creating and refreshing a <xref:System.Data.DataSet>, and in turn, updating the original data are to:  
  
1.  Build and fill each <xref:System.Data.DataTable> in a <xref:System.Data.DataSet> with data from a data source using a <xref:System.Data.Common.DataAdapter>.  
  
2.  Change the data in individual <xref:System.Data.DataTable> objects by adding, updating, or deleting <xref:System.Data.DataRow> objects.  
  
3.  Invoke the <xref:System.Data.DataSet.GetChanges%2A> method to create a second <xref:System.Data.DataSet> that features only the changes to the data.  
  
4.  Call the <xref:System.Data.Common.DataAdapter.Update%2A> method of the <xref:System.Data.Common.DataAdapter>, passing the second <xref:System.Data.DataSet> as an argument.  
  
5.  Invoke the <xref:System.Data.DataSet.Merge%2A> method to merge the changes from the second <xref:System.Data.DataSet> into the first.  
  
6.  Invoke the <xref:System.Data.DataSet.AcceptChanges%2A> on the <xref:System.Data.DataSet>. Alternatively, invoke <xref:System.Data.DataSet.RejectChanges%2A> to cancel the changes.  
  
> [!NOTE]
>  The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> objects inherit from <xref:System.ComponentModel.MarshalByValueComponent>, and support the <xref:System.Runtime.Serialization.ISerializable> interface for remoting. These are the only ADO.NET objects that can be remoted.  
  
> [!NOTE]
>  Classes inherited from <xref:System.Data.DataSet> are not finalized by the garbage collector, because the finalizer has been suppressed in <xref:System.Data.DataSet>. The derived class can call the <xref:System.GC.ReRegisterForFinalize%2A> method in its constructor to allow the class to be finalized by the garbage collector.  
  
   
  
## 例  
 The following example consists of several methods that, combined, create and fill a <xref:System.Data.DataSet> from the **legacyBold tag is not supported!!!!**  
 database.  
  
 [!code-csharp[Classic WebData DataSet Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is safe for multithreaded read operations. You must synchronize any write operations.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This implementation of the <xref:System.Data.DataSet> constructor takes no parameters, and creates a default name, "NewDataSet," for the new instance.  
  
 A name for the <xref:System.Data.DataSet> is required to ensure that the XML representation of the <xref:System.Data.DataSet> always has a name for the document element, which is the highest\-level element in a schema definition.  
  
   
  
## 例  
 The following example creates a new <xref:System.Data.DataSet>, and adds two <xref:System.Data.DataTable> objects to it.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">
          <see cref="T:System.Data.DataSet" /> の名前。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Data.DataSet" /> 、指定した名前のクラスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 名前、 <xref:System.Data.DataSet> の XML 表現することを確認するために必要な <xref:System.Data.DataSet> 常にスキーマ定義の最上位レベルの要素は、ドキュメントの要素の名前が指定されています。  
  
   
  
## 例  
 次の例が、新たに作成 <xref:System.Data.DataSet>, 、2 つに <xref:System.Data.DataTable> オブジェクトが追加されます。  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">オブジェクトを逆シリアル化または逆シリアル化に必要なデータです。</param>
        <param name="context">ソースと指定したシリアル化されたストリームの転送先。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Data.DataSet" /> を指定したシリアル化情報とコンテキストを持つクラス。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクト。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> オブジェクト。</param>
        <param name="ConstructSchema">ブール値。</param>
        <summary>
          <see cref="T:System.Data.DataSet" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>これに加えられたすべての変更をコミット <see cref="T:System.Data.DataSet" /> 読み込まれた後、または前回 <see cref="M:System.Data.DataSet.AcceptChanges" /> 呼び出されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 両方の <xref:System.Data.DataRow> と <xref:System.Data.DataTable> クラスが <xref:System.Data.DataSet.AcceptChanges%2A> メソッドです。 呼び出す <xref:System.Data.DataTable.AcceptChanges%2A> で、 <xref:System.Data.DataTable> レベルの原因、 <xref:System.Data.DataRow.AcceptChanges%2A> メソッドごとに <xref:System.Data.DataRow> に呼び出されます。 同様を呼び出す <xref:System.Data.DataSet.AcceptChanges%2A> 上、 <xref:System.Data.DataSet> により <xref:System.Data.DataTable.AcceptChanges%2A> 内の各テーブルに呼び出される、 <xref:System.Data.DataSet>です。 この方法では、複数レベルのメソッドを呼び出すことができますがあります。 呼び出す、 <xref:System.Data.DataSet.AcceptChanges%2A> の <xref:System.Data.DataSet> すると、1 回の呼び出しですべての従属オブジェクト \(テーブルおよび行など\) に対してメソッドを呼び出すことができます。  
  
 呼び出すと `AcceptChanges` 上、 `DataSet`, 、 <xref:System.Data.DataRow> まだ編集モードでのオブジェクトが編集内容を正常に終了します。<xref:System.Data.DataRow.RowState%2A> の各プロパティ <xref:System.Data.DataRow> も変わります。 `Added` と `Modified` になる行 `Unchanged`, 、および `Deleted` 行は削除されます。  
  
 場合、 `DataSet` が含まれています <xref:System.Data.ForeignKeyConstraint> を呼び出すオブジェクト、 `AcceptChanges` メソッドは、また、 <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> 強制されるようにします。  
  
> [!NOTE]
>  `AcceptChanges` `RejectChanges` にのみ適用 `DataRow` 関連の変更 \(つまり、追加、削除、削除、および変更\)。 これらはスキーマまたは構造の変更を適用できません。  
>   
>  AcceptChanges を呼び出すはレプリケートされませんこれらの変更データ ソースに戻る場合は、データ アダプターを使用して、データセットに格納されました。 そのような状況で呼び出す <xref:System.Data.Common.DataAdapter.Update%2A> 代わりにします。 参照してください [Updating Data Sources with DataAdapters](http://msdn.microsoft.com/library/33y2221y.aspx) の詳細。  
  
   
  
## 例  
 次の例では追加、 <xref:System.Data.DataRow> に、 <xref:System.Data.DataTable> で、 <xref:System.Data.DataSet>です。<xref:System.Data.DataSet.AcceptChanges%2A> にメソッドが呼び出され、 <xref:System.Data.DataSet>, 、すべてをどの連鎖 <xref:System.Data.DataTable> それに含まれるオブジェクト。  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用する <see cref="T:System.Data.DataSet" /> の初期化を開始します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Visual Studio .NET のデザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントで使用するコンポーネントの初期化を開始します。<xref:System.Data.DataSet.EndInit%2A> メソッドが初期化を終了します。 使用して、 <xref:System.Data.DataSet.BeginInit%2A> と <xref:System.Data.DataSet.EndInit%2A> メソッドによって、コントロールが完全に初期化される前に使用されないようにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>内で比較を文字列かどうかを示す値を取得または設定 <see cref="T:System.Data.DataTable" /> オブジェクトは、大文字小文字を区別します。</summary>
        <value>
          <see langword="true" /> 場合は文字列の比較では大文字小文字を区別します。それ以外の場合 <see langword="false" />します。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.CaseSensitive%2A> プロパティは、それぞれで並べ替え、検索、およびフィルター処理を実行する方法に影響 <xref:System.Data.DataTable> オブジェクトに含まれている、 <xref:System.Data.DataSet> を使用する場合、 <xref:System.Data.DataTable.Select%2A> メソッドです。  
  
 既定では、設定、 <xref:System.Data.DataSet.CaseSensitive%2A> プロパティを <xref:System.Data.DataSet> 設定も、 <xref:System.Data.DataTable.CaseSensitive%2A> のそれぞれの関連付けられたプロパティ <xref:System.Data.DataTable> 同じ値にします。  
  
   
  
## 例  
 次の例を切り替えます、 <xref:System.Data.DataSet.CaseSensitive%2A> プロパティです。  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>消去、 <see cref="T:System.Data.DataSet" /> のすべてのテーブル内のすべての行を削除することによってデータのです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Data.DataSet> にバインドされて、 <xref:System.Xml.XmlDataDocument>, を呼び出す <xref:System.Data.DataSet.Clear%2A?displayProperty=fullName> または <xref:System.Data.DataTable.Clear%2A?displayProperty=fullName> を発生させる、 <xref:System.NotSupportedException>です。 このような状況を避けるためには、一度に 1 行ずつを削除する各テーブルを走査します。  
  
   
  
## 例  
 次の例では、クリア、 <xref:System.Data.DataSet> のすべてのテーブルのすべての行。  
  
 [!code-csharp[Classic WebData DataSet.Clear Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>構造をコピー、 <see cref="T:System.Data.DataSet" />, 、すべてを含めて <see cref="T:System.Data.DataTable" /> スキーマ、リレーション、および制約。 すべてのデータをコピーしません。</summary>
        <returns>新しい <see cref="T:System.Data.DataSet" /> 現在と同じスキーマを持つ <see cref="T:System.Data.DataSet" />, が、すべてのデータです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  これらのクラスがサブクラス化されている場合、複製は同じサブクラスもできます。  
  
   
  
## 例  
 次の例の複製を作成する、 <xref:System.Data.DataSet> オブジェクトのスキーマです。  
  
 [!code-csharp[Classic WebData DataSet.Clone Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この構造体とデータの両方をコピー <see cref="T:System.Data.DataSet" />します。</summary>
        <returns>新しい <see cref="T:System.Data.DataSet" /> 同じ構造 \(テーブルのスキーマ、リレーション、および制約\) とデータとしてこの <see cref="T:System.Data.DataSet" />します。  
  
 <block subset="none" type="note">  
<para>  
 これらのクラスがサブクラス化されている場合は、コピーが同じサブクラスもできます。  
  
</para>  
</block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、 <xref:System.Data.DataSet.Copy%2A> 、元のコピーを作成するメソッド <xref:System.Data.DataSet>します。  
  
 [!code-csharp[Classic WebData DataSet.Copy Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返します。、 <see cref="T:System.Data.DataTableReader" /> ごとに設定する 1 つの結果と <see cref="T:System.Data.DataTable" />, の内のテーブルと同じシーケンス、 <see cref="P:System.Data.DataSet.Tables" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内で返された結果セットの順序を確認するために <xref:System.Data.DataTableReader>, 場合、 <xref:System.Data.DataTable> 内で、 <xref:System.Data.DataSet> が空で、として表現される空の結果セット内で返された `DataTableReader`です。  
  
   
  
## 例  
 この例では、コンソール アプリケーションを作成 3 <xref:System.Data.DataTable> をインスタンス化し、それぞれを追加、 <xref:System.Data.DataSet>です。 呼び出しの例、 <xref:System.Data.DataSet.CreateDataReader%2A> メソッドと、返された内容を表示 <xref:System.Data.DataTableReader>します。 注結果の順序を設定する、 `DataTableReader` の順序によって制御される、 `DataTable` パラメーターとして渡されたインスタンス。  
  
> [!NOTE]
>  この例では、いずれかのオーバー ロードされたバージョンを使用して `CreateDataReader`します。 利用可能なその他の例は、個々 のオーバー ロードに関するトピックを参照してください。  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 例では、コンソール ウィンドウに次のコードが表示されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します。、 <see cref="T:System.Data.DataTableReader" /> ごとに設定する 1 つの結果と <see cref="T:System.Data.DataTable" />, の内のテーブルと同じシーケンス、 <see cref="P:System.Data.DataSet.Tables" /> コレクションです。</summary>
        <returns>A <see cref="T:System.Data.DataTableReader" /> に対応する 1 つまたは複数の結果セットを含む、 <see cref="T:System.Data.DataTable" /> ソース内に含まれるインスタンス <see cref="T:System.Data.DataSet" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内で返された結果セットの順序を確認するために <xref:System.Data.DataTableReader>, 場合は、 <xref:System.Data.DataTable> 内で、 <xref:System.Data.DataSet> が空はによって表される空の結果セット内で返された `DataTableReader`です。  
  
   
  
## 例  
 次の例では、3 つが作成されます <xref:System.Data.DataTable> をインスタンス化、およびに追加、 <xref:System.Data.DataSet>です。 渡します、塗りつぶされた `DataSet` を呼び出すプロシージャに、 <xref:System.Data.DataSet.CreateDataReader%2A> メソッド、および内に含まれるすべての結果セットを反復処理に進みます、 <xref:System.Data.DataTableReader>です。 この例では、コンソール ウィンドウに、結果を表示します。  
  
 [!code-csharp[DataWorks DataSet.DataTableReader\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">返される結果の順序を提供するデータ テーブルの配列を設定、 <see cref="T:System.Data.DataTableReader" />です。</param>
        <summary>返します。、 <see cref="T:System.Data.DataTableReader" /> ごとに設定する 1 つの結果と <see cref="T:System.Data.DataTable" />です。</summary>
        <returns>A <see cref="T:System.Data.DataTableReader" /> に対応する 1 つまたは複数の結果セットを含む、 <see cref="T:System.Data.DataTable" /> ソース内に含まれるインスタンス <see cref="T:System.Data.DataSet" />します。 返された結果セットが指定された順序では、 <paramref name="dataTables" /> パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された内の結果の順序を設定することを確認するために <xref:System.Data.DataTableReader>, 場合は、 <xref:System.Data.DataTable> 内で、 <xref:System.Data.DataSet> が空はによって表される空の結果セット内で返された `DataTableReader`です。 このオーバー ロードされたバージョンでは、一覧を指定することができますので `DataTable` パラメーターとして、インスタンス内で返された結果セットが表示される順序を指定できます `DataTableReader`します。  
  
   
  
## 例  
 この例では、コンソール アプリケーションを作成 3 <xref:System.Data.DataTable> をインスタンス化し、それぞれを追加、 <xref:System.Data.DataSet>です。 呼び出しの例、 <xref:System.Data.DataSet.CreateDataReader%2A> メソッドと、返された内容を表示 <xref:System.Data.DataTableReader>します。 注結果の順序を設定する、 `DataTableReader` の順序によって制御される、 `DataTable` パラメーターとして渡されたインスタンス。 この例では、コンソール ウィンドウに、結果を表示します。  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の名前を取得または <see cref="T:System.Data.DataSet" />です。</summary>
        <value>
          <see cref="T:System.Data.DataSet" /> の名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例が、新たに作成 <xref:System.Data.DataSet> と、指定された <xref:System.Data.DataSet.DataSetName%2A>します。  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>含まれるデータのカスタム ビューを取得、 <see cref="T:System.Data.DataSet" /> フィルター処理、検索、およびカスタムの使用を許可するように <see cref="T:System.Data.DataViewManager" />します。</summary>
        <value>
          <see cref="T:System.Data.DataViewManager" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataViewManager> によって返される、 <xref:System.Data.DataSet.DefaultViewManager%2A> プロパティでは、それぞれのカスタム設定を作成できます。 <xref:System.Data.DataTable> で、 <xref:System.Data.DataSet>です。  
  
 取得する場合、 <xref:System.Data.DataView> から、 <xref:System.Data.DataTable>, 、フィルター処理、並べ替え順、および <xref:System.Data.DataViewRowState> の設定に従って構成されて、 <xref:System.Data.DataSet.DefaultViewManager%2A> プロパティです。  
  
   
  
## 例  
 次の例は、既定値を取得 <xref:System.Data.DataViewManager> の <xref:System.Data.DataSet>, を追加し、 <xref:System.Data.DataTable> に、 <xref:System.Data.DataTableCollection>です。  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>決定、 <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> の <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型指定された逆シリアル化時にこのメソッドを呼び出すことができる <xref:System.Data.DataSet> を決定する、 <xref:System.Data.DataSet.SchemaSerializationMode%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> の逆シリアル化中に渡されるインスタンス、 <see cref="T:System.Data.DataSet" />です。</param>
        <summary>決定、 <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> の <see cref="T:System.Data.DataSet" />です。</summary>
        <returns>
          <see cref="T:System.Data.SchemaSerializationMode" /> ペイロードのスキーマ情報が省略されているかどうかを示す列挙値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型指定された逆シリアル化時にこのメソッドを呼び出すことができる <xref:System.Data.DataSet> を決定する、 <xref:System.Data.DataSet.SchemaSerializationMode%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> を <see langword="DataSet" />コンス トラクターの保護 <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> を使ってリモート処理のシナリオで逆シリアル化中に呼び出されます。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> を <see langword="DataSet" />コンス トラクターの保護 <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> を使ってリモート処理のシナリオで逆シリアル化中に呼び出されます。</param>
        <summary>決定、 <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> の <see cref="T:System.Data.DataSet" />です。</summary>
        <returns>
          <see cref="T:System.Data.SchemaSerializationMode" /> ペイロードのスキーマ情報が省略されているかどうかを示す列挙値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型指定された逆シリアル化時にこのメソッドを呼び出すことができる <xref:System.Data.DataSet> を決定する、 <xref:System.Data.DataSet.SchemaSerializationMode%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用する <see cref="T:System.Data.DataSet" /> の初期化を終了します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The Visual Studio .NET design environment uses this method to end the initialization of a component that is used on a form or used by another component. The <xref:System.Data.DataSet.BeginInit%2A> method starts the initialization. Using the <xref:System.Data.DataSet.BeginInit%2A> and <xref:System.Data.DataSet.EndInit%2A> methods prevents the control from being used before it is fully initialized.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または更新操作が実行時に、制約規則に従うかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> ルールが適用された; 場合それ以外の場合 <see langword="false" />します。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 制約が設定されて、 <xref:System.Data.DataTable> レベル \(<xref:System.Data.DataTable.Constraints%2A> プロパティ\)。 制約の作成の詳細については、次を参照してください。 [Adding Constraints to a Table](http://msdn.microsoft.com/ja-jp/27c9f2fd-f64d-4b4e-bbf6-1d24f47067cb)します。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Data.DataSet> 1 つのテーブル、1 つの列、5 つの行および 1 つで <xref:System.Data.UniqueConstraint>します。<xref:System.Data.DataSet.EnforceConstraints%2A> にプロパティが設定されている `false` され各行の値が同じ値に設定します。 ときに、 <xref:System.Data.DataSet.EnforceConstraints%2A> にプロパティをリセット `true`, 、 <xref:System.Data.ConstraintException> が生成されます。  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">1 つまたは複数の制約を適用することはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられているカスタマイズされたユーザー情報のコレクションを取得、 <see langword="DataSet" />です。</summary>
        <value>A <see cref="T:System.Data.PropertyCollection" /> すべてのユーザー情報を使用します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.ExtendedProperties%2A> プロパティを使用するとカスタム情報を格納する、 `DataSet`です。 たとえば、データを更新する場合、時刻を格納可能性があります。  
  
 拡張プロパティは、型でなければなりません <xref:System.String> ようにする場合と永続化、 <xref:System.Data.DataSet> XML として書き込まれます。  
  
   
  
## 例  
 次の例では、カスタム プロパティを <xref:System.Data.PropertyCollection> によって返される、 <xref:System.Data.DataColumn.ExtendedProperties%2A> プロパティです。 2 番目の例では、カスタム プロパティを取得します。  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コピーを取得、 <see cref="T:System.Data.DataSet" /> 読み込まれた後、または後に加えられたすべての変更内容を含む <see cref="M:System.Data.DataSet.AcceptChanges" /> 最後に呼び出されています。</summary>
        <returns>これから加えた変更はコピー <see cref="T:System.Data.DataSet" /> をマージすると、それを後でを実行するアクションを持つ <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />です。 変更された行が見つからないかどうか、メソッドに返します <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新たに作成 <xref:System.Data.DataSet> は元のすべての行のコピーを格納する <xref:System.Data.DataSet> 保留中の変更があります。 リレーションシップの制限が原因で、新規作成\] を追加するその他の変更されていない行 <xref:System.Data.DataSet> 変更されていない行が変更された行の外部キーに対応する主キーを含むかどうか。 このメソッドを返します `null` は元の行がない場合 <xref:System.Data.DataSet> 保留中の変更があります。  
  
   
  
## 例  
 次の例では、単純な <xref:System.Data.DataSet> 1 つのテーブル、2 つの列、および 10 行を使用します。 2 つの値が変更され、1 つの行が追加されます。 使用して、変更されたデータのサブセットを作成、 <xref:System.Data.DataSet.GetChanges%2A> メソッドです。 エラーを解決した後は、新しい列は、スキーマを変更するサブセットに追加されます。 ときに、 <xref:System.Data.DataSet.Merge%2A> メソッドが呼び出された、 `missingSchemaAction` 設定 `MissingSchemaAction.Add`, 、元に新しい列が追加 <xref:System.Data.DataSet> オブジェクトのスキーマです。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">
          <see cref="T:System.Data.DataRowState" /> 値のいずれか。</param>
        <summary>コピーを取得、 <see cref="T:System.Data.DataSet" /> で行われた後、読み込まれた最後後またはすべての変更を含む <see cref="M:System.Data.DataSet.AcceptChanges" /> が呼び出されるでフィルター処理された <see cref="T:System.Data.DataRowState" />します。</summary>
        <returns>フィルター処理された、 <see cref="T:System.Data.DataSet" /> をマージして、その後を実行するアクションを持つ <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />です。 場合は、目的の行はありません <see cref="T:System.Data.DataRowState" /> が見つかると、このメソッドを返します <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.GetChanges%2A> メソッドは、1 秒あたりの生成に使用される <xref:System.Data.DataSet> を元の変更のみを格納しているオブジェクトが導入されました。 使用して、 `rowStates` 新しいオブジェクトを含める必要があります変更の種類を指定する引数。  
  
 これが返されるコピーは、この元に戻すでマージするように設計された <xref:System.Data.DataSet>します。 リレーションシップ制約がマークされている親行あります `Unchanged` を含める。 場合は、目的の行はありません <xref:System.Data.DataRowState> が見つかると、 <xref:System.Data.DataSet.GetChanges%2A> メソッドが返す `null`します。  
  
   
  
## 例  
 次の例で、 <xref:System.Data.DataSet.GetChanges%2A> 秒を作成する方法 <xref:System.Data.DataSet> データ ソースを更新するその後使用されるオブジェクト。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">指定されたスキーマを設定します。</param>
        <summary>コピーを取得 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> データセット。</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> のコピー。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> と関連付けるシリアル化データを保持する <see cref="T:System.Data.DataSet" />。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> に関連付けるシリアル化ストリームの転送元および転送先を格納する <see cref="T:System.Data.DataSet" />。</param>
        <summary>シリアル化に必要なデータにシリアル化情報オブジェクトを入力します。、 <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化できる返します <see cref="T:System.Xml.Schema.XMLSchema" /> インスタンス。</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XMLSchema" /> インスタンス。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> インスタンス。</param>
        <param name="context">ストリーム コンテキスト。</param>
        <summary>バイナリまたは XML ストリームからテーブル データを逆シリアル化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>格納されたデータの XML 表現を返す、 <see cref="T:System.Data.DataSet" />です。</summary>
        <returns>示す文字列に格納されたデータの表現、 <see cref="T:System.Data.DataSet" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出すことは、呼び出し元と同じ <xref:System.Data.DataSet.WriteXml%2A> と <xref:System.Data.XmlWriteMode> に設定 <xref:System.Data.XmlWriteMode.IgnoreSchema>します。  
  
 <xref:System.Data.DataSet.GetXml%2A> 以上のオーバーヘッドを必要し、なる XML を文字列として返します <xref:System.Data.DataSet.WriteXml%2A> ファイルに XML を記述します。  
  
 ビルドする場合、 <xref:System.Data.DataSet> スキーマの推論を使用して、シリアル化する XML または Web サービスを使用して列の順序変更可能性があります。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Data.DataSet> と <xref:System.Data.DataTable>, 、サンプル データを追加し、XML 形式でデータを表示します。  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 このサンプルでは、データセット内の XML ファイルにデータを作成し、XML からデータセットにデータを読み取る方法を示します。 このサンプルは 2 つのテーブルに 1 つのデータセットを作成、データセットを XML ファイル \(WriteXml および GetXml\) にエクスポートする 2 つの方法を使用して、\(ReadXml および InferXmlSchema\) のデータセットをインポートする XML ファイルから 2 つの方法を使用しています。  
  
 コンパイルして、サンプルを実行する前に、サンプル ディレクトリに次の 4 つの XML ファイルを作成する必要があります。 まず、ElementsWithAttributes.xml を作成します。  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 次に、ElementsWithChildElementsxml.xml を作成します。  
  
```  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 ElementsWithOnlyAttributes.xml を作成します。  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 最後に、RepeatingElements.xml を作成します。  
  
```  
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 これでコンパイルして、次のソース コードを実行することができます。[How to Store Data of DataSet into XML File](http://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) このサンプルの Visual Basic および c\# のプロジェクトが含まれています。  
  
```  
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>XML スキーマに格納されたデータの XML 表現を返します、 <see cref="T:System.Data.DataSet" />です。</summary>
        <returns>XML スキーマに格納されたデータの XML 表現を示す文字列、 <see cref="T:System.Data.DataSet" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すことと同じではこのメソッドを呼び出す <xref:System.Data.DataSet.WriteXmlSchema%2A>, プライマリ スキーマのみが書き込まれる点が異なります。  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> 以上のオーバーヘッドを必要し、なる XML を文字列として返します <xref:System.Data.DataSet.WriteXmlSchema%2A> ファイルに XML を記述します。  
  
 ビルドする場合、 <xref:System.Data.DataSet> スキーマの推論を使用して、シリアル化する XML または Web サービスを使用して列の順序変更可能性があります。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Data.DataSet> と <xref:System.Data.DataTable>, 、し、スキーマを XML 形式で表示します。  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Data.DataSet" /> が新しい、削除、または変更された行を含めて、変更します。</summary>
        <returns>
          <see langword="true" /> 場合、 <see cref="T:System.Data.DataSet" /> の変更します。 そうしないと <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、 <xref:System.Data.DataSet.GetChanges%2A> 秒を作成する方法 <xref:System.Data.DataSet> オブジェクト データ ソースを更新するために使用されます。  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">
          <see cref="T:System.Data.DataRowState" /> 値のいずれか。</param>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Data.DataSet" /> でフィルター処理された、新しい、削除、または変更された行を含む、変更内容を含む <see cref="T:System.Data.DataRowState" />します。</summary>
        <returns>
          <see langword="true" /> 場合、 <see cref="T:System.Data.DataSet" /> の変更します。 そうしないと <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 確認、 <xref:System.Data.DataSet.HasChanges%2A> のプロパティ、 `DataSet` を呼び出す前に、 <xref:System.Data.DataSet.GetChanges%2A> メソッドです。  
  
   
  
## 例  
 次の例で、 <xref:System.Data.DataSet.GetChanges%2A> 秒を作成する方法 <xref:System.Data.DataSet> データ ソースを更新するその後使用されるオブジェクト。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>いずれかでエラーがあるかどうかを示す値を取得、 <see cref="T:System.Data.DataTable" /> この内のオブジェクト <see cref="T:System.Data.DataSet" />します。</summary>
        <value>
          <see langword="true" /> 任意のテーブルには、エラーが含まれている場合それ以外の場合 <see langword="false" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各 <xref:System.Data.DataTable> で、 <xref:System.Data.DataSet> も、 <xref:System.Data.DataTable.HasErrors%2A> プロパティです。 使用して、 `HasErrors` のプロパティ、 `DataSet` 最初は、個別にチェックインする前に、エラーがある任意のテーブルか <xref:System.Data.DataTable> オブジェクトです。 場合、 `DataTable` 、エラーが発生した、 <xref:System.Data.DataTable.GetErrors%2A> メソッドの配列を返す <xref:System.Data.DataRow> 、誤差を含むオブジェクト。  
  
   
  
## 例  
 次の例では、 <xref:System.Data.DataSet.HasErrors%2A> を確認するにするかどうか、 <xref:System.Data.DataSet> オブジェクトには、エラーが含まれています。 場合は、各エラー <xref:System.Data.DataRow> 各 <xref:System.Data.DataTable> 印刷されます。  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see langword="Stream" /> 元となる、スキーマを読み取ったりします。</param>
        <param name="nsArray">スキーマの推論から除外する名前空間 Uniform Resource Identifier \(URI\) の文字列の配列。</param>
        <summary>指定された対象から XML スキーマを適用 <see cref="T:System.IO.Stream" /> に、 <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="TextReader" /> 元となる、スキーマを読み取ったりします。</param>
        <param name="nsArray">スキーマの推論から除外する名前空間 Uniform Resource Identifier \(URI\) の文字列の配列。</param>
        <summary>指定された対象から XML スキーマを適用 <see cref="T:System.IO.TextReader" /> に、 <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">スキーマの読み込み元のファイル \(パスを含む\) の名前。</param>
        <param name="nsArray">スキーマの推論から除外する名前空間 Uniform Resource Identifier \(URI\) の文字列の配列。</param>
        <summary>指定されたファイルから XML スキーマの適用、 <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> 設定されていない <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />します。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">For reading and writing files. Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="XMLReader" /> 元となる、スキーマを読み取ったりします。</param>
        <param name="nsArray">スキーマの推論から除外する名前空間 Uniform Resource Identifier \(URI\) の文字列の配列。</param>
        <summary>指定された対象から XML スキーマを適用 <see cref="T:System.Xml.XmlReader" /> に、 <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以降、 <see cref="T:System.Data.DataSet" /> が初期化されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 詳細については、「<xref:System.Data.DataSet.IsInitialized%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのバイナリまたは XML ストリームからのデータセットのテーブル データを逆シリアル化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクト。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> オブジェクト。</param>
        <summary>形式のシリアル化されたデータの書式を調べ、 <see langword="DataSet" />です。</summary>
        <returns>
          <see langword="true" /> 場合は、指定した <see cref="T:System.Runtime.Serialization.SerializationInfo" /> を表す、 <see langword="DataSet" /> 、バイナリ形式でシリアル化された <see langword="false" /> それ以外の場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは .NET Framework インフラストラクチャをサポートします。独自に作成したコードから直接使用するためのものではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Data.DataSet" /> が初期化されています。</summary>
        <value>
          <see langword="true" /> コンポーネントを示すために初期化が完了しました。それ以外の場合 <see langword="false" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 状態を取得、 <xref:System.Data.DataSet> に構築される、たとえば Visual Studio によって中です。<xref:System.Data.DataSet.BeginInit%2A> メソッドによりに設定 `false` と <xref:System.Data.DataSet.EndInit%2A> メソッドによりに設定 `true`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>入力、 <see cref="T:System.Data.DataSet" /> 、指定されたを使用してデータ ソースから値を持つ <see cref="T:System.Data.IDataReader" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataTable.Load%2A> メソッドは、1 つの入力時に、手法を提供 <xref:System.Data.DataTable> から取得したデータを <xref:System.Data.IDataReader> インスタンス。 このメソッドは、同等の機能を提供、読み込むことができますから複数の結果セット、 `IDataReader` 内で複数のテーブルに、 `DataSet`です。  
  
 場合、 `DataSet` 既に行を含んでいるデータ ソースからの受信データは、既存の行に結合されます。  
  
 `Load` メソッドは、指定したデータ ソースからデータを取得し、現在のデータ コンテナーに追加することをすべて中央揃え、いくつかの一般的なシナリオで使用できます \(ここで、 `DataSet`\)。 これらのシナリオについての標準的使用方法を説明する、 `DataSet`, その更新プログラムを記述する方法、および動作をマージします。  
  
 A `DataSet` により同期または単一のプライマリ データ ソースを更新します。`DataSet` プライマリ データ ソースとの同期を許可する、変更を追跡します。 さらに、 `DataSet` 1 つまたは複数のセカンダリ データ ソースからデータの増分を受け入れることができます。`DataSet` セカンダリ データ ソースと同期できるようにするために変更を追跡する必要はありません。  
  
 これら 2 つの架空のデータ ソースを指定するには、ユーザーは、次の動作のいずれかが必要な可能性。  
  
-   初期化 `DataSet` プライマリ データ ソースからです。 このシナリオでは、ユーザーが、空の初期化が `DataSet` プライマリ データ ソースからの値。 1 つまたは複数の DataTable の内容が変更されます。 後で、ユーザーは、プライマリ データ ソースに変更を反映する予定です。  
  
-   変更を保持し、プライマリ データ ソースから再同期します。 このシナリオでは、ユーザーが実行する、 `DataSet` 上記のシナリオでは、増分同期で行われた変更を維持し、プライマリ データ ソースで実行され、 `DataSet`です。  
  
-   データの増分は、セカンダリ データ ソースからフィードです。 このシナリオでは、ユーザーは、1 つまたは複数のセカンダリ データ ソースからの変更をマージし、プライマリ データ ソースにそれらの変更を伝達するためができます。  
  
 `Load`  メソッドにより、このようなシナリオすべてが可能になります。 このメソッドでは、読み込みのオプション パラメーターを指定することができますを示す方法に既に行、 <xref:System.Data.DataTable> 読み込まれる行と結合します。 次の表に、次の 3 つの負荷で提供されるオプション、 <xref:System.Data.LoadOption> 列挙します。 各ケースでは、説明は、受信データで行の主キーには、既存の行の主キーと一致する場合に、動作を示します。  
  
|読み込みオプション|説明|  
|---------------|--------|  
|`PreserveChanges` \(既定値\)|受信した行の値を持つ行の元のバージョンを更新します。|  
|`OverwriteChanges`|受信した行の値を持つ行の現在と元のバージョンを更新します。|  
|`Upsert`|受信した行の値を持つ行の現在のバージョンを更新します。|  
  
 一般に、 `PreserveChanges` と `OverwriteChanges` を同期するユーザーが必要なシナリオ向けのオプションでは、 `DataSet` し、プライマリ データ ソースに変更します。`Upsert` オプションには、1 つまたは複数のセカンダリ データ ソースから集計の変更が容易になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> 1 つまたは複数の結果セットを提供します。</param>
        <param name="loadOption">値、 <see cref="T:System.Data.LoadOption" /> を示す列挙体方法に既に行、 <see cref="T:System.Data.DataTable" /> 内でインスタンス化、 <see cref="T:System.Data.DataSet" /> 同じ主キーを共有する受信の行と組み合わされます。</param>
        <param name="tables">配列 <see cref="T:System.Data.DataTable" /> 元のインスタンス、 <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> メソッド名と名前空間の情報を取得します。 これらのテーブルのそれぞれのメンバーである必要があります、 <see cref="T:System.Data.DataTableCollection" /> これに含まれる <see cref="T:System.Data.DataSet" />です。</param>
        <summary>入力、 <see cref="T:System.Data.DataSet" /> 、指定されたを使用してデータ ソースから値を持つ <see cref="T:System.Data.IDataReader" />, 、配列を使用して <see cref="T:System.Data.DataTable" /> スキーマと名前空間の情報を提供するインスタンス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataTable.Load%2A> メソッドは、1 つの入力時に、手法を提供 <xref:System.Data.DataTable> から取得したデータを <xref:System.Data.IDataReader> インスタンス。 このメソッドは、同等の機能を提供、読み込むことができますから複数の結果セット、 <xref:System.Data.IDataReader> 内で複数のテーブルに、 <xref:System.Data.DataSet>です。  
  
> [!NOTE]
>  読み込み操作は失敗、 <xref:System.InvalidOperationException> 場合は、入力方向の変換元データ列のいずれかの `reader` は計算列です。  
  
 `loadOption` パラメーターでは、インポートしたデータの既存のデータと対話して値のいずれかの方法を指定することができます、 <xref:System.Data.LoadOption> 列挙します。 ドキュメントを参照して、 <xref:System.Data.DataTable><xref:System.Data.DataTable.Load%2A> 方法の詳細で、このパラメーターを使用します。  
  
 `tables` パラメーターの配列を指定できます。 <xref:System.Data.DataTable> 設定、リーダーから読み込まれた各結果に対応するテーブルの順序を示すインスタンスです。<xref:System.Data.DataSet.Load%2A>メソッド塗りつぶし各提供 <xref:System.Data.DataTable> のデータ ソースのデータ リーダーから 1 つの結果を使用してインスタンス。 各結果セットの後、 <xref:System.Data.DataSet.Load%2A>メソッドは、次の結果をこれ以上の結果セットがあるまで、リーダー内の設定移動します。  
  
 このメソッドの名前解決スキームは、それに続くと同じ、 <xref:System.Data.Common.DbDataAdapter.Fill%2A> のメソッド、 <xref:System.Data.Common.DbDataAdapter> クラスです。  
  
   
  
## 例  
 次の例が、新たに作成 <xref:System.Data.DataSet>, 、2 つ追加 <xref:System.Data.DataTable> インスタンスを <xref:System.Data.DataSet>, 、データを格納し、 <xref:System.Data.DataSet> を使用して、 <xref:System.Data.DataSet.Load%2A> からデータを取得するメソッド、 <xref:System.Data.DataTableReader> 2 つの結果セットを格納します。 最後に、コンソール ウィンドウで、テーブルの内容を表示します。  
  
 [!code-csharp[DataWorks DataSet.LoadTables\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> 1 つまたは複数の結果セットを提供します。</param>
        <param name="loadOption">値、 <see cref="T:System.Data.LoadOption" /> を示す列挙体方法に既に行、 <see cref="T:System.Data.DataTable" /> 内でインスタンス化、 <see langword="DataSet" /> 同じ主キーを共有する受信の行と組み合わされます。</param>
        <param name="tables">元の文字列の配列、 <see langword="Load" /> メソッドはテーブル名の情報を取得します。</param>
        <summary>入力、 <see cref="T:System.Data.DataSet" /> 、指定されたを使用してデータ ソースから値を持つ <see cref="T:System.Data.IDataReader" />, 、内のテーブルの名前を指定する文字列の配列を使用して、 <see langword="DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataTable.Load%2A> メソッドは、1 つの入力時に、手法を提供 <xref:System.Data.DataTable> から取得したデータを <xref:System.Data.IDataReader> インスタンス。 このメソッドは、同等の機能を提供、読み込むことができますから複数の結果セット、 `IDataReader` 内で複数のテーブルに、 `DataSet`です。  
  
> [!NOTE]
>  読み込み操作は失敗、 <xref:System.InvalidOperationException> 場合は、入力方向の変換元データ列のいずれかの `reader` は計算列です。  
  
 `loadOption` パラメーターでは、インポートしたデータの既存のデータと対話して値のいずれかの方法を指定することができます、 <xref:System.Data.LoadOption> 列挙します。 ドキュメントを参照して、 <xref:System.Data.DataTable.Load%2A> 方法の詳細で、このパラメーターを使用します。  
  
 `tables` パラメーターでは、各結果セット、リーダーから読み込まれたに対応するテーブルの順序を示すテーブル名の配列を指定することができます。`Load` メソッドがテーブル内で検索しようとした場合、 `DataSet` の順序でのテーブル名の配列については、名前と一致します。 一致するテーブルが見つかった場合は、現在の結果セットの内容とそのテーブルが読み込まれます。 一致するテーブルが見つからない場合は、テーブル名の配列で指定された名前を使用して、テーブルを作成し、結果セットから新しいテーブルのスキーマを推論します。 各結果セットの後、 `Load` メソッドは、次の結果をこれ以上の結果セットがあるまで、リーダー内の設定移動します。  
  
 関連付けられている既定の名前空間 `DataSet`, 新しく作成された各と、いずれかが関連付けられている場合は、 `DataTable`です。 このメソッドの名前解決スキームは、それに続くと同じ、 <xref:System.Data.Common.DbDataAdapter.Fill%2A> のメソッド、 <xref:System.Data.Common.DbDataAdapter> クラスです。  
  
   
  
## 例  
 次のコンソール アプリケーションの例は、まずテーブルを作成しにリーダーからデータを読み込む、 <xref:System.Data.DataSet>, を使用して、 `Load` メソッドです。 例では、テーブルを追加し、 <xref:System.Data.DataSet> テーブルにデータを挿入しようと、 <xref:System.Data.DataTableReader>です。 この例でにパラメーターが渡されるため、 `Load` メソッドが存在しないテーブル名を示す、 `Load` メソッドをパラメーターとして渡された名前と一致する新しいテーブルを作成します。 データが読み込まれると、例では、コンソール ウィンドウにすべてのテーブルの内容が表示されます。  
  
 [!code-csharp[DataWorks DataSet.LoadString\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> 1 つまたは複数の結果セットを提供します。</param>
        <param name="loadOption">値、 <see cref="T:System.Data.LoadOption" /> を示す列挙体方法に既に行、 <see cref="T:System.Data.DataTable" /> 内でインスタンス化、 <see cref="T:System.Data.DataSet" /> 同じ主キーを共有する受信の行と組み合わされます。</param>
        <param name="errorHandler">A <see cref="T:System.Data.FillErrorEventHandler" /> データの読み込み中にエラーが発生したときに呼び出すデリゲート。</param>
        <param name="tables">配列 <see cref="T:System.Data.DataTable" /> 元のインスタンス、 <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> メソッド名と名前空間の情報を取得します。</param>
        <summary>入力、 <see cref="T:System.Data.DataSet" /> 、指定されたを使用してデータ ソースから値を持つ <see cref="T:System.Data.IDataReader" />, 、配列を使用して <see cref="T:System.Data.DataTable" /> スキーマと名前空間の情報を提供するインスタンス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataTable.Load%2A> メソッドは、1 つの入力時に、手法を提供 <xref:System.Data.DataTable> から取得したデータを <xref:System.Data.IDataReader> インスタンス。 このメソッドは、同等の機能を提供、読み込むことができますから複数の結果セット、 <xref:System.Data.IDataReader> 内で複数のテーブルに、 <xref:System.Data.DataSet>です。  
  
> [!NOTE]
>  読み込み操作は失敗、 <xref:System.InvalidOperationException> 場合は、入力方向の変換元データ列のいずれかの `reader` は計算列です。  
  
 `loadOption` パラメーターでは、インポートしたデータの既存のデータと対話して値のいずれかの方法を指定することができます、 <xref:System.Data.LoadOption> 列挙します。 ドキュメントを参照して、 <xref:System.Data.DataTable><xref:System.Data.DataTable.Load%2A> 方法の詳細で、このパラメーターを使用します。  
  
 `errorHandler` パラメーターは、 <xref:System.Data.FillErrorEventHandler> データの読み込み中にエラーが発生したときに呼び出されるプロシージャを参照するデリゲート。<xref:System.Data.FillErrorEventArgs> プロシージャに渡されるパラメーターの現在の行のデータをエラーが発生したに関する情報を取得するためのプロパティを提供し、 <xref:System.Data.DataTable> 埋め尽くされます。 このデリゲートのメカニズムを使用して、シンプルな try\/catch ブロックではなく、エラーを確認することができます、状況に対処し、必要な場合の処理を続行します。<xref:System.Data.FillErrorEventArgs> パラメーターにより、 <xref:System.Data.FillErrorEventArgs.Continue%2A> プロパティ: このプロパティを設定 `true` 処理を続行してエラーを処理したことを示すためにプロパティを設定します `false` 処理を停止することを示すためにします。 注意してくださいそのプロパティを設定する `false` コードが例外をスローする問題が発生します。  
  
 `tables` パラメーターの配列を指定できます。 <xref:System.Data.DataTable> 設定、リーダーから読み込まれた各結果に対応するテーブルの順序を示すインスタンスです。<xref:System.Data.DataSet.Load%2A>メソッド塗りつぶし各提供 <xref:System.Data.DataTable> のデータ ソースのデータ リーダーから 1 つの結果を使用してインスタンス。 各結果セットの後、 <xref:System.Data.DataSet.Load%2A>メソッドは、次の結果をこれ以上の結果セットがあるまで、リーダー内の設定移動します。  
  
 このメソッドの名前解決スキームは、それに続くと同じ、 <xref:System.Data.Common.DbDataAdapter.Fill%2A> のメソッド、 <xref:System.Data.Common.DbDataAdapter> クラスです。  
  
   
  
## 例  
 次の例は、テーブルを追加、 <xref:System.Data.DataSet>, 、使用しようと、 <xref:System.Data.DataSet.Load%2A> からデータを読み込むためのメソッド、 <xref:System.Data.DataTableReader> 互換性のないスキーマを含みます。 この例では、エラーをトラップするのではなく、 <xref:System.Data.FillErrorEventHandler> を調査し、エラーを処理するデリゲート。 出力がコンソール ウィンドウに表示されます。  
  
 [!code-csharp[DataWorks DataSet.Load\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはテーブル内の文字列を比較するために使用するロケール情報を設定します。</summary>
        <value>A <see cref="T:System.Globalization.CultureInfo" /> 、ユーザーのコンピューターのロケールに関するデータを格納します。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.Locale%2A> プロパティは、ロケールを指定する並べ替えを適用します。  
  
 既定では、設定、 <xref:System.Data.DataSet.Locale%2A> の <xref:System.Data.DataSet> 設定も、 <xref:System.Data.DataSet.Locale%2A> ごと <xref:System.Data.DataTable> オブジェクトに `DataSet` 同じ値にします。  
  
> [!NOTE]
>  式が含まれている列で、 <xref:System.StringComparison.InvariantCulture> を使用します。<xref:System.StringComparison.CurrentCulture> は無視されます。  
  
   
  
## 例  
 次の例では取得、 <xref:System.Globalization.CultureInfo> の <xref:System.Data.DataSet> を印刷し、 <xref:System.Globalization.CultureInfo.DisplayName%2A> と <xref:System.Globalization.CultureInfo.EnglishName%2A> プロパティです。  
  
 [!code-vb[Classic WebData DataSet.Locale Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">配列 <see langword="DataRow" /> にマージするオブジェクト、 <see langword="DataSet" />です。</param>
        <summary>配列をマージ <see cref="T:System.Data.DataRow" /> オブジェクトを現在に <see cref="T:System.Data.DataSet" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.Merge%2A> メソッドを使用して、2 つのマージ <xref:System.Data.DataSet> ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションで既存のデータ ソースから最新の変更を反映する <xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションを更新して <xref:System.Data.DataSet> データ ソースからの最新データです。  
  
 <xref:System.Data.DataSet.Merge%2A> メソッドは通常、一連の変更の検証、エラーを調整、変更されたデータ ソースの更新、および最後に、既存の更新に関連する手順の最後に呼び出されます <xref:System.Data.DataSet>します。  
  
 クライアント アプリケーションでは、通常、単一のボタンをユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証です。 このシナリオでは、 <xref:System.Data.DataSet.GetChanges%2A> メソッドが最初に呼び出されます。 1 秒あたりに返ります <xref:System.Data.DataSet> 検証とマージ用に最適化されています。 次にこの <xref:System.Data.DataSet> オブジェクトのみを含む、 <xref:System.Data.DataTable> と <xref:System.Data.DataRow> 、元のサブセットの結果として、変更されたオブジェクト <xref:System.Data.DataSet>します。 このサブセットは一般に小さいため、中間層コンポーネントにより効率的によく渡されます。 中間層コンポーネントは、ストアド プロシージャを使用して、変更を元のデータ ソースを更新します。 中間層が、新しいバックアップを送信できますし、 <xref:System.Data.DataSet> \(再度実行して、元のクエリ\)、元のデータとデータ ソースから最新のデータを含むかして、データ ソースから加えられた変更のサブセットに送り返すことができます。 \(たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値を伝達するクライアント アプリケーションに返信します。\) どちらの場合に返された <xref:System.Data.DataSet> クライアント アプリケーションの元に再び結合することができます <xref:System.Data.DataSet> で、 <xref:System.Data.DataSet.Merge%2A> メソッドです。  
  
 ときに、 <xref:System.Data.DataSet.Merge%2A> メソッドを呼び出して、2 つのスキーマ <xref:System.Data.DataSet> オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列可能性がありますが追加されて XML スキーマに自動化されたプロセスによってです。 場合、ソース <xref:System.Data.DataSet> スキーマ要素が含まれています \(追加 <xref:System.Data.DataColumn> オブジェクト\)、ターゲットに不足して、スキーマ要素は、設定して、ターゲットに追加できる、 `missingSchemaAction` への引数 `MissingSchemaAction.Add`します。 その場合は、統合 <xref:System.Data.DataSet> 、追加されたスキーマとデータが含まれています。  
  
 スキーマのマージ後に、データをマージします。  
  
 新しいソースをマージするときに <xref:System.Data.DataSet> 、ターゲットに任意のソースの行で、 <xref:System.Data.DataRowState> の値 `Unchanged`, 、`Modified`, 、または `Deleted` 、同じプライマリ キーの値を持つ特定の行にも一致します。 ソースを持つ行、 <xref:System.Data.DataRowState> の値 `Added` 新しいソース行と同じプライマリ キー値を持つ新しいターゲットの行に一致します。  
  
 マージ中に制約が無効になります。 場合は、マージの最後に、すべての制約を有効にすることはできません、 <xref:System.Data.ConstraintException> が生成され、制約を無効にして、結合されたデータは保持されます。 ここで、 <xref:System.Data.DataSet.EnforceConstraints%2A> にプロパティが設定されている `false`, 、無効なすべての行がエラーでマークされるとします。 リセットする前に、エラーを解決する必要があります、 <xref:System.Data.DataSet.EnforceConstraints%2A> プロパティを `true`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> データとスキーマがマージされます。</param>
        <summary>指定されたマージ <see cref="T:System.Data.DataSet" /> とそのスキーマに現在 <see langword="DataSet" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.Merge%2A> メソッドを使用して、2 つのマージ <xref:System.Data.DataSet> ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションで既存のデータ ソースから最新の変更を反映する <xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションを更新して <xref:System.Data.DataSet> データ ソースからの最新データです。  
  
 <xref:System.Data.DataSet.Merge%2A> メソッドは通常、一連の変更の検証、エラーを調整、変更されたデータ ソースの更新、および最後に、既存の更新に関連する手順の最後に呼び出されます <xref:System.Data.DataSet>します。  
  
 クライアント アプリケーションでは、通常、単一のボタンをユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証です。 このシナリオでは、 <xref:System.Data.DataSet.GetChanges%2A> メソッドが最初に呼び出されます。 1 秒あたりに返ります <xref:System.Data.DataSet> 検証とマージ用に最適化されています。 次にこの <xref:System.Data.DataSet> オブジェクトのみを含む、 <xref:System.Data.DataTable> と <xref:System.Data.DataRow> 、元のサブセットの結果として、変更されたオブジェクト <xref:System.Data.DataSet>します。 このサブセットは一般的に小さくし、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して、変更を元のデータ ソースを更新します。 中間層が、新しいバックアップを送信できますし、 <xref:System.Data.DataSet> \(再度実行して、元のクエリ\)、元のデータとデータ ソースから最新のデータを含むかして、データ ソースから加えられた変更のサブセットに送り返すことができます。 \(たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値を伝達するクライアント アプリケーションに返信します。\) どちらの場合に返された <xref:System.Data.DataSet> クライアント アプリケーションの元に再び結合することができます <xref:System.Data.DataSet> で、 <xref:System.Data.DataSet.Merge%2A> メソッドです。  
  
 ときに、 <xref:System.Data.DataSet.Merge%2A> メソッドを呼び出して、2 つのスキーマ <xref:System.Data.DataSet> オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列可能性がありますが追加されて XML スキーマに自動化されたプロセスによってです。 場合、ソース <xref:System.Data.DataSet> のスキーマ要素が含まれています \(追加 <xref:System.Data.DataColumn> オブジェクト\)、ターゲットに不足して、スキーマ要素は、設定して、ターゲットに追加できる、 `missingSchemaAction` に渡す引数 `MissingSchemaAction.Add`します。 その場合は、統合 <xref:System.Data.DataSet> 、追加されたスキーマとデータが含まれています。  
  
 スキーマのマージ後に、データをマージします。  
  
 新しいソースをマージするときに <xref:System.Data.DataSet> 、ターゲットに任意のソースの行で、 <xref:System.Data.DataRowState> の値 `Unchanged`, 、`Modified`, 、または `Deleted` 、同じプライマリ キーの値を持つ特定の行にも一致します。 ソースを持つ行、 `DataRowState` の値 `Added` 新しいソース行と同じプライマリ キー値を持つ新しいターゲットの行に一致します。  
  
 マージ中に制約が無効になります。 場合は、制約は、merge、年末に有効にすることはできません、 <xref:System.Data.ConstraintException> が生成され、制約を無効にして、結合されたデータは保持されます。 ここで、 <xref:System.Data.DataSet.EnforceConstraints%2A> にプロパティが設定されている `false`, 、無効なすべての行がエラーでマークされるとします。 リセットする前に、エラーを解決する必要があります、 <xref:System.Data.DataSet.EnforceConstraints%2A> プロパティを `true`します。  
  
   
  
## 例  
 次の例では、 <xref:System.Data.DataSet.GetChanges%2A>, 、Update、および <xref:System.Data.DataSet.Merge%2A> 上のメソッド、 <xref:System.Data.DataSet>です。  
  
 [!code-csharp[Classic WebData DataSet.Merge Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">1 つまたは複数の制約を有効にすることはできません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> データとスキーマがマージされます。</param>
        <summary>指定されたマージ <see cref="T:System.Data.DataTable" /> とそのスキーマに現在 <see cref="T:System.Data.DataSet" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.Merge%2A> メソッドを使用して、2 つのマージ <xref:System.Data.DataSet> ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションで既存のデータ ソースから最新の変更を反映する <xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションを更新して <xref:System.Data.DataSet> データ ソースからの最新データです。  
  
 <xref:System.Data.DataSet.Merge%2A> メソッドは通常、一連の変更の検証、エラーを調整、変更されたデータ ソースの更新、および最後に、既存の更新に関連する手順の最後に呼び出されます <xref:System.Data.DataSet>します。  
  
 クライアント アプリケーションでは、通常、単一のボタンをユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証です。 このシナリオでは、 <xref:System.Data.DataSet.GetChanges%2A> メソッドが最初に呼び出されます。 1 秒あたりに返ります <xref:System.Data.DataSet> 検証とマージ用に最適化されています。 次にこの <xref:System.Data.DataSet> オブジェクトのみを含む、 <xref:System.Data.DataTable> と <xref:System.Data.DataRow> 、元のサブセットの結果として、変更されたオブジェクト <xref:System.Data.DataSet>します。 このサブセットは一般的に小さくし、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して、変更を元のデータ ソースを更新します。 中間層が、新しいバックアップを送信できますし、 <xref:System.Data.DataSet> \(再度実行して、元のクエリ\)、元のデータとデータ ソースから最新のデータを含むかして、データ ソースから加えられた変更のサブセットに送り返すことができます。 \(たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値を伝達するクライアント アプリケーションに返信します。\) どちらの場合に返された <xref:System.Data.DataSet> クライアント アプリケーションの元に再び結合することができます <xref:System.Data.DataSet> で、 <xref:System.Data.DataSet.Merge%2A> メソッドです。  
  
 ときに、 <xref:System.Data.DataSet.Merge%2A> メソッドを呼び出して、2 つのスキーマ <xref:System.Data.DataSet> オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列可能性がありますが追加されて XML スキーマに自動化されたプロセスによってです。 場合、ソース <xref:System.Data.DataSet> スキーマ要素が含まれています \(追加 <xref:System.Data.DataColumn> オブジェクト\)、ターゲットに不足して、スキーマ要素は、設定して、ターゲットに追加できる、 `missingSchemaAction` への引数 `MissingSchemaAction.Add`します。 その場合は、統合 <xref:System.Data.DataSet> 、追加されたスキーマとデータが含まれています。  
  
 スキーマのマージ後に、データをマージします。  
  
 新しいソースをマージするときに <xref:System.Data.DataSet> 、ターゲットに任意のソースの行で、 <xref:System.Data.DataRowState> の値 `Unchanged`, 、`Modified`, 、または `Deleted` 、同じプライマリ キーの値を持つ特定の行にも一致します。 ソースを持つ行、 `DataRowState` の値 `Added` 新しいソース行と同じプライマリ キー値を持つ新しいターゲットの行に一致します。  
  
 マージ中に制約が無効になります。 場合は、制約は、merge、年末に有効にすることはできません、 <xref:System.Data.ConstraintException> が生成され、制約を無効にして、結合されたデータは保持されます。 ここで、 <xref:System.Data.DataSet.EnforceConstraints%2A> にプロパティが設定されている `false`, 、無効なすべての行がエラーでマークされるとします。 リセットする前に、エラーを解決する必要があります、 <xref:System.Data.DataSet.EnforceConstraints%2A> プロパティを `true`します。  
  
   
  
## 例  
 次の例では、単純な <xref:System.Data.DataSet> 1 つのテーブル、2 つの列、および 10 行を使用します。 1 秒あたり <xref:System.Data.DataTable> に作成された 1 つ目と同じです。 2 つの行にマージし、2 番目のテーブルに追加されます、 <xref:System.Data.DataSet>です。  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="table" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> データとスキーマがマージされます。</param>
        <param name="preserveChanges">
          <see langword="true" /> 現在の変更を保存する <see langword="DataSet" />。 そうしないと <see langword="false" />です。</param>
        <summary>指定されたマージ <see cref="T:System.Data.DataSet" /> とそのスキーマに現在 <see langword="DataSet" />, 保持したり、この変更を破棄すること、 <see langword="DataSet" /> が指定した引数に応じて。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.Merge%2A> メソッドを使用して、2 つのマージ <xref:System.Data.DataSet> ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションで既存のデータ ソースから最新の変更を反映する <xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションを更新して <xref:System.Data.DataSet> データ ソースからの最新データです。  
  
 <xref:System.Data.DataSet.Merge%2A> メソッドは通常、一連の変更の検証、エラーを調整、変更されたデータ ソースの更新、および最後に、既存の更新に関連する手順の最後に呼び出されます <xref:System.Data.DataSet>します。  
  
 クライアント アプリケーションでは、通常、単一のボタンをユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証です。 このシナリオでは、 <xref:System.Data.DataSet.GetChanges%2A> メソッドが最初に呼び出されます。 1 秒あたりに返ります <xref:System.Data.DataSet> 検証とマージ用に最適化されています。 次にこの <xref:System.Data.DataSet> オブジェクトのみを含む、 <xref:System.Data.DataTable> と <xref:System.Data.DataRow> 、元のサブセットの結果として、変更されたオブジェクト <xref:System.Data.DataSet>します。 このサブセットは一般的に小さくし、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して、変更を元のデータ ソースを更新します。 中間層が、新しいバックアップを送信できますし、 <xref:System.Data.DataSet> \(再度実行して、元のクエリ\)、元のデータとデータ ソースから最新のデータを含むかして、データ ソースから加えられた変更のサブセットに送り返すことができます。 \(たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値を伝達するクライアント アプリケーションに返信します。\) どちらの場合に返された <xref:System.Data.DataSet> クライアント アプリケーションの元に再び結合することができます <xref:System.Data.DataSet> で、 <xref:System.Data.DataSet.Merge%2A> メソッドです。  
  
 ときに、 <xref:System.Data.DataSet.Merge%2A> メソッドを呼び出して、2 つのスキーマ <xref:System.Data.DataSet> オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列可能性がありますが追加されて XML スキーマに自動化されたプロセスによってです。 場合、ソース <xref:System.Data.DataSet> スキーマ要素が含まれています \(追加 <xref:System.Data.DataColumn> オブジェクト\)、ターゲットに不足して、スキーマ要素は、設定して、ターゲットに追加できる、 `missingSchemaAction` への引数 `MissingSchemaAction.Add`します。 その場合は、統合 <xref:System.Data.DataSet> 、追加されたスキーマとデータが含まれています。  
  
 スキーマのマージ後に、データをマージします。  
  
 新しいソースをマージするときに <xref:System.Data.DataSet> 、ターゲットに任意のソースの行で、 <xref:System.Data.DataRowState> の値 `Unchanged`, 、`Modified`, 、または `Deleted` 、同じプライマリ キーの値を持つ特定の行にも一致します。 ソースを持つ行、 `DataRowState` の値 `Added` 新しいソース行と同じプライマリ キー値を持つ新しいターゲットの行に一致します。  
  
 マージ中に制約が無効になります。 場合は、制約は、merge、年末に有効にすることはできません、 <xref:System.Data.ConstraintException> が生成され、制約を無効にして、結合されたデータは保持されます。 ここで、 <xref:System.Data.DataSet.EnforceConstraints%2A> にプロパティが設定されている `false`, 、無効なすべての行がエラーでマークされるとします。 リセットする前に、エラーを解決する必要があります、 <xref:System.Data.DataSet.EnforceConstraints%2A> プロパティを `true`します。  
  
   
  
## 例  
 次の例では、単純な <xref:System.Data.DataSet> 1 つのテーブル、2 つの列、および 10 行を使用します。 10 行を追加すると、2 つの値が変更され、1 つの行が追加されます。 使用して、変更されたデータのサブセットを作成、 <xref:System.Data.DataSet.GetChanges%2A> メソッドです。 エラーを解決した後、サブセット データが元にマージ <xref:System.Data.DataSet>します。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">配列 <see cref="T:System.Data.DataRow" /> にマージするオブジェクト、 <see langword="DataSet" />です。</param>
        <param name="preserveChanges">
          <see langword="true" /> 変更を保持するために、 <see langword="DataSet" />。 そうしないと <see langword="false" />です。</param>
        <param name="missingSchemaAction">
          <see cref="T:System.Data.MissingSchemaAction" /> 値のいずれか 1 つ。</param>
        <summary>配列をマージ <see cref="T:System.Data.DataRow" /> オブジェクトを現在に <see cref="T:System.Data.DataSet" />, を維持し、または変更を破棄すること、 <see langword="DataSet" /> と、指定した引数に応じての互換性のないスキーマを処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Merge メソッド \(DataRow\<xref:System.Data.DataSet.Merge%2A> メソッドを使用して、2 つのマージ [Merge メソッド \(DataRow\<xref:System.Data.DataSet> ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションで既存のデータ ソースから最新の変更を反映する [Merge メソッド \(DataRow\<xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションを更新して [Merge メソッド \(DataRow\<xref:System.Data.DataSet> データ ソースからの最新データです。  
  
 [Merge メソッド \(DataRow\<xref:System.Data.DataSet.Merge%2A> メソッドは通常、一連の変更の検証、エラーを調整、変更されたデータ ソースの更新、および最後に、既存の更新に関連する手順の最後に呼び出されます [Merge メソッド \(DataRow\<xref:System.Data.DataSet>します。  
  
 クライアント アプリケーションでは、通常、単一のボタンをユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証です。 このシナリオでは、 [Merge メソッド \(DataRow\<xref:System.Data.DataSet.GetChanges%2A> メソッドが最初に呼び出されます。 1 秒あたりに返ります [Merge メソッド \(DataRow\<xref:System.Data.DataSet> 検証とマージ用に最適化されています。 次にこの [Merge メソッド \(DataRow\<xref:System.Data.DataSet> オブジェクトのみを含む、 [Merge メソッド \(DataRow\<xref:System.Data.DataTable> と [Merge メソッド \(DataRow\<xref:System.Data.DataRow> 、元のサブセットの結果として、変更されたオブジェクト [Merge メソッド \(DataRow\<xref:System.Data.DataSet>します。 このサブセットは一般的に小さくし、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して、変更を元のデータ ソースを更新します。 中間層が、新しいバックアップを送信できますし、 [Merge メソッド \(DataRow\<xref:System.Data.DataSet> \(再度実行して、元のクエリ\)、元のデータとデータ ソースから最新のデータを含むかして、データ ソースから加えられた変更のサブセットに送り返すことができます。 \(たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値を伝達するクライアント アプリケーションに返信します。\) どちらの場合に返された [Merge メソッド \(DataRow\<xref:System.Data.DataSet> クライアント アプリケーションの元に再び結合することができます [Merge メソッド \(DataRow\<xref:System.Data.DataSet> で、 [Merge メソッド \(DataRow\<xref:System.Data.DataSet.Merge%2A> メソッドです。  
  
 説明を容易にするために、 [Merge メソッド \(DataRow\<xref:System.Data.DataSet.Merge%2A> メソッドを使用して「ターゲット」現在のことを示す [Merge メソッド \(DataRow\<xref:System.Data.DataSet>, 、および 2 つ目の \(パラメーター\) の名前を付けるには、"source" [Merge メソッド \(DataRow\<xref:System.Data.DataSet>します。 ターゲット [Merge メソッド \(DataRow\<xref:System.Data.DataSet> と呼ばれるアクション \(マージ\) が発生しているオブジェクトであるためです。 2 番目 [Merge メソッド \(DataRow\<xref:System.Data.DataSet> も含まれている情報は変わりませんが代わりに、現在に結合されているため、「ソース」と呼びます [Merge メソッド \(DataRow\<xref:System.Data.DataSet>します。  
  
 ときに、 [Merge メソッド \(DataRow\<xref:System.Data.DataSet.Merge%2A> メソッドを呼び出して、2 つのスキーマ [Merge メソッド \(DataRow\<xref:System.Data.DataSet> オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列可能性がありますが追加されて XML スキーマに自動化されたプロセスによってです。 場合、ソース [Merge メソッド \(DataRow\<xref:System.Data.DataSet> スキーマ要素が含まれています \(追加 [Merge メソッド \(DataRow\<xref:System.Data.DataColumn> オブジェクト\)、ターゲットに不足して、スキーマ要素は、設定して、ターゲットに追加できる、 `missingSchemaAction` への引数 `MissingSchemaAction.Add`します。 その場合は、統合 [Merge メソッド \(DataRow\<xref:System.Data.DataSet> 、追加されたスキーマとデータが含まれています。  
  
 スキーマのマージ後に、データをマージします。  
  
 新しいソースをマージするときに [Merge メソッド \(DataRow\<xref:System.Data.DataSet> 、ターゲットに任意のソースの行で、 [Merge メソッド \(DataRow\<xref:System.Data.DataRowState> の値 `Unchanged`, 、`Modified`, 、または `Deleted` 、同じプライマリ キーの値を持つ特定の行にも一致します。 ソースを持つ行、 `DataRowState` の値 `Added` 新しいソース行と同じプライマリ キー値を持つ新しいターゲットの行に一致します。  
  
 マージ中に制約が無効になります。 場合は、制約は、merge、年末に有効にすることはできません、 [Merge メソッド \(DataRow\<xref:System.Data.ConstraintException> が生成され、制約を無効にして、結合されたデータは保持されます。 ここで、 [Merge メソッド \(DataRow\<xref:System.Data.DataSet.EnforceConstraints%2A> にプロパティが設定されている `false`, 、無効なすべての行がエラーでマークされるとします。 リセットする前に、エラーを解決する必要があります、 [Merge メソッド \(DataRow\<xref:System.Data.DataSet.EnforceConstraints%2A> プロパティを `true`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> データとスキーマがマージされます。</param>
        <param name="preserveChanges">
          <see langword="true" /> 現在の変更を保存する <see langword="DataSet" />。 そうしないと <see langword="false" />です。</param>
        <param name="missingSchemaAction">
          <see cref="T:System.Data.MissingSchemaAction" /> 値のいずれか。</param>
        <summary>指定されたマージ <see cref="T:System.Data.DataSet" /> および現在のスキーマ <see langword="DataSet" />, を維持し、または現在の変更を破棄する <see langword="DataSet" /> と、指定した引数に応じての互換性のないスキーマを処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.Merge%2A> メソッドを使用して、2 つのマージ <xref:System.Data.DataSet> ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションで既存のデータ ソースから最新の変更を反映する <xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションを更新して <xref:System.Data.DataSet> データ ソースからの最新データです。  
  
 <xref:System.Data.DataSet.Merge%2A> メソッドは通常、一連の変更の検証、エラーを調整、変更されたデータ ソースの更新、および最後に、既存の更新に関連する手順の最後に呼び出されます <xref:System.Data.DataSet>します。  
  
 クライアント アプリケーションでは、通常、単一のボタンをユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証です。 このシナリオでは、 <xref:System.Data.DataSet.GetChanges%2A> メソッドが最初に呼び出されます。 1 秒あたりに返ります <xref:System.Data.DataSet> 検証とマージ用に最適化されています。 次にこの <xref:System.Data.DataSet> オブジェクトのみを含む、 <xref:System.Data.DataTable> と <xref:System.Data.DataRow> 、元のサブセットの結果として、変更されたオブジェクト <xref:System.Data.DataSet>します。 このサブセットは一般的に小さくし、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して、変更を元のデータ ソースを更新します。 中間層が、新しいバックアップを送信できますし、 <xref:System.Data.DataSet> \(再度実行して、元のクエリ\)、元のデータとデータ ソースから最新のデータを含むかして、データ ソースから加えられた変更のサブセットに送り返すことができます。 \(たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値を伝達するクライアント アプリケーションに返信します。\) どちらの場合に返された <xref:System.Data.DataSet> クライアント アプリケーションの元に再び結合することができます <xref:System.Data.DataSet> で、 <xref:System.Data.DataSet.Merge%2A> メソッドです。  
  
 説明を容易にするために、 <xref:System.Data.DataSet.Merge%2A> メソッドを使用して「ターゲット」現在のことを示す <xref:System.Data.DataSet>, 、および 2 つ目の \(パラメーター\) の名前を付けるには、"source" <xref:System.Data.DataSet>します。 ターゲット <xref:System.Data.DataSet> と呼ばれるアクション \(マージ\) が発生しているオブジェクトであるためです。 2 番目 <xref:System.Data.DataSet> も含まれている情報は変わりませんが代わりに、現在に結合されているため、「ソース」と呼びます <xref:System.Data.DataSet>します。  
  
 ときに、 <xref:System.Data.DataSet.Merge%2A> メソッドを呼び出して、2 つのスキーマ <xref:System.Data.DataSet> オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列可能性がありますが追加されて XML スキーマに自動化されたプロセスによってです。 場合、ソース <xref:System.Data.DataSet> スキーマ要素が含まれています \(追加 <xref:System.Data.DataColumn> オブジェクト\)、ターゲットに不足して、スキーマ要素は、設定して、ターゲットに追加できる、 `missingSchemaAction` への引数 `MissingSchemaAction.Add`します。 その場合は、統合 <xref:System.Data.DataSet> 、追加されたスキーマとデータが含まれています。  
  
 スキーマのマージ後に、データをマージします。  
  
 新しいソースをマージするときに <xref:System.Data.DataSet> 、ターゲットに任意のソースの行で、 <xref:System.Data.DataRowState> の値 `Unchanged`, 、`Modified`, 、または `Deleted` 、同じプライマリ キーの値を持つ特定の行にも一致します。 ソースを持つ行、 `DataRowState` の値 `Added` 新しいソース行と同じプライマリ キー値を持つ新しいターゲットの行に一致します。  
  
 マージ中に制約が無効になります。 場合は、制約は、merge、年末に有効にすることはできません、 <xref:System.Data.ConstraintException> が生成され、制約を無効にして、結合されたデータは保持されます。 ここで、 <xref:System.Data.DataSet.EnforceConstraints%2A> にプロパティが設定されている `false`, 、無効なすべての行がエラーでマークされるとします。 リセットする前に、エラーを解決する必要があります、 <xref:System.Data.DataSet.EnforceConstraints%2A> プロパティを `true`します。  
  
   
  
## 例  
 次の例では、単純な <xref:System.Data.DataSet> 1 つのテーブル、2 つの列、および 10 行を使用します。 2 つの値が変更され、1 つの行が追加されます。 使用して、変更されたデータのサブセットを作成、 <xref:System.Data.DataSet.GetChanges%2A> メソッドです。 エラーを解決した後は、新しい列は、スキーマを変更するサブセットに追加されます。 ときに、 <xref:System.Data.DataSet.Merge%2A> メソッドが呼び出された、 `missingSchemaAction` 設定 `MissingSchemaAction.Add`, 、元に新しい列が追加 <xref:System.Data.DataSet> オブジェクトのスキーマです。  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">
          <see langword="DataTable" /> データとスキーマがマージされます。</param>
        <param name="preserveChanges">
          <see cref="T:System.Data.MissingSchemaAction" /> 値のいずれか。</param>
        <param name="missingSchemaAction">
          <see langword="true" /> 変更を保持するために、 <see langword="DataSet" />。 そうしないと <see langword="false" />です。</param>
        <summary>指定されたマージ <see cref="T:System.Data.DataTable" /> とそのスキーマに現在 <see langword="DataSet" />, を維持し、または変更を破棄すること、 <see langword="DataSet" /> と、指定した引数に応じての互換性のないスキーマを処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.Merge%2A> メソッドを使用して、2 つのマージ <xref:System.Data.DataSet> ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションで既存のデータ ソースから最新の変更を反映する <xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションを更新して <xref:System.Data.DataSet> データ ソースからの最新データです。  
  
 <xref:System.Data.DataSet.Merge%2A> メソッドは通常、一連の変更の検証、エラーを調整、変更されたデータ ソースの更新、および最後に、既存の更新に関連する手順の最後に呼び出されます <xref:System.Data.DataSet>します。  
  
 イオン クライアント アプリケーションでは、通常、単一のボタンをユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証です。 このシナリオでは、 <xref:System.Data.DataSet.GetChanges%2A> メソッドが最初に呼び出されます。 1 秒あたりに返ります <xref:System.Data.DataSet> 検証とマージ用に最適化されています。 次にこの <xref:System.Data.DataSet> オブジェクトのみを含む、 <xref:System.Data.DataTable> と <xref:System.Data.DataRow> 、元のサブセットの結果として、変更されたオブジェクト <xref:System.Data.DataSet>します。 このサブセットは一般的に小さくし、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して、変更を元のデータ ソースを更新します。 中間層が、新しいバックアップを送信できますし、 <xref:System.Data.DataSet> \(再度実行して、元のクエリ\)、元のデータとデータ ソースから最新のデータを含むかして、データ ソースから加えられた変更のサブセットに送り返すことができます。 \(たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値を伝達するクライアント アプリケーションに返信します。\) どちらの場合に返された <xref:System.Data.DataSet> クライアント アプリケーションの元に再び結合することができます <xref:System.Data.DataSet> で、 <xref:System.Data.DataSet.Merge%2A> メソッドです。  
  
 ときに、 <xref:System.Data.DataSet.Merge%2A> メソッドを呼び出して、2 つのスキーマ <xref:System.Data.DataSet> オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列可能性がありますが追加されて XML スキーマに自動化されたプロセスによってです。 場合、ソース <xref:System.Data.DataSet> スキーマ要素が含まれています \(追加 <xref:System.Data.DataColumn> オブジェクト\)、ターゲットに不足して、スキーマ要素は、設定して、ターゲットに追加できる、 `missingSchemaAction` への引数 `MissingSchemaAction.Add`します。 その場合は、統合 <xref:System.Data.DataSet> 、追加されたスキーマとデータが含まれています。  
  
 スキーマのマージ後に、データをマージします。  
  
 新しいソースをマージするときに <xref:System.Data.DataSet> 、ターゲットに任意のソースの行で、 <xref:System.Data.DataRowState> の値 `Unchanged`, 、`Modified`, 、または `Deleted` 、同じプライマリ キーの値を持つ特定の行にも一致します。 ソースを持つ行、 `DataRowState` の値 `Added` 新しいソース行と同じプライマリ キー値を持つ新しいターゲットの行に一致します。  
  
 マージ中に制約が無効になります。 場合は、制約は、merge、年末に有効にすることはできません、 <xref:System.Data.ConstraintException> が生成され、制約を無効にして、結合されたデータは保持されます。 ここで、 <xref:System.Data.DataSet.EnforceConstraints%2A> にプロパティが設定されている `false`, 、無効なすべての行がエラーでマークされるとします。 リセットする前に、エラーを解決する必要があります、 <xref:System.Data.DataSet.EnforceConstraints%2A> プロパティを `true`します。  
  
   
  
## 例  
 次の例では、単純な <xref:System.Data.DataSet> 1 つのテーブル、2 つの列、および 10 行を使用します。 1 秒あたり <xref:System.Data.DataTable> に作成された最初のとほぼ同じする点を除いて、新しい `DataColumn` テーブルに追加します。 2 つの行にマージし、2 番目のテーブルに追加されます、 <xref:System.Data.DataSet> で、 `preserveChanges` 引数に設定されて `false`, 、および `missingSchemaAction` 引数に設定されて `MissingSchemaAction.Add`します。  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ターゲットおよびソースときに発生 <see cref="T:System.Data.DataRow" /> 同じ主キーの値があると <see cref="P:System.Data.DataSet.EnforceConstraints" /> 設定を true にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/ja-jp/01e4f1bc-e55e-413f-98c7-6588493e5f67)します。  
  
   
  
## 例  
 次の例では、使用、 <xref:System.Data.DataSet.MergeFailed> イベントです。  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の名前空間、 <see cref="T:System.Data.DataSet" />です。</summary>
        <value>名前空間、 <see cref="T:System.Data.DataSet" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.Namespace%2A> に文書化 XML を読み書きするときにプロパティが使用される、 <xref:System.Data.DataSet> を使用して、 <xref:System.Data.DataSet.ReadXml%2A>, 、<xref:System.Data.DataSet.WriteXml%2A>, 、<xref:System.Data.DataSet.ReadXmlSchema%2A>, 、または <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドです。  
  
 XML ドキュメントの名前空間を使用して XML 属性と要素を読み取るときにスコープする、 <xref:System.Data.DataSet>です。 たとえば場合、 <xref:System.Data.DataSet> スキーマを含む"myCompany、"名前空間を持つドキュメントから読み込まれたと別の名前空間を持つドキュメントからのみデータを読み取るしようとしましたが、既存のスキーマに対応していないすべてのデータは無視されます。  
  
   
  
## 例  
 次の例のセット、 <xref:System.Data.DataSet.Prefix%2A> 呼び出す前に、 <xref:System.Data.DataSet.ReadXml%2A> メソッドです。  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">名前空間は、データを既に持っています。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">イベント データを格納している <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />。</param>
        <summary>
          <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/ja-jp/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> in a derived class, be sure to call the base class' <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> method.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">
          <see cref="T:System.Data.DataRelation" /> 削除されています。</param>
        <summary>発生したときに、 <see cref="T:System.Data.DataRelation" /> からオブジェクトが削除された、 <see cref="T:System.Data.DataTable" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、テーブルの削除を制限するサブクラスによってオーバーライドする必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> 削除されています。</param>
        <summary>発生したときに、 <see cref="T:System.Data.DataTable" /> から削除、 <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サブクラスから削除されているテーブルを制限するには、このメソッドをオーバーライドできます。  
  
   
  
## 例  
 次の例から派生するクラス、 <xref:System.Data.DataSet> で、 <xref:System.Data.DataSet.OnRemoveTable%2A> メソッドをオーバーライドします。  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の名前空間のエイリアスを表すプレフィックス、XML、 <see cref="T:System.Data.DataSet" />です。</summary>
        <value>XML プレフィックス、 <see cref="T:System.Data.DataSet" /> 名前空間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.Prefix%2A> プロパティが XML ドキュメント全体にわたっての名前空間に属している要素を識別するために使用される、 <xref:System.Data.DataSet> オブジェクト \(設定によって、 <xref:System.Data.DataSet.Namespace%2A> プロパティ\)。  
  
   
  
## 例  
 次の例のセット、 <xref:System.Data.DataSet.Prefix%2A> 呼び出す前に、 <xref:System.Data.DataSet.ReadXml%2A> メソッドです。  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">変更されるプロパティの名前。</param>
        <summary>通知の送信、指定した <see cref="T:System.Data.DataSet" /> プロパティが変更されようとしています。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">派生したオブジェクト <see cref="T:System.IO.Stream" />します。</param>
        <summary>XML スキーマとデータを読み取り、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.IO.Stream" />します。</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> データを読み取るために使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.ReadXml%2A> メソッドを提供するいずれかのデータのみを確認する方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントからは、 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、 `ReadXML` を含むオーバー ロード、 `mode` パラメーター、その値に設定し、 `ReadSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.WriteXml%2A> と <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、 `DataSet`, を使用して、 `WriteXml` メソッドです。 スキーマだけを記述する、 `WriteXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 競合 \(たとえば、異なるデータ型で定義されている同じテーブルに同じ列\) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するために、推論によってスキーマを拡張できません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` とそれに対応する XML 要素は関連付けられません `DataColumn` または `DataTable` \(「\_」\) のように有効な XML 文字はシリアル化された XML でエスケープするとします。`DataSet` のみ XML 要素の名前に無効な XML 文字をエスケープ自体と、したがって 귩럊뾭궥귡 と同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、 <xref:System.Data.DataSet> が含まれています `targetNamespace`, データが読み取られず、呼び出すときに例外が発生する可能性があります <xref:System.Data.DataSet.ReadXml%2A> を読み込む、 <xref:System.Data.DataSet> 修飾名前空間のない要素を含む XML をします。 修飾されていない要素を読み取り、次のように設定します。 `elementFormDefault` と等しい"qualified"に、XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスロー、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXml%2A> を指定して `XmlReadMode.ReadSchema`します。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## 例  
 次の例は、単純なをまず作成 <xref:System.Data.DataSet> いずれかで <xref:System.Data.DataTable>, 、2 つの列と 10 行です。<xref:System.Data.DataSet> スキーマとデータがディスクに書き込まを呼び出して、 <xref:System.Data.DataSet.WriteXml%2A> メソッドです。 1 秒あたり <xref:System.Data.DataSet> が作成されると、 <xref:System.Data.DataSet.ReadXml%2A> メソッドを使用して、スキーマとデータを格納します。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="TextReader" /> スキーマとデータを読み取り元です。</param>
        <summary>XML スキーマとデータを読み取り、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.IO.TextReader" />します。</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> データを読み取るために使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.ReadXml%2A> メソッドを提供するいずれかのデータのみを確認する方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントからは、 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、 `ReadXML` を含むオーバー ロード、 `mode` パラメーター、その値に設定し、 `ReadSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.WriteXml%2A> と <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、 `DataSet`, を使用して、 `WriteXml` メソッドです。 スキーマだけを記述する、 `WriteXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 競合 \(たとえば、異なるデータ型で定義されている同じテーブルに同じ列\) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するために、推論によってスキーマを拡張できません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` とそれに対応する XML 要素は関連付けられません `DataColumn` または `DataTable` \(「\_」\) のように有効な XML 文字はシリアル化された XML でエスケープするとします。`DataSet` のみ XML 要素の名前に無効な XML 文字をエスケープ自体と、したがって 귩럊뾭궥귡 と同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、 <xref:System.Data.DataSet> が含まれています `targetNamespace`, データが読み取られず、呼び出すときに例外が発生する可能性があります <xref:System.Data.DataSet.ReadXml%2A> を読み込む、 <xref:System.Data.DataSet> 修飾名前空間のない要素を含む XML をします。 修飾されていない要素を読み取り、次のように設定します。 `elementFormDefault` と等しい"qualified"に XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 継承するクラス、 <xref:System.IO.TextReader> クラスが含まれて、 <xref:System.IO.StreamReader> と <xref:System.IO.StringReader> クラスです。  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスロー、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXml%2A> を指定して `XmlReadMode.ReadSchema`します。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## 例  
 次の例は、単純なをまず作成 <xref:System.Data.DataSet> いずれかで <xref:System.Data.DataTable>, 、2 つの列と 10 行です。<xref:System.Data.DataSet> スキーマとデータがディスクに書き込まを呼び出して、 <xref:System.Data.DataSet.WriteXml%2A> メソッドです。 1 秒あたり <xref:System.Data.DataSet> が作成されると、 <xref:System.Data.DataSet.ReadXml%2A> メソッドを使用して、スキーマとデータを格納します。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">読み取り元 \(パスを含む\) ファイル名です。</param>
        <summary>XML スキーマとデータを読み取り、 <see cref="T:System.Data.DataSet" /> 指定のファイルを使用します。</summary>
        <returns>
          <see langword="XmlReadMode" /> データを読み取るために使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.ReadXml%2A> メソッドを提供するいずれかのデータのみを確認する方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントからは、 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、 `ReadXML` を含むオーバー ロード、 `mode` パラメーター、その値に設定し、 `ReadSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.WriteXml%2A> と <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、 `DataSet`, を使用して、 `WriteXml` メソッドです。 スキーマだけを記述する、 `WriteXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 競合 \(たとえば、異なるデータ型で定義されている同じテーブルに同じ列\) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するために、推論によってスキーマを拡張できません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` とそれに対応する XML 要素は関連付けられません `DataColumn` または `DataTable` \(「\_」\) のように有効な XML 文字はシリアル化された XML でエスケープするとします。`DataSet` のみ XML 要素の名前に無効な XML 文字をエスケープ自体と、したがって 귩럊뾭궥귡 と同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、 <xref:System.Data.DataSet> が含まれています、 `targetNamespace`, データが読み取られず、呼び出すときに例外が発生する可能性があります <xref:System.Data.DataSet.ReadXml%2A> を読み込む、 <xref:System.Data.DataSet> 修飾名前空間のない要素を含む XML をします。 修飾されていない要素を読み取り、次のように設定します。 `elementFormDefault` と等しい"qualified"に XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスロー、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXml%2A> を指定して `XmlReadMode.ReadSchema`します。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## 例  
 次の例は、単純なをまず作成 <xref:System.Data.DataSet> いずれかで <xref:System.Data.DataTable>, 、2 つの列と 10 行です。<xref:System.Data.DataSet> スキーマとデータがディスクに書き込まを呼び出して、 <xref:System.Data.DataSet.WriteXml%2A> メソッドです。 1 秒あたり <xref:System.Data.DataSet> が作成されると、 <xref:System.Data.DataSet.ReadXml%2A> メソッドを使用して、スキーマとデータを格納します。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> 設定されていない <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />します。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading and writing files. Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> 読み取り元です。</param>
        <summary>XML スキーマとデータを読み取り、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.Xml.XmlReader" />します。</summary>
        <returns>
          <see langword="XmlReadMode" /> データを読み取るために使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.ReadXml%2A> メソッドを提供するいずれかのデータのみを確認する方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントからは、 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、 `ReadXML` を含むオーバー ロード、 `mode` パラメーター、その値に設定し、 `ReadSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.WriteXml%2A> と <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、 `DataSet`, を使用して、 `WriteXml` メソッドです。 スキーマだけを記述する、 `WriteXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 競合 \(たとえば、異なるデータ型で定義されている同じテーブルに同じ列\) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するために、推論によってスキーマを拡張できません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` とそれに対応する XML 要素は関連付けられません `DataColumn` または `DataTable` \(「\_」\) のように有効な XML 文字はシリアル化された XML でエスケープするとします。`DataSet` のみ XML 要素の名前に無効な XML 文字をエスケープ自体と、したがって 귩럊뾭궥귡 と同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、 <xref:System.Data.DataSet> が含まれています、 `targetNamespace`, データが読み取られず、呼び出すときに例外が発生する可能性があります <xref:System.Data.DataSet.ReadXml%2A> を読み込む、 <xref:System.Data.DataSet> 修飾名前空間のない要素を含む XML をします。 修飾されていない要素を読み取り、次のように設定します。 `elementFormDefault` と等しい"qualified"に XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=fullName> は <xref:System.Xml.XmlReader> を継承します。  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスロー、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXml%2A> を指定して `XmlReadMode.ReadSchema`します。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## 例  
 次の例は、単純なをまず作成 <xref:System.Data.DataSet> いずれかで <xref:System.Data.DataTable>, 、2 つの列と 10 行です。<xref:System.Data.DataSet> スキーマとデータがディスクに書き込まを呼び出して、 <xref:System.Data.DataSet.WriteXml%2A> メソッドです。 1 秒あたり <xref:System.Data.DataSet> が作成されると、 <xref:System.Data.DataSet.ReadXml%2A> メソッドを使用して、スキーマとデータを格納します。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> 読み取り元です。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlReadMode" /> 値のいずれか 1 つ。</param>
        <summary>XML スキーマとデータを読み取り、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.IO.Stream" /> と <see cref="T:System.Data.XmlReadMode" />です。</summary>
        <returns>
          <see langword="XmlReadMode" /> データを読み取るために使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.ReadXml%2A> メソッドを提供するいずれかのデータのみを確認する方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントからは、 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、 `ReadXML` を含むオーバー ロード、 `mode` パラメーター、その値に設定し、 `ReadSchema`します。  
  
 場合も同様です、 <xref:System.Data.DataSet.WriteXml%2A> と <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、 `DataSet`, を使用して、 `WriteXml` メソッドです。 スキーマだけを記述する、 `WriteXmlSchema` メソッドです。  
  
> [!NOTE]
>  使用すると <xref:System.Data.DataSet.ReadXml%2A> を設定して <xref:System.Data.XmlReadMode> に `Diffgram`, 、ターゲットのコンテンツ `DataSet` し、元 `DataSet` 、diffgram の生成し、処理の方法により異なる場合があります。 Diffgram の詳細については、次を参照してください。 [DiffGrams](http://msdn.microsoft.com/ja-jp/037f3991-7bbc-424b-b52e-8b03585d3e34)します。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 競合 \(たとえば、異なるデータ型で定義されている同じテーブルに同じ列\) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するために、推論によってスキーマを拡張できません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` とそれに対応する XML 要素は関連付けられません `DataColumn` または `DataTable` \(「\_」\) のように有効な XML 文字はシリアル化された XML でエスケープするとします。`DataSet` のみ XML 要素の名前に無効な XML 文字をエスケープ自体と、したがって 귩럊뾭궥귡 と同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、 <xref:System.Data.DataSet> が含まれています `targetNamespace`, データが読み取られず、呼び出すときに例外が発生する可能性があります <xref:System.Data.DataSet.ReadXml%2A> を読み込む、 <xref:System.Data.DataSet> 修飾名前空間のない要素を含む XML をします。 修飾されていない要素を読み取り、次のように設定します。 `elementFormDefault` と等しい"qualified"に XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスロー、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXml%2A> を指定して `XmlReadMode.ReadSchema`します。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> 読み取り元です。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlReadMode" /> 値のいずれか。</param>
        <summary>XML スキーマとデータを読み取り、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.IO.TextReader" /> と <see cref="T:System.Data.XmlReadMode" />です。</summary>
        <returns>
          <see langword="XmlReadMode" /> データを読み取るために使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.ReadXml%2A> メソッドを提供するいずれかのデータのみを確認する方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントからは、 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、 `ReadXML` を含むオーバー ロード、 `mode` パラメーター、その値に設定し、 `ReadSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.WriteXml%2A> と <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、 `DataSet`, を使用して、 `WriteXml` メソッドです。 スキーマだけを記述する、 `WriteXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 競合 \(たとえば、異なるデータ型で定義されている同じテーブルに同じ列\) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するために、推論によってスキーマを拡張できません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` とそれに対応する XML 要素は関連付けられません `DataColumn` または `DataTable` \(「\_」\) のように有効な XML 文字はシリアル化された XML でエスケープするとします。`DataSet` のみ XML 要素の名前に無効な XML 文字をエスケープ自体と、したがって 귩럊뾭궥귡 と同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、 <xref:System.Data.DataSet> が含まれています `targetNamespace`, データが読み取られず、呼び出すときに例外が発生する可能性があります <xref:System.Data.DataSet.ReadXml%2A> を読み込む、 <xref:System.Data.DataSet> 修飾名前空間のない要素を含む XML をします。 修飾されていない要素を読み取り、次のように設定します。 `elementFormDefault` と等しい"qualified"に XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスロー、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXml%2A> を指定して `XmlReadMode.ReadSchema`します。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">読み取り元 \(パスを含む\) ファイル名です。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlReadMode" /> 値のいずれか。</param>
        <summary>XML スキーマとデータを読み取り、 <see cref="T:System.Data.DataSet" /> 指定のファイルを使用し、 <see cref="T:System.Data.XmlReadMode" />です。</summary>
        <returns>
          <see langword="XmlReadMode" /> データを読み取るために使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.ReadXml%2A> メソッドを提供するいずれかのデータのみを確認する方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントからは、 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、 `ReadXML` を含むオーバー ロード、 `mode` パラメーター、その値に設定し、 `ReadSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.WriteXml%2A> と <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、 `DataSet`, を使用して、 `WriteXml` メソッドです。 スキーマだけを記述する、 `WriteXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 競合 \(たとえば、異なるデータ型で定義されている同じテーブルに同じ列\) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するために、推論によってスキーマを拡張できません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` とそれに対応する XML 要素は関連付けられません `DataColumn` または `DataTable` \(「\_」\) のように有効な XML 文字はシリアル化された XML でエスケープするとします。`DataSet` のみ XML 要素の名前に無効な XML 文字をエスケープ自体と、したがって 귩럊뾭궥귡 と同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、 <xref:System.Data.DataSet> が含まれています、 `targetNamespace`, データが読み取られず、呼び出すときに例外が発生する可能性があります <xref:System.Data.DataSet.ReadXml%2A> を読み込む、 <xref:System.Data.DataSet> 修飾名前空間のない要素を含む XML をします。 修飾されていない要素を読み取り、次のように設定します。 `elementFormDefault` と等しい"qualified"に XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスロー、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXml%2A> を指定して `XmlReadMode.ReadSchema`します。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> 設定されていない <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />します。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading and writing files. Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> 読み取り元です。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlReadMode" /> 値のいずれか。</param>
        <summary>XML スキーマとデータを読み取り、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.Xml.XmlReader" /> と <see cref="T:System.Data.XmlReadMode" />です。</summary>
        <returns>
          <see langword="XmlReadMode" /> データを読み取るために使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Data.DataSet.ReadXml%2A> メソッドを提供するいずれかのデータのみを確認する方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントからは、 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、 `ReadXML` を含むオーバー ロード、 `mode` パラメーター、その値に設定し、 `ReadSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.WriteXml%2A> と <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、 `DataSet`, を使用して、 `WriteXml` メソッドです。 スキーマだけを記述する、 `WriteXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 競合 \(たとえば、異なるデータ型で定義されている同じテーブルに同じ列\) がある場合は、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 すべてのデータを公開するために、推論によってスキーマを拡張できません、例外が発生します。  
  
> [!NOTE]
>  `DataSet` とそれに対応する XML 要素は関連付けられません `DataColumn` または `DataTable` \(「\_」\) のように有効な XML 文字はシリアル化された XML でエスケープするとします。`DataSet` のみ XML 要素の名前に無効な XML 文字をエスケープ自体と、したがって 귩럊뾭궥귡 と同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、 <xref:System.Data.DataSet> が含まれています、 `targetNamespace`, データが読み取られず、呼び出すときに例外が発生する可能性があります <xref:System.Data.DataSet.ReadXml%2A> を読み込む、 <xref:System.Data.DataSet> 修飾名前空間のない要素を含む XML をします。 修飾されていない要素を読み取り、次のように設定します。 `elementFormDefault` と等しい"qualified"に XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスロー、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXml%2A> を指定して `XmlReadMode.ReadSchema`します。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> 読み取り元です。</param>
        <summary>指定された対象から XML スキーマを読み込みます <see cref="T:System.IO.Stream" /> に、 <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Data.DataSet.ReadXmlSchema%2A> のスキーマを作成する方法、 <xref:System.Data.DataSet>です。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。 XML ドキュメントにスキーマを記述する、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
> [!NOTE]
>  データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドを呼び出す前に、通常、 <xref:System.Data.DataSet.ReadXml%2A> の塗りつぶしに使用するメソッド、 <xref:System.Data.DataSet>です。  
  
 派生するクラス、 <xref:System.IO.Stream> クラスが含まれて <xref:System.IO.BufferedStream>, 、<xref:System.IO.FileStream>, 、<xref:System.IO.MemoryStream>, 、および <xref:System.Net.Sockets.NetworkStream>です。  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスローする、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXmlSchema%2A>です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## 例  
 次の例、 <xref:System.IO.FileStream> オブジェクトを XML スキーマとなり、 <xref:System.Data.DataSet.ReadXmlSchema%2A> オブジェクトを持つメソッドです。  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> 読み取り元です。</param>
        <summary>指定された対象から XML スキーマを読み込みます <see cref="T:System.IO.TextReader" /> に、 <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Data.DataSet.ReadXmlSchema%2A> のスキーマを作成する方法、 <xref:System.Data.DataSet>です。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。 XML ドキュメントにスキーマを記述する、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
> [!NOTE]
>  データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドを呼び出す前に、通常、 <xref:System.Data.DataSet.ReadXml%2A> の塗りつぶしに使用するメソッド、 <xref:System.Data.DataSet>です。  
  
 継承するクラス、 <xref:System.IO.TextReader> クラスが含まれて、 <xref:System.IO.StreamReader> と <xref:System.IO.StringReader> クラスです。  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスローする、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXmlSchema%2A>です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## 例  
 次の例、 <xref:System.IO.StreamReader> 、スキーマを読み取ったりオブジェクトとなり、 <xref:System.Data.DataSet.ReadXmlSchema%2A> オブジェクトを持つメソッドです。  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">ファイルを読み取る対象の名前 \(パスを含む\)。</param>
        <summary>指定したファイルから XML スキーマを読み取り、 <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Data.DataSet.ReadXmlSchema%2A> のスキーマを作成する方法、 <xref:System.Data.DataSet>です。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。 XML ドキュメントにスキーマを記述する、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
> [!NOTE]
>  データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドを呼び出す前に、通常、 <xref:System.Data.DataSet.ReadXml%2A> の塗りつぶしに使用するメソッド、 <xref:System.Data.DataSet>です。  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスロー、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXmlSchema%2A>です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## 例  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> 設定されていない <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />します。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading and writing files. Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> 読み取り元です。</param>
        <summary>指定された対象から XML スキーマを読み込みます <see cref="T:System.Xml.XmlReader" /> に、 <see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Data.DataSet.ReadXmlSchema%2A> のスキーマを作成する方法、 <xref:System.Data.DataSet>です。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
> [!NOTE]
>  データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドを呼び出す前に、通常、 <xref:System.Data.DataSet.ReadXml%2A> の塗りつぶしに使用するメソッド、 <xref:System.Data.DataSet>です。  
  
 <xref:System.Xml.XmlReader?displayProperty=fullName> クラスは抽象クラスです。 継承するクラス、 `XmlReader` は、 <xref:System.Xml.XmlTextReader?displayProperty=fullName> クラスです。  
  
> [!NOTE]
>  場合のスキーマ、 <xref:System.Data.DataSet> 要素が含まれていますにスキーマを読み取ろうとしたときに、同じ名前が同じ名前空間内の別の種類の例外がスローする、 <xref:System.Data.DataSet> と <xref:System.Data.DataSet.ReadXmlSchema%2A>です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## 例  
 次の例が、新たに作成 <xref:System.Data.DataSet> と <xref:System.IO.FileStream?displayProperty=fullName> オブジェクトです。<xref:System.IO.FileStream> を作成するファイルのパスとファイル名で作成されたオブジェクトが使用される、 <xref:System.Xml.XmlTextReader?displayProperty=fullName> への引数として渡される、 <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッドです。  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">指定した XML リーダー。</param>
        <summary>属性を無視し、空のデータセットを返します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>加えられたすべての変更をロールバック、 <see cref="T:System.Data.DataSet" /> が、作成後、または前回 <see cref="M:System.Data.DataSet.AcceptChanges" /> 呼び出されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す、 <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=fullName> を呼び出して、 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> メソッドをすべて <xref:System.Data.DataTable> に含まれるオブジェクト、 <xref:System.Data.DataSet>です。  
  
 <xref:System.Data.DataRow> 含まれるオブジェクト、 <xref:System.Data.DataSet> ごとに設定できる編集モードを呼び出して、 <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=fullName> メソッドです。 呼び出した後、 <xref:System.Data.DataRow.EndEdit%2A?displayProperty=fullName> メソッドを呼び出して変更が拒否されることも、 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> 上、 <xref:System.Data.DataTable> する、 <xref:System.Data.DataRow> オブジェクトが属しています。  
  
 ときに、 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> メソッドが呼び出されると、編集モードにまだ行が、編集をキャンセルします。 新しい行が削除されます。 元の状態を変更および削除された行に返す \(`DataRowState.Unchanged`\)。  
  
 Acceptchange と Rejectchange にのみ適用 <xref:System.Data.DataRow> 関連の変更 \(つまり、 `Add`, 、`Remove`, 、`Delete`, 、および `Modify`\)。 これらはスキーマまたは構造の変更を適用できません。  
  
   
  
## 例  
 次の例から派生するクラス、 <xref:System.Data.DataSet> クラスです。<xref:System.Data.DataSet.RejectChanges%2A> イベントが関数内から呼び出されます。  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーブルをリンクし、ナビゲーションの親から子テーブルへのテーブルを可能にするリレーションシップのコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Data.DataRelationCollection" /> オブジェクトのコレクションを格納している <see cref="T:System.Data.DataRelation" />。 ない場合、空のコレクションが返される <see cref="T:System.Data.DataRelation" /> オブジェクトが存在します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例でを介してすべての子テーブルの列の名前を表示、 <xref:System.Data.DataSet.Relations%2A> プロパティです。  
  
 [!code-vb[Classic WebData DataSet.Relations Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 <see cref="T:System.Data.SerializationFormat" /> の <see cref="T:System.Data.DataSet" /> リモート処理中に使用します。</summary>
        <value>
          <see cref="T:System.Data.SerializationFormat" /> オブジェクト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのテーブルをクリアし、すべての関係、外部の制約、およびテーブルからの削除、 <see cref="T:System.Data.DataSet" />です。 サブクラスをオーバーライドする必要があります <see cref="M:System.Data.DataSet.Reset" /> を復元する、 <see cref="T:System.Data.DataSet" /> 元の状態にします。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 <see cref="T:System.Data.SchemaSerializationMode" /> の <see cref="T:System.Data.DataSet" />です。</summary>
        <value>取得または設定、 <see cref="T:System.Data.SchemaSerializationMode" /> の <see cref="T:System.Data.DataSet" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Data.DataSet> Web サービスとリモート処理のシナリオでは既定のスキーマとインスタンス データをシリアル化します。 設定、 <xref:System.Data.DataSet.SchemaSerializationMode%2A> プロパティの型指定された `DataSet` に <xref:System.Data.SchemaSerializationMode.ExcludeSchema> スキーマ情報がシリアル化ペイロードから除外します。  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 型指定されたに対してのみ `DataSet`します。 型指定のされていないため `DataSet` のみこのプロパティを設定できます <xref:System.Data.SchemaSerializationMode.IncludeSchema>します。  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> スキーマ情報を基になるが型指定された場合にのみ使用する必要があります `DataTables`, 、`DataRelations` と `Constraints` は変更されていません。 変更が必要で、完全なスキーマ情報をシリアル化する必要があります <xref:System.Data.SchemaSerializationMode.IncludeSchema>します。  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> バージョン 2.0 以降の .NET Framework でサポートされています。  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 設定すると、上に存在トップ レベルのランタイム プロパティのみ、 <xref:System.Data.DataSet> はシリアル化します。 さらに、既定値とは異なるられない場合にのみをシリアル化します。 いずれも、 `Tables`, 、`Relations` または `Constraints` はシリアル化します。 シリアル化されたランタイム プロパティには、 <xref:System.Data.DataSet.DataSetName%2A>, 、<xref:System.Data.DataSet.Namespace%2A>, 、<xref:System.Data.DataSet.Prefix%2A>, 、<xref:System.Data.DataSet.Locale%2A>, 、<xref:System.Data.DataSet.EnforceConstraints%2A>, 、および <xref:System.Data.DataSet.CaseSensitive%2A>です。 これらのプロパティは、全体的な実行時データの整合性が維持されるかどうかを確認するシリアル化されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>示す値を取得するかどうか <see cref="P:System.Data.DataSet.Relations" /> プロパティを永続化する必要があります。</summary>
        <returns>
          <see langword="true" /> プロパティの値が既定から変更されている場合それ以外の場合 <see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 いずれかのデザイナーを作成する場合は通常このメソッドを使用する、 <xref:System.Data.DataSet>, 、組み込むこと、独自のコントロールを作成するか、 <xref:System.Data.DataSet>です。  
  
   
  
## 例  
 次の例から派生するクラスを示して、 <xref:System.Data.DataSet> クラスです。<xref:System.Data.DataSet.Reset%2A> と <xref:System.Data.DataSet.ShouldSerializeRelations%2A> メソッドは派生クラスの関数内から起動します。  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>示す値を取得するかどうか <see cref="P:System.Data.DataSet.Tables" /> プロパティを永続化する必要があります。</summary>
        <returns>
          <see langword="true" /> プロパティの値が既定から変更されている場合それ以外の場合 <see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 デザイナーを作成するか、場合にのみ通常このメソッドを使用する、 <xref:System.Data.DataSet>, 、組み込むこと、独自のコントロールを作成するか、 <xref:System.Data.DataSet>です。  
  
   
  
## 例  
 次の例から派生するクラス、 <xref:System.Data.DataSet> クラスです。<xref:System.Data.DataSet.ShouldSerializeTables%2A> 派生クラスの関数内から呼び出されます。  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" /> の <see cref="T:System.ComponentModel.ISite" /> を取得または設定します。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> の <see cref="T:System.Data.DataSet" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サイトのバインド、 <xref:System.ComponentModel.Component> に、 <xref:System.ComponentModel.Container> と、それらの間の通信を有効にするだけでなく、コンテナーがコンポーネントを管理するための手段を提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />」をご覧ください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.ComponentModel.IListSource> インターフェイスにキャストされる場合にのみ、使用できます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.ComponentModel.IListSource.GetList" />」を参照してください。</summary>
        <returns>このメンバーの詳細については、「<see cref="M:System.ComponentModel.IListSource.GetList" />」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.ComponentModel.IListSource> インターフェイスにキャストされる場合にのみ、使用できます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />」を参照してください。</summary>
        <returns>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />
        </param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" />
        </param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>含まれているテーブルのコレクションを取得、 <see cref="T:System.Data.DataSet" />です。</summary>
        <value>
          <see cref="T:System.Data.DataTableCollection" /> これに含まれる <see cref="T:System.Data.DataSet" />です。 ない場合、空のコレクションが返される <see cref="T:System.Data.DataTable" /> オブジェクトが存在します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 テーブルをコレクションに追加するには使用 <xref:System.Data.DataTableCollection.Add%2A> のメソッド、 <xref:System.Data.DataTableCollection>です。 テーブルを削除するには、使用、 <xref:System.Data.DataTableCollection.Remove%2A> メソッドです。  
  
   
  
## 例  
 次の例、 <xref:System.Data.DataSet> オブジェクトの <xref:System.Data.DataTableCollection>, 、各テーブルの行と列を出力します。  
  
 [!code-csharp[Classic WebData DataSet.Tables Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> ファイルへの書き込みに使用されるオブジェクト。</param>
        <summary>現在のデータを書き込み、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.IO.Stream" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `WriteXml` メソッドを提供するいずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> XML ドキュメントに対し、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドは、スキーマだけを書き込みます。 記述するにはデータとスキーマの両方を含むオーバー ロードのいずれかを使用して、 `mode` パラメーター、その値に設定し、 `WriteSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.ReadXml%2A> と <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、 `DataSet`, を使用して、 `ReadXml` メソッドです。 スキーマだけを読み取るには使用、 `ReadXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.IO.FileStream?displayProperty=fullName> オブジェクトです。 オブジェクトを使用して、 <xref:System.Data.DataSet.WriteXml%2A> に XML ドキュメントを書き込みます。  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> 書き込みに使用するオブジェクト。</param>
        <summary>現在のデータを書き込み、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.IO.TextWriter" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `WriteXml` メソッドを提供するいずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> XML ドキュメントに対し、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドは、スキーマだけを書き込みます。 記述するにはデータとスキーマの両方を含むオーバー ロードのいずれかを使用して、 `mode` パラメーター、その値に設定し、 `WriteSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.ReadXml%2A> と <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、 `DataSet`, を使用して、 `ReadXml` メソッドです。 スキーマだけを読み取るには使用、 `ReadXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">ファイルを記述する名前 \(パスを含む\)。</param>
        <summary>現在のデータを書き込み、 <see cref="T:System.Data.DataSet" /> 指定したファイルにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `WriteXml` メソッドを提供するいずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> XML ドキュメントに対し、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドは、スキーマだけを書き込みます。 記述するにはデータとスキーマの両方を含むオーバー ロードのいずれかを使用して、 `mode` パラメーター、その値に設定し、 `WriteSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.ReadXml%2A> と <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、 `DataSet`, を使用して、 `ReadXml` メソッドです。 スキーマだけを読み取るには使用、 `ReadXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> 設定されていない <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />します。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading and writing files. Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> 書き込みに使用します。</param>
        <summary>現在のデータを書き込み、 <see cref="T:System.Data.DataSet" /> を指定した <see cref="T:System.Xml.XmlWriter" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `WriteXml` メソッドを提供するいずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> XML ドキュメントに対し、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドは、スキーマだけを書き込みます。 記述するにはデータとスキーマの両方を含むオーバー ロードのいずれかを使用して、 `mode` パラメーター、その値に設定し、 `WriteSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.ReadXml%2A> と <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、 `DataSet`, を使用して、 `ReadXml` メソッドです。 スキーマだけを読み取るには使用、 `ReadXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> ファイルへの書き込みに使用されるオブジェクト。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか。</param>
        <summary>現在のデータと、必要に応じて、スキーマを書き込み、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.IO.Stream" /> と <see cref="T:System.Data.XmlWriteMode" />です。 スキーマを作成するには、値を設定、 <paramref name="mode" /> パラメーターを <see langword="WriteSchema" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `WriteXml` メソッドを提供するいずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> XML ドキュメントに対し、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドは、スキーマだけを書き込みます。 データとスキーマの両方を作成するには、設定、 `mode` パラメーターを `WriteSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.ReadXml%2A> と <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、 `DataSet`, を使用して、 `ReadXml` メソッドです。 スキーマだけを読み取るには使用、 `ReadXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.IO.TextWriter" /> 、ドキュメントの書き込みに使用されるオブジェクト。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか 1 つ。</param>
        <summary>現在のデータと、必要に応じて、スキーマを書き込み、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.IO.TextWriter" /> と <see cref="T:System.Data.XmlWriteMode" />です。 スキーマを作成するには、値を設定、 <paramref name="mode" /> パラメーターを <see langword="WriteSchema" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `WriteXml` メソッドを提供するいずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> XML ドキュメントに対し、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドは、スキーマだけを書き込みます。 データとスキーマの両方を作成するには、設定、 `mode` パラメーターを `WriteSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.ReadXml%2A> と <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、 `DataSet`, を使用して、 `ReadXml` メソッドです。 スキーマだけを読み取るには使用、 `ReadXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
   
  
## 例  
 次の例は、単純なをまず作成 <xref:System.Data.DataSet> いずれかで <xref:System.Data.DataTable>, 、2 つの列と 10 行です。<xref:System.Data.DataSet> スキーマとデータがディスクに書き込まを呼び出して、 <xref:System.Data.DataSet.WriteXml%2A> メソッドです。 1 秒あたり <xref:System.Data.DataSet> が作成されると、 <xref:System.Data.DataSet.ReadXml%2A> メソッドを使用して、スキーマとデータを格納します。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">ファイルを記述する名前 \(パスを含む\)。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか 1 つ。</param>
        <summary>現在のデータと、必要に応じて、スキーマを書き込み、 <see cref="T:System.Data.DataSet" /> 指定して、指定したファイルに <see cref="T:System.Data.XmlWriteMode" />します。 スキーマを作成するには、値を設定、 <paramref name="mode" /> パラメーターを <see langword="WriteSchema" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `WriteXml` メソッドを提供するいずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> XML ドキュメントに対し、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドは、スキーマだけを書き込みます。 データとスキーマの両方を作成するには、設定、 `mode` パラメーターを `WriteSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.ReadXml%2A> と <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、 `DataSet`, を使用して、 `ReadXml` メソッドです。 スキーマだけを読み取るには使用、 `ReadXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
   
  
## 例  
 次の例では、 <xref:System.Data.DataSet.WriteXml%2A> に XML ドキュメントを書き込みます。  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> 設定されていない <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />します。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading and writing files. Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> 書き込みに使用します。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 値のいずれか。</param>
        <summary>現在のデータと、必要に応じて、スキーマを書き込み、 <see cref="T:System.Data.DataSet" /> 指定して <see cref="T:System.Xml.XmlWriter" /> と <see cref="T:System.Data.XmlWriteMode" />です。 スキーマを作成するには、値を設定、 <paramref name="mode" /> パラメーターを <see langword="WriteSchema" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `WriteXml` メソッドを提供するいずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> XML ドキュメントに対し、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドは、スキーマだけを書き込みます。 データとスキーマの両方を作成するには、設定、 `mode` パラメーターを `WriteSchema`します。  
  
 同じに注意してください、 <xref:System.Data.DataSet.ReadXml%2A> と <xref:System.Data.DataSet.ReadXmlSchema%2A> メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、 `DataSet`, を使用して、 `ReadXml` メソッドです。 スキーマだけを読み取るには使用、 `ReadXmlSchema` メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> で列の型の場合にスロー、 `DataRow` から読み取られたり、実装に書き込まれる <xref:System.Dynamic.IDynamicMetaObjectProvider> を実装していません <xref:System.Xml.Serialization.IXmlSerializable>します。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.IO.FileStream?displayProperty=fullName> 新規作成に使用されるオブジェクト <xref:System.Xml.XmlTextWriter?displayProperty=fullName>します。<xref:System.Xml.XmlTextWriter> オブジェクトでは、使用して、 <xref:System.Data.DataSet.WriteXml%2A> に XML ドキュメントを書き込みます。  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> ファイルへの書き込みに使用されるオブジェクト。</param>
        <summary>書き込み、 <see cref="T:System.Data.DataSet" /> 構造体を指定された XML スキーマとして <see cref="T:System.IO.Stream" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Data.DataSet.WriteXmlSchema%2A> のスキーマを記述するメソッド、 <xref:System.Data.DataSet> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。 XML ドキュメントにスキーマを記述する、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、 <xref:System.Data.DataSet.WriteXml%2A> メソッドです。  
  
 派生するクラス、 <xref:System.IO.Stream> クラスが含まれて <xref:System.IO.BufferedStream>, 、<xref:System.IO.FileStream>, 、<xref:System.IO.MemoryStream>, 、および <xref:System.Net.Sockets.NetworkStream>です。  
  
   
  
## 例  
 次の例が、新たに作成 <xref:System.IO.FileStream> に渡されるオブジェクト、 <xref:System.Data.DataSet.WriteXmlSchema%2A> にスキーマをディスクに書き込みます。  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">書き込む対象の <see cref="T:System.IO.TextWriter" /> オブジェクト。</param>
        <summary>XML スキーマとして <see cref="T:System.Data.DataSet" /> 構造体を指定した <see cref="T:System.IO.TextWriter" /> オブジェクトに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use the <xref:System.Data.DataSet.WriteXmlSchema%2A> method to write the schema for a <xref:System.Data.DataSet> to an XML document. The schema includes table, relation, and constraint definitions. To write a schema to an XML document, use the <xref:System.Data.DataSet.WriteXmlSchema%2A> method.  
  
 The XML schema is written using the XSD standard.  
  
 To write the data to an XML document, use the <xref:System.Data.DataSet.WriteXml%2A> method.  
  
 Classes the derive from the <xref:System.IO.TextWriter?displayProperty=fullName> class include the <xref:System.Web.HttpWriter?displayProperty=fullName>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=fullName>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=fullName>, <xref:System.IO.StreamWriter?displayProperty=fullName>, and <xref:System.IO.StringWriter?displayProperty=fullName>.  
  
   
  
## 例  
 The following example creates a <xref:System.Text.StringBuilder?displayProperty=fullName> object to that is used to create a new <xref:System.IO.StringWriter?displayProperty=fullName>. The <xref:System.IO.StringWriter> is passed to the <xref:System.Data.DataSet.WriteXmlSchema%2A> method, and the resulting string is printed to the console window.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">ファイルを記述する名前 \(パスを含む\)。</param>
        <summary>書き込み、 <see cref="T:System.Data.DataSet" /> ファイルに XML スキーマと構造が作成されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Data.DataSet.WriteXmlSchema%2A> のスキーマを記述するメソッド、 <xref:System.Data.DataSet> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。 XML ドキュメントにスキーマを記述する、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、 <xref:System.Data.DataSet.WriteXml%2A> メソッドです。  
  
   
  
## 例  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> 設定されていない <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />します。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading and writing files. Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">書き込み先の <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>書き込み、 <see cref="T:System.Data.DataSet" /> する XML スキーマと構造、 <see cref="T:System.Xml.XmlWriter" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Data.DataSet.WriteXmlSchema%2A> のスキーマを記述するメソッド、 <xref:System.Data.DataSet> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれます。 XML ドキュメントにスキーマを記述する、 <xref:System.Data.DataSet.WriteXmlSchema%2A> メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、 <xref:System.Data.DataSet.WriteXml%2A> メソッドです。  
  
 1 つのクラスから継承する、 <xref:System.Xml.XmlWriter?displayProperty=fullName> クラスは、 <xref:System.Xml.XmlTextWriter?displayProperty=fullName> クラスです。  
  
   
  
## 例  
 次の例が、新たに作成 <xref:System.IO.FileStream?displayProperty=fullName> 、指定したパスのオブジェクト。<xref:System.IO.FileStream> オブジェクトを使用して作成する、 <xref:System.Xml.XMLTextWriter?displayProperty=fullName> オブジェクトです。<xref:System.Data.DataSet.WriteXmlSchema%2A> でメソッドが呼び出され、 <xref:System.Xml.XmlTextWriter> にスキーマをディスクに書き込むオブジェクト。  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example\#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> に書き込むオブジェクト。</param>
        <param name="multipleTargetConverter">変換に使用するデリゲート <see cref="T:System.Type" /> 文字列にします。</param>
        <summary>書き込み、 <see cref="T:System.Data.DataSet" /> 構造体を指定された XML スキーマとして <see cref="T:System.IO.Stream" /> オブジェクトです。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.IO.TextWriter" /> に書き込むオブジェクト。</param>
        <param name="multipleTargetConverter">変換に使用するデリゲート <see cref="T:System.Type" /> 文字列にします。</param>
        <summary>書き込み、 <see cref="T:System.Data.DataSet" /> 構造体を指定された XML スキーマとして <see cref="T:System.IO.TextWriter" />します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">書き込み先ファイルの名前。</param>
        <param name="multipleTargetConverter">変換に使用するデリゲート <see cref="T:System.Type" /> 文字列にします。</param>
        <summary>書き込み、 <see cref="T:System.Data.DataSet" /> ファイルに XML スキーマと構造が作成されます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.Xml.XmlWriter" /> に書き込むオブジェクト。</param>
        <param name="multipleTargetConverter">変換に使用するデリゲート <see cref="T:System.Type" /> 文字列にします。</param>
        <summary>書き込み、 <see cref="T:System.Data.DataSet" /> 構造体を指定された XML スキーマとして <see cref="T:System.Xml.XmlWriter" />します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML スキーマを読み取り、 <see cref="T:System.Data.DataSet" />です。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataSet" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML スキーマとデータを読み取り、 <see cref="T:System.Data.DataSet" />です。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML データ、および必要に応じて、スキーマを書き込みます、 <see cref="T:System.Data.DataSet" />です。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Data.DataSet" /> が新しい、削除、または変更された行を含めて、変更します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたマージ <see cref="T:System.Data.DataSet" />, 、<see cref="T:System.Data.DataTable" />, 、または配列の <see cref="T:System.Data.DataRow" /> オブジェクトを現在に <see langword="DataSet" /> または <see langword="DataTable" />です。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>書き込み、 <see cref="T:System.Data.DataSet" /> XML スキーマと構造が作成されます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コピーを取得、 <see cref="T:System.Data.DataSet" /> で行われた後、読み込まれた最後後またはすべての変更を含む <see cref="M:System.Data.DataSet.AcceptChanges" /> 呼び出されました。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML スキーマの適用、 <see cref="T:System.Data.DataSet" />です。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>