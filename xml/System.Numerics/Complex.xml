<Type Name="Complex" FullName="System.Numerics.Complex">
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>複素数を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 A complex number is a number that comprises a real number part and an imaginary number part. A complex number **math tag is not supported!!!!**  
 is usually written in the form **math tag is not supported!!!!**  
, where **placeholder tag is not supported!!!!**  
 and **placeholder tag is not supported!!!!**  
 are real numbers, and **placeholder tag is not supported!!!!**  
 is the imaginary unit that has the property **placeholder tag is not supported!!!!**  
<sup>2</sup> \= \-1. The real part of the complex number is represented by **placeholder tag is not supported!!!!**  
, and the imaginary part of the complex number is represented by **placeholder tag is not supported!!!!**  
.  
  
 The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system \(real, imaginary\) when instantiating and manipulating complex numbers. A complex number can be represented as a point in a two\-dimensional coordinate system, which is known as the complex plane. The real part of the complex number is positioned on the x\-axis \(the horizontal axis\), and the imaginary part is positioned on the y\-axis \(the vertical axis\).  
  
 Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:  
  
-   Its magnitude, which is the distance of the point from the origin \(that is, 0,0, or the point at which the x\-axis and the y\-axis intersect\).  
  
-   Its phase, which is the angle between the real axis and the line drawn from the origin to the point.  
  
## Instantiating a Complex Number  
 You can assign a value to a complex number in one of the following ways:  
  
-   By passing two <xref:System.Double> values to its constructor. The first value represents the real part of the complex number, and the second value represents its imaginary part. These values represent the position of the complex number in the two\-dimensional Cartesian coordinate system.  
  
-   By calling the static \(**languageKeyword tag is not supported!!!!**  
     in Visual Basic\) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=fullName> method to create a complex number from its polar coordinates.  
  
-   By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object. The value becomes the real part of the complex number, and its imaginary part equals 0.  
  
-   By casting \(in C\#\) or converting \(in Visual Basic\) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object. The value becomes the real part of the complex number, and its imaginary part equals 0.  
  
-   By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object. For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=fullName> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=fullName> operator adds two complex numbers and returns the result.  
  
 The following example demonstrates each of these five ways of assigning a value to a complex number.  
  
 [!code-csharp[System.Numerics.Complex.Class\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## Operations with Complex Numbers  
 The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:  
  
-   Methods to compare two complex numbers to determine whether they are equal.  
  
-   Operators to perform arithmetic operations on complex numbers. <xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.  
  
-   Methods to perform other numerical operations on complex numbers. In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.  
  
-   Methods to perform trigonometric operations on complex numbers. For example, you can calculate the tangent of an angle represented by a complex number.  
  
 Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read\-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.  All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.  
  
## Precision and Complex Numbers  
 The real and imaginary parts of a complex number are represented by two double\-precision floating\-point values. This means that <xref:System.Numerics.Complex> values, like double\-precision floating\-point values, can lose precision as a result of numerical operations. This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision. For more information, see <xref:System.Double>.  
  
 For example, performing exponentiation on the logarithm of a number should return the original number. However, in some cases, the loss of precision of floating\-point values can cause slight differences between the two values, as the following example illustrates.  
  
 [!code-csharp[System.Numerics.Complex.Class\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32\-bit and IA64 versions of the .NET Framework.  
  
 [!code-csharp[System.Numerics.Complex.Class\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## Complex Numbers, Infinity, and NaN  
 The real and imaginary parts of a complex number are represented by <xref:System.Double> values. In addition to ranging from <xref:System.Double.MinValue?displayProperty=fullName> to <xref:System.Double.MaxValue?displayProperty=fullName>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=fullName>, <xref:System.Double.NegativeInfinity?displayProperty=fullName>, or <xref:System.Double.NaN?displayProperty=fullName>. <xref:System.Double.PositiveInfinity?displayProperty=fullName>, <xref:System.Double.NegativeInfinity?displayProperty=fullName>, and <xref:System.Double.NaN?displayProperty=fullName> all propagate in any arithmetic or trigonometric operation.  
  
 In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=fullName>. As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=fullName>. Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=fullName> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=fullName>. Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=fullName> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=fullName>.  
  
 [!code-csharp[System.Numerics.Complex.Class\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception. Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=fullName>, <xref:System.Double.NegativeInfinity?displayProperty=fullName>, or <xref:System.Double.NaN?displayProperty=fullName> under the following conditions:  
  
-   The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=fullName>.  
  
-   Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=fullName>.  
  
-   The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=fullName>.  
  
-   Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=fullName>.  
  
-   The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=fullName>.  
  
-   Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=fullName>, <xref:System.Double.NegativeInfinity?displayProperty=fullName>, or <xref:System.Double.NaN?displayProperty=fullName> returns <xref:System.Double.PositiveInfinity?displayProperty=fullName>, <xref:System.Double.NegativeInfinity?displayProperty=fullName>, or <xref:System.Double.NaN?displayProperty=fullName>, depending on the specific operation.  
  
 Note that this applies to any intermediate calculations performed by a method. For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula **math tag is not supported!!!!**  
. The calculation of the real component that results from the multiplication evaluates the expression **math tag is not supported!!!!**  
. Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=fullName>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=fullName> from <xref:System.Double.PositiveInfinity?displayProperty=fullName> returns <xref:System.Double.NaN?displayProperty=fullName>.  
  
## Formatting a Complex Number  
 By default, the string representation of a complex number takes the form **languageKeyword tag is not supported!!!!**  
**placeholder tag is not supported!!!!**  
**languageKeyword tag is not supported!!!!**  
**placeholder tag is not supported!!!!**  
**languageKeyword tag is not supported!!!!**  
, where **placeholder tag is not supported!!!!**  
 and **placeholder tag is not supported!!!!**  
 are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components. Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string. \(For more information, see [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) and [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4).\)  
  
 One of the more common ways of expressing the string representation of a complex number takes the form **math tag is not supported!!!!**  
, where **math tag is not supported!!!!**  
 is the complex number's real component, and **math tag is not supported!!!!**  
 is the complex number's imaginary component. In electrical engineering, a complex number is most commonly expressed as **math tag is not supported!!!!**  
. You can return the string representation of a complex number in either of these two forms. To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName> method.  
  
 The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either **math tag is not supported!!!!**  
 or **math tag is not supported!!!!**  
.  
  
 [!code-csharp[System.Numerics.Complex.Class\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 The following example then uses this custom formatter to display the string representation of a complex number.  
  
 [!code-csharp[System.Numerics.Complex.Class\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
   
  
## 例  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">複素数の実数部。</param>
        <param name="imaginary">複素数の虚数部。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Numerics.Complex" /> 指定された実数部と虚数値を使用して構造化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `real` または `imaginary` への明示的なキャストが必要なデータ型の場合、引数は有効桁数を失う可能性があります <xref:System.Double>します。  
  
   
  
## 例  
 次の例では、2 つの複素数をインスタンス化し、加算、減算、乗算、および除算操作でそれらを使用します。  
  
 [!code-csharp[System.Numerics.Complex.ctor\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>複素数の絶対値 \(または大きさ\) を取得します。</summary>
        <returns>絶対値 <paramref name="value" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複素数の絶対値はその <xref:System.Numerics.Complex.Magnitude%2A> プロパティです。 実数値の絶対値 a \+ bi 次のように計算されます。  
  
-   場合 b \= 0, 、0 になります。  
  
-   If a \> b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=fullName>\(1 \+ b<sup>2</sup>\/a<sup>2</sup>\).  
  
-   If b \> a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=fullName>\(1 \+ a<sup>2</sup>\/b<sup>2</sup>\).  
  
 絶対値を計算の結果、オーバーフローになる場合は、いずれかが返されます <xref:System.Double.PositiveInfinity?displayProperty=fullName> または <xref:System.Double.NegativeInfinity?displayProperty=fullName>です。 いずれか、 <xref:System.Numerics.Complex.Real%2A> または <xref:System.Numerics.Complex.Imaginary%2A> プロパティは <xref:System.Double.NaN?displayProperty=fullName> し、その他のプロパティがどちらも <xref:System.Double.PositiveInfinity?displayProperty=fullName> も <xref:System.Double.NegativeInfinity?displayProperty=fullName>, 、メソッドが戻る <xref:System.Double.NaN?displayProperty=fullName>します。  
  
   
  
## 例  
 次の例は、複素数の絶対値を計算しの値と等価であるを示しています、 <xref:System.Numerics.Complex.Magnitude%2A> プロパティです。  
  
 [!code-csharp[System.Numerics.Complex.Abs\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">コサインを表す複素数。</param>
        <summary>指定した複素数のアーク コサインである角度を返します。</summary>
        <returns>アーク コサインであるラジアン単位の角度の <paramref name="value" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Acos%2A> 複素数のメソッドに対応して、 <xref:System.Math.Acos%2A?displayProperty=fullName> 実数メソッドです。  
  
 <xref:System.Numerics.Complex.Acos%2A> メソッドは、次の式を使用します。  
  
 \(\-<xref:System.Numerics.Complex.ImaginaryOne>\) \* <xref:System.Numerics.Complex.Log%2A>\(`value` \+ <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>\(<xref:System.Numerics.Complex.One> \- `value` \* `value`\)\)\)  
  
   
  
## 例  
 次の例を示しています、 <xref:System.Numerics.Complex.Acos%2A> メソッドです。 によって返される値を渡すことを示しています、 <xref:System.Numerics.Complex.Acos%2A> メソッドを <xref:System.Numerics.Complex.Cos%2A> メソッドが戻る元 <xref:System.Numerics.Complex> 値。  
  
 [!code-csharp[System.Numerics.Complex.Acos\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">加算する 1 番目の複素数。</param>
        <param name="right">加算する 2 番目の複素数。</param>
        <summary>2 つの複素数を加算し、その結果を返します。</summary>
        <returns>
          <paramref name="left" /> と <paramref name="right" /> の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The addition of a complex number, **math tag is not supported!!!!**  
, and a second complex number, **math tag is not supported!!!!**  
, takes the following form:  
  
 \(a \+ c\) \+ \(b \+ d\)i.  
  
 If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=fullName> or <xref:System.Double.NegativeInfinity?displayProperty=fullName>.  
  
 Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.  
  
   
  
## 例  
 The following example illustrates addition with complex numbers.  
  
 [!code-csharp[System.Numerics.Complex.Add\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数のアーク サインである角度を返します。</summary>
        <returns>アーク サインである角度の <paramref name="value" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Asin%2A> 複素数のメソッドに対応して、 <xref:System.Math.Asin%2A?displayProperty=fullName> 実数メソッドです。  
  
 <xref:System.Numerics.Complex.Asin%2A> メソッドは、次の式を使用します。  
  
 \-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>\(<xref:System.Numerics.Complex.ImaginaryOne> \* value \+ <xref:System.Numerics.Complex.Sqrt%2A>\(<xref:System.Numerics.Complex.One> \- value \* value\)\)  
  
   
  
## 例  
 次の例を示しています、 <xref:System.Numerics.Complex.Asin%2A> メソッドです。 によって返される値を渡すことを示しています、 <xref:System.Numerics.Complex.Asin%2A> メソッドを <xref:System.Numerics.Complex.Sin%2A> メソッドが戻る元 <xref:System.Numerics.Complex> 値。  
  
 [!code-csharp[System.Numerics.Complex.Asin\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数のアーク タンジェントである角度を返します。</summary>
        <returns>アーク タンジェントである角度 <paramref name="value" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Atan%2A> 複素数のメソッドに対応して、 <xref:System.Math.Atan%2A?displayProperty=fullName> 実数メソッドです。  
  
 <xref:System.Numerics.Complex.Atan%2A> メソッドは、次の式を使用します。  
  
 <xref:System.Numerics.Complex.ImaginaryOne> \/ new Complex\(2.0, 0.0\)\) \* \(<xref:System.Numerics.Complex.Log%2A>\(<xref:System.Numerics.Complex.One> \- <xref:System.Numerics.Complex.ImaginaryOne> \* value\) \- <xref:System.Numerics.Complex.Log%2A>\(<xref:System.Numerics.Complex.One> \+ ImaginaryOne \* value\)  
  
   
  
## 例  
 次の例を示しています、 <xref:System.Numerics.Complex.Atan%2A> メソッドです。 によって返される値を渡すことを示しています、 <xref:System.Numerics.Complex.Atan%2A> メソッドを <xref:System.Numerics.Complex.Tan%2A> メソッドが戻る元 <xref:System.Numerics.Complex> 値。  
  
 [!code-csharp[System.Numerics.Complex.Atan\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>複素数の共役を計算し、結果を返します。</summary>
        <returns>共役 <paramref name="value" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複素数の共役虚数の符号を反転させます。つまり、虚数部に単項否定演算子が適用されます。 場合 a \+ bi が値から複素数の共役は a \- biです。  
  
   
  
## 例  
 次の例では、2 つの複素数の共役を表示します。  
  
 [!code-csharp[System.Numerics.Complex.Conjugate\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数のコサインを返します。</summary>
        <returns>
          <paramref name="value" /> のコサイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=fullName> method for real numbers.  
  
 The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number **math tag is not supported!!!!**  
:  
  
 \(<xref:System.Math.Cos%2A>\(a\) \* <xref:System.Math.Cosh%2A>\(b\), \-\(<xref:System.Math.Sin%2A>\(a\) \* <xref:System.Math.Sinh%2A>\(b\)\)\)  
  
   
  
## 例  
 The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method. It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.  
  
 [!code-csharp[System.Numerics.Complex.Acos\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数のハイパーボリック コサインを返します。</summary>
        <returns>
          <paramref name="value" /> のハイパーボリック コサイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=fullName> method for real numbers.  
  
 The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number **math tag is not supported!!!!**  
:  
  
 \(<xref:System.Math.Cosh%2A>\(a\) \* <xref:System.Math.Cos%2A>\(b\), <xref:System.Math.Sinh%2A>\(a\) \* <xref:System.Math.Sin%2A>\(b\)\)  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">被除数の複素数。</param>
        <param name="divisor">除数の複素数。</param>
        <summary>複素数を別の複素数で除算し、その結果を返します。</summary>
        <returns>除算の商。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The division of a complex number, **math tag is not supported!!!!**  
, by a second complex number, number, **math tag is not supported!!!!**  
, takes the following form:  
  
 \(\(ac \+ bd\) \/ \(c<sup>2</sup> \+ d<sup>2</sup>\)\) \+ \(\(bc \- ad\) \/ \(c<sup>2</sup> \+ d<sup>2</sup>\)i  
  
 If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=fullName> or <xref:System.Double.NegativeInfinity?displayProperty=fullName>.  
  
 The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators. Its behavior is identical to division using the division operator.  
  
   
  
## 例  
 The following example divides a complex number by each element in an array of complex numbers.  
  
 [!code-csharp[System.Numerics.Complex.Divide\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の複素数。</param>
        <summary>現在のインスタンスの値と指定した複素数の値が等しいかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> 場合はこの複素数の値と <paramref name="value" /> 値が同じである。 そうしないと、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> メソッドには、 <xref:System.IEquatable%601> の実装、 <xref:System.Numerics.Complex> 構造体。 少し実行よりも良い <xref:System.Numerics.Complex.Equals%28System.Object%29> メソッド値から複素数へのパラメーターに変換があるないためです。  
  
 2 つの複素数は、その実数部が等しいとその虚数部が等しい場合と同じです。<xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> メソッドは、次の式に相当します。  
  
 [!code-csharp[System.Numerics.Complex.Equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.  
  
 [!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)]
 [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  
  
 One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal. The following example uses this technique to compare the two complex values that the previous code example found to be unequal. It finds the two complex numbers to be equal.  
  
 [!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">比較対象のオブジェクト。</param>
        <summary>現在のインスタンスの値と指定されたオブジェクトの値が等しいかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> 場合、 <paramref name="obj" /> パラメーターは、 <see cref="T:System.Numerics.Complex" /> オブジェクトまたは暗黙的に変換できる型、 <see cref="T:System.Numerics.Complex" /> オブジェクト、およびその値が値を現在 <see cref="T:System.Numerics.Complex" /> オブジェクト。 それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 2 つの複素数は、その実数部が等しいとその虚数部が等しい場合と同じです。<xref:System.Numerics.Complex.Equals%28System.Object%29> メソッドは、次の式に相当します。  
  
 [!code-csharp[System.Numerics.Complex.Equals\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 場合、 `obj` パラメーターではありません、 <xref:System.Numerics.Complex> オブジェクトが、暗黙的な変換が定義するために、データ型では、 <xref:System.Numerics.Complex.Equals%28System.Object%29> メソッドに変換 `obj` に、 <xref:System.Numerics.Complex> 実数部がの値と等しいオブジェクト `obj` 、比較を実行する前に、虚数部は 0 に等しいとします。 次の例は、複素数と倍精度浮動小数点値が等しいことを検出して、これを示しています。  
  
 [!code-csharp[System.Numerics.Complex.Equals\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison. The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value. As the output shows, the comparison for equality returns <see langword="False" />.  
  
 [!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)]
 [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  
  
 One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal. The following example uses this technique to compare the two values that the previous code example found to be unequal. It now finds them to be equal.  
  
 [!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)]
 [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">累乗に使用する値を指定する複素数。</param>
        <summary>返します。 <see langword="e" /> 累乗した値から複素数で指定します。</summary>
        <returns>数値 <see langword="e" /> を <paramref name="value" /> で累乗した値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Numerics.Complex.Pow%2A> メソッドを他のべき乗を計算します。  
  
 <xref:System.Numerics.Complex.Exp%2A> 複素数のメソッドに対応して、 <xref:System.Math.Exp%2A?displayProperty=fullName> 実数メソッドです。<xref:System.Numerics.Complex.Exp%2A> 逆の操作は、 <xref:System.Numerics.Complex.Log%2A>です。  
  
   
  
## 例  
 次の例を示しています、 <xref:System.Numerics.Complex.Exp%2A> メソッドです。 示しています、いくつかの有効桁数が不足している状況において、 <xref:System.Double> によって返される値を渡すと、データ型、 <xref:System.Numerics.Complex.Log%2A> メソッドを <xref:System.Numerics.Complex.Exp%2A> メソッドが戻る元 <xref:System.Numerics.Complex> 値。  
  
 [!code-csharp[System.Numerics.Complex.Log\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.Complex.Log\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">原点 \(X 軸と Y 軸の交点\) から値までの距離である大きさ。</param>
        <param name="phase">線から水平軸までの角度であるフェーズ \(ラジアン単位\)。</param>
        <summary>ポイントの極座標から複素数を作成します。</summary>
        <returns>複素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> メソッド極座標に基づいて複素数のインスタンスを作成します。  
  
 戻り値、複雑な平面上の点の複数の表現があるため、 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> メソッドを正規化します。 絶対値が正の数に正規化され、フェーズの範囲内の値は正規化<xref:System.Math.PI> に <xref:System.Math.PI>します。 その結果の値、 <xref:System.Numerics.Complex.Phase%2A> と <xref:System.Numerics.Complex.Magnitude%2A> 結果として得られる複素数のプロパティではの元の値が等しくない場合があります、 `magnitude` と `phase` パラメーター。  
  
 値を度からラジアンに変換する、 `phase` ことによって乗算パラメーター <xref:System.Math.PI?displayProperty=fullName>180\/です。  
  
   
  
## 例  
 次の例では、 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 値から複素数をインスタンス化するメソッドが極座標に基づいておりの値が表示されます、 <xref:System.Numerics.Complex.Magnitude%2A> と <xref:System.Numerics.Complex.Phase%2A> プロパティです。  
  
 [!code-csharp[System.Numerics.Complex.Phase\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のハッシュ コードを返す <see cref="T:System.Numerics.Complex" /> オブジェクトです。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の虚数部を取得 <see cref="T:System.Numerics.Complex" /> オブジェクトです。</summary>
        <value>複素数の虚数部。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複雑な数を指定した a \+ bi, 、 <xref:System.Numerics.Complex.Imaginary%2A> プロパティの値を返す bします。  
  
   
  
## 例  
 次の例の配列をインスタンス化 <xref:System.Numerics.Complex> オブジェクトおよび各形式の実数部と虚数部のコンポーネントが表示されます a \+ biします。  
  
 [!code-csharp[System.Numerics.Complex.Real\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しい返します <see cref="T:System.Numerics.Complex" /> 実数が 0 と 1 に等しい仮想的な番号に等しいインスタンス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例のインスタンスを作成、 <xref:System.Numerics.Complex> 値を使用して、 <xref:System.Numerics.Complex.ImaginaryOne> プロパティです。 この値が呼び出すことによってインスタンス化されるその他の値を比較して、 <xref:System.Numerics.Complex> 0 に等しい実数部と 1 に等しいの虚数部を持つコンス トラクターです。 この例の出力に示すように、2 つの値が等しいです。  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>自然を返します \(基本 <see langword="e" />\) と指定した複素数の対数。</summary>
        <returns>自然 \(基本 <see langword="e" />\) の対数 <paramref name="value" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> 複素数のメソッドに対応して、 <xref:System.Math.Log%28System.Double%29?displayProperty=fullName> 実数メソッドです。  
  
   
  
## 例  
 次の例を示しています、 <xref:System.Numerics.Complex.Log%2A> メソッドです。 示しています、いくつかの有効桁数が不足している状況において、 <xref:System.Double> によって返される値を渡すと、データ型、 <xref:System.Numerics.Complex.Log%2A> メソッドを <xref:System.Numerics.Complex.Exp%2A> メソッドが戻る元 <xref:System.Numerics.Complex> 値。  
  
 [!code-csharp[System.Numerics.Complex.Log\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.Complex.Log\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <param name="baseValue">対数の底。</param>
        <summary>指定した複素数の指定した底での対数を返します。</summary>
        <returns>自然対数 <paramref name="value" /> ベースで <paramref name="baseValue" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> 複素数のメソッドに対応して、 <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=fullName> 実数メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数の底 10 の対数を返します。</summary>
        <returns>底 10 の対数 <paramref name="value" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Log10%2A> 複素数のメソッドに対応して、 <xref:System.Math.Log10%2A?displayProperty=fullName> 実数メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複素数の大きさ \(または絶対値\) を取得します。</summary>
        <value>現在のインスタンスの大きさ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Magnitude%2A> プロパティは、複素数の絶対値に相当します。 2 次元の値から複素数によって表される点に、原点 \(x 軸とデカルト座標系では、y 軸の交点\) からの距離が指定します。 値の絶対値は次のように計算されます。  
  
 &#124; a \+ bi &#124; \= <xref:System.Math.Sqrt%2A?displayProperty=fullName>\(a \* a \+ b \* b\)  
  
 このプロパティに、いずれかを返します絶対値を計算の結果、オーバーフローになる場合 <xref:System.Double.PositiveInfinity?displayProperty=fullName> または <xref:System.Double.NegativeInfinity?displayProperty=fullName>です。  
  
 <xref:System.Numerics.Complex.Magnitude%2A> と <xref:System.Numerics.Complex.Phase%2A> プロパティは、極座標グラフの座標系では複素数を表すポイントの位置を定義します。  
  
 呼び出して、デカルト座標ではなく極座標に基づく値から複素数をインスタンス化することができます、 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> メソッドです。  
  
   
  
## 例  
 次の例は、複素数の絶対値を計算しの値と等価であるを示しています、 <xref:System.Numerics.Complex.Magnitude%2A> プロパティです。  
  
 [!code-csharp[System.Numerics.Complex.Abs\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">乗算する 1 番目の複素数。</param>
        <param name="right">乗算する 2 番目の複素数。</param>
        <summary>2 つの複素数の積を返します。</summary>
        <returns>製品、 <paramref name="left" /> と <paramref name="right" /> パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複素数の乗算 a \+ bi, 、および 2 番目の複素数 c \+ di, 、次の形式します。  
  
 \(ac \- bd\) \+ \(ad \+ bc\)i  
  
 そのコンポーネントの値が、いずれかでは、乗算の結果実際部または虚数部のいずれかのコンポーネントで、オーバーフローになる場合 <xref:System.Double.PositiveInfinity?displayProperty=fullName> または <xref:System.Double.NegativeInfinity?displayProperty=fullName>です。  
  
 <xref:System.Numerics.Complex.Multiply%2A> カスタム演算子をサポートしていない言語のメソッドを実装します。 その動作は、乗算演算子を使用する乗算と同じです。  
  
   
  
## 例  
 次の例では、複素数の配列内の各要素で複素数を乗算します。  
  
 [!code-csharp[System.Numerics.Complex.Multiply\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数の加法に関する逆元を返します。</summary>
        <returns>結果、 <see cref="P:System.Numerics.Complex.Real" /> と <see cref="P:System.Numerics.Complex.Imaginary" /> のコンポーネント、 <paramref name="value" /> パラメーターが\-1 で乗算します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複素数の加法に関する逆元は、複素数の値を生成する <xref:System.Numerics.Complex.Zero> 元複素数に追加された場合。 このメソッドは、元の複素数の実数部と虚数部のコンポーネントが\-1 で乗算される複素数を返します。  
  
 <xref:System.Numerics.Complex.Negate%2A> カスタム演算子をサポートしていない言語のメソッドを実装します。 この動作は、単項否定演算子を使用した否定演算 <xref:System.Numerics.Complex.op_UnaryNegation%2A>します。  
  
   
  
## 例  
 次の例では、複素数の配列内の各要素の加法に関する逆元を取得します。  
  
 [!code-csharp[System.Numerics.Complex.Negate\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しい返します <see cref="T:System.Numerics.Complex" /> 実数が 1 つと、虚数が 0 に等しいインスタンス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例のインスタンスを作成、 <xref:System.Numerics.Complex> 値を使用して、 <xref:System.Numerics.Complex.One> プロパティです。 この値が呼び出すことによってインスタンス化されるその他の値を比較して、 <xref:System.Numerics.Complex> 1 に等しい実数部および 0 に等しいの虚数部を持つコンス トラクターです。 この例の出力に示すように、2 つの値が等しいです。  
  
 [!code-csharp[System.Numerics.Complex.One\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Addition (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">加算する 1 番目の値。</param>
        <param name="right">加算する 2 番目の値。</param>
        <summary>2 つの複素数を加算します。</summary>
        <returns>
          <paramref name="left" /> と <paramref name="right" /> の合計。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.op_Addition%2A> メソッドは、複素数の加算演算を定義します。 次のようなコードが有効にします。  
  
 [!code-csharp[System.Numerics.Complex.Add\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 値から複素数の追加 a \+ bi, 、および 2 番目の複素数 c \+ di, 、次の形式します。  
  
 \(a \+ c\) \+ \(b \+ d\)i  
  
 そのコンポーネントの値は、いずれかの場合は、メソッドは、リアルタイムまたは仮想的なコンポーネント、いずれかでオーバーフローが結果を呼び出し、 <xref:System.Double.PositiveInfinity?displayProperty=fullName> または <xref:System.Double.NegativeInfinity?displayProperty=fullName>です。  
  
 カスタム演算子をサポートしない言語を呼び出すことができます、 <xref:System.Numerics.Complex.Add%2A> メソッド代わりにします。  
  
 The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=fullName>  
  
## 例  
 次の例は、複素数の加算を示しています。  
  
 [!code-csharp[System.Numerics.Complex.Add\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Division (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">被除数。</param>
        <param name="right">除数。</param>
        <summary>指定した複素数を別の指定した複素数で除算します。</summary>
        <returns>
          <paramref name="left" /> を <paramref name="right" /> で除算した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers. It enables code such as the following:  
  
 [!code-csharp[System.Numerics.Complex.Divide\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 The division of a complex number, **math tag is not supported!!!!**  
, and a second complex number, **math tag is not supported!!!!**  
, takes the following form:  
  
 \(\(ac \+ bd\) \/ \(c<sup>2</sup> \+ d<sup>2</sup>\)\) \+ \(\(bc \- ad\) \/ \(c<sup>2</sup> \+ d<sup>2</sup>\)i  
  
 If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=fullName> or <xref:System.Double.NegativeInfinity?displayProperty=fullName>.  
  
 Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.  
  
 The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=fullName>  
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">比較対象の 1 番目の複素数。</param>
        <param name="right">比較対象の 2 番目の複素数。</param>
        <summary>2 つの複素数が等しいかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> 場合、 <paramref name="left" /> と <paramref name="right" /> パラメーター値が同じである。 そうしないと、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.op_Equality%2A> メソッドに対して等値演算子の動作を定義する <xref:System.Numerics.Complex> 値。 次のようなコードが有効にします。  
  
 [!code-csharp[System.Numerics.Complex.Equals\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 カスタム演算子をサポートしない言語を呼び出すことができます、 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> メソッド代わりにします。  
  
 2 つの複素数は、その実数部が等しいとその虚数部が等しい場合と同じです。<xref:System.Numerics.Complex.op_Equality%2A> メソッドは、次の式に相当します。  
  
 [!code-csharp[System.Numerics.Complex.Equals\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 有効桁数の違い、ため明らかに等価な 2 つの複素数できますと見なされる等しくないことを注意してください。 詳細については、回避策を参照してください、 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> メソッドです。  
  
 The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=fullName>  
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Explicit (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>明示的な変換を定義、 <see cref="T:System.Decimal" /> 値から複素数への値。</summary>
        <returns>実数部にある複素数 <paramref name="value" /> と虚数値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 明示的な変換演算子に変換できる型を定義する、 <xref:System.Numerics.Complex> オブジェクトです。 言語コンパイラは行いませんこの変換に自動的にデータの損失が生じる可能性があるためです。 \(C\#\) のキャスト演算子または変換関数の場合のみが変換を実行する代わりに、\(よう `CType` Visual Basic で\) を使用します。 それ以外の場合、コンパイラ エラーが表示されます。  
  
 変換、 <xref:System.Decimal> ために、複素数の実数部の値が有効桁数の損失につながる可能性、 <xref:System.Double>, 、これは、複素数の型 <xref:System.Numerics.Complex.Real%2A> プロパティには、有効桁数よりも少ないのは、 <xref:System.Decimal>です。  
  
   
  
## 例  
 次の例では、明示的な変換の <xref:System.Decimal> 値 <xref:System.Numerics.Complex> 値。  
  
 [!code-csharp[System.Numerics.Complex.Explicit\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]
 [!code-vb[System.Numerics.Complex.Explicit\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Explicit (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>明示的な変換を定義、 <see cref="T:System.Numerics.BigInteger" /> 値から複素数への値。</summary>
        <returns>実数部にある複素数 <paramref name="value" /> と虚数値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 明示的な変換演算子に変換できる型を定義する、 <xref:System.Numerics.Complex> オブジェクトです。 言語コンパイラは行いませんこの変換に自動的にデータの損失が生じる可能性があるためです。 \(C\#\) のキャスト演算子または変換関数の場合のみが変換を実行する代わりに、\(よう `CType` Visual Basic で\) を使用します。 それ以外の場合、コンパイラ エラーが表示されます。  
  
 変換、 <xref:System.Numerics.BigInteger> ために、複素数の実数部の値が有効桁数の損失につながる可能性、 <xref:System.Double>, 、これは、複素数の型 <xref:System.Numerics.Complex.Real%2A> プロパティには、有効桁数よりも少ないのは、 <xref:System.Numerics.BigInteger>です。  
  
 変換が成功した場合、 <xref:System.Numerics.BigInteger> の範囲外の値は、 <xref:System.Double> 型、操作はスローされません、 <xref:System.OverflowException>です。 代わりに場合、 `value` がより小さい <xref:System.Double.MinValue?displayProperty=fullName>, 、結果は、ある複素数、 <xref:System.Numerics.Complex.Real%2A> プロパティの値と等しい <xref:System.Double.NegativeInfinity?displayProperty=fullName>します。 場合 `value` よりも大きい <xref:System.Double.MaxValue?displayProperty=fullName>, 、結果は、ある複素数、 <xref:System.Numerics.Complex.Real%2A> プロパティの値と等しい <xref:System.Double.PositiveInfinity?displayProperty=fullName>します。  
  
   
  
## 例  
 次の例では、明示的な変換の <xref:System.Numerics.BigInteger> 値 <xref:System.Numerics.Complex> 値。  
  
 [!code-csharp[System.Numerics.Complex.Explicit\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]
 [!code-vb[System.Numerics.Complex.Explicit\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Implicit (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>符号なしバイト値から複素数への暗黙の型変換を定義します。</summary>
        <returns>値を格納しているオブジェクト、 <paramref name="value" /> 実数部と虚数部として 0 個のパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Numerics.Complex.op_Implicit%2A> 演算子は、コンパイラを自動的に変換する元となる型を定義、 <xref:System.Numerics.Complex> オブジェクト \(c\#\) の明示的なキャスト演算子または \(Visual Basic で\) 変換関数の呼び出しなし。 これらには、拡大変換をデータの損失を伴わないスローしないで、 <xref:System.OverflowException>です。  
  
 このオーバー ロードにより、コンパイラからの変換を処理する <xref:System.Byte> から次の例のように、複素数の値。 変換の結果は実数部はバイト値へと虚数部は 0 に等しい複素数であることに注意してください。  
  
 [!code-csharp[System.Numerics.Complex.Implicit\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]
 [!code-vb[System.Numerics.Complex.Implicit\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Implicit (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>倍精度浮動小数点数から複素数への暗黙の型変換を定義します。</summary>
        <returns>値を格納しているオブジェクト、 <paramref name="value" /> 実数部と虚数部として 0 個のパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Numerics.Complex.op_Implicit%2A> 演算子は、コンパイラを自動的に変換する元となる型を定義、 <xref:System.Numerics.Complex> オブジェクト \(c\#\) の明示的なキャスト演算子または \(Visual Basic で\) 変換関数の呼び出しなし。 これらには、拡大変換をデータの損失を伴わないスローしないで、 <xref:System.OverflowException>です。  
  
 このオーバー ロードにより、コンパイラからの変換を処理する <xref:System.Double> から次の例のように、複素数の値。 変換の結果は、複素数の実数部に等しいことに注意してください、 <xref:System.Double> 値と虚数部は 0 に等しい。  
  
 [!code-csharp[System.Numerics.Complex.Implicit\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]
 [!code-vb[System.Numerics.Complex.Implicit\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Implicit (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>16 ビット符号付き整数値から複素数への暗黙の型変換を定義します。</summary>
        <returns>値を格納しているオブジェクト、 <paramref name="value" /> 実数部と虚数部として 0 個のパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Numerics.Complex.op_Implicit%2A> 演算子は、コンパイラを自動的に変換する元となる型を定義、 <xref:System.Numerics.Complex> オブジェクト \(c\#\) の明示的なキャスト演算子または \(Visual Basic で\) 変換関数の呼び出しなし。 これらには、拡大変換をデータの損失を伴わないスローしないで、 <xref:System.OverflowException>です。  
  
 このオーバー ロードでは、コンパイラは、次の例のように、符号付き 16 ビット整数から値から複素数への変換を処理することができます。 変換の結果は実数部は 16 ビット符号付き整数へと虚数部は 0 に等しい複素数であることに注意してください。  
  
 [!code-csharp[System.Numerics.Complex.Implicit\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]
 [!code-vb[System.Numerics.Complex.Implicit\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Implicit (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>32 ビット符号付き整数値から複素数への暗黙の型変換を定義します。</summary>
        <returns>値を格納しているオブジェクト、 <paramref name="value" /> 実数部と虚数部として 0 個のパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Numerics.Complex.op_Implicit%2A> 演算子は、コンパイラを自動的に変換する元となる型を定義、 <xref:System.Numerics.Complex> オブジェクト \(c\#\) の明示的なキャスト演算子または \(Visual Basic で\) 変換関数の呼び出しなし。 これらには、拡大変換をデータの損失を伴わないスローしないで、 <xref:System.OverflowException>です。  
  
 このオーバー ロードにより、コンパイラは次の例のように、符号付き 32 ビット整数の値から複素数への変換を処理します。 変換の結果は、複素数の実数部は符号付き 32 ビット整数と虚数部は 0 に等しいことに注意してください。  
  
 [!code-csharp[System.Numerics.Complex.Implicit\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]
 [!code-vb[System.Numerics.Complex.Implicit\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Implicit (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>64 ビット符号付き整数値から複素数への暗黙の型変換を定義します。</summary>
        <returns>値を格納しているオブジェクト、 <paramref name="value" /> 実数部と虚数部として 0 個のパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Numerics.Complex.op_Implicit%2A> 演算子は、コンパイラを自動的に変換する元となる型を定義、 <xref:System.Numerics.Complex> オブジェクト \(c\#\) の明示的なキャスト演算子または \(Visual Basic で\) 変換関数の呼び出しなし。 これらには、拡大変換をデータの損失を伴わないスローしないで、 <xref:System.OverflowException>です。  
  
 このオーバー ロードでは、コンパイラは、次の例のように、符号付き 64 ビット整数から値から複素数への変換を処理することができます。 変換の結果は実数部は 64 ビットの符号付き整数と虚数部は 0 に等しい複素数であることに注意してください。  
  
 [!code-csharp[System.Numerics.Complex.Implicit\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]
 [!code-vb[System.Numerics.Complex.Implicit\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Implicit (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>符号付きバイト値から複素数への暗黙の型変換を定義します。</summary>
        <returns>値を格納しているオブジェクト、 <paramref name="value" /> 実数部と虚数部として 0 個のパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Numerics.Complex.op_Implicit%2A> 演算子は、コンパイラを自動的に変換する元となる型を定義、 <xref:System.Numerics.Complex> オブジェクト \(c\#\) の明示的なキャスト演算子または \(Visual Basic で\) 変換関数の呼び出しなし。 これらには、拡大変換をデータの損失を伴わないスローしないで、 <xref:System.OverflowException>です。  
  
 このオーバー ロードでは、コンパイラは、次の例のように、符号付きバイトから値から複素数への変換を処理することができます。 変換の結果は、複素数の実数部が符号付きバイト値と等しいと虚数部は 0 に等しいことに注意してください。  
  
 [!code-csharp[System.Numerics.Complex.Implicit\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]
 [!code-vb[System.Numerics.Complex.Implicit\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Implicit (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>単精度浮動小数点数から複素数への暗黙の型変換を定義します。</summary>
        <returns>値を格納しているオブジェクト、 <paramref name="value" /> 実数部と虚数部として 0 個のパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Numerics.Complex.op_Implicit%2A> 演算子は、コンパイラを自動的に変換する元となる型を定義、 <xref:System.Numerics.Complex> オブジェクト \(c\#\) の明示的なキャスト演算子または \(Visual Basic で\) 変換関数の呼び出しなし。 これらには、拡大変換をデータの損失を伴わないスローしないで、 <xref:System.OverflowException>です。  
  
 このオーバー ロードにより、コンパイラからの変換を処理する <xref:System.Single> から次の例のように、複素数の値。 変換の結果は、複素数の実数部に等しいことに注意してください、 <xref:System.Single> 値と虚数部は 0 に等しい。  
  
 [!code-csharp[System.Numerics.Complex.Implicit\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]
 [!code-vb[System.Numerics.Complex.Implicit\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Implicit (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>16 ビット符号なし整数値から複素数への暗黙の型変換を定義します。</summary>
        <returns>値を格納しているオブジェクト、 <paramref name="value" /> 実数部と虚数部として 0 個のパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Numerics.Complex.op_Implicit%2A> 演算子は、コンパイラを自動的に変換する元となる型を定義、 <xref:System.Numerics.Complex> オブジェクト \(c\#\) の明示的なキャスト演算子または \(Visual Basic で\) 変換関数の呼び出しなし。 これらには、拡大変換をデータの損失を伴わないスローしないで、 <xref:System.OverflowException>です。  
  
 このオーバー ロードでは、コンパイラは、次の例のように、符号なし 16 ビット整数から値から複素数への変換を処理することができます。 変換の結果は実数部は 16 ビットの符号なし整数へと虚数部は 0 に等しい複素数であることに注意してください。  
  
 [!code-csharp[System.Numerics.Complex.Implicit\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]
 [!code-vb[System.Numerics.Complex.Implicit\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Implicit (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>32 ビット符号なし整数値から複素数への暗黙の型変換を定義します。</summary>
        <returns>値を格納しているオブジェクト、 <paramref name="value" /> 実数部と虚数部として 0 個のパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Numerics.Complex.op_Implicit%2A> 演算子は、コンパイラを自動的に変換する元となる型を定義、 <xref:System.Numerics.Complex> オブジェクト \(c\#\) の明示的なキャスト演算子または \(Visual Basic で\) 変換関数の呼び出しなし。 これらには、拡大変換をデータの損失を伴わないスローしないで、 <xref:System.OverflowException>です。  
  
 このオーバー ロードでは、コンパイラは、次の例のように、符号なしの 32 ビット整数から値から複素数への変換を処理することができます。 変換の結果は実数部は 32 ビットの符号なし整数へと虚数部は 0 に等しい複素数であることに注意してください。  
  
 [!code-csharp[System.Numerics.Complex.Implicit\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]
 [!code-vb[System.Numerics.Complex.Implicit\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Implicit (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">複素数に変換する値。</param>
        <summary>64 ビット符号なし整数値から複素数への暗黙の型変換を定義します。</summary>
        <returns>値を格納しているオブジェクト、 <paramref name="value" /> 実数部と虚数部として 0 個のパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Numerics.Complex.op_Implicit%2A> 演算子は、コンパイラを自動的に変換する元となる型を定義、 <xref:System.Numerics.Complex> オブジェクト \(c\#\) の明示的なキャスト演算子または \(Visual Basic で\) 変換関数の呼び出しなし。 これらには、拡大変換をデータの損失を伴わないスローしないで、 <xref:System.OverflowException>です。  
  
 このオーバー ロードでは、コンパイラは、次の例のように、符号なし 64 ビット整数から値から複素数への変換を処理することができます。 変換の結果は実数部は符号なし 64 ビット整数と虚数部は 0 に等しい複素数であることに注意してください。  
  
 [!code-csharp[System.Numerics.Complex.Implicit\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]
 [!code-vb[System.Numerics.Complex.Implicit\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値。</param>
        <param name="right">比較する 2 番目の値。</param>
        <summary>2 つの複素数が等しくないかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="left" /> と <paramref name="right" /> が等しくない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.op_Equality%2A> メソッドは、複素数の非等値演算子の動作を定義します。 次のようなコードが有効にします。  
  
 [!code-csharp[System.Numerics.Complex.Inequality\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 カスタム演算子をサポートしない言語が呼び出すことでの非等値テストできる、 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> メソッドとその値を反転します。  
  
 有効桁数の違い、ため明らかに等価な 2 つの複素数できますと見なされる等しくないことを注意してください。 1 つの回避策を返す比較メソッドを実装する `true` 2 つの複素数の実数部と虚数部分部分の違いは、特定のしきい値を超えた場合にのみ \(など。 の複素数の 1 つの実部または虚数部のコンポーネントの値の 01%\)。 詳細については、<xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> メソッドを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">乗算する 1 番目の値。</param>
        <param name="right">乗算する 2 番目の値。</param>
        <summary>指定した 2 つの複素数を乗算します。</summary>
        <returns>製品 <paramref name="left" /> と <paramref name="right" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.op_Multiply%2A> メソッドは、複素数の乗算演算子の動作を定義します。 次のようなコードが有効にします。  
  
 [!code-csharp[System.Numerics.Complex.Multiply\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 複素数の乗算 a \+ bi, 、および 2 番目の複素数 c \+ di, 、次の形式します。  
  
 \(ac \- bd\) \+ \(ad \+ bc\)i  
  
 そのコンポーネントの値が、いずれかでは、乗算の結果実際部または虚数部のいずれかのコンポーネントで、オーバーフローになる場合 <xref:System.Double.PositiveInfinity?displayProperty=fullName> または <xref:System.Double.NegativeInfinity?displayProperty=fullName>です。  
  
 カスタム演算子をサポートしない言語を呼び出すことができます、 <xref:System.Numerics.Complex.Multiply%2A> メソッド代わりにします。  
  
 The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=fullName>  
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_Subtraction (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">減算される値 \(被減数\)。</param>
        <param name="right">減算する値 \(減数\)。</param>
        <summary>複素数を別の複素数から減算します。</summary>
        <returns>
          <paramref name="left" /> から <paramref name="right" /> を減算した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.op_Subtraction%2A> メソッドは、複素数の減算演算子の動作を定義します。 次のようなコードが有効にします。  
  
 [!code-csharp[System.Numerics.Complex.Subtract\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 そのコンポーネントの値は、いずれかの場合は、メソッドは、リアルタイムまたは仮想的なコンポーネント、いずれかでオーバーフローが結果を呼び出し、 <xref:System.Double.PositiveInfinity?displayProperty=fullName> または <xref:System.Double.NegativeInfinity?displayProperty=fullName>です。  
  
 複素数の減算 c \+ di, 、別の複素数から a \+ bi, 、次の形式します。  
  
 \(a \- c\) \+ \(b \- d\)i  
  
 カスタム演算子をサポートしない言語を呼び出すことができます、 <xref:System.Numerics.Complex.Subtract%2A> メソッド代わりにします。  
  
 The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=fullName>  
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex op_UnaryNegation (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">否定する値。</param>
        <summary>指定した複素数の加法に関する逆元を返します。</summary>
        <returns>結果、 <see cref="P:System.Numerics.Complex.Real" /> と <see cref="P:System.Numerics.Complex.Imaginary" /> のコンポーネント、 <paramref name="value" /> パラメーターが\-1 で乗算します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.op_UnaryNegation%2A> メソッドは、複素数の単項否定 \(加法に関する逆元\) 演算子の動作を定義します。 次のようなコードが有効にします。  
  
 [!code-csharp[System.Numerics.Complex.Negate\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 結果として得られる複素数の値を生成する <xref:System.Numerics.Complex.Zero> 0 \(ゼロ\) を元の複素数に追加されるとします。 カスタム演算子をサポートしない言語を呼び出すことができます、 <xref:System.Numerics.Complex.Negate%2A> メソッド代わりにします。  
  
 The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=fullName>  
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複素数のフェーズを取得します。</summary>
        <value>複素数のフェーズ \(ラジアン単位\)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複素数の a \+ bi, 、フェーズとして計算され <xref:System.Math.Atan2%2A?displayProperty=fullName>\(b, a\)します。  
  
 複素数複素平面上、デカルト座標または極座標によって識別できます。 複素数のフェーズ \(引数\) は、複素数で表される点を実際の軸の原点 \(x 軸と y 軸の交点\) から描画される直線の角度です。 絶対値 \(によって表される、 <xref:System.Numerics.Complex.Magnitude%2A> プロパティ\) の原点からの複素数で表されるポイントまでの距離であります。  
  
 呼び出して、デカルト座標ではなく極座標に基づく値から複素数をインスタンス化することができます、 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> メソッドです。  
  
 フェーズをラジアンから度に変換する 180 乗算\/<xref:System.Math.PI?displayProperty=fullName>します。  
  
   
  
## 例  
 次の例では、 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 値から複素数をインスタンス化するメソッドがその極座標に基づいておりの値が表示されます、 <xref:System.Numerics.Complex.Magnitude%2A> と <xref:System.Numerics.Complex.Phase%2A> プロパティです。  
  
 [!code-csharp[System.Numerics.Complex.Phase\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">累乗する複素数。</param>
        <param name="power">累乗を指定する倍精度浮動小数点数。</param>
        <summary>倍精度浮動小数点数で指定した値で複素数を累乗した値を返します。</summary>
        <returns>複素数 <paramref name="value" /> 乗 <paramref name="power" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `value` が <xref:System.Numerics.Complex.Zero?displayProperty=fullName> の場合、メソッドは <xref:System.Numerics.Complex.Zero?displayProperty=fullName> を返します。 その他の値の場合 `power` 、メソッドが戻る 0 では、 <xref:System.Numerics.Complex.One?displayProperty=fullName>, 、場合 `power` は 1 を返します `value`します。  
  
 このメソッドに対応、 <xref:System.Math.Pow%2A?displayProperty=fullName> のプリミティブ数値型のメソッドです。  
  
   
  
## 例  
 次の例は、\-1 を 10 にある値の範囲値から複素数と指数部を使用して指数演算を示しています。  
  
 [!code-csharp[System.Numerics.Complex.Pow\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">累乗する複素数。</param>
        <param name="power">累乗に使用する値を指定する複素数。</param>
        <summary>別の複素数で指定した値で複素数を累乗した値を返します。</summary>
        <returns>複素数 <paramref name="value" /> 乗 <paramref name="power" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の実数部を取得 <see cref="T:System.Numerics.Complex" /> オブジェクトです。</summary>
        <value>複素数の実数部。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複雑な数を指定した a \+ bi, 、 <xref:System.Numerics.Complex.Real%2A> プロパティの値を返す aします。  
  
   
  
## 例  
 次の例の配列をインスタンス化 <xref:System.Numerics.Complex> オブジェクトおよび各形式の実数部と虚数部のコンポーネントが表示されます a \+ biします。  
  
 [!code-csharp[System.Numerics.Complex.Real\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>複素数の逆数を返します。</summary>
        <returns>逆数 <paramref name="value" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 逆数、または数値の逆数 *x* 数値 *y* 、 *x* を掛けた *y* 1 となります。 複素数の逆数を生成する複素数は、 <xref:System.Numerics.Complex.One?displayProperty=fullName> と 2 つの数値を乗算します。 で複素数を表す場合 a \+bi, 、その逆数は、式で表される a\/\(a<sup>2</sup>\+b<sup>2</sup>\) \+ \-b\/\(a<sup>2</sup> \+ b<sup>2</sup>\)します。  
  
 値の場合 <xref:System.Numerics.Complex.Zero?displayProperty=fullName>, 、メソッドが返す <xref:System.Numerics.Complex.Zero?displayProperty=fullName>します。 それ以外の場合、式の結果を返す <xref:System.Numerics.Complex.One?displayProperty=fullName>\/`value`します。  
  
   
  
## 例  
 次の例では、 <xref:System.Numerics.Complex.Reciprocal%2A> メソッドのいくつかの複素数の相互の値を計算します。 紹介していますが、逆数で複素数を乗算した結果である <xref:System.Numerics.Complex.One?displayProperty=fullName>です。  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数のサインを返します。</summary>
        <returns>
          <paramref name="value" /> のサイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Sin%2A> 複素数のメソッドに対応して、 <xref:System.Math.Sin%2A?displayProperty=fullName> 実数メソッドです。  
  
 <xref:System.Numerics.Complex.Sin%2A> メソッドでは、次の数式を使用して、複素数のサインを計算 a \+ bi:  
  
 \(<xref:System.Math.Sin%2A>\(a\) \* <xref:System.Math.Cosh%2A>\(b\), <xref:System.Math.Cos%2A>\(a\) \* <xref:System.Math.Sinh%2A>\(b\)\)  
  
   
  
## 例  
 次の例を示しています、 <xref:System.Numerics.Complex.Sin%2A> メソッドです。 によって返される値を渡すことを示しています、 <xref:System.Numerics.Complex.Asin%2A> メソッドを <xref:System.Numerics.Complex.Sin%2A> メソッドが戻る元 <xref:System.Numerics.Complex> 値。  
  
 [!code-csharp[System.Numerics.Complex.Asin\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数のハイパーボリック サインを返します。</summary>
        <returns>
          <paramref name="value" /> のハイパーボリック サイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Sinh%2A> 複素数のメソッドに対応して、 <xref:System.Math.Sinh%2A?displayProperty=fullName> 実数メソッドです。  
  
 <xref:System.Numerics.Complex.Sinh%2A> メソッドでは、次の数式を使用して、複素数のハイパーボリック サインを計算 a \+ bi:  
  
 \(<xref:System.Math.Sinh%2A>\(a\) \* <xref:System.Math.Cos%2A>\(b\), <xref:System.Math.Cosh%2A>\(a\) \* <xref:System.Math.Sin%2A>\(b\)\)  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数の平方根を返します。</summary>
        <returns>平方根 <paramref name="value" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複素数の平方根 `value` 次の数式を使用して計算されます。  
  
 <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=fullName>\(<xref:System.Math.Sqrt%2A?displayProperty=fullName>\(`value`.<xref:System.Numerics.Complex.Magnitude%2A>\), `value`.<xref:System.Numerics.Complex.Phase%2A>\/2.0\)  
  
 <xref:System.Numerics.Complex.Sqrt%2A> 複素数のメソッドに対応して、 <xref:System.Math.Sqrt%2A?displayProperty=fullName> 実数メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">減算される値 \(被減数\)。</param>
        <param name="right">減算する値 \(減数\)。</param>
        <summary>複素数を別の複素数から減算し、その結果を返します。</summary>
        <returns>
          <paramref name="left" /> から <paramref name="right" /> を減算した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複素数の減算 c \+ di, 、別の複素数から a \+ bi, 、次の形式します。  
  
 \(a \- c\) \+ \(b \- d\)i  
  
 そのコンポーネントの値は、いずれかの場合は、メソッドは、リアルタイムまたは仮想的なコンポーネント、いずれかでオーバーフローが結果を呼び出し、 <xref:System.Double.PositiveInfinity?displayProperty=fullName> または <xref:System.Double.NegativeInfinity?displayProperty=fullName>です。  
  
 カスタム演算子をサポートしない言語を使用して、 <xref:System.Numerics.Complex.Subtract%2A> 複素数を使用して減算を実行するメソッドです。  
  
   
  
## 例  
 次の例では、複素数から、配列のそれぞれの複雑な数値を減算します。  
  
 [!code-csharp[System.Numerics.Complex.Subtract\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数のタンジェントを返します。</summary>
        <returns>
          <paramref name="value" /> のタンジェント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Tan%2A> 複素数のメソッドに対応して、 <xref:System.Math.Tan%2A?displayProperty=fullName> 実数メソッドです。  
  
 <xref:System.Numerics.Complex.Tan%2A> メソッドでは、次の数式を使用して、複素数のタンジェントを計算 `value`:  
  
 <xref:System.Numerics.Complex.Sin%2A>\(`value`\) \/ <xref:System.Numerics.Complex.Cos%2A>\(`value`\)  
  
   
  
## 例  
 次の例を示しています、 <xref:System.Numerics.Complex.Tan%2A> メソッドです。 によって返される値を渡すことを示しています、 <xref:System.Numerics.Complex.Atan%2A> メソッドを <xref:System.Numerics.Complex.Tan%2A> メソッドが戻る元 <xref:System.Numerics.Complex> 値。  
  
 [!code-csharp[System.Numerics.Complex.Atan\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">複素数。</param>
        <summary>指定した複素数のハイパーボリック タンジェントを返します。</summary>
        <returns>
          <paramref name="value" /> のハイパーボリック タンジェント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Tanh%2A> 複素数のメソッドに対応して、 <xref:System.Math.Tanh%2A?displayProperty=fullName> 実数メソッドです。  
  
 <xref:System.Numerics.Complex.Tanh%2A> メソッドでは、次の数式を使用して、複素数のハイパーボリック タンジェントを計算 `value`:  
  
 <xref:System.Numerics.Complex.Sinh%2A>\(`value`\) \/ <xref:System.Numerics.Complex.Cosh%2A>\(`value`\)  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の複素数の値を等価のデカルト形式の文字列形式に変換します。</summary>
        <returns>現在のインスタンスを表すデカルト形式の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複素数の既定の文字列表現には、フォームで、デカルト座標を使用して番号が表示されます。 `(`*、*`,` *b*`)`, ここで、 *、* した複素数の実数部は、と *b* 虚数部は、です。 両方とも *、* と *b* 一般書式指定子 \("G"\) と、現在のシステムのカルチャの規則を使用してフォーマットされています。  
  
   
  
## 例  
 次の例では、複数の複雑な数値の文字列形式を表示します。 出力は、英語 \- 米国 \("EN\-US"\) カルチャである、この場合は、現在のシステム カルチャの書式指定規則を使用します。  
  
 [!code-csharp[System.Numerics.Complex.ToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>指定したカルチャ固有の書式情報を使用して、現在の複素数を等価のデカルト形式の文字列形式に変換します。</summary>
        <returns>指定したとおりのデカルト形式の現在のインスタンスの文字列表現 <paramref name="provider" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドによって返される複雑な数の文字列形式には、フォームで、デカルト座標を使用して番号が表示されます。 `(`*、*`,` *b*`)`, ここで、 *、* した複素数の実数部は、と *b* 複素数。 両方とも *、* と *b* 一般書式指定子 \("G"\) として定義されているカルチャの規則を使用してフォーマットされて `provider`します。  
  
 `provider` パラメーターは、 <xref:System.IFormatProvider> 実装します。 その <xref:System.IFormatProvider.GetFormat%2A> メソッドが返される、 <xref:System.Globalization.NumberFormatInfo> 、real クラスと虚数が返される文字列の書式に関するカルチャに固有の情報を提供するオブジェクト。 場合 `provider` は `null`, を使用して、返される文字列が書式設定、 <xref:System.Globalization.NumberFormatInfo> の現在のカルチャ オブジェクト。  
  
 `provider` パラメーターは、次のいずれかを指定できます。  
  
-   A <xref:System.Globalization.CultureInfo> の書式情報を提供するカルチャを表すオブジェクト  
  
-   <xref:System.Globalization.NumberFormatInfo> を書式設定情報を提供するオブジェクト。  
  
-   実装するカスタム オブジェクト、 <xref:System.IFormatProvider> インターフェイスです。 その <xref:System.IFormatProvider.GetFormat%2A> メソッドが返される、 <xref:System.Globalization.NumberFormatInfo> を書式設定情報を提供するオブジェクト。  
  
   
  
## 例  
 次の例では、複数の複雑な数値の文字列形式を表示します。 結果は、英語 \- 米国 \("EN\-US"\) とフランス語 \- フランス \("FR\-FR"\) のカルチャの書式指定規則を使用します。  
  
 [!code-csharp[System.Numerics.Complex.ToString\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">標準またはカスタムの数値書式指定文字列。</param>
        <summary>実数部と虚数部で構成される指定した書式を使用して、現在の複素数を等価のデカルト形式の文字列形式に変換します。</summary>
        <returns>現在のインスタンスを表すデカルト形式の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドによって返される複雑な数の文字列形式には、フォームで、デカルト座標を使用して番号が表示されます。 `(`*、*`,` *b*`)`, ここで、 *、* した複素数の実数部は、と *b* 複素数。 両方とも *、* と *b* で指定された書式指定文字列を使用してフォーマットされて `format`します。`format` パラメーターには、任意の有効な標準の数値書式指定子、またはカスタムの数値書式指定子の任意の組み合わせを指定できます。 場合 `format` に等しい <xref:System.String.Empty?displayProperty=fullName> か、 `null`, 、複素数の実数部と虚数部構成は、一般書式指定子 \("G"\) でフォーマットされています。 場合 `format` その他の値、メソッドがスローされますが、 <xref:System.FormatException>です。  
  
 .NET Framework では、次のトピックで詳しく説明されている広範な書式設定のサポートを提供します。  
  
-   数値書式指定文字列の詳細については、次を参照してください。 [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。  
  
-   .NET Framework における書式設定の詳細については、次を参照してください。 [Formatting Types](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)します。  
  
 によって返される文字列の形式が決まりますが、 <xref:System.Globalization.NumberFormatInfo> 、現在のカルチャ オブジェクト。 によって、 `format` パラメーター、このオブジェクトは、マイナス記号、桁区切り記号、および、出力文字列に小数点記号などの記号を制御します。 現在のカルチャ以外のカルチャの書式に関する情報を提供する、 <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> オーバー ロードします。  
  
   
  
## 例  
 次の例では、複素数を初期化し、いくつかの標準書式指定文字列を使用して、表示します。  
  
 [!code-csharp[System.Numerics.Complex.ToString\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 有効な書式文字列ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">標準またはカスタムの数値書式指定文字列。</param>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>実数部と虚数部で構成される指定した書式およびカルチャ固有の書式情報を使用して、現在の複素数を等価のデカルト形式の文字列形式に変換します。</summary>
        <returns>指定したとおりのデカルト形式の現在のインスタンスの文字列表現 <paramref name="format" /> と <paramref name="provider" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドによって返される複雑な数の文字列形式には、フォームで、デカルト座標を使用して番号が表示されます。 `(`*、*`,` *b*`)`, ここで、 *、* した複素数の実数部は、と *b* 複素数。 両方とも *、* と *b* で指定された書式指定文字列を使用してフォーマットされて `format`します。`format` パラメーターには、任意の有効な標準の数値書式指定子、またはカスタムの数値書式指定子の任意の組み合わせを指定できます。 場合 `format` に等しい <xref:System.String.Empty?displayProperty=fullName> か、 `null`, 、複素数の実数部と虚数部構成は、一般書式指定子 \("G"\) でフォーマットされています。 場合 `format` その他の値、メソッドがスローされますが、 <xref:System.FormatException>です。  
  
 .NET Framework では、次のトピックで詳しく説明されている広範な書式設定のサポートを提供します。  
  
-   数値書式指定文字列の詳細については、次を参照してください。 [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。  
  
-   .NET Framework における書式設定の詳細については、次を参照してください。 [Formatting Types](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)します。  
  
 `provider` パラメーターは、 <xref:System.IFormatProvider> 実装します。 その <xref:System.IFormatProvider.GetFormat%2A> メソッドが返される、 <xref:System.Globalization.NumberFormatInfo> 、real クラスと虚数が返される文字列の書式に関するカルチャに固有の情報を提供するオブジェクト。 によって、 `format` パラメーター、このオブジェクトは、マイナス記号、桁区切り記号、および、出力文字列に小数点記号などの記号を制御します。 場合 `provider` は `null`, を使用して、返される文字列が書式設定、 <xref:System.Globalization.NumberFormatInfo> の現在のカルチャ オブジェクト。  
  
 `provider` パラメーターは、次のいずれかを指定できます。  
  
-   A <xref:System.Globalization.CultureInfo> の書式情報を提供するカルチャを表すオブジェクト  
  
-   <xref:System.Globalization.NumberFormatInfo> を書式設定情報を提供するオブジェクト。  
  
-   実装するカスタム オブジェクト、 <xref:System.IFormatProvider> インターフェイスです。 その <xref:System.IFormatProvider.GetFormat%2A> メソッドが返される、 <xref:System.Globalization.NumberFormatInfo> を書式設定情報を提供するオブジェクト。  
  
   
  
## 例  
 次の例は、複素数の配列を作成し、いくつかの標準書式指定文字列を使用して各表示だけでなく <xref:System.Globalization.CultureInfo> 英語 \- 米国 \("EN\-US"\) とフランス語 \- フランス \("FR\-FR"\) のカルチャを表すオブジェクト。  
  
 [!code-csharp[System.Numerics.Complex.ToString\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 有効な書式文字列ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しい返します <see cref="T:System.Numerics.Complex" /> 実数が 0 と、虚数が 0 に等しいインスタンス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Numerics.Complex.Zero> プロパティが比較に使用される最も頻繁に、 <xref:System.Numerics.Complex> 値を 0 にします。  
  
   
  
## 例  
 次の例のインスタンスを作成、 <xref:System.Numerics.Complex> 値を使用して、 <xref:System.Numerics.Complex.Zero> プロパティです。 この値が呼び出すことによってインスタンス化されるその他の値を比較して、 <xref:System.Numerics.Complex> 0 に等しい実数部と虚数部 0 に等しいを持つコンス トラクターです。 この例の出力に示すように、2 つの値が等しいです。  
  
 [!code-csharp[System.Numerics.Complex.Zero\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した値で複素数を累乗した値を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Numerics.Complex" /> オブジェクトと別の型の間の明示的な変換を定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つの複素数が等しいかどうかを示す値を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>複素数の値を等価の文字列形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>間の暗黙的な変換を定義、 <see cref="T:System.Numerics.Complex" /> オブジェクトと別の型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>複素数の対数を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>