<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>ASP.NET 操作からの HTTP 応答情報をカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドとプロパティの <xref:System.Web.HttpResponse> クラスがを介して公開される、 <xref:System.Web.HttpApplication.Response%2A> のプロパティ、 <xref:System.Web.HttpApplication>, 、<xref:System.Web.HttpContext>, 、<xref:System.Web.UI.Page>, 、および <xref:System.Web.UI.UserControl> クラスです。  
  
 次のメソッド、 <xref:System.Web.HttpResponse> クラスはポストバックのシナリオでのみサポートし、非同期の投稿ではなくバックアップ シナリオを作成します。  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 使用すると、部分ページ更新が有効に <xref:System.Web.UI.UpdatePanel> ポスト バックをページ全体が更新ではなくページの選択した地域を更新するコントロール。 詳細については、[UpdatePanel Control Overview](http://msdn.microsoft.com/ja-jp/29a2265d-9674-4c19-b70e-e5560ee9689a) および [Partial\-Page Rendering Overview](http://msdn.microsoft.com/ja-jp/5c12736d-d9e9-464a-9388-3fe0f9f49e49) を参照してください。  
  
   
  
## 例  
 次の例は、ページが要求されたときに、重複する 3 つの四角形を描画します。 コードを開始するには、 <xref:System.Web.HttpResponse.ContentType%2A> プロパティ image\/jpeg をできるように、ページ全体は JPEG 画像としてレンダリングされます。 コードを呼び出して、 <xref:System.Web.HttpResponse.Clear%2A> メソッドをこの応答に不要なコンテンツを送信しないことを確認します。 次に、設定、 <xref:System.Web.HttpResponse.BufferOutput%2A> プロパティを true 要求元のクライアントに送信される前に、ページが完全に処理されるようにします。 四角形を描画するために使用する 2 つのオブジェクトが作成されます。 <xref:System.Drawing.Bitmap> と <xref:System.Drawing.Graphics> オブジェクトです。 ページで作成された変数は、四角形と最大の四角形内に表示される文字列を描画する座標として使用されます。  
  
 次の 3 つの四角形とその内部に表示される文字列が描画されると、 <xref:System.Drawing.Bitmap> に保存、 <xref:System.IO.Stream> オブジェクトに関連付けられている、 <xref:System.Web.HttpResponse.OutputStream%2A> プロパティとその形式が JPEG に設定します。 コードの呼び出し、 <xref:System.Drawing.Image.Dispose%2A> と <xref:System.Drawing.Graphics.Dispose%2A> メソッドを 2 つの描画オブジェクトによって使用されているリソースを解放します。 最後に、コードを呼び出す、 <xref:System.Web.HttpResponse.Flush%2A> 要求クライアントにバッファー内の応答を送信する方法です。  
  
> [!NOTE]
>  コードでは、 <xref:System.Web.HttpResponse> オブジェクトは、キーワードで参照される `Response`します。 たとえば、 `Response.Clear()` を指す、 <xref:System.Web.HttpResponse.Clear%2A?displayProperty=fullName> メソッドです。<xref:System.Web.UI.Page> クラスはという名前のプロパティには、 <xref:System.Web.UI.Page.Response%2A> の現在のインスタンスを公開する <xref:System.Web.HttpResponse>です。  
  
 [!code-csharp[System.Web.HttpResponse\_Samples1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-vb[System.Web.HttpResponse\_Samples1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">カスタム HTTP 出力を有効にする <see cref="T:System.IO.TextWriter" /> オブジェクト。</param>
        <summary>
          <see cref="T:System.Web.HttpResponse" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.  
  
 The methods and properties of the <xref:System.Web.HttpResponse> class are exposed through the intrinsic <xref:System.Web.HttpContext.Response%2A> object in ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">アプリケーション依存関係のリストに追加するファイル、キャッシュ キー、または <see cref="T:System.Web.Caching.CacheDependency" />。</param>
        <summary>応答が出力キャッシュに格納されていて、指定した依存関係が変化した場合、キャッシュ依存関係のセットを応答に関連付け、応答を効率的に無効化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.AddCacheDependency%2A> メソッドを使用してキャッシュされた応答の間で作成される依存関係と <xref:System.Web.Caching.CacheDependency> オブジェクトです。  
  
   
  
## 例  
 次の例を使用して、キャッシュ依存関係を作成する方法、 <xref:System.Web.HttpResponse.AddCacheDependency%2A> メソッドと <xref:System.Web.Caching.CacheDependency> オブジェクトです。  
  
 [!code-csharp[HttpResponse.AddCacheDependency\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-vb[HttpResponse.AddCacheDependency\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencies" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">このメソッドでは、キャッシュされた応答が既に作成した後、キャッシュ処理パイプラインが遅すぎますに呼び出されました。</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">現在のキャッシュされた応答が依存しているアイテムのキーを格納する <see cref="T:System.Collections.ArrayList" />。</param>
        <summary>キャッシュ内の他のアイテムに依存するキャッシュされた応答を有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 When the items referred to in the **parameterReference tag is not supported!!!!**  
 parameter are removed from the cache, the cached response of the current item is not valid.  
  
   
  
## 例  
 The following example demonstrates how to use an ASP.NET page that is output cached. The code for the page creates an <xref:System.Collections.ArrayList> object of keys that are associated with items that are stored in the <xref:System.Web.Caching.Cache> object. Next, the code passes the <xref:System.Collections.ArrayList> as the parameter in a call to the <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> method. This makes the output cached response not valid, if any of the files specified in the <xref:System.Collections.ArrayList> change.  
  
 [!code-csharp[System.Web.HttpResponse\_Samples2\#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-vb[System.Web.HttpResponse\_Samples2\#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">キャッシュされた応答が依存するアイテム キーの配列。</param>
        <summary>キャッシュ内の他のアイテムに依存するキャッシュされたアイテムを有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 いずれか、 `cacheKey`s はキャッシュから削除、現在のアイテムのキャッシュされた応答が無効です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">キャッシュされた応答が依存するアイテムのキー。</param>
        <summary>キャッシュ内の他のアイテムに依存するキャッシュされた応答を有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、項目に対応する、 `cacheKey` パラメーターがキャッシュから削除されても、現在のアイテムのキャッシュされた応答が無効です。  
  
   
  
## 例  
 次の例は、出力キャッシュされた ASP.NET ユーザー コントロールです。 コントロールの呼び出しのコード、 <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> に格納されているアイテムのキーを持つメソッド、 <xref:System.Web.Caching.Cache> オブジェクトのパラメーターとして渡されます。 項目がキャッシュに存在しない場合、出力キャッシュに格納されたコントロールの応答が無効になります。 これは、後続の要求では、コントロールの応答の新しいバージョンが追加されること、出力キャッシュをことを意味します。  
  
 次に、このコードは項目に関連付けられているかどうかをチェック、 `bookData` でキーが格納されている、 `Cache` オブジェクト、および 2 つの行のテキスト、その結果のいずれかが表示されます。 コードを次に、設定、 <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> のプロパティ、 <xref:System.Web.UI.WebControls.DataGrid> というコントロール `dgBooks`, 、カスタムへの呼び出しで `DataHelper` クラスの共有 `GetBookData` メソッド、し、設定、 <xref:System.Web.UI.WebControls.DataGrid> で、 <xref:System.Web.UI.Control.DataBind%2A> メソッドです。  
  
 [!code-csharp[System.Web.HttpResponse\_Samples2\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-vb[System.Web.HttpResponse\_Samples2\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">追加するファイルのコレクション。</param>
        <summary>ファイル名のグループを、現在の応答が依存しているファイル名のコレクションに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例は、出力キャッシュされた ASP.NET ページです。 ページのコードを作成、 <xref:System.Collections.ArrayList> パスとファイル パス、 <xref:System.Collections.ArrayList> への呼び出しでパラメーターとして、 <xref:System.Web.HttpResponse.AddFileDependencies%2A> メソッドです。 これにより、キャッシュされた応答が無効の場合の \[出力で指定されたファイルのいずれか、 <xref:System.Collections.ArrayList> 変更します。  
  
 [!code-csharp[System.Web.HttpResponse\_Samples2\#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-vb[System.Web.HttpResponse\_Samples2\#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">追加するファイルの配列。</param>
        <summary>ファイル名の配列を、現在の応答が依存しているファイル名のコレクションに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following example adds an array of file names to the <xref:System.Web.HttpResponse.AddFileDependencies%2A> file dependency list. If the files changes, the cached response is invalidated.  
  
 [!code-csharp[Response.AddFileDependency\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-vb[Response.AddFileDependency\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">追加するファイルの名前。</param>
        <summary>現在の応答が依存しているファイル名のコレクションに、ファイル名を 1 つ追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用すると、 <xref:System.Web.HttpResponse.AddFileDependency%2A> ファイルの依存関係を追加するメソッドを出力キャッシュをプログラムでまたは宣言によって指定することも必要があります。 たとえば、宣言によって出力キャッシュを指定するには、ディレクティブを使用します。 詳細については、「[How to: Cache Page Output with File Dependencies](http://msdn.microsoft.com/ja-jp/95ad1c54-329e-45af-9343-a03a1d2ce9db)」を参照してください。  
  
   
  
## 例  
 次の例では、1 つのファイル名を追加する方法、 <xref:System.Web.HttpResponse.AddFileDependency%2A> ファイル依存関係の一覧です。 ファイルが変更された場合、キャッシュされた応答が無効になります。  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <c>value</c> を追加する対象となる HTTP ヘッダーの名前。</param>
        <param name="value">ヘッダーに追加する文字列。</param>
        <summary>HTTP ヘッダーを出力ストリームに追加します。<see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> は、ASP の旧バージョンとの互換性のために提供されています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.AddHeader%2A> 同じ <xref:System.Web.HttpResponse.AppendHeader%2A> ASP の旧バージョンとの互換性のためにのみ提供されています。 ASP.NET では、次のように使用します。 <xref:System.Web.HttpResponse.AppendHeader%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">コールバック メソッド。</param>
        <summary>\[.NET Framework 4.5.2 以降のバージョンでのみでサポート\]  
  
 この要求に対応する応答ヘッダーを送信する直前に、ASP.NET ランタイムが呼び出すコールバックを登録します。</summary>
        <returns>OnSendingHeaders 疑似イベントへのサブスクリプションを表す <see cref="T:System.Web.ISubscriptionToken" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  ネイティブ モジュールの応答を最初にフラッシュする場合は、AddOnSendingHeaders メソッドは呼び出されません。  
  
 擬似イベント OnSendingHeaders は、アプリケーションごとのサブスクリプションではなく、要求ごとのサブスクリプションがあるという点で、IHttpModule レベルのパイプライン イベントとは異なります。 目的は、コールバックが応答状態コードを変更することがありますか、応答のクッキーまたはヘッダーを設定することがあります。 その他の使用上の注意と注意事項:  
  
-   このメソッドは、統合パイプライン モード パイプラインで IIS が実行されている場合にのみ、および応答ヘッダーは、現在の要求にまだ送信されていない場合にのみ有効です。  
  
-   ASP.NET ランタイムでは、スレッドでコールバックを呼び出すことは何も保証はされません。 たとえば、コールバック可能性がありますが呼び出される同期的にバック グラウンド スレッドでフラッシュのバック グラウンドで実行される場合。<xref:System.Web.HttpContext.Current%2A> このようなスレッドで使用できるようには保証されません。  
  
-   コールバックは、応答のエンティティ本体を操作するか、フラッシュで任意のメソッドを呼び出さないでください。 コールバックを呼び出してはならないなど <xref:System.Web.HttpResponse.Redirect%2A>, 、そのメソッドは、応答のエンティティ本体を操作できます。  
  
-   コールバックは、実行時間が短い同期コードのみを含める必要があります。 非同期操作を呼び出し、このような操作を待機しようとしています。 すると、デッドロックが発生する可能性があります。  
  
-   コールバックには例外をスローする必要があります。それ以外の場合の動作は定義されていません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">出力ストリームに追加する <see cref="T:System.Web.HttpCookie" />。</param>
        <summary>HTTP クッキーを組み込みクッキー コレクションに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、という名前の新しい cookie `LastVisit`, クッキーの値を現在の日付と時刻に設定、および cookie を現在のクッキー コレクションに追加します。 クッキー コレクションのすべての cookie がクライアントに送信される、 `Set-Cookie` の HTTP ヘッダーがストリームを出力します。  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP ヘッダーが送信された後に、cookie が追加されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">出力ストリームに追加する HTTP ヘッダーの名前。</param>
        <param name="value">ヘッダーに追加する文字列。</param>
        <summary>HTTP ヘッダーを出力ストリームに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用する場合、 <xref:System.Web.HttpResponse.AppendHeader%2A> キャッシュ固有のヘッダーを送信し、同時に、キャッシュ オブジェクト モデルを使用する方法 \(<xref:System.Web.HttpResponse.Cache%2A>\) キャッシュ ポリシーのキャッシュに関連する HTTP 応答ヘッダーを設定する \(`Cache-Control`, 、`Expires`, 、`Last-Modified`, 、`Pragma`, 、および `Vary`\) キャッシュのオブジェクト モデルを使用すると、削除された可能性があります。 この動作では、ASP.NET で最も制限の厳しい設定を維持するためにできるようにします。 たとえば、ユーザー コントロールを含むページがあるとします。 これらのコントロールには、競合しているキャッシュ ポリシーがある場合は、最も限定的なキャッシュ ポリシーが使用されます。 1 つのユーザー コントロールは、ヘッダーを設定する場合"`Cache-Control: Public`「と別のユーザー コントロールより制限の厳しいヘッダーを設定」`Cache-Control: Private`"への呼び出しを使用して <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, 、続いて、"`Cache-Control: Private`"ヘッダーを応答で送信されます。  
  
 標準 http\/1.1 ヘッダーについては、14、「Header Field Definitions」セクションを参照してください、 [Hypertext Transfer Protocol \-\- HTTP\/1.1](http://go.microsoft.com/fwlink/?LinkID=73147) World Wide Web コンソーシアム \(W3C\) の Web サイトを指定します。  
  
   
  
## 例  
 次の例では、 <xref:System.Web.HttpResponse.AppendHeader%2A> にカスタム ヘッダーを追加するメソッドを <xref:System.Web.HttpResponse> 要求クライアントに送信されたオブジェクト。  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader\_Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader\_Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP ヘッダーが送信された後に、ヘッダーが追加されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">ログ ファイルに追加するテキスト。</param>
        <summary>カスタム ログ情報をインターネット インフォメーション サービス \(IIS: Internet Information Services\) ログ ファイルに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ログ ファイルに記録する指定した文字列は、まずさせる必要があります、 **URI クエリ** のオプション、 **拡張ログ プロパティ** サイトの IIS でのアクティビティ ログに記録する\] ダイアログ ボックス。  
  
 IIS 6.0 で拡張ログをカスタマイズするのには、次の手順を実行します。  
  
1.  IIS マネージャーで、ローカル コンピューターのノードを展開し、Web や FTP サイト\] フォルダーを展開、Web または FTP サイトを右クリックして、および順にクリックして **プロパティ**します。  
  
2.  クリックして、 **Web や FTP サイト** タブをクリックし、選択、 **ログ記録を有効にする** \(既に選択されていない\) 場合、チェック ボックスです。  
  
3.  **アクティブ ログ形式** ボックスで、クリックして **W3C 拡張ログ ファイル形式**します。  
  
4.  **\[プロパティ\]** をクリックします。  
  
5.  をクリックして、 **詳細** \] タブで、ログ、およびをクリックするプロパティを選択して **\[ok\]**します。  
  
   
  
## 例  
 次の例では、文字列をログに追加する方法を示します。  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">リソースへの仮想パス。</param>
        <summary>セッションが <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> セッション状態を使用している場合に、セッション ID を仮想パスに追加し、その ID を組み合わせたパスを返します。<see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> セッション状態が使用されていない場合、<see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> は元の仮想パスを返します。</summary>
        <returns>セッション ID が挿入された <paramref name="virtualPath" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> 絶対 HREFs を構築する cookieless セッションでのみ使用されます。  
  
   
  
## 例  
 次の例は、という名前の文字列変数を宣言 `urlConverted`, の結果に設定し、 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> メソッドの呼び出しです。 このコードは変数の値を <xref:System.Web.UI.WebControls.HyperLink> コントロールの <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> プロパティです。  
  
 [!code-csharp[System.Web.HttpResponse\_Sample5\#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse\_Sample5\#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">コールバック オブジェクト。</param>
        <param name="state">応答状態。</param>
        <summary>現在バッファリングされているすべての応答をクライアントへ送信します。</summary>
        <returns>非同期の結果オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合は、基になる <xref:System.Web.HttpWorkerRequest> オブジェクトが非同期フラッシュ操作をサポートしていると非同期モジュール イベントとは、非同期ハンドラーからこのメソッドを呼び出すのフラッシュ操作が非同期に実行します。 それ以外の場合のフラッシュ操作は同期的に実行します。 IIS 6.0 以降、非同期フラッシュがサポートされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">応答は既に完了しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">出力ストリームに書き込むバイト。</param>
        <summary>HTTP 出力ストリームにバイナリ文字の文字列を書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、バッファーにテキスト ファイルを読み取ってし、バッファーを HTTP 出力ストリームに書き込みます。  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>応答全体の処理が完了した後に、出力をバッファリングしてから送信するかどうかを示す値を取得または設定します。</summary>
        <value>クライアントへの出力をバッファリングする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.Buffer%2A> の代わりに、プロパティは廃止されて、 <xref:System.Web.HttpResponse.BufferOutput%2A> プロパティ ASP の旧バージョンとの互換性のためにのみ提供されています。 ASP.NET では、次のように使用します。 <xref:System.Web.HttpResponse.BufferOutput%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ全体の処理が完了した後に、出力をバッファリングしてから送信するかどうかを示す値を取得または設定します。</summary>
        <value>クライアントへの出力をバッファリングする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 設定を次に例を <xref:System.Web.HttpResponse.ContentType%2A> image\/jpeg への応答のプロパティを呼び出し、 <xref:System.Web.HttpResponse.Clear%2A> 、応答にアタッチすることがあり、設定をその他のコンテンツを削除する方法、 <xref:System.Web.HttpResponse.BufferOutput%2A> プロパティを任意のコンテンツは、要求元クライアントに送信する前にページ全体が処理できるようにを true にします。  
  
 完全な例については、 <xref:System.Web.HttpResponse> クラスです。  
  
 [!code-csharp[System.Web.HttpResponse\_Samples1\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse\_Samples1\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページのキャッシュ ポリシー \(expiration time 句、privacy settings 句、および vary 句\) を取得します。</summary>
        <value>現在の応答のキャッシュ ポリシーに関する情報を格納する <see cref="T:System.Web.HttpCachePolicy" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following example writes properties of the current cache policy to the HTTP output stream.  
  
 [!code-csharp[Classic HttpResponse.Cache Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.HttpCacheability" /> 列挙値の 1 つに一致する <see langword="Cache-Control" /> HTTP ヘッダーを取得または設定します。</summary>
        <value>
          <see cref="T:System.Web.HttpCacheability" /> 列挙値の文字列表現。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値は、 `Private`, 、`Public`, 、および `No-Cache` 文字列は、引用符で囲む必要があります \(""\) です。 場合、 <xref:System.Web.HttpResponse.CacheControl%2A> のいずれかに一致しない値にプロパティが設定されている、 <xref:System.Web.HttpCacheability> 列挙値、 <xref:System.ArgumentException> がスローされます。 場合、 <xref:System.Web.HttpResponse.CacheControl%2A> プロパティが設定されていない応答のキャッシュの設定が設定され、 <xref:System.Web.HttpCacheability.NoCache>です。  
  
 `CacheControl`, 、<xref:System.Web.HttpResponse.Expires%2A>, 、および <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> プロパティは廃止されました。 代わりのメソッド、 <xref:System.Web.HttpCachePolicy> クラスから入手、 <xref:System.Web.HttpResponse.Cache%2A> インターネット インフォメーション サービス \(IIS\) を制御する組み込みのオブジェクトがキャッシュとクライアントのキャッシュを出力します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">いずれとも設定されている文字列値が一致しない、 <see cref="T:System.Web.HttpCacheability" /> 列挙値。</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>出力ストリームの HTTP 文字セットを取得または設定します。</summary>
        <value>出力ストリームの HTTP 文字セット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `Charset` プロパティを設定してを `null` を抑制する状況、HTTP `Content-Type` ヘッダー。  
  
   
  
## 例  
 次の例では、出力ストリームの文字セットが中央ヨーロッパ言語 \(ISO\) であるかどうかを確認します。  
  
 [!code-csharp[System.Web.HttpResponse.Charset\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see langword="Charset" /> ヘッダーが送信された後にプロパティが設定されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべての内容出力をバッファー ストリームから削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.Clear%2A> メソッドでは、ヘッダー情報はクリアされません。  
  
   
  
## 例  
 設定を次に例を <xref:System.Web.HttpResponse.ContentType%2A> image\/jpeg への応答のプロパティを呼び出し、 <xref:System.Web.HttpResponse.Clear%2A> 、応答にアタッチすることがあり、設定をその他のコンテンツを削除する方法、 <xref:System.Web.HttpResponse.BufferOutput%2A> プロパティを任意のコンテンツは、要求元クライアントに送信する前に、\[完了\] ページが処理できるようにを true にします。  
  
 完全な例については、 <xref:System.Web.HttpResponse> クラスです。  
  
 [!code-csharp[System.Web.HttpResponse\_Samples1\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse\_Samples1\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべての内容出力をバッファー ストリームから削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.ClearContent%2A> メソッドでは、ヘッダー情報はクリアされません。  
  
   
  
## 例  
 次の例では、バッファー ストリームからすべてのコンテンツを消去します。  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>バッファー ストリームからすべてのヘッダーを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、 <xref:System.Web.HttpResponse.ClearHeaders%2A> で現在の応答ヘッダーを送信しないことを確認します。 この方法は、ASP.NET の応答が、JPEG ファイルなどのイメージを生成する場合に特に重要なことがあります。 この例では、 <xref:System.Web.HttpResponse.ContentType%2A> プロパティがイメージ\/jpeg に設定します。  
  
 [!code-csharp[System.Web.HttpResponse\_Sample5\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse\_Sample5\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">ヘッダーは、HTTP ヘッダーが送信された後にクリアされます。</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントの接続が切断されるとトリップされる <see cref="T:System.Threading.CancellationToken" /> オブジェクトを取得します。</summary>
        <value>キャンセル トークン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この API は、スレッド セーフです。 ただし、キャンセル トークンの使用方法に関するいくつかの制限があります。 正しく使用しないとは、競合状態、デッドロック、またはその他の予期しない動作につながります。 次のガイドラインに留意してください。  
  
-   ASP.NET は、キャンセル トークン、要求の最後の時点で破棄するために、1 つの要求の範囲外には、この API を呼び出さないことを確認します。 破棄される前に、トークンが取り消された状態に変わることを保証はありません。 たとえば場合は、要求は、クライアントが切断されていることがなくても完了すると、最初に取り消されたことがなく、トークンに破棄されます。  
  
-   待機しません、 <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=fullName>, 、この非同期の通知の目的が果たせなくなり、デッドロックが発生することができます。  
  
-   呼び出す必要はありません、 <xref:System.Threading.CancellationToken.Register%2A?displayProperty=fullName> オーバー ロード元のコールバックが呼び出されます <xref:System.Threading.SynchronizationContext> オブジェクトです。  
  
-   使用しないでください、 <xref:System.Web.HttpContext> オブジェクトまたはその他の非スレッド セーフな ASP.NET 組み込み内からオブジェクトに指定されたコールバック、 <xref:System.Threading.CancellationToken.Register%2A?displayProperty=fullName> メソッドです。 他の ASP.NET と同時に、コールバックが実行されているか、アプリケーション コードです。  
  
-   コールバック メソッドの実行時間が短いと非ブロッキングを保持します。  
  
-   コールバック メソッド内からの例外がスローされないようにするには、あらゆる努力を重ねてを確認します。  
  
 このプロパティは統合モードでのみインターネット インフォメーション サービス \(IIS\) 7.5 を適用します。 右側の IIS のバージョンまたはパイプライン モードを使用せずに起動する場合、 <xref:System.PlatformNotSupportedException> がスローされます。 IIS のバージョンを調べるには使用 <xref:System.Web.HttpRuntime.IISVersion%2A>します。 パイプライン モードを確認するに <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>クライアントへのソケット接続を閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method terminates the connection to the client in an abrupt manner and is not intended for normal HTTP request processing. The method sends a reset packet to the client, which can cause response data that is buffered on the server, the client, or somewhere in between to be dropped.  
  
 However, typically you should call <xref:System.Web.HttpApplication.CompleteRequest%2A> instead if you want to jump ahead to the <xref:System.Web.HttpApplication.EndRequest> event and send a response to the client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>出力ストリームの HTTP 文字セットを取得または設定します。</summary>
        <value>現在の応答の文字セットに関する情報を格納している <see cref="T:System.Text.Encoding" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の`ContentEncoding`ASP.NET 構成ファイル内に指定することができます、[グローバリゼーション要素 \(ASP.NET 設定スキーマ\)](http://msdn.microsoft.com/ja-jp/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7)セクションです。 場合<xref:System.Web.HttpResponse.ContentEncoding%2A>が指定されて、クライアントによって既定の構成設定が上書きされます。  
  
   
  
## 例  
 次の例では、文字セットを出力ストリームのエンコーディングの人間が判読できる説明を書き込みます。  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Web.HttpResponse.ContentEncoding" /> を <see langword="null" /> に設定しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>出力ストリームの HTTP MIME タイプを取得または設定します。</summary>
        <value>出力ストリームの HTTP MIME タイプ。 既定値は "<see langword="text/html" />" です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following example sets the <xref:System.Web.HttpResponse.ContentType%2A> property for the response to image\/jpeg, calls the <xref:System.Web.HttpResponse.Clear%2A> method to remove other content that might be attached to the response, and then sets the <xref:System.Web.HttpResponse.BufferOutput%2A> property to true so that the complete page will be processed before any content is sent to the requesting client.  
  
 For a complete example, see the <xref:System.Web.HttpResponse> class.  
  
 [!code-csharp[System.Web.HttpResponse\_Samples1\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse\_Samples1\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.ContentType" /> プロパティが <see langword="null" /> に設定されている。</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>応答のクッキー コレクションを取得します。</summary>
        <value>応答のクッキー コレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET includes two intrinsic cookie collections. The collection accessed through the <xref:System.Web.HttpRequest.Cookies%2A> collection of <xref:System.Web.HttpRequest> contains cookies transmitted by the client to the server in the **languageKeyword tag is not supported!!!!**  
 header. The collection accessed through the <xref:System.Web.HttpResponse.Cookies%2A> collection of <xref:System.Web.HttpResponse> contains new cookies created on the server and transmitted to the client in the **languageKeyword tag is not supported!!!!**  
 header.  
  
 After you add a cookie by using the <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=fullName> collection, the cookie is immediately available in the <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=fullName> collection, even if the response has not been sent to the client.  
  
   
  
## 例  
 The following example creates a new cookie named `LastVisit`, sets the value of the cookie to the current date and time, and adds the cookie to the current cookie collection. All cookies in the cookie collection are sent to the client in the **languageKeyword tag is not supported!!!!**  
 header with the HTTP output stream.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の応答に対するカーネル キャッシュを無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If kernel caching is not supported, this method has no effect.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この応答に対する IIS ユーザー モードのキャッシュを無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If IIS user\-mode caching is not supported, this method returns without performing any action.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在バッファリングされているすべての出力をクライアントへ送信し、ページの実行を停止して、<see cref="E:System.Web.HttpApplication.EndRequest" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは ASP との互換性のためだけに提供: は、ASP.NET の前に COM ベースの Web プログラミング テクノロジとの互換性。 身にする場合、<xref:System.Web.HttpApplication.EndRequest>イベントと、クライアントへの応答の送信、勧め呼び出しに<xref:System.Web.HttpApplication.CompleteRequest%2A>代わりにします。  
  
 動作を模倣するために、`End`メソッドの ASP では、このメソッドは、生成を試みます、<xref:System.Threading.ThreadAbortException>例外。 この試行が成功した場合は、呼び出し元のスレッドが中止されました、これは、サイトのパフォーマンスを低下させます。 その場合、呼び出しの後にコードなしで、<xref:System.Web.HttpResponse.End%2A>メソッドが実行されます。  
  
 場合、<xref:System.Web.HttpResponse.End%2A>メソッドを上げることはありません、<xref:System.Threading.ThreadAbortException>に代わりに、応答のバイト数をクライアントにフラッシュします。 これは、同期的に、サイトのパフォーマンスに悪影響を及ぼすすることができます。  
  
 どちらの場合 \(かどうか、<xref:System.Threading.ThreadAbortException>例外が発生しました\)、応答パイプライン ジャンプ、<xref:System.Web.HttpApplication.EndRequest>イベント。  
  
 <xref:System.Web.HttpApplication.CompleteRequest%2A>メソッドは、例外を発生させるされず、コードの呼び出しの後に、<xref:System.Web.HttpApplication.CompleteRequest%2A>メソッドを実行する可能性があります。 後続のコードの実行を回避するのには、場合のパフォーマンスの低下<xref:System.Web.HttpResponse.End%2A>は呼び出すことができます、許容<xref:System.Web.HttpResponse.End%2A>の代わりに<xref:System.Web.HttpApplication.CompleteRequest%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">
          <see cref="M:System.Web.HttpResponse.End" /> の呼び出しは、現在の要求を終了しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">非同期の結果オブジェクト。</param>
        <summary>非同期のフラッシュ操作を完了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">非同期のフラッシュがサポートされていません、 <paramref name="asyncResult" /> パラメーターは <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">非同期のフラッシュがサポートされていません、 <paramref name="asyncResult" /> にパラメーターをキャストできません、 <c>FlushAsyncResult</c> オブジェクトです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブラウザーでキャッシュされたページの有効期限が切れるまでの時間を分単位で取得または設定します。 有効期限が切れる前にユーザーが同じページに戻った場合、キャッシュされたバージョンが表示されます。<see cref="P:System.Web.HttpResponse.Expires" /> は、ASP の旧バージョンとの互換性のために提供されています。</summary>
        <value>ページの有効期限が切れるまでの分単位の時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The **languageKeyword tag is not supported!!!!**  
, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> and <xref:System.Web.HttpResponse.CacheControl%2A> properties have been deprecated in favor of the methods of the <xref:System.Web.HttpCachePolicy> class available through the <xref:System.Web.HttpResponse.Cache%2A> intrinsic object to control the Internet Information Services \(IIS\) output cache and client caches.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャッシュされた情報をキャッシュから削除する絶対日時を取得または設定します。<see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> は、ASP の旧バージョンとの互換性のために提供されています。</summary>
        <value>ページの有効期限が切れる日付と時刻。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The **languageKeyword tag is not supported!!!!**  
, <xref:System.Web.HttpResponse.Expires%2A>, and <xref:System.Web.HttpResponse.CacheControl%2A> properties have been deprecated in favor of the methods of the <xref:System.Web.HttpCachePolicy> class available through the <xref:System.Web.HttpResponse.Cache%2A> intrinsic object to control the Internet Information Services \(IIS\) output cache and client caches.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>伝送する前に HTTP エンティティ本体を変更するために使用される、ラッピング フィルター オブジェクトを取得または設定します。</summary>
        <value>出力フィルターとして機能する <see cref="T:System.IO.Stream" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 作成するときに、 `Stream` オブジェクトし、設定、 <xref:System.Web.HttpResponse.Filter%2A> プロパティを `Stream` オブジェクト、すべての HTTP によって送信された出力 <xref:System.Web.HttpResponse.Write%2A> 、フィルタを通過します。  
  
   
  
## 例  
 次の例は、ASP.NET ページを設定する、 <xref:System.Web.HttpResponse.Filter%2A> プロパティの新しいインスタンスを `UpperCaseFilter` クラス、カスタム <xref:System.IO.Stream> を大文字に通過するすべてのテキストに変換するクラス。 要求に関する情報がテキスト ファイルに保存し、 <xref:System.Web.HttpResponse.Filter%2A> プロパティを設定します。 応答フィルターを配置した後、コードを呼び出す、 <xref:System.Web.HttpRequest.MapPath%2A> という名前のテキスト ファイルへの絶対パスを取得するメソッド `TestFile.txt` 応答のコンテンツのソースとして機能します。 コードは、新しい作成 <xref:System.IO.StreamReader> を終了するには、最初の呼び出しからテキスト ファイルを読み込むため、 <xref:System.Web.HttpResponse.Write%2A> 、ページ上のファイルの内容を表示するメソッドです。  
  
 [!code-csharp[System.Web.HttpRequest\_Samples2\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest\_Samples2\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">エンティティには、フィルター処理することはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在バッファリングされているすべての出力をクライアントへ送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 強制は、クライアントに送信する出力中のすべてをバッファーします。<xref:System.Web.HttpResponse.Flush%2A> メソッドは、要求処理中に複数回呼び出すことがあります。  
  
   
  
## 例  
 次の例では、 <xref:System.Drawing.Graphics.Save%2A> を保存する方法、 <xref:System.Drawing.Bitmap> オブジェクトを <xref:System.Web.HttpResponse.OutputStream%2A> プロパティに変換し、イメージ、jpeg 形式に書式を設定します。 コードを呼び出して、 `Dispose` メソッドを <xref:System.Drawing.Bitmap> オブジェクトと <xref:System.Drawing.Graphics> オブジェクトを使用していたリソースを解放します。 呼び出して、 <xref:System.Web.HttpResponse.Flush%2A> 要求元のクライアントへの応答のコンテンツを送信するメソッドです。  
  
 完全な例については、 <xref:System.Web.HttpResponse> クラスです。  
  
 [!code-csharp[System.Web.HttpResponse\_Samples1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-vb[System.Web.HttpResponse\_Samples1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">応答が送信された後、キャッシュがフラッシュされます。</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在バッファリングされているすべての出力をクライアントへ非同期的に送信します。</summary>
        <returns>非同期操作を表す <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のヘッダー出力ストリームのエンコーディングを表す <see cref="T:System.Text.Encoding" /> オブジェクトを取得または設定します。</summary>
        <value>現在のヘッダーの文字セットに関する情報が格納されている <see cref="T:System.Text.Encoding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.HeaderEncoding%2A> プロパティが無効にするか、または変更する機能を使用する、 <xref:System.Text.Encoding> オブジェクトを使用して応答ヘッダーに、 <xref:System.Text.ASCIIEncoding>, 、<xref:System.Text.UnicodeEncoding>, 、<xref:System.Text.UTF7Encoding>, 、または <xref:System.Text.UTF8Encoding> オブジェクトです。 既定のエンコーディング値は、 <xref:System.Text.UTF8Encoding> クラスです。  
  
 型を変更して、 <xref:System.Web.HttpResponse.HeaderEncoding%2A> プロパティには、特定の悪意のある攻撃や応答ヘッダーを使って送信する原因の機密データのリスク可能性のある増やすことができます。 ヘッダーのインジェクション攻撃を回避できますの一部にすることで、 <xref:System.Web.HttpResponse.HeaderEncoding%2A> プロパティの既定の設定に応答します。 応答ヘッダーの一部としてデータをバックアップから委託され、影響を受けるアプリケーションに対する攻撃をエコーします。 場合、 <xref:System.Web.HttpResponse.HeaderEncoding%2A> を継続ヘッダー内の行またはヘッダーのデータを応答ストリームに送信する前に検証する場合は、任意のヘッダーを構築するには信頼されていないデータの結果に基づくと、要件を満たすのため無効にします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">エンコーディング値は <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException">エンコーディング値は <see cref="P:System.Text.Encoding.Unicode" /> です。  
  
 または  
  
 ヘッダーは既に送信されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>応答ヘッダーのコレクションを取得します。</summary>
        <value>応答ヘッダーの <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.Headers%2A> プロパティのみをサポート、 [!INCLUDE[iisver](~/includes/iisver-md.md)] 統合パイプライン モードと、少なくとも .NET Framework 3.0。 アクセスしようとすると、 <xref:System.Web.HttpResponse.Headers%2A> プロパティと、これら 2 つの条件のいずれかが満たされない、 <xref:System.PlatformNotSupportedException> がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">操作には、IIS 7.0 の統合パイプライン モードと、少なくとも .NET Framework バージョン 3.0 が必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>\[.NET Framework 4.5.2 以降のバージョンでのみでサポート\]  
  
 応答ヘッダーが既に作成されたかどうかを示す値を取得します。</summary>
        <value>応答ヘッダーが書き込まれている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントがサーバーにまだ接続されているかどうかを示す値を取得します。</summary>
        <value>クライアントが現在接続されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.IsClientConnected%2A> プロパティを返します。 `false` 、次の条件が当てはまる場合。  
  
-   クライアントへの接続が終了しました。 これは、場合に発生、 <xref:System.Web.HttpResponse.Close%2A> メソッドが呼び出された場合は、クライアントは、Web ページの実行を停止しているか、別のページを参照またはです。  
  
-   <xref:System.Web.HttpWorkerRequest> 、要求を処理するオブジェクトは、 `null` または <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=fullName> メソッドが返す `false`します。 場合は、カスタム <xref:System.Web.HttpWorkerRequest> オブジェクトは、要求を処理し、 <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=fullName> メソッドに設定できるに基づいてユーザー定義の条件。 たとえば、カスタムのワーカーの要求では、一定時間後にタイムアウトを強制する可能性があります。  
  
   
  
## 例  
 次の例では、 <xref:System.Web.HttpResponse.IsClientConnected%2A> ページを要求しているクライアントがサーバーに接続されているかどうかを確認するプロパティです。 場合 <xref:System.Web.HttpResponse.IsClientConnected%2A> が true の場合、コードでは、 <xref:System.Web.HttpResponse.Redirect%2A> メソッド、およびクライアントが別のページに表示されます。 場合 <xref:System.Web.HttpResponse.IsClientConnected%2A> が false の場合、コードを呼び出す、 <xref:System.Web.HttpResponse.End%2A> メソッドとページのすべての処理を終了します。  
  
 [!code-csharp[System.Web.HttpResponse\_Sample4\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse\_Sample4\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントが新しい場所へ転送されている最中かどうかを示すブール値を取得します。</summary>
        <value>Location 応答ヘッダーの値が現在の場所と異なる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> プロパティを <xref:System.Web.HttpResponse.RedirectLocation%2A> プロパティをテストし、確認するかどうかの絶対 URI には、HTTP でクライアントに転送 `Location` ヘッダーは、現在の URI となる新しい対象 URI に転送されているとは異なる。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発信 HTTP 応答ストリームへのテキストの出力を有効にします。</summary>
        <value>クライアントへのカスタム出力を有効にする <see cref="T:System.IO.TextWriter" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例を含む ASP.NET ページは、 <xref:System.Web.UI.WebControls.TextBox> を持つコントロール、 <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> プロパティに設定 <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>します。 ページのコードは、ユーザーに入力したテキスト、 <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, を使用して、 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> HTML にメソッドがエンコードおよび <xref:System.Web.HttpResponse.Output%2A> ページに、エンコードされた文字列を表示するプロパティをします。  
  
 [!code-csharp[System.Web.HttpResponse.Output\_Sample\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Output\_Sample\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発信 HTTP コンテンツ本体へのバイナリ出力を有効にします。</summary>
        <value>発信 HTTP コンテンツ本体の生の内容を表す IO <see cref="T:System.IO.Stream" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 以降、.NET Framework version 2.0 では、使用する場合、 <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> メソッドによって返される IO ストリームのメソッド、 <xref:System.Web.HttpResponse.OutputStream%2A> プロパティには、次の例外がスローされる可能性があります。  
  
-   <xref:System.ArgumentOutOfRangeException>, 、場合、 `offset` または `count` パラメーターが負の値と、 `buffer` \-パラメーターの長さ、 `offset` パラメーターが 0 未満です。  
  
-   <xref:System.ArgumentNullException>, 、場合、 `buffer` パラメーターは `null`です。  
  
   
  
## 例  
 次の例では、 <xref:System.Drawing.Image.Save%2A> を保存する方法、 <xref:System.Drawing.Bitmap> オブジェクトを <xref:System.Web.HttpResponse.OutputStream%2A> プロパティには、画像を JPEG 形式に変換します。 コードはさらに Dispose メソッドを呼び出し、 <xref:System.Drawing.Bitmap> オブジェクトと <xref:System.Drawing.Graphics> が使用しているリソースを解放し、オブジェクトです。 最後に、コードが呼び出され、 <xref:System.Web.HttpResponse.Flush%2A> 要求元のクライアントへの応答のコンテンツを送信するメソッドです。  
  
 完全な例については、 <xref:System.Web.HttpResponse> クラスです。  
  
 [!code-csharp[System.Web.HttpResponse\_Samples1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-vb[System.Web.HttpResponse\_Samples1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> 使用できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="PICS-Label" /> ヘッダーに追加する文字列。</param>
        <summary>HTTP <see langword="PICS-Label" /> ヘッダーを出力ストリームに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プラットフォーム用のインターネット コンテンツの選択 \(画像\) は、コンテンツのラベル付けの World Wide Web Consortium \(W3C\) 標準です。 写真は、基本的に規制システムを作成するため言語です。  
  
 任意の値は、写真のラベルを指定できます。ASP.NET では、ラベルは検証されません。 文字列の最大長は、255 文字です。 写真の基準と構文に関する詳細については、次を参照してください。、 [World Wide Web Consortium](http://go.microsoft.com/fwlink/?LinkID=37125) Web サイトです。  
  
   
  
## 例  
 次の例は、イメージを表示する ASP.NET ページです。 ページのコードの呼び出し、 <xref:System.Web.HttpResponse.Pics%2A> 、HTTP を設定するメソッドを `PICS-Label` 応答のヘッダー。 パラメーターとして渡される文字列、 <xref:System.Web.HttpResponse.Pics%2A> メソッドは、インターネット コンテンツ評価サイトを参照\) の Web サイトから生成された規制ラベルを表します。  
  
 [!code-csharp[System.Web.HttpResponse\_Sample4\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-vb[System.Web.HttpResponse\_Sample4\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">プッシュ要求の URL です。 サーバーがクライアントにプッシュする相対リソースの仮想パスになります。</param>
        <summary>この API は、プッシュ promise を HTTP 2.0 クライアントに送信する アプリケーションをサポートするためのものです。 詳細についてを参照して Http2 サーバー プッシュに関する [HTTP\/2 Specification Section 8.2: Server Push](http://http2.github.io/http2-spec/#PushResources)します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 PushPromise は非確定的と、アプリケーションが依存するロジックがあるべきではありません。 唯一の目的は、場合によってはパフォーマンス上の利点です。 プッシュ要求を完全に無視する原因となる多くの状況 \(プロトコルと実装\) があります。 想定は、ファイア アンド フォーゲットに基づいています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">プッシュ要求の URL です。 サーバーがクライアントにプッシュする相対リソースの仮想パスになります。</param>
        <param name="method">プッシュ要求で使用される http 要求メソッド。</param>
        <param name="headers">プッシュ要求で使用される http 要求ヘッダー。</param>
        <summary>この API は、プッシュ promise を HTTP 2.0 クライアントに送信する アプリケーションをサポートするためのものです。 詳細についてを参照して Http2 サーバー プッシュに関する [HTTP\/2 Specification Section 8.2: Server Push](http://http2.github.io/http2-spec/#PushResources)します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 PushPromise は非確定的と、アプリケーションが依存するロジックがあるべきではありません。 唯一の目的は、場合によってはパフォーマンス上の利点です。 プッシュ要求を完全に無視する原因となる多くの状況 \(プロトコルと実装\) があります。 想定は、ファイア アンド フォーゲットに基づいています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">対象となる位置。</param>
        <summary>新しい URL に要求をリダイレクトして、新しい URL を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す<xref:System.Web.HttpResponse.Redirect%2A>は呼び出すことと同じ<xref:System.Web.HttpResponse.Redirect%2A>2 番目のパラメーターを設定して`true`です。  
  
 <xref:System.Web.HttpResponse.Redirect%2A>呼び出し<xref:System.Web.HttpResponse.End%2A>どのスロー、<xref:System.Threading.ThreadAbortException>完了時に例外です。 この例外は、Web アプリケーションのパフォーマンスに悪影響を与えます。 そのため、ことをお勧めこのオーバー ロードではなくを使用すること、<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=fullName>オーバー ロードして渡す`false`の`endResponse`パラメーター、およびを呼び出します、<xref:System.Web.HttpApplication.CompleteRequest%2A>メソッドです。 詳細については、<xref:System.Web.HttpResponse.End%2A> メソッドを参照してください。  
  
> [!NOTE]
>  モバイル ページに対してのみ場合、アプリケーションが cookie なしのセッションに依存または cookie なしのセッションを必要とするモバイル デバイスから要求を受信する可能性がありますパスにティルダ \(~\) を使用可能性新しいセッションが作成され、セッション データが失われる可能性があります。 など、パスを持つモバイル コントロールのプロパティを設定する"~\/パス"、パスを使用して、解決するには<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>"~\/パス"プロパティに割り当てる前にします。  
  
 ASP.NET は、302 HTTP ステータス コードを返すことによってリダイレクトを実行します。 別のページにコントロールを転送することも、<xref:System.Web.HttpServerUtility.Transfer%2A>メソッドです。<xref:System.Web.HttpServerUtility.Transfer%2A>メソッドでは通常より効率的なクライアントのラウンド トリップが発生しません。 詳細については、「[How to: Redirect Users to Another Page](http://msdn.microsoft.com/ja-jp/daef3f43-e018-43aa-b43c-46b27bac599e)」を参照してください。  
  
   
  
## 例  
 次の例では、別の Web サイトへのリダイレクトを無条件を強制します。  
  
 [!code-csharp[Classic HttpResponse.Redirect Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP ヘッダーが送信された後にリダイレクトしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">リダイレクト先の場所。</param>
        <param name="endResponse">現在のページの実行を終了するかどうかを示します。</param>
        <summary>クライアントを新しい URL にリダイレクトします。 新しい URL を指定し、さらに現在のページの実行を終了するかどうかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ターゲットの場所の絶対 URL \(たとえば、http:\/\/www.contoso.com\/default.aspx\) または相対 URL \(たとえば、Default.aspx\) を指定することができますが、一部のブラウザーは相対 URL を拒否することがあります。  
  
 ときにこのメソッドを使用するページのハンドラーで 1 つのページと開始の別のページでは、新しい要求セットの要求を終了`endResponse`に`false`およびを呼び出すの<xref:System.Web.HttpApplication.CompleteRequest%2A>メソッドです。 指定した場合`true`の`endResponse`パラメーター、このメソッドを呼び出す、<xref:System.Web.HttpResponse.End%2A>スロー、元の要求のメソッド、<xref:System.Threading.ThreadAbortException>完了時に例外です。 この例外は渡す理由は、Web アプリケーションのパフォーマンスに悪影響を与えます`false`の`endResponse`パラメーターをお勧めです。 詳細については、<xref:System.Web.HttpResponse.End%2A> メソッドを参照してください。  
  
> [!NOTE]
>  モバイル ページは、場合は、アプリケーションが cookie なしのセッションに依存または cookie なしのセッションを必要とするモバイル デバイスから要求を受信する可能性がありますを新しいセッションを作成し、セッション データが失われる可能性があることができますパスにティルダ \(~\) を使用します。 など、パスを持つモバイル コントロールのプロパティを設定する"~\/パス"を使用してパスを解決する<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>"~\/パス"プロパティに割り当てる前にします。  
  
 ASP.NET は、302 HTTP ステータス コードを返すことで、リダイレクトを実行します。 別のページにコントロールを転送することも、<xref:System.Web.HttpServerUtility.Transfer%2A>メソッドです。<xref:System.Web.HttpServerUtility.Transfer%2A>メソッドでは通常より効率的なクライアントのラウンド トリップが発生しません。 詳細については、「[How to: Redirect Users to Another Page](http://msdn.microsoft.com/ja-jp/daef3f43-e018-43aa-b43c-46b27bac599e)」を参照してください。  
  
   
  
## 例  
 次の例では、<xref:System.Web.HttpResponse.IsClientConnected%2A>ページを要求しているクライアントがサーバーに接続されているかどうかを確認するプロパティです。 場合<xref:System.Web.HttpResponse.IsClientConnected%2A>は true、コードの呼び出し、<xref:System.Web.HttpResponse.Redirect%2A>メソッド、およびクライアントは別のページに表示されます。 場合<xref:System.Web.HttpResponse.IsClientConnected%2A>コードを呼び出しますが false の場合、<xref:System.Web.HttpResponse.End%2A>メソッドとすべてのページ処理が終了しました。  
  
 [!code-csharp[System.Web.HttpResponse\_Sample4\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse\_Sample4\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> に改行文字が含まれています。</exception>
        <exception cref="T:System.Web.HttpException">HTTP ヘッダーが送信された後にリダイレクトしようとしました。</exception>
        <exception cref="T:System.ApplicationException">ページ要求がコールバックの結果となっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP <see langword="Location" /> ヘッダーの値を取得または設定します。</summary>
        <value>HTTP <see langword="Location" /> ヘッダーのクライアントに送信される絶対 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、このプロパティを使用して HTTP 301 応答コードを使用して永続的なリダイレクトをコーディングするときに、リダイレクト URL を指定する方法を示します。  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP ヘッダーは既に書き込まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">要求のリダイレクト先の場所。</param>
        <summary>要求された URL から指定された URL への永続的なリダイレクトを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> メソッドのオーバー ロードが応答で 301 HTTP ステータス コードを提供しへの要求をリダイレクトする URL を備えています。 301 HTTP ステータス コードは、HTTP 応答で標準的なコードです。 これは、ある永続的なリダイレクトが存在し、コードで、リダイレクト先を示します。  
  
 呼び出す、 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> メソッドのオーバー ロードは、応答を終了します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> 改行文字が含まれています \(<c>\n</c>\)。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">要求のリダイレクト先の場所。</param>
        <param name="endResponse">応答を終了する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</param>
        <summary>要求された URL から指定された URL への永続的なリダイレクトを実行し、応答を完了するためのオプションを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> メソッドのオーバー ロードが応答で 301 HTTP ステータス コードを提供しへの要求をリダイレクトする URL を備えています。 このメソッドのオーバー ロードでは、終了するか、リダイレクトが実行された後に応答を完了するかを指定するオプションも提供します。 301 HTTP ステータス コードは、HTTP 応答で標準的なコードです。 これは、ある永続的なリダイレクトが存在し、コードで、リダイレクト先を示します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> 改行文字が含まれています \(<c>\n</c>\)。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">ルートのパラメーター値。</param>
        <summary>ルートのパラメーター値を使用して、新しい URL に要求をリダイレクトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 2 番目のパラメーターを設定したメソッド `false`します。  
  
 このメソッドに渡されるオブジェクトは変換 `routeValues` に、 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=fullName> オブジェクトを使用して、 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=fullName> コンス トラクターです。<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> 、URL を確認するメソッドが呼び出されます。  
  
 ASP.NET では、302 HTTP ステータス コードを返すことで、リダイレクトを実行します。  
  
   
  
## 例  
 次の例はという名前のパラメーターを持つルートにリダイレクトするには、このメソッドを呼び出す方法を示しています。 `productid` と `category`です。  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したルート パラメーターに対応するルートがありません。</exception>
        <exception cref="T:System.Web.HttpException">リダイレクトは、HTTP ヘッダーが送信された後にしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <summary>ルート名を使用して、新しい URL に要求をリダイレクトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 2 番目のパラメーターを設定したメソッド `false`します。  
  
 このメソッドは変換は、渡されたルート名 `routeName` を使用して URL を <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> メソッドです。  
  
 ASP.NET では、302 HTTP ステータス コードを返すことで、リダイレクトを実行します。  
  
   
  
## 例  
 次の例は、という名前のルートにリダイレクトするには、このメソッドを呼び出す方法を示しています。 `Products`します。  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したルート パラメーターに対応するルートがありません。</exception>
        <exception cref="T:System.Web.HttpException">リダイレクトは、HTTP ヘッダーが送信された後にしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">ルートのパラメーター値。</param>
        <summary>ルートのパラメーター値を使用して、新しい URL に要求をリダイレクトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 2 番目のパラメーターを設定したメソッド `false`します。  
  
 このメソッドは、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> URL を決定する方法です。  
  
 ASP.NET では、302 HTTP ステータス コードを返すことで、リダイレクトを実行します。  
  
   
  
## 例  
 次の例はという名前のパラメーターを持つルートにリダイレクトするには、このメソッドを呼び出す方法を示しています。 `productid` と `category`です。  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したルート パラメーターに対応するルートがありません。</exception>
        <exception cref="T:System.Web.HttpException">リダイレクトは、HTTP ヘッダーが送信された後にしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeValues">ルートのパラメーター値。</param>
        <summary>ルートのパラメーター値とルート名を使用して、新しい URL に要求をリダイレクトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 2 番目のパラメーターを設定したメソッド `false`します。  
  
 このメソッドに渡されるオブジェクトは変換 `routeValues` に、 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=fullName> オブジェクトを使用して、 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=fullName> コンス トラクターです。<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> 、URL を確認するメソッドが呼び出されます。  
  
 ASP.NET では、302 HTTP ステータス コードを返すことで、リダイレクトを実行します。  
  
   
  
## 例  
 次の例は、という名前のルートにリダイレクトするには、このメソッドを呼び出す方法を示しています。 `Product` というパラメーターを持つと `productid` と `category`です。  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したルート パラメーターに対応するルートがありません。</exception>
        <exception cref="T:System.Web.HttpException">リダイレクトは、HTTP ヘッダーが送信された後にしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeValues">ルートのパラメーター値。</param>
        <summary>ルートのパラメーター値とルート名を使用して、新しい URL に要求をリダイレクトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 2 番目のパラメーターを設定したメソッド `false`します。  
  
 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> 、URL を確認するメソッドが呼び出されます。  
  
 ASP.NET では、302 HTTP ステータス コードを返すことで、リダイレクトを実行します。  
  
   
  
## 例  
 次の例は、という名前のルートにリダイレクトするには、このメソッドを呼び出す方法を示しています。 `Product` というパラメーターを持つと `productid` と `category`です。  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したルート パラメーターに対応するルートがありません。</exception>
        <exception cref="T:System.Web.HttpException">リダイレクトは、HTTP ヘッダーが送信された後にしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">ルートのパラメーター値。</param>
        <summary>ルートのパラメーター値を使用して、要求された URL から新しい URL への永続的なリダイレクトを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> 2 番目のパラメーターを設定したメソッド `false`します。  
  
 このメソッドに渡されるオブジェクトは変換 `routeValues` に、 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=fullName> オブジェクトを使用して、 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=fullName> コンス トラクターです。<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> 、URL を確認するメソッドが呼び出されます。  
  
 ASP.NET では、HTTP ステータス コード 301 を返すことによって、リダイレクトを実行します。  
  
   
  
## 例  
 次の例はという名前のパラメーターを持つルートにリダイレクトするには、このメソッドを呼び出す方法を示しています。 `productid` と `category`です。  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したルート パラメーターに対応するルートがありません。</exception>
        <exception cref="T:System.Web.HttpException">リダイレクトは、HTTP ヘッダーが送信された後にしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <summary>ルート名を使用して、要求された URL から新しい URL への永続的なリダイレクトを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> 2 番目のパラメーターを設定したメソッド `false`します。  
  
 このメソッドは変換は、渡されたルート名 `routeName` を使用して URL を <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> メソッドです。  
  
 ASP.NET では、HTTP ステータス コード 301 を返すことによって、リダイレクトを実行します。  
  
   
  
## 例  
 次の例は、という名前のルートにリダイレクトするには、このメソッドを呼び出す方法を示しています。 `Products`します。  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したルート パラメーターに対応するルートがありません。</exception>
        <exception cref="T:System.Web.HttpException">リダイレクトは、HTTP ヘッダーが送信された後にしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">ルートのパラメーター値。</param>
        <summary>ルートのパラメーター値を使用して、要求された URL から新しい URL への永続的なリダイレクトを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 2 番目のパラメーターを設定したメソッド `false`します。  
  
 このメソッドは、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> URL を決定する方法です。  
  
 ASP.NET では、HTTP ステータス コード 301 を返すことによって、リダイレクトを実行します。  
  
   
  
## 例  
 次の例はという名前のパラメーターを持つルートにリダイレクトするには、このメソッドを呼び出す方法を示しています。 `productid` と `category`です。  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したルート パラメーターに対応するルートがありません。</exception>
        <exception cref="T:System.Web.HttpException">リダイレクトは、HTTP ヘッダーが送信された後にしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeValues">ルートのパラメーター値。</param>
        <summary>新しい URL に対応するルートのパラメーター値とルート名を使用して、要求された URL から新しい URL への永続的なリダイレクトを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.HttpResponse.RedirectPermanent%2A> 2 番目のパラメーターを設定したメソッド `false`します。  
  
 このメソッドに渡されるオブジェクトは変換 `routeValues` に、 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=fullName> オブジェクトを使用して、 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=fullName> コンス トラクターです。<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> 、URL を確認するメソッドが呼び出されます。  
  
 ASP.NET では、HTTP ステータス コード 301 を返すことによって、リダイレクトを実行します。  
  
   
  
## 例  
 次の例は、という名前のルートにリダイレクトするには、このメソッドを呼び出す方法を示しています。 `Product` というパラメーターを持つと `productid` と `category`です。  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したルート パラメーターに対応するルートがありません。</exception>
        <exception cref="T:System.Web.HttpException">リダイレクトは、HTTP ヘッダーが送信された後にしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeValues">ルートのパラメーター値。</param>
        <summary>ルートのパラメーター値とルート名を使用して、要求された URL から新しい URL への永続的なリダイレクトを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 2 番目のパラメーターを設定したメソッド `false`します。  
  
 このメソッドは、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> URL を決定する方法です。  
  
 ASP.NET では、HTTP ステータス コード 301 を返すことによって、リダイレクトを実行します。  
  
   
  
## 例  
 次の例は、という名前のルートにリダイレクトするには、このメソッドを呼び出す方法を示しています。 `Product` というパラメーターを持つと `productid` と `category`です。  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したルート パラメーターに対応するルートがありません。</exception>
        <exception cref="T:System.Web.HttpException">リダイレクトは、HTTP ヘッダーが送信された後にしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">キャッシュから削除されるアイテムへの仮想絶対パス。</param>
        <summary>既定の出力キャッシュ プロバイダーに関連付けられているキャッシュされたアイテムをすべてキャッシュから削除します。 これは静的メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の出力キャッシュ プロバイダーに関連付けられている出力キャッシュ アイテムを削除するには、このメソッドを呼び出します。 呼び出す、 <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> Web サイトの構成ファイルで指定されているカスタムの出力キャッシュ プロバイダーに関連付けられている出力キャッシュ アイテムを削除する方法です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 絶対仮想パスではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">キャッシュから削除されるアイテムへの絶対仮想パス。</param>
        <param name="providerName">指定されたパスに関連付けられている出力キャッシュの成果物を削除するのに使用されるプロバイダー。</param>
        <summary>指定された出力キャッシュ プロバイダーを使用して、指定されたパスに関連付けられている出力キャッシュ アイテムをすべて削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web サイトの構成ファイルで指定されているカスタムの出力キャッシュ プロバイダーに関連付けられている出力キャッシュ アイテムを削除するには、このメソッドを呼び出します。 既定の出力キャッシュ プロバイダーに関連付けられている出力キャッシュ アイテムを削除するには、呼び出し、 <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> メソッドのオーバー ロードします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> が null です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 無効なパスです。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">更新するコレクションに存在するクッキー。</param>
        <summary>クッキー コレクションの既存のクッキーを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、既存のクッキーの値を更新します。  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP ヘッダーが送信された後に、cookie を設定しようとしています。</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントに返される <see langword="Status" /> ラインを設定します。</summary>
        <value>ステータス コードを設定すると、HTTP 出力のステータスを記述する文字列がクライアントへ返されます。 既定値は 200 \(OK\) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.Status%2A> 優先の使用は推奨されて <xref:System.Web.HttpResponse.StatusDescription%2A> ASP の旧バージョンとの互換性のためにのみ提供されています。 ASP.NET では、次のように使用します。 <xref:System.Web.HttpResponse.StatusDescription%2A> 代わりにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">状態は、無効なステータス コードに設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントへ返される出力の HTTP ステータス コードを取得または設定します。</summary>
        <value>クライアントへ返される HTTP 出力のステータスを表す整数。 既定値は 200 \(OK\) です。 有効なステータス コードの一覧については、次を参照してください。 [Http Status Codes](http://go.microsoft.com/fwlink/?LinkId=73157)します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、出力ストリームのステータス コードを確認します。 ステータス コードが 200 と等しくない場合は、追加のコードが実行されます。  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.StatusCode" /> HTTP ヘッダーが送信された後に設定されています。</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントへ返される出力の HTTP ステータス文字列を取得または設定します。</summary>
        <value>クライアントへ返される HTTP 出力のステータスを記述する文字列。 既定値は "OK" です。 有効なステータス コードの一覧については、次を参照してください。 [Http Status Codes](http://go.microsoft.com/fwlink/?LinkId=73157)します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、出力ストリームのステータス文字列を確認します。 状態が"ok"と等しくない場合は、追加のコードが実行されます。  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="StatusDescription" /> HTTP ヘッダーが送信された後に設定されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">選択した値は、512 より大きい長さです。</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>応答のステータス コードを修飾する値を取得または設定します。</summary>
        <value>IIS 7.0 のサブステータス コードを表す整数の値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.SubStatusCode%2A> プロパティは統合パイプライン モードでのみサポート [!INCLUDE[iisver](~/includes/iisver-md.md)] と少なくとも .NET Framework バージョン 3.0。 設定すると、 <xref:System.Web.HttpResponse.SubStatusCode%2A> プロパティには、状態がログオンして [!INCLUDE[iisver](~/includes/iisver-md.md)] 失敗した要求トレースが構成されている場合。 トレースを構成しているかどうかに依存せず、コードは、要求には、最後の応答の一部としては送信されません。 詳細については、次を参照してください。 [Troubleshooting Failed Requests Using Failed Request Tracing in IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1)します。  
  
   
  
## 例  
 次の例のセット、 <xref:System.Web.HttpResponse.SubStatusCode%2A> のイベント ハンドラーのプロパティ、 <xref:System.Web.HttpApplication> のインスタンス、 <xref:System.Web.HttpApplication.PostAuthenticateRequest> イベントです。 コード ファイルを Web アプリケーションの App\_Code フォルダーに配置し、モジュールを登録する Web.config ファイルを構成します。 詳細については、「[How to: Create and Register Custom HTTP Modules](http://msdn.microsoft.com/ja-jp/7787d5be-40a4-4072-9075-c2b767428453)」を参照してください。  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">操作には、IIS 7.0 の統合パイプライン モードと、少なくとも .NET Framework バージョン 3.0 が必要です。</exception>
        <exception cref="T:System.Web.HttpException">状態コードは、すべての HTTP ヘッダーが送信された後に設定されます。</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続が非同期のフラッシュ操作をサポートするかどうかを示す値を取得します。</summary>
        <value>接続が非同期フラッシュ操作をサポートする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの値を返す、 <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=fullName> プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP コンテンツをクライアントに送信するかどうかを示す値を取得または設定します。</summary>
        <value>出力しない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例を確認するかどうか、 <xref:System.Web.HttpRequest.IsSecureConnection%2A> プロパティが false に設定します。 である場合、 <xref:System.Web.HttpResponse.SuppressContent%2A> プロパティが送信されてからの応答を停止する場合は true に設定します。  
  
 [!code-csharp[System.Web.HttpResponse\_Sample5\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse\_Sample5\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>\[.NET Framework 4.5.2 以降のバージョンでのみでサポート\]  
  
 現在の HTTP 応答に対して既定の <c>Cache Control: private</c> を抑制するかどうかを示す値を取得または設定します。</summary>
        <value>現在の HTTP 応答に対して既定の <c>Cache Control: private</c> ヘッダーを抑制する場合は <see langword="true" />。それ以外の場合は<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、ASP.NET の送信、 `Cache-Control: private` 応答ヘッダーこの応答を明示的にキャッシュ ポリシーが指定されていない限りです。 このプロパティでは、要求ごとにこの既定の応答ヘッダーを抑制します。 ヘッダーはまだ設定アプリケーション全体の非表示 <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> で [httpRuntime 要素 \(ASP.NET 設定スキーマ\)](http://msdn.microsoft.com/ja-jp/e9b81350-8aaf-47cc-9843-5f7d0c59f369) または [outputCache 要素 \(ASP.NET 設定スキーマ\) をキャッシュ用](http://msdn.microsoft.com/ja-jp/47cd2b47-316f-4dfd-bbf8-539be3066fee)します。  
  
 既定値を非表示を不用意に `Cache-Control: private` プロキシとしてのヘッダーなどの中継ぎ局として扱ってことがこのヘッダーを使用せずに応答キャッシュ可能な既定です。 この処理は、機密情報の不慮のキャッシュを可能性があります。 参照してください [RFC 2616, Sec. 13.4](http://tools.ietf.org/html/rfc2616) の詳細。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ログイン ページへのフォーム認証のリダイレクトを抑制する必要があるかどうかを示す値を取得または設定します。</summary>
        <value>フォーム認証のリダイレクトを抑制する必要がある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、フォーム認証は、ログイン ページにリダイレクトするために HTTP 401 ステータス コードを 302 に変換します。 これは、適切なは、特定の認証が成功した場合も、承認などのエラーのクラスが失敗した場合、または現在の要求が、AJAX や web サービス要求の場合はありません。 このプロパティは、リダイレクトの動作を抑制して、元の状態コードをクライアントに送信する方法を提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">HTTP 出力に書き込むファイルの名前。</param>
        <summary>指定されたファイル ディレクトリを、メモリにバッファリングせずに、HTTP 応答出力ストリームに直接書き込みます。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> パラメーターは、 <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">HTTP 出力に書き込むファイルの名前。</param>
        <param name="offset">HTTP 出力への書き出しを始める、ファイル内の位置。</param>
        <param name="length">送信されるバイト数。</param>
        <summary>指定したファイル ディレクトリの一部を、メモリにバッファリングせずに、HTTP 応答出力ストリームに直接書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 として 0 を指定する場合、 `offset` パラメーターと\-1 である場合、 `length` パラメーター、ファイル全体を送信します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="offset" /> パラメーターが 0 未満。  
  
 または  
  
 <paramref name="length" /> パラメーターが \-1 未満。  
  
 または  
  
 <paramref name="length" /> パラメーターは、オフセットを引いたファイルに含まれるバイト数を超えるバイト数を指定します。</exception>
        <exception cref="T:System.PlatformNotSupportedException">アウト プロセス ワーカー要求はサポートされていません。  
  
 または  
  
 応答を使用していない、 <see cref="T:System.Web.HttpWriter" /> オブジェクトです。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> パラメーターが 0 未満か、ファイルのサイズより大きい。  
  
 または  
  
 <paramref name="length" /> パラメーターが\-1 の値より大きいか小さい、 <paramref name="offset" /> パラメーターとファイルのサイズ。</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>IIS 7.0カスタム エラーが無効かどうかを指定する値を取得または設定します。</summary>
        <value>IIS カスタム エラーが無効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> プロパティは、アプリケーションが IIS 7.0 でホストされている場合にのみ使用します。 IIS 7.0 でクラシック モードで実行する場合、 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> プロパティの既定値は `true`です。 統合モードで実行する場合、 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> プロパティの既定値は `false`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">HTTP 出力ストリームに書き込む文字。</param>
        <summary>文字を HTTP 応答出力ストリームに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、一連の Write メソッドを使用して、ASP.NET ページに書き込まれる定数を作成します。 コードでは、このバージョンの個々 の文字定数をページに書き込む、Write メソッドを呼び出します。  
  
 [!code-csharp[System.Web.HttpResponse\_Sample5\#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-vb[System.Web.HttpResponse\_Sample5\#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">HTTP 出力ストリームに書き込む <see cref="T:System.Object" />。</param>
        <summary>
          <see cref="T:System.Object" /> を HTTP 応答出力ストリームに書き込みます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">HTTP 出力ストリームに書き込む文字列。</param>
        <summary>文字列を HTTP 応答出力ストリームに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 動的に生成された HTML ページは、クライアントから受信したとき、またはクライアントに送信する場合、Web クライアントから受信した入力は検証されていない場合、セキュリティ上のリスクを導入できます。 Web サイトに送信され、後で出力をクライアントに入力に埋め込まれている悪意のあるスクリプトが表示され、信頼できるソースから発生します。 このセキュリティ上のリスクは、クロスサイト スクリプティング攻撃と呼ばれます。 常に、サイトからクライアントのブラウザーに送信されますしたときに、クライアントから受信するデータを検証する必要があります。  
  
 さらに、記述するときに html 形式で入力として受信したすべてのデータをエンコードするなどの手法を使用して、 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> または <xref:System.Web.HttpServerUtility.UrlEncode%2A> を悪意のあるスクリプトが実行するを防ぐためにします。 この手法は、受信したときに検証されていないデータに役立ちます。  
  
 エンコードまたはデータをフィルター処理するときに、フィルターを特定してに属していないれるバイトのシーケンスで、\(英数字以外のシーケンス\) などを設定しに埋め込まれている悪意のあるスクリプトを持つ可能性がある可能性がありますを削除するよう、Web ページに対して設定文字を指定する必要があります。  
  
 詳細については、クロスサイト スクリプティング攻撃、記事を参照して Q252985、「方法に防止クロスサイト スクリプティング セキュリティの問題」に、 [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?LinkID=37115) Web サイトです。  
  
   
  
## 例  
 次の例では、クライアントのブラウザーに返し、クライアントの名前をエコーします。<xref:System.Web.HttpServerUtility.HtmlEncode%2A> メソッドでは、悪意のあるスクリプトと無効な文字で送信される可能性がありますが、 `UserName` 入力フィールドです。  
  
 [!code-csharp[System.Web.HttpResponse.Write\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">書き込む文字配列。</param>
        <param name="index">書き込みを開始する文字配列内の位置。</param>
        <param name="count">書き込む文字数。書き込みは、<c>index</c> から開始されます。</param>
        <summary>文字配列を HTTP 応答出力ストリームに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、一連の書き込みメソッドを使用して、ASP.NET ページに書き込まれる定数を作成します。 コードでは、このバージョンの個々 の文字定数をページに書き込む、書き込みメソッドを呼び出します。  
  
 [!code-csharp[System.Web.HttpResponse\_Sample5\#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-vb[System.Web.HttpResponse\_Sample5\#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">HTTP 出力に書き込むファイルの名前。</param>
        <summary>指定されたファイルの内容を、ファイル ブロックとして HTTP 応答出力ストリームに直接書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サイズの大きなファイルにこのメソッドは、使用する場合は、メソッドを呼び出すと例外がスローする可能性があります。 このメソッドで使用できるファイルのサイズは、Web サーバーのハードウェア構成によって異なります。 詳細については、記事を参照して 812406「PRB:: Response.WriteFile できません、大規模なファイルのダウンロード」で、 [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) Web サイトです。  
  
   
  
## 例  
 次の例は、という名前のテキスト ファイルのすべての内容を書き込む `Login.txt` \(リテラルの HTML テキストと入力コントロールを含む可能性があります\) 出力ストリームに直接します。  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">メモリ ブロックに書き込むファイルの名前。</param>
        <param name="readIntoMemory">ファイルがメモリ ブロックに書き込まれるかどうかを示します。</param>
        <summary>指定されたファイルの内容を、メモリ ブロックとして HTTP 応答出力ストリームに直接書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サイズの大きなファイルにこのメソッドは、使用する場合は、メソッドを呼び出すと例外がスローする可能性があります。 このメソッドで使用できるファイルのサイズは、Web サーバーのハードウェア構成によって異なります。 詳細については、記事を参照して 812406「PRB:: Response.WriteFile できません、大規模なファイルのダウンロード」で、 [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) Web サイトです。  
  
   
  
## 例  
 次の例は、ファイルをメモリに書き込みます。  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">HTTP 出力ストリームに書き込むファイルのファイル ハンドル。</param>
        <param name="offset">書き込みを開始するファイル内のバイト位置。</param>
        <param name="size">出力ストリームに書き込むバイト数。</param>
        <summary>指定したファイルを HTTP 応答出力ストリームに直接書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サイズの大きなファイルにこのメソッドは、使用する場合は、メソッドを呼び出すと例外がスローする可能性があります。 このメソッドで使用できるファイルのサイズは、Web サーバーのハードウェア構成によって異なります。 詳細については、記事を参照して 812406「PRB:: Response.WriteFile できません、大規模なファイルのダウンロード」で、 [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) Web サイトです。  
  
   
  
## 例  
 次の例は、という名前のテキスト ファイルのすべての内容を書き込む `Login.txt` \(リテラルの HTML テキストと入力コントロールを含む可能性があります\) 出力ストリームに直接します。  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileHandler" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> は、ファイルのサイズから <paramref name="offset" /> を引いた値よりも大きいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">HTTP 出力ストリームに書き込むファイルの名前。</param>
        <param name="offset">書き込みを開始するファイル内のバイト位置。</param>
        <param name="size">出力ストリームに書き込むバイト数。</param>
        <summary>指定したファイルを HTTP 応答出力ストリームに直接書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サイズの大きなファイルにこのメソッドは、使用する場合は、メソッドを呼び出すと例外がスローする可能性があります。 このメソッドで使用できるファイルのサイズは、Web サーバーのハードウェア構成によって異なります。 詳細については、記事を参照して 812406「PRB:: Response.WriteFile できません、大規模なファイルのダウンロード」で、 [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) Web サイトです。  
  
   
  
## 例  
 次の例は、という名前のテキスト ファイルのすべての内容を書き込む `Login.txt` \(入力コントロールのリテラル テキストと HTML を含んでいる可能性があります\) 出力ストリームに直接します。  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> は、ファイルのサイズから <paramref name="offset" /> を引いた値よりも大きいです。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">置換するメソッド、ユーザー コントロール、またはオブジェクト。</param>
        <summary>応答置換ブロックを応答に挿入できます。これにより、出力キャッシュされた応答の指定された応答領域を動的に生成できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することができます、<xref:System.Web.HttpResponse.WriteSubstitution%2A>出力キャッシュのページ キャッシュ後置換用のメソッドです。 渡すことによって、<xref:System.Web.HttpContext>オブジェクトを持つ、指定されたコールバック メソッドに<xref:System.Web.HttpResponseSubstitutionCallback>署名、出力キャッシュを置き換えることができますページ キャッシュ内の任意の指定した場所にコンテンツ。 交換を開始するには、呼び出し、<xref:System.Web.HttpResponse.WriteSubstitution%2A>メソッドをコールバック メソッドは、スレッド セーフである必要があります、次のいずれかを渡します。  
  
-   コンテナーのページやユーザー コントロールの静的メソッド。  
  
-   静的な他の任意のオブジェクトでメソッドまたはインスタンス メソッドです。  
  
 ページに最初の要求で、<xref:System.Web.HttpResponse.WriteSubstitution%2A>呼び出し、<xref:System.Web.HttpResponseSubstitutionCallback>出力を生成するためにデリゲートします。 次に、今後の要求を呼び出すデリゲートを保持すると、応答に代替バッファーを追加します。 最後に、クライアント側キャッシュからパブリック サーバーのみをキャッシュしないと、クライアント上でデリゲートをページを再度呼び出してに今後の要求に確保が低下します。  
  
> [!NOTE]
>  キャッシュ後置換はキャッシュされたユーザー コントロールがユーザーの制御レベル出力キャッシュの適用先ではサポートされていません。 これは、フラグメント キャッシュとも呼ばれます。 詳細については、「[Caching Portions of an ASP.NET Page](http://msdn.microsoft.com/ja-jp/cdd8e523-7305-4685-a456-c5be1de1367e)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Web.UI.Control" /> 型の <paramref name="callback" /> パラメーターのターゲット。</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>promise オブジェクトを昇格させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ファイル名のグループを、現在の応答が依存しているファイル名のコレクションに追加します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>クライアントを新しい URL にリダイレクトします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>キャッシュ内の他のアイテムに依存するキャッシュされた応答を有効にします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既定の出力キャッシュ プロバイダーを使用して、出力キャッシュからキャッシュされたアイテムを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>情報を HTTP 応答出力ストリームに書き込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ルートのパラメーター値とルート名の両方またはいずれかを使用して、要求された URL から新しい URL への永続的なリダイレクトを実行します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ルートのパラメーター値とルート名の両方またはいずれかを使用して、新しい URL に要求をリダイレクトします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したファイルを HTTP 応答出力ストリームに直接書き込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>要求された URL から指定された URL への永続的なリダイレクトを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたファイル ディレクトリを、メモリにバッファリングせずに、HTTP 応答出力ストリームに直接書き込みます。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>