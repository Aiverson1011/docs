<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Web 要求中にクライアントから送信された HTTP 値を ASP.NET で読み取ることができるようにします。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドとプロパティの <xref:System.Web.HttpRequest> クラスがを介して公開される、 `Request` のプロパティ、 <xref:System.Web.HttpApplication>, 、<xref:System.Web.HttpContext>, 、<xref:System.Web.UI.Page>, 、および <xref:System.Web.UI.UserControl> クラスです。  
  
 データにアクセスする、 <xref:System.Web.HttpRequest.QueryString%2A>, 、<xref:System.Web.HttpRequest.Form%2A>, 、<xref:System.Web.HttpRequest.Cookies%2A>, 、または <xref:System.Web.HttpRequest.ServerVariables%2A> 記述するコレクション、 `Request["key"]`, の例のように、 <xref:System.Web.HttpRequest.QueryString%2A> プロパティです。  
  
> [!NOTE]
>  Unicode のサポートの <xref:System.Web.HttpRequest> クラスのメンバーには、IIS バージョン 6.0 以降が必要です。  
  
   
  
## 例  
 次の例のアクセス、 <xref:System.Web.HttpRequest> を使用して現在の要求のインスタンス、 <xref:System.Web.UI.Page.Request%2A> のプロパティ、 <xref:System.Web.UI.Page> クラスです。  
  
 簡略化された構文を使用するにはからのデータにアクセスするため、 <xref:System.Web.HttpRequest.QueryString%2A>, 、<xref:System.Web.HttpRequest.Form%2A>, 、<xref:System.Web.HttpRequest.Cookies%2A>, 、または <xref:System.Web.HttpRequest.ServerVariables%2A> コレクションです。 記述する `Request["key"]`です。  
  
 最初の例では、ページの読み込み時に、クエリ文字列の値を取得する方法を示します。  
  
```csharp  
public partial class AddToCart : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        string rawId = Request["ProductID"];  
        int productId;  
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))  
        {  
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())  
            {  
                usersShoppingCart.AddToCart(productId);  
            }  
        }  
        else  
        {  
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");  
        }  
        Response.Redirect("ShoppingCart.aspx");  
    }  
}  
```  
  
```vb  
Public Class AddToCart  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        Dim rawId = Request("ProductID")  
        Dim productId As Integer  
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then  
            Using usersShoppingCart As New ShoppingCartActions()  
                usersShoppingCart.AddToCart(productId)  
            End Using  
  
        Else  
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")  
        End If  
        Response.Redirect("ShoppingCart.aspx")  
    End Sub  
End Class  
```  
  
 次の例では、要求が認証されているかどうかは確認および生の URL を取得する方法を示します。  
  
```csharp  
public partial class RestrictedPage : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        if (!Request.IsAuthenticated)  
        {  
            var rawUrl = Request.RawUrl;  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));  
        }  
    }  
}  
```  
  
```vb  
Public Class RestrictedPage  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        If Not Request.IsAuthenticated Then  
            Dim rawUrl = Request.RawUrl  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))  
        End If  
    End Sub  
End Class  
```  
  
 ソース コードの Visual Studio の Web サイト プロジェクトはこのトピック用に使用可能な: [Download](http://go.microsoft.com/fwlink/?LinkID=191455)します。  
  
 この例では、 <xref:System.IO.StreamWriter> いくつかの値を書き込むためにクラス <xref:System.Web.HttpRequest> クラスのプロパティをファイルにします。 プロパティが文字列型で、HTML エンコードされることは、ファイルに書き込まれるとは、値になります。 コレクションを表すプロパティがループし、そこに含まれるキー\/値ペアは、ファイルに書き込まれます。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要求に関連付けられたファイルの名前。</param>
        <param name="url">現在の要求の URL に関する情報。</param>
        <param name="queryString">要求と共に送信されるクエリ文字列全体 \(<c>'?'</c> の後の部分すべて\)。</param>
        <summary>
          <see cref="T:System.Web.HttpRequest" /> オブジェクトを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 You do not need to create your own instance of the <xref:System.Web.HttpRequest> class. The methods and properties of the <xref:System.Web.HttpRequest> class are exposed through the **languageKeyword tag is not supported!!!!**  
 property of the <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, and <xref:System.Web.UI.UserControl> classes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>基になっている TCP 接続を強制的に終了します。未処理の I\/O は失敗します。 悪意のある HTTP クライアントによる攻撃に対してこのメソッドを使用できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is thread\-safe. Any thread may call it at any time.  
  
 This method can only be used in integrated mode. If you invoke it in classic mode, an exception is thrown. To determine the pipeline mode, use <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントにサポートされている MIME で使用できる型の文字列配列を取得します。</summary>
        <value>クライアントにサポートされている MIME で使用できる型の文字列配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例は、によって返される複数の値をキャプチャ、 <xref:System.Web.HttpRequest.AcceptTypes%2A> オブジェクト変数にプロパティの各値の名前と番号を書き込みますHTTP 出力の個別の行にします。  
  
 [!code-csharp[Classic HttpRequest.AcceptTypes Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>存在する場合は、ユーザーの匿名 ID を取得します。</summary>
        <value>現在の匿名ユーザーの ID を表す文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest.AnonymousID%2A> プロパティ内のデータを格納することがなく、そのユーザー プロファイルのプロパティを割り当てるユーザーを追跡するために使用する未認証のユーザーに長期間維持される一意の識別子を割り当てます、 `Session` オブジェクトです。 既定では、 <xref:System.Web.HttpRequest.AnonymousID%2A> プロパティは、cookie を使用して、追跡、URI を使用する設定できますが、ときに、 <xref:System.Web.Configuration.SessionStateSection.Cookieless%2A> 匿名 id の構成\] セクションで属性に設定されている、 <xref:System.Web.HttpCookieMode.UseUri>, 、<xref:System.Web.HttpCookieMode.UseDeviceProfile>, 、または <xref:System.Web.HttpCookieMode.AutoDetect> 値。 必要がなくなったこと、たとえば、匿名ユーザーが認証されたら、使用可能な場合に明示的に、cookie をオフにする必要があります。  
  
 認証されていないエンティティを識別する必要がある場合に、および承認が必要な場合は、匿名 id が使用されます。 詳細については、「[anonymousIdentification Element \(ASP.NET Settings Schema\)](http://msdn.microsoft.com/ja-jp/2bd927ef-9057-4703-9c55-4cfb6d7d0929)」を参照してください。  
  
   
  
## 例  
 次の例では、使用する方法、 <xref:System.Web.HttpRequest.AnonymousID%2A> プロパティを処理することにより、 <xref:System.Web.Security.AnonymousIdentificationModule.Creating> Global.asax ファイル内のイベントです。 この例では、2 つの部分があります。  
  
-   Global.asax ファイルを処理するメソッド、 <xref:System.Web.Security.AnonymousIdentificationModule.Creating> イベントです。  
  
-   Web フォーム ページです。  
  
 このコード例の最初の部分を設定する方法を示しています、 <xref:System.Web.HttpRequest.AnonymousID%2A> プロパティを処理することにより、 <xref:System.Web.Security.AnonymousIdentificationModule.Creating> Global.asax ファイル内のイベントです。 名前はメソッド `AnonymousIdentification_Creating` 設定、 <xref:System.Web.HttpRequest.AnonymousID%2A> 匿名 ID を作成するプロパティです。  
  
 [!code-csharp[System.Web.HttpRequest\_AnonymousID\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest\_AnonymousID\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]  
  
 コード例の 2 番目の部分が、新しい表示方法を示す <xref:System.Web.HttpRequest.AnonymousID%2A> によって作成、 `AnonymousIdentification_Creating` 前の例では、イベント ハンドラーです。  
  
 [!code-csharp[System.Web.HttpRequest\_AnonymousID\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest\_AnonymousID\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.IsAuthenticated" />
        <altmember cref="E:System.Web.Security.AnonymousIdentificationModule.Creating" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバーの ASP.NET アプリケーションの仮想アプリケーション ルート パスを取得します。</summary>
        <value>現在のアプリケーションの仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを使用すると、ページまたは Web ユーザー コントロールがルート ディレクトリにない場合のアプリケーションのルートに対する相対 URL を構築します。 これにより、ページと同じコードで、アプリケーションで固定の場所のリソースへのリンクを使用してディレクトリ構造のさまざまなレベルで存在するコントロールを共有できます。  
  
   
  
## 例  
 次の例では、 <xref:System.IO.StreamWriter.Write%2A> HTML エンコードする方法の値を書き込むと、 <xref:System.Web.HttpRequest.ApplicationPath%2A> プロパティをテキスト ファイルです。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。 ことを想定する <xref:System.IO.StreamWriter> という名前のオブジェクト `sw`します。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 次の例では、 <xref:System.Web.HttpRequest.ApplicationPath%2A> プロパティをプログラムで、アプリケーションで固定した場所にあるリソースへのパスを構築します。 リソースを参照するページには、リソースと同じディレクトリにある必要はありません。  
  
 [!code-csharp[System.Web.HttpRequest.ApplicationPath\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-vb[System.Web.HttpRequest.ApplicationPath\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]  
  
 WebSite1、という Web アプリケーションでこの例を実行する場合  `/WebSite1` の値として表示される、 <xref:System.Web.HttpRequest.ApplicationPath%2A> プロパティと `/WebSite1/images/Image1.gif` はイメージの完全なパスとして表示されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ルートの仮想パスを取得し、ティルダ \(~\) 表記 \("~\/page.aspx" など\) を使用した、アプリケーション ルートの相対パスにします。</summary>
        <value>現在の要求に対応するアプリケーション ルートの仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this property to provide URL information that will stay the same even if the application changes location. This allows the same URL\-mapping code to be used in a test environment and in the final deployment environment, or to be used by copies of Web applications in different domains.  
  
   
  
## 例  
 The following example uses the <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> property to set the URL of an <xref:System.Web.UI.WebControls.Image> control to an image in the same directory as the page. Run this page at different levels of a directory structure to see the resulting <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> property values.  
  
 [!code-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]  
  
 The following example uses the <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> property to programmatically set the path to a resource, based on the current path of the page.  
  
 [!code-csharp[System.Web.HttpRequest.ApplicationPath\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-vb[System.Web.HttpRequest.ApplicationPath\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">読み取るバイト数。</param>
        <summary>現在の入力ストリームから、指定したバイト数のバイナリ読み取りを実行します。</summary>
        <returns>バイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest.BinaryRead%2A> の ASP との互換性のためにメソッドが用意されています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> は 0 です。  
  
 または  
  
 <paramref name="count" /> は使用可能なバイト数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求を実行中のクライアントのブラウザーの性能に関する情報を取得または設定します。</summary>
        <value>クライアントのブラウザーの性能を一覧表示する <see cref="T:System.Web.HttpBrowserCapabilities" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、クライアントに HTML ページに戻る、ブラウザーの機能の一覧を送信します。  
  
 [!code-csharp[Classic HttpRequest.Browser Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在、要求しているクライアントのセキュリティ証明書を取得します。</summary>
        <value>クライアントのセキュリティ証明書の設定に関する情報を格納している <see cref="T:System.Web.HttpClientCertificate" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following code example sends the client's certificate settings back to the client in an HTML page.  
  
 [!code-csharp[Classic HttpRequest.ClientCertificate Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エンティティ本体の文字セットを取得または設定します。</summary>
        <value>クライアントの文字セットを表す <see cref="T:System.Text.Encoding" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Default content encoding can be specified in the [globalization Element \(ASP.NET Settings Schema\)](http://msdn.microsoft.com/ja-jp/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) of a configuration file. If content encoding is also specified by the client, the default configuration settings are overridden.  
  
   
  
## 例  
 The following code example assigns a value representing the description of the current HTTP encoding to a string variable.  
  
 [!code-csharp[Classic HttpRequest.ContentEncoding Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから送信されたコンテンツの長さをバイト単位で指定します。</summary>
        <value>クライアントから送信されたコンテンツの長さ \(バイト単位\)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、整数型の変数への着信要求のコンテンツの長さを表す値を割り当てます。  
  
 [!code-csharp[Classic HttpRequest.ContentLength Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>受信要求で使用する MIME の Content\-Type を取得または設定します。</summary>
        <value>受信要求の MIME コンテンツ タイプを表す文字列 \("text\/html" など\)。 このほかに、一般的な MIME タイプとしては "audio.wav"、"image\/gif"、"application\/pdf" などがあります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following code example assigns the value representing the content type of the incoming request to a string variable.  
  
 [!code-csharp[Classic HttpRequest.ContentType Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]  
  
 The following example shows output that might be produced by this code.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから送信されたクッキーのコレクションを取得します。</summary>
        <value>クライアントのクッキー変数を表す <see cref="T:System.Web.HttpCookieCollection" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET には、2 つの組み込みクッキー コレクションが含まれています。 によってアクセスされるコレクション、 <xref:System.Web.HttpRequest.Cookies%2A> のコレクション <xref:System.Web.HttpRequest> 内のサーバーにクライアントによって送信される cookie を含む、 `Cookie` ヘッダー。 によってアクセスされるコレクション、 <xref:System.Web.HttpResponse.Cookies%2A> のコレクション <xref:System.Web.HttpResponse> 、サーバー上に作成され、クライアントに送信された新しい cookie を含む、 `Set-Cookie` ヘッダー。  
  
> [!NOTE]
>  使用して cookie を追加した後、 <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=fullName> コレクション、cookie がですぐに使用できる、 <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=fullName> 応答がクライアントに送信されていない場合でも、コレクションです。  
  
   
  
## 例  
 次のコード例では、クライアントから送信されたすべての cookie をループ処理し、名前、有効期限の日付、セキュリティ パラメーター、および各 cookie の値を HTTP 出力に送信します。  
  
 [!code-csharp[Classic HttpRequest.Cookies Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の仮想パスを取得します。</summary>
        <value>現在の要求の仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> 現在実行中のページ ハンドラーへのファイル パスを返します。 使用して、リダイレクトのシナリオの <xref:System.Web.HttpServerUtility.Execute%2A> と <xref:System.Web.HttpServerUtility.Transfer%2A> つまり、このメソッド、 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> プロパティが \(子ページ\) にリダイレクトされるページへのパスを返します。 別のページにクライアントがリダイレクトされるときに、 <xref:System.Web.HttpRequest.FilePath%2A> プロパティが元のページへのパスを返します。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.HttpUtility.HtmlEncode%2A> HTML エンコードする方法の値、 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="M:System.Web.HttpServerUtility.Execute(System.String)" />
        <altmember cref="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> プロパティで指定されているファイル名の拡張子を取得します。</summary>
        <value>
          <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> プロパティで指定されているファイル名の拡張子。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の仮想パスを取得します。</summary>
        <value>現在の要求の仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest.FilePath%2A> プロパティを含まない、 <xref:System.Web.HttpRequest.PathInfo%2A> トレーラです。 たとえば、URL http:\/\/www.contoso.com\/virdir\/page.html\/tail、 <xref:System.Web.HttpRequest.FilePath%2A> 値は\/virdir\/page.html です。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.HttpUtility.HtmlEncode%2A> HTML エンコードする方法の値、 <xref:System.Web.HttpRequest.FilePath%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マルチパート MIME 形式でクライアントによってアップロードされたファイルのコレクションを取得します。</summary>
        <value>クライアントによってアップロードされたファイルのコレクションを表す <see cref="T:System.Web.HttpFileCollection" /> オブジェクト。<see cref="T:System.Web.HttpFileCollection" /> オブジェクトの項目は <see cref="T:System.Web.HttpPostedFile" /> 型です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ファイル コレクションの設定のみ、HTTP の要求と `Content-Type` 値は「マルチパート\/フォームのデータ」です。  
  
   
  
## 例  
 次のコード例のすべてのファイルの名前を表示する、 <xref:System.Web.HttpRequest.Files%2A> コレクションです。  
  
 [!code-csharp[Classic HttpRequest.Files Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の入力ストリームを読み取るときに使用するフィルターを取得または設定します。</summary>
        <value>フィルターとして使用される <see cref="T:System.IO.Stream" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例は、2 つの新しいクラスを作成 `QQQ1` と `QQQ2` そのフィルター、 <xref:System.Web.HttpRequest.InputStream%2A>です。 アプリケーションのすべての ASP.NET Web ページのすべての入力がフィルター処理できるように、ASP.NET アプリケーションのディレクトリに Global.asax ファイルにクラスを配置します。  
  
 [!code-csharp[System.Web.HttpRequest.Filter\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest.Filter\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">指定した <see cref="T:System.IO.Stream" /> が無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォーム変数のコレクションを取得します。</summary>
        <value>フォーム変数のコレクションを表す <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest.Form%2A> プロパティは、設定、HTTP の要求と `Content-Type` 値が"アプリケーション\/x\-www\-form\-urlencoded"または「マルチパート\/フォームのデータ」です。  
  
   
  
## 例  
 次の例では、ブラウザーからポストされたフォームのコレクション内の値を読み取る方法を示します。 コレクション内の各名前\/値ペアは、フォームとその値にコントロールを表します。  
  
 [!code-csharp[Classic HttpRequest.Form Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得します。</summary>
        <returns>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを同じ <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> 設定に ASP.NET によって使用される内部ストレージに読み取られるバイトをコピーする点を除いて、 <xref:System.Web.HttpRequest.Form%2A>, 、<xref:System.Web.HttpRequest.Files%2A>, 、および <xref:System.Web.HttpRequest.InputStream%2A> プロパティです。 この情報が保持されるため、ASP.NET Web フォーム ページ \(.aspx ファイル\) などのダウンストリーム コードは正常に実行されます。 これは、<xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> メソッドには該当しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求のエンティティ本体は既に読み込まれ解析されます。 エンティティ本体を読み込んで解析するプロパティの例については、次のとおりです。  
  
-   <see cref="P:System.Web.HttpRequest.Form" /> プロパティ。  
  
-   <see cref="P:System.Web.HttpRequest.Files" /> プロパティ。  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" /> プロパティ。  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" /> メソッド。  
  
 この例外を避けるためには、呼び出し、 <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> メソッド最初です。 この例外は、エンティティ本体の読み取り中に、クライアントが切断した場合にもスローされます。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得します。</summary>
        <returns>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、使用する代わりに、 <xref:System.Web.HttpRequest.InputStream%2A> プロパティです。<xref:System.Web.HttpRequest.InputStream%2A> プロパティを返す前に全体の要求を受け取るまでの待機、 <xref:System.IO.Stream> オブジェクトです。 これに対し、 <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> メソッドが返される、 <xref:System.IO.Stream> すぐにオブジェクトです。 メソッドを使用すると、本文の内容全体が受信される前に、エンティティ本体の処理を開始します。  
  
 エンティティ本体 \(できるだけ多くの部分を要求が受信された\) オブジェクトを使用するときにのみ返されるストリームを読み取るなどのメソッドを呼び出すことで、このメソッドによって返される、 <xref:System.IO.Stream.Read%2A> メソッドです。 パラメーターを使用して、 <xref:System.IO.Stream.Read%2A> エンティティ本体を読み取るの量を指定します。  
  
 <xref:System.IO.Stream> ASP.NET によってこのメソッドから返されるオブジェクトは、同期および非同期の読み取りメソッドをサポートしています。<xref:System.IO.Stream> オブジェクトでは、両方を実装して、 <xref:System.IO.Stream.BeginRead%2A> と <xref:System.IO.Stream.EndRead%2A> メソッドです。 非同期のメソッドを使用して、ASP.NET は、非同期読み取りループの各反復処理の間に、現在のスレッドを解放中に、チャンク単位で要求のエンティティを非同期的に読み取りますできます。  
  
 このメソッドは、要求がサイズの大きなファイルをアップロードして、アップロードが完了する前に、ファイルの内容へのアクセスを開始する場合、役に立ちます。 ただし、必要がありますのみこのメソッド シナリオに対して使用するすべてのエンティティ本体の処理を実行します。 つまり、.aspx ページが実行されるまでに、エンティティの本文は既に読み取られているため、.aspx ページからこのメソッドを使用することはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求のエンティティ本体は既に読み込まれ解析されます。 エンティティ本体を読み込んで解析するプロパティの例については、次のとおりです。  
  
-   <see cref="P:System.Web.HttpRequest.Form" />  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   <see cref="P:System.Web.HttpRequest.Files" />  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />  
  
 この例外を避けるためには、呼び出し、 <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> メソッド最初です。 この例外は、エンティティ本体の読み取り中に、クライアントが切断した場合にもスローされます。</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength">要求の期間の制限を無効にする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得し、オプションで <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" /> プロパティに設定した要求の期間の制限を無効にします。</summary>
        <returns>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この方法の詳細については、次を参照してください。、 <xref:System.Web.HttpRequest.GetBufferlessInputStream> オーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求のエンティティ本体は既に読み込まれ解析されます。 エンティティ本体を読み込んで解析するプロパティの例については、次のとおりです。  
  
-   <see cref="P:System.Web.HttpRequest.Form" /> プロパティ。  
  
-   <see cref="P:System.Web.HttpRequest.Files" /> プロパティ。  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" /> プロパティ。  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" /> メソッド。  
  
 この例外を避けるためには、呼び出し、 <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> メソッド最初です。 この例外は、エンティティ本体の読み取り中に、クライアントが切断した場合にもスローされます。</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP ヘッダーのコレクションを取得します。</summary>
        <value>ヘッダーの <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 すべての可能なヘッダーの一覧については、次を参照してください。 [Request Header Fields](http://go.microsoft.com/fwlink/?LinkId=73147) W3C Web サイトです。  
  
   
  
## 例  
 次のコード例は、HTTP 要求で、名前とすべてのヘッダーの値を表示します。  
  
 [!code-csharp[Classic HttpRequest.Headers Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Web.HttpWorkerRequest" /> インスタンスの <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> オブジェクトを取得します。</summary>
        <value>現在の <see cref="T:System.Web.HttpWorkerRequest" /> インスタンスの <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">現在 <see cref="T:System.Web.HttpWorkerRequest" /> オブジェクトは、 <see langword="System.Web.Hosting.IIS7WorkerRequest" /> オブジェクトまたは <see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" /> オブジェクトです。</exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントによって使用される HTTP データ転送メソッド \(<see langword="GET" />、<see langword="POST" />、<see langword="HEAD" /> など\) を取得します。</summary>
        <value>クライアントによって使用される HTTP データの転送方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、 <xref:System.Web.HttpUtility.HtmlEncode%2A> HTML エンコードする方法の値、 <xref:System.Web.HttpRequest.HttpMethod%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 次の例では、このコードによって生成される出力を示します。  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>受信 HTTP エンティティ本体の内容を取得します。</summary>
        <value>受信 HTTP コンテンツ本体の内容を表す <see cref="T:System.IO.Stream" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例の内容をコピーする、 <xref:System.Web.HttpRequest.InputStream%2A> を文字列にします。  
  
 [!code-csharp[Classic HttpRequest.InputStream Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>HTTP 要求エンティティ本体をメモリに挿入する IIS のメソッドのマネージ ラッパーを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A> メソッドのオーバー ロードは、IIS 7 へのアクセスを管理を提供 `IHttpRequest::InsertEntityBody` メソッドです。 IIS のメソッドでは、HTTP 要求エンティティ本体 \(クライアントが掲載されているデータ\) をメモリに挿入します。 これは、機能が読み取られた後に、IIS で要求したエンティティのコピーが維持されないため便利です。<xref:System.Web.HttpRequest.InsertEntityBody%2A> メソッドが HTTP 要求エンティティ データのコピーを作成および使用できるように IIS 追加処理をカスタマイズします。  
  
> [!NOTE]
>  <xref:System.Web.HttpRequest.InsertEntityBody%2A> メソッド オーバー ロードのみを IIS 7.0 以降の作業のため、 `IHttpRequest::InsertEntityBody` メソッドは、IIS 7.0 で追加されました。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>HTTP 要求エンティティ本体のコピーを IIS に提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 読み取られた後、IIS は要求のコピーを保持しません。 そのため、HTTP 要求に対するハンドラーのみが要求したエンティティを読み取ることをお勧めします。  
  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=fullName> が、ASP.NET で既に読み取られた場合、メソッドのオーバー ロードで要求したエンティティのコピーを使用して IIS が提供されます。 このメソッドのオーバー ロードは、ASP.NET がエンティティ要求を読み取り、既存の要求データを再利用する場合に便利です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、IIS 7.0 より前のバージョンの IIS で呼び出されました。</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">For operating in a hosted environment. Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Associated enumeration: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要求エンティティ データが格納されている配列。</param>
        <param name="offset">要求エンティティ データの格納を開始する、<c>buffer</c> 内の、インデックス番号が 0 から始まる位置。</param>
        <param name="count">
          <c>buffer</c> 配列に読み取るバイト数。</param>
        <summary>HTTP 要求エンティティ本体のコピーおよび要求エンティティ オブジェクトについての情報を IIS に提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 読み取られた後、IIS は要求のコピーを保持しません。 そのため、HTTP 要求に対するハンドラーのみが要求したエンティティを読み取ることをお勧めします。  
  
 [InsertEntityBody メソッド \(Byte\<xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=fullName> メソッドのオーバー ロードは、別のエンティティ本体をメモリに挿入するなどのカスタム処理を実行する場合に役立ちます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、IIS 7.0 より前のバージョンの IIS で呼び出されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 負の値です。</exception>
        <exception cref="T:System.ArgumentException">内の項目数 <paramref name="count" /> で利用可能な領域よりも大きい <paramref name="buffer" />, 、指定された、 <paramref name="offset" /> 値。</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">for operating in a hosted environment. Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Associated enumeration: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求が認証されているかどうかを示す値を取得します。</summary>
        <value>要求が認証されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、 <xref:System.Web.HttpRequest.IsAuthenticated%2A> プロパティを現在の要求が認証されているかどうかを判断します。 認証されていない、要求が Web アプリケーションに、ユーザーが自分の資格情報を入力する場所別のページにリダイレクトされます。 これは、アプリケーションの既定のページで使用される一般的な手法です。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample3\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest\_Sample3\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がローカル コンピューターから送信されたかどうかを示す値を取得します。</summary>
        <value>要求がローカル コンピューターから送信された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest.IsLocal%2A> プロパティを返します。 `true` 要求の発信元の IP アドレスが 127.0.0.1 である場合、または要求の IP アドレスがサーバーの IP アドレスと同じである場合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>セキュリティ設定されたソケットを HTTP 接続で使用しているかどうか \(つまり、HTTPS かどうか\) を示す値を取得します。</summary>
        <value>接続に SSL を使用する場合は<see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例を決定するかどうか、 <xref:System.Web.HttpRequest.IsSecureConnection%2A> プロパティが false に設定します。 である場合、 <xref:System.Web.HttpResponse.SuppressContent%2A> プロパティが送信されてからの応答を停止する場合は true に設定します。  
  
 [!code-csharp[System.Web.HttpResponse\_Sample5\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse\_Sample5\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">取得するコレクション メンバーの名前。</param>
        <summary>
          <see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" />、または <see cref="P:System.Web.HttpRequest.ServerVariables" /> の各コレクションから指定したオブジェクトを取得します。</summary>
        <value>
          <paramref name="key" /> パラメーターで指定された <see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" />、または <see cref="P:System.Web.HttpRequest.ServerVariables" /> コレクションのメンバー。 指定した <paramref name="key" /> が見つからない場合は <see langword="null" /> が返されます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のユーザーに対する <see cref="T:System.Security.Principal.WindowsIdentity" /> の種類を取得します。</summary>
        <value>現在の Microsoft Internet Information Services \(IIS\) の認証設定に対応する <see cref="T:System.Security.Principal.WindowsIdentity" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest.LogonUserIdentity%2A> プロパティとメソッドのプロパティには、 <xref:System.Security.Principal.WindowsIdentity> 現在接続しているユーザーに Microsoft インターネット インフォメーション サービス \(IIS\) のオブジェクト。 インスタンス、 <xref:System.Security.Principal.WindowsIdentity> クラスによって公開される <xref:System.Web.HttpRequest.LogonUserIdentity%2A> IIS トークンの要求を追跡し、ASP.NET の内部で処理されている現在の HTTP 要求に対するこのトークンに簡単にアクセスを提供します。 インスタンス、 <xref:System.Security.Principal.WindowsIdentity> メソッドとプロパティにアクセスするためを構築する必要はありませんので、クラスが自動的に作成します。  
  
   
  
## 例  
 次のコード例を取得する方法を示しています、 <xref:System.Web.HttpRequest.LogonUserIdentity%2A> プロパティ、現在のユーザーとテキスト ファイル内の各項目の値を設定します。 このコードをフォームのによって参照されている ASP.NET ページに配置 `ACTION` 属性です。  
  
 [!code-csharp[System.Web.HttpRequest\_LogonUserIdentity\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest\_LogonUserIdentity\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Web アプリケーションが IIS 7 の統合モードで実行されていると、 <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> イベントが発生していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">フォーム イメージ マップの名前。</param>
        <summary>インカミング イメージ フィールド フォーム パラメーターを、該当する x 座標値および y 座標値に割り当てます。</summary>
        <returns>整数の 2 次元配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">現在の要求の仮想パス \(絶対パスまたは相対パス\)。</param>
        <summary>指定された仮想パスを物理パスに割り当てます。</summary>
        <returns>
          <paramref name="virtualPath" /> で指定されたサーバー上の物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A> プロパティには可能性のあるホスティング環境に関する機密情報が含まれています。 戻り値をユーザーに表示しない必要があります。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.HttpRequest.MapPath%2A> 仮想パスをサーバー上の完全修飾物理パスに変換します。 この例では、2 つの部分があります。  
  
-   .Aspx ページは、パスを割り当て、ファイルが読み込まれ、読み取り操作の結果を表示します。  
  
-   クラス、 `UpperCaseFilterStream`, 、大文字にパススルーのすべての文字を変更します。  
  
 この例の最初の部分は、物理的な絶対パスを使用して、仮想パスに変換する方法を示しています。、 <xref:System.Web.HttpRequest.MapPath%2A> メソッドです。 この物理パスに渡されます、 <xref:System.IO.StreamReader> オブジェクトで、ファイルの内容を取得します。<xref:System.Web.HttpResponse.Write%2A> 、ページ上のファイルの内容を表示するメソッドが呼び出されます。<xref:System.Web.HttpResponse.Filter%2A> プロパティを使用して、フィルターをすべて大文字のページに表示されるテキストは、応答ストリームにアタッチします。  
  
 [!code-csharp[System.Web.HttpRequest\_Samples2\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest\_Samples2\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 例の 2 番目の部分から継承するクラスを示しています。 <xref:System.IO.Stream> し、ストリーム内のすべての文字を大文字に変換します。 このコードで配置、 `App_Code` 、アプリケーションのフォルダーです。  
  
 [!code-csharp[System.Web.HttpRequest\_Samples2\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest\_Samples2\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求に対して <see cref="T:System.Web.HttpContext" /> オブジェクトが定義されていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">現在の要求の仮想パス \(絶対パスまたは相対パス\)。</param>
        <param name="baseVirtualDir">相対解決に使用される仮想ベース ディレクトリ パス。</param>
        <param name="allowCrossAppMapping">
          <c>virtualPath</c> が別のアプリケーションに所属できることを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定された仮想パスを物理パスに割り当てます。</summary>
        <returns>サーバー上の物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A> プロパティには可能性のあるホスティング環境に関する機密情報が含まれています。 戻り値をユーザーに表示しない必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求に対して <see cref="T:System.Web.HttpContext" /> オブジェクトが定義されていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">イメージ フィールドの名前。</param>
        <summary>着信イメージ フィールド フォーム パラメーターを、適切な x 座標値および y 座標値にマップします。</summary>
        <returns>x および y 座標値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" />、および <see cref="P:System.Web.HttpRequest.ServerVariables" /> の各項目が組み合わされたコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Collections.Specialized.NameValueCollection" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 名前と値のペアは、次の順序でコレクションに追加されます。  
  
1.  クエリ文字列パラメーターです。  
  
2.  フォームのフィールドです。  
  
3.  クッキー。  
  
4.  サーバー変数。  
  
   
  
## 例  
 次のコード例は、ループ処理する方法を示しています、 <xref:System.Web.HttpRequest.Params%2A> プロパティ ページとキー\/値ペアを表示する方法です。  
  
 [!code-csharp[System.Web.HttpRequest.Params\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-vb[System.Web.HttpRequest.Params\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の仮想パスを取得します。</summary>
        <value>現在の要求の仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest.Path%2A> を連結したもの、 <xref:System.Web.HttpRequest.FilePath%2A> と <xref:System.Web.HttpRequest.PathInfo%2A> トレーラです。 たとえば、URL http:\/\/www.contoso.com\/virdir\/page.html\/tail、 <xref:System.Web.HttpRequest.Path%2A> は\/virdir\/page.html\/tail です。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.HttpUtility.HtmlEncode%2A> HTML エンコードする方法の値、 <xref:System.Web.HttpRequest.Path%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URL 拡張子付きリソースの追加パス情報を取得します。</summary>
        <value>リソースの追加パス情報。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 URL Http:\/\/www.contoso.com\/virdir\/page.html\/tail の <xref:System.Web.HttpRequest.PathInfo%2A> 値は\/tail です。  
  
   
  
## 例  
 次のコード例を決定するかどうか、 <xref:System.Web.HttpRequest.PathInfo%2A> プロパティには、空の文字列が含まれています。 そのような場合、 <xref:System.IO.StreamWriter.Write%2A> メソッドをファイルにこれを示す文字列を書き込みます。 その場合は、 <xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドが HTML エンコードし、値の <xref:System.Web.HttpRequest.PathInfo%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> メソッドは、ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行しているサーバー アプリケーションのルート ディレクトリの物理ファイル システム パスを取得します。</summary>
        <value>現在のアプリケーションのルート ディレクトリのファイル システム パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、 <xref:System.Web.HttpUtility.HtmlEncode%2A> HTML エンコードする方法の値、 <xref:System.Web.HttpRequest.PhysicalApplicationPath%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求された URL に一致する物理ファイル システム パスを取得します。</summary>
        <value>現在の要求のファイル システム パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、リダイレクトのシナリオで <xref:System.Web.HttpServerUtility.Execute%2A> と <xref:System.Web.HttpServerUtility.Transfer%2A>, 、 <xref:System.Web.HttpRequest.PhysicalPath%2A> プロパティが元のページへのパスを返します。 現在実行中のページの物理的なパスを検索する、 <xref:System.Web.HttpRequest.MapPath%2A> として、入力引数を持つメソッドの設定、 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> プロパティです。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.HttpUtility.HtmlEncode%2A> HTML エンコードする方法の値、 <xref:System.Web.HttpRequest.PhysicalPath%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.MapPath(System.String)" />
        <altmember cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP クエリ文字列変数のコレクションを取得します。</summary>
        <value>クライアントから送信されたクエリ文字列変数。 URL デコードされたキーと値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、"fullname"という名前のクエリ文字列変数の値を取得する 2 つの方法を示します。 URL の場合、各ケースで `http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri`, 、ため、返される値は"Fadi Fakhouri"、 `%20` は空白文字を URL デコードします。 URL がない場合、 `fullname` 文字列 ID のクエリを使用して、返される値は `null`です。  
  
 コードの最初の行が"fullname"クエリ文字列でのみキーを探します2 行目は、キーのすべての HTTP 要求のコレクションには、"fullname"を検索します。 2 番目の行の詳細については、次を参照してください。 <xref:System.Web.HttpRequest.Item%2A>します。  
  
```csharp  
string fullname1 = Request.QueryString["fullname"];  
string fullname2 = Request["fullname"];  
  
```  
  
```vb  
Dim fullname1 As String = Request.QueryString("fullname")  
Dim fullname2 As String = Request("fullname")  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の生の URL を取得します。</summary>
        <value>現在の要求の生の URL。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 生の URL は、次のドメイン情報の URL の一部として定義されます。 URL の文字列 http:\/\/www.contoso.com\/articles\/recent.aspx では、生の URL は、\/articles\/recent.aspx です。 生の URL には、存在する場合、クエリ文字列が含まれます。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.HttpUtility.HtmlEncode%2A> HTML エンコードする方法の値、 <xref:System.Web.HttpRequest.RawUrl%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求エンティティ本体が読み取られたかどうかおよび読み取った方法 \(読み取られた場合\) を示す値を取得します。</summary>
        <value>要求エンティティ本体がどのように読み取られたか、または読み取られていないことを示す値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、互換性のないメソッドを使用して読み取りが試行され、エンティティ本体が既に読み取られている場合にスローされる例外を回避するのには使用します。 メソッドとプロパティ、エンティティの本文の読み取りを次に示します。  
  
-   <xref:System.Web.HttpRequest.Form%2A> プロパティ。  
  
-   <xref:System.Web.HttpRequest.Files%2A> プロパティ。  
  
-   <xref:System.Web.HttpRequest.InputStream%2A> プロパティ。  
  
-   <xref:System.Web.HttpRequest.GetBufferedInputStream%2A> メソッド。  
  
-   <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の <see cref="T:System.Web.Routing.RequestContext" /> インスタンスを取得します。</summary>
        <value>現在の要求の <see cref="T:System.Web.Routing.RequestContext" /> インスタンス。 非ルーティング要求の場合、返される <see cref="T:System.Web.Routing.RequestContext" /> オブジェクトは空です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティへのアクセスを提供する、 <xref:System.Web.Routing.RouteData> 現在の要求のオブジェクト。 ASP.NET のルーティングの詳細についてを参照してください。[ASP.NET Routing](http://msdn.microsoft.com/ja-jp/892441af-8f1d-483e-ab5f-b82c23576f5a)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントによって使用される HTTP データ転送メソッド \(<see langword="GET" /> または <see langword="POST" />\) を取得または設定します。</summary>
        <value>クライアントから送信される HTTP 呼び出し型を表す文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、 <xref:System.Web.HttpUtility.HtmlEncode%2A> HTML エンコードする方法の値、 <xref:System.Web.HttpRequest.RequestType%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">物理ドライブ パス。</param>
        <param name="includeHeaders">HTTP ヘッダーをディスクに保存するかどうかを指定するブール値。</param>
        <summary>HTTP 要求をディスクに保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要求コンテキストをディスクに保存は、デバッグに役立ちます。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.HttpRequest.SaveAs%2A> メソッドは、ページが読み込まれるとします。 呼び出しでは、要求を書き込みアクセス許可およびファイル内の要求に含まれるすべてのヘッダー情報が含まれる ASP.NET プロセス id に付与されているディレクトリに、テキスト ファイルとして保存することを指定します。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample6\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest\_Sample6\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" /> のプロパティ、 <see cref="T:System.Web.Configuration.HttpRuntimeSection" /> に設定されている <see langword="true" /> が <paramref name="filename" /> 絶対パスではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web サーバー変数のコレクションを取得します。</summary>
        <value>サーバー変数の <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 IIS でサポートされているサーバー変数の一覧は、次を参照してください。 [IIS Server Variables](http://go.microsoft.com/fwlink/?LinkId=52471)します。  
  
   
  
## 例  
 次のコード例では、名前と名前付きサーバーのすべての変数の値が表示されます。  
  
 [!code-csharp[Classic HttpRequest.ServerVariables Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がタイムアウトするとトリップされる <see cref="T:System.Threading.CancellationToken" /> オブジェクトを取得します。</summary>
        <value>キャンセル トークン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web.config ファイルで、タイムアウト期間を指定できます \(を参照してください <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=fullName>\) またはプログラムによって \(を参照してください <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=fullName>\)。 タイムアウト期間は、要求が届いたときから測定されます。 110 秒の既定のタイムアウトは有効になっている場合、キャンセル トークンを要求の処理を開始した後、110 秒よりトリップされます。 変更することができます、 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=fullName> プロパティの値、新しいタイムアウト値を尊重するようにこのトークンに時間がまだトリップしていないとします。  
  
 現在、トークンは、15 秒おき、のみを提供するその場合、タイムアウト値は 110 秒から 110 して 125 秒後、要求の処理が開始されるまでの間、トークンがトリップされます。 今後は、粒度を変更できます。  
  
 このプロパティには、スレッド セーフであるが、使用上の制限があります。 詳細については、「<xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=fullName>」を参照してください。  
  
 このプロパティは、Websocket 要求の処理が開始された場合に意味がなくなります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>TLS トークンのバインド情報を取得します。 このプロパティによりアプリケーションは、強化された認証のために受信 HTTP 要求からトークンの情報を取得できます。</summary>
        <value>現在の接続のバインド トークンです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返します `null` windows10 以外のプラットフォームです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の入力ストリームのバイト数を取得します。</summary>
        <value>入力ストリームのバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例を決定するかどうか、 <xref:System.Web.HttpRequest.TotalBytes%2A> プロパティの値が 1000 バイトより大きいと、その情報をファイルに書き込みます。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求の検証をトリガーせずに HTTP 要求値を取得します。</summary>
        <value>要求の検証を使用してチェックされていない HTTP 要求値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 HTML マークアップとクロスサイト スクリプティング攻撃の危険性を示す可能性があるスクリプトの検証を要求します。 要求の検証を使用して既定では、すべての値がチェックされますして任意の値は、マークアップやスクリプトを含む、ASP.NET をスローする <xref:System.Web.HttpRequestValidationException> 例外です。 要求のマークアップが含まれることが予想される場合は、このメソッドを使用 \(たとえば、マークアップを含むコンテンツを投稿するユーザーを許可する\) を要求の生の値を取得するとします。  
  
> [!IMPORTANT]
>  このプロパティを使用する場合は、潜在的なクロスサイト スクリプティング攻撃用のデータを手動で確認する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の URL に関する情報を取得します。</summary>
        <value>現在の要求の URL を格納している <see cref="T:System.Uri" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例を割り当て、 <xref:System.Uri> 、現在の要求のオブジェクト変数を表示するオブジェクトの URL の 2 つのプロパティの値を HTTP 出力へのオブジェクト。  
  
 [!code-csharp[Classic HttpRequest.Url Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
        <altmember cref="P:System.Web.HttpRequest.RawUrl" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の URL にリンクされている、クライアントが前回要求した URL に関する情報を取得します。</summary>
        <value>
          <see cref="T:System.Uri" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、現在のアプリケーションにクライアントを参照する URL の 2 つのプロパティの値を表示します。  
  
 [!code-csharp[Classic HttpRequest.UrlReferrer Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">HTTP<see langword="Referer" />要求ヘッダーの形式が正しくないとを変換することはできません、<see cref="T:System.Uri" />オブジェクト。</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアント ブラウザーの生のユーザー エージェント文字列を取得します。</summary>
        <value>クライアント ブラウザーの生のユーザー エージェント文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、要求元のブラウザーの種類 id を文字列変数に代入します。  
  
 [!code-csharp[Classic HttpRequest.UserAgent Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート クライアントの IP ホスト アドレスを取得します。</summary>
        <value>リモート クライアントの IP アドレス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、 <xref:System.Web.HttpUtility.HtmlEncode%2A> HTML エンコードする方法の値、 <xref:System.Web.HttpRequest.UserHostAddress%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート クライアントの DNS 名を取得します。</summary>
        <value>リモート クライアントの DNS 名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、 <xref:System.Web.HttpUtility.HtmlEncode%2A> HTML エンコードする方法の値、 <xref:System.Web.HttpRequest.UserHostName%2A> プロパティおよび <xref:System.IO.TextWriter.WriteLine%2A> ファイルにエンコードされた値を書き込みます。 このコード例が示されている例の一部は、 <xref:System.Web.HttpRequest> クラスです。  
  
 [!code-csharp[System.Web.HttpRequest\_Sample1\#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest\_Sample1\#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントの言語設定の並べ替えられた文字列配列を取得します。</summary>
        <value>クライアント言語設定の並べ替えられた文字列配列。空の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例は、によって返される複数の値をキャプチャ、 <xref:System.Web.HttpRequest.UserLanguages%2A> プロパティ文字列の配列と書き込みの HTTP 出力の個別の行に各言語の名前にします。  
  
 言語の名前が、ブラウザーによって提供され、すべての可能なコードの信頼性のある情報の一覧はありません。  通常で構成され、言語、ハイフン、およびカルチャの 2 文字コードの 2 文字コードのなど"en\-私たち"米国の英語とカナダ フランス語の"fr\-ca"です。  
  
 [!code-csharp[Classic HttpRequest.UserLanguages Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Web.HttpRequest.Cookies" />、<see cref="P:System.Web.HttpRequest.Form" />、および <see cref="P:System.Web.HttpRequest.QueryString" /> の各プロパティを通じてアクセスするコレクションに対して検証を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest> クラスを通じてアクセス要求のコレクションに対して検証を実行するかどうかを追跡するために入力の検証フラグを使用して、 <xref:System.Web.HttpRequest.Cookies%2A>, 、<xref:System.Web.HttpRequest.Form%2A>, 、および <xref:System.Web.HttpRequest.QueryString%2A> プロパティです。<xref:System.Web.HttpRequest.ValidateInput%2A> メソッド設定これらのフラグようにする場合の get アクセサー、 <xref:System.Web.HttpRequest.Cookies%2A>, 、<xref:System.Web.HttpRequest.Form%2A>, 、または <xref:System.Web.HttpRequest.QueryString%2A> プロパティが呼び出されるため、入力の検証が実行されます。 検証は、ハード コーディングされた一連の危険性のあるデータに対してすべての入力データをチェックして動作します。  
  
 ページの中にこのメソッドが呼び出されますページ ディレクティブまたは構成の検証機能が有効な場合 `ProcessRequest` 処理フェーズ。<xref:System.Web.HttpRequest.ValidateInput%2A> メソッドは、検証機能が有効になっていない場合は、コードを呼び出すことができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">危険性のあるデータは、クライアントから受信しました。</exception>
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>要求された URL の仮想パスを、現在の要求に対するサーバー上の物理パスに割り当てます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetBufferlessInputStream">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>