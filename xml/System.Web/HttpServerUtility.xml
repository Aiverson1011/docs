<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Web 要求を処理するヘルパー メソッドを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドとプロパティの <xref:System.Web.HttpServerUtility> クラスは、組み込みを介して公開される <xref:System.Web.HttpContext.Server%2A> ASP.NET によって提供されるオブジェクト。  
  
   
  
## 例  
 ソース コードの Visual Studio の Web サイト プロジェクトはこのトピック用に使用可能な: [Download](http://go.microsoft.com/fwlink/?LinkId=192870)します。  
  
 次の例では、使用して、 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> メソッドおよび <xref:System.Web.HttpServerUtility.UrlEncode%2A> のメソッド、 <xref:System.Web.HttpServerUtility> クラスです。<xref:System.Web.HttpServerUtility.HtmlEncode%2A> メソッドにより、任意のユーザーが指定した文字列の入力は実行可能なスクリプトまたは HTML 要素の代わりにブラウザーで静的なテキストとしてレンダリングされることを確認します。<xref:System.Web.HttpServerUtility.UrlEncode%2A> メソッドが HTTP ストリームで正しく送信されるように、Url をエンコードします。  
  
 [!code-csharp[System.Web.HttpServerUtility1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-vb[System.Web.HttpServerUtility1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>前回の例外を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、スローされた最後の例外を削除します。  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">インスタンスを作成するオブジェクトのクラスまたは型。</param>
        <summary>オブジェクトのプログラム ID \(ProgID\) で識別されている COM オブジェクトのサーバー インスタンスを作成します。</summary>
        <returns>新しいオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、オブジェクトの ProgID を使用してオブジェクトを作成します。  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">オブジェクトのインスタンスを作成できませんでした。</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> を作成するオブジェクトを表します。</param>
        <summary>オブジェクトの型で識別されている COM オブジェクトのサーバー インスタンスを作成します。</summary>
        <returns>新しいオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">インスタンスを作成するオブジェクトのクラス ID。</param>
        <summary>オブジェクトのクラス ID \(CLSID\) で識別されている COM オブジェクトのサーバー インスタンスを作成します。</summary>
        <returns>新しいオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following example demonstrates how to use the <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> method to create a server instance of a COM object.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">オブジェクトのインスタンスを作成できませんでした。</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">実行する URL パス。</param>
        <summary>指定した仮想パスのハンドラーを現在の要求のコンテキストで実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドは、新しいページの実行が完了した後に、元のページの実行を継続します。<xref:System.Web.HttpServerUtility.Transfer%2A> メソッドでは、他のハンドラーに、実行を無条件で転送します。  
  
 ASP.NET は、によって配信されるリソースを表示する、現在のユーザーが承認されていることを確認できません、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。 ASP.NET が直接によって示されるハンドラーを呼び出しますが、ASP.NET の認証および承認ロジックを実行元のリソースのハンドラーが呼び出される前に、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドと、新しいリソースの認証と承認ロジックを再実行されません。 アプリケーションのセキュリティ ポリシーでは、クライアントのリソースにアクセスする適切な承認する必要がある場合は、アプリケーションを強制またはカスタムのアクセス制御メカニズムを提供します。  
  
 使用して強制することができます、 <xref:System.Web.HttpResponse.Redirect%2A> メソッドの代わりに、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。<xref:System.Web.HttpResponse.Redirect%2A> ブラウザーが新しいリソースを要求するクライアント側リダイレクトを実行します。 このリダイレクトは、システムへの新しい要求であるために、インターネット インフォメーション サービス \(IIS\) と ASP.NET の両方のセキュリティ ポリシーのすべての認証と承認ロジックをそれが加わっています。  
  
 ユーザーが使用するカスタム承認メソッドを組み込むことにより、リソースを表示するアクセス許可を持っていることを確認できる、 <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッド アプリケーション呼び出しの前に、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。  
  
   
  
## 例  
 次の例では、現在のディレクトリで .aspx ページ"Updateinfo.aspx"を表示します。 プログラムの実行は、Updateinfo.aspx ページが表示された後に、開始ページに戻ります。  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が <see langword="null" /> です。  
  
 または  
  
 指定されたハンドラーの実行中にエラーが発生しました <paramref name="path" />します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="path" /> が仮想パスではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">実行する URL パス。</param>
        <param name="preserveForm">
          <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションを保持する場合は <see langword="true" />。<see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションをクリアする場合は <see langword="false" />。</param>
        <summary>現在の要求のコンテキストで指定した仮想パスのハンドラーを実行し、オフにするかどうかを指定、 <see cref="P:System.Web.HttpRequest.QueryString" /> と <see cref="P:System.Web.HttpRequest.Form" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例は、.aspx ページを実行する方法を示します `Updateinfo.aspx` で現在の要求と保持する、 <xref:System.Web.HttpRequest.QueryString%2A> と <xref:System.Web.HttpRequest.Form%2A> コレクションです。 プログラムの実行後の開始ページに戻ります `Updateinfo.aspx` が表示されます。  
  
 [!code-csharp[HttpServerUtility.Execute\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が <see langword="null" /> です。  
  
 または  
  
 指定されたハンドラーの実行中にエラーが発生しました <paramref name="path" />します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="path" /> が仮想パスではありません。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">実行する URL パス。</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> 、出力をキャプチャします。</param>
        <summary>指定した仮想パスのハンドラーを現在の要求のコンテキストで実行します。 A <see cref="T:System.IO.TextWriter" /> 、実行されたハンドラーからの出力をキャプチャします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドは、指定された仮想パスの実行が完了した後に元の要求の実行を継続します。<xref:System.Web.HttpServerUtility.Transfer%2A> メソッドでは、他のハンドラーに、実行を無条件で転送します。  
  
 ASP.NET は、によって配信されるリソースを表示する、現在のユーザーが承認されていることを確認できません、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。 ASP.NET が直接によって示されるハンドラーを呼び出しますが、ASP.NET の認証および承認ロジックを実行元のリソースのハンドラーが呼び出される前に、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドと、新しいリソースの認証と承認ロジックを再実行されません。 アプリケーションのセキュリティ ポリシーでは、クライアントのリソースにアクセスする適切な承認する必要がある場合は、アプリケーションを強制またはカスタムのアクセス制御メカニズムを提供します。  
  
 使用して強制することができます、 <xref:System.Web.HttpResponse.Redirect%2A> メソッドの代わりに、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。<xref:System.Web.HttpResponse.Redirect%2A> ブラウザーが新しいリソースを要求するクライアント側リダイレクトを実行します。 このリダイレクトは、システムへの新しい要求であるために、インターネット インフォメーション サービス \(IIS\) と ASP.NET の両方のセキュリティ ポリシーのすべての認証と承認ロジックをそれが加わっています。  
  
 ユーザーが使用するカスタム承認メソッドを組み込むことにより、リソースを表示するアクセス許可を持っていることを確認できる、 <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッド アプリケーション呼び出しの前に、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。  
  
   
  
## 例  
 次の例で実行される、 `Login.aspx` \] ページで、サーバーの現在のディレクトリと出力を使用して、ページから受け取る、 <xref:System.IO.StringWriter> オブジェクト `writer`します。 受け取った HTML ストリームを書き込む `writer` http 出力ストリーム。  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が <see langword="null" /> です。  
  
 または  
  
 指定されたハンドラーの実行中にエラーが発生しました <paramref name="path" />します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="path" /> が仮想パスではありません。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">実行する URL パス。</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> 、出力をキャプチャします。</param>
        <param name="preserveForm">
          <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションを保持する場合は <see langword="true" />。<see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションをクリアする場合は <see langword="false" />。</param>
        <summary>指定した仮想パスのハンドラーを現在の要求のコンテキストで実行します。 A <see cref="T:System.IO.TextWriter" /> をオフにするかどうかを指定するページとブール値パラメーターからの出力を取り込み、 <see cref="P:System.Web.HttpRequest.QueryString" /> と <see cref="P:System.Web.HttpRequest.Form" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドは、指定した仮想パスの実行が完了した後に元の要求の実行を継続します。<xref:System.Web.HttpServerUtility.Transfer%2A> メソッドでは、他のハンドラーに、実行を無条件で転送します。  
  
 ASP.NET は、によって配信されるリソースを表示する、現在のユーザーが承認されていることを確認できません、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。 ASP.NET が直接によって示されるハンドラーを呼び出しますが、ASP.NET の認証および承認ロジックを実行元のリソースのハンドラーが呼び出される前に、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドと、新しいリソースの認証と承認ロジックを再実行されません。 アプリケーションのセキュリティ ポリシーでは、クライアントのリソースにアクセスする適切な承認する必要がある場合は、アプリケーションを強制またはカスタムのアクセス制御メカニズムを提供します。  
  
 使用して強制することができます、 <xref:System.Web.HttpResponse.Redirect%2A> メソッドの代わりに、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。<xref:System.Web.HttpResponse.Redirect%2A> ブラウザーが新しいリソースを要求するクライアント側リダイレクトを実行します。 このリダイレクトは、システムへの新しい要求であるために、インターネット インフォメーション サービス \(IIS\) と ASP.NET の両方のセキュリティ ポリシーのすべての認証と承認ロジックをそれが加わっています。  
  
 ユーザーが使用するカスタム承認メソッドを組み込むことにより、リソースを表示するアクセス許可を持っていることを確認できる、 <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッド アプリケーション呼び出しの前に、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。  
  
   
  
## 例  
 次の例で実行される、 `Login.aspx` \] ページで、サーバーの現在のディレクトリと出力を使用して、ページから受け取る、 <xref:System.IO.StringWriter> オブジェクト `writer`します。 受け取った HTML ストリームを書き込む `writer` http 出力ストリーム。 内容、 <xref:System.Web.HttpRequest.Form%2A> と <xref:System.Web.HttpRequest.QueryString%2A> コレクションが保持されます。  
  
 [!code-csharp[HttpServerUtility.Execute02\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在 <see cref="T:System.Web.HttpContext" /> null 参照 \(<see langword="Nothing" /> Visual Basic で\)。  
  
 または  
  
 <paramref name="path" /> がピリオド \(.\) で終わっています。  
  
 または  
  
 指定されたハンドラーの実行中にエラーが発生しました <paramref name="path" />します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> が仮想パスではありません。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">実装する HTTP ハンドラー、 <see cref="T:System.Web.IHttpHandler" /> を現在の要求を転送します。</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> 、出力をキャプチャします。</param>
        <param name="preserveForm">
          <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションを保持する場合は <see langword="true" />。<see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションをクリアする場合は <see langword="false" />。</param>
        <summary>指定した仮想パスのハンドラーを現在の要求のコンテキストで実行します。 A <see cref="T:System.IO.TextWriter" /> をオフにするかどうかを指定する、実行されたハンドラーとブール値パラメーターからの出力を取り込み、 <see cref="P:System.Web.HttpRequest.QueryString" /> と <see cref="P:System.Web.HttpRequest.Form" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 カスタムの HTTP ハンドラーが、定義済みの特定の種類は、共通言語仕様 \(CLS\) に準拠した言語での HTTP 要求の処理を記述することができます。 従来の \(従来の ASP とも呼ばれます\) の ASP ページや ASP.NET ページではなく HTTP ハンドラー クラスで定義されている実行可能ファイルのコードは、これらの個々 の要求に応答します。 低レベルの要求とインターネット インフォメーション サービス \(IIS\) を実行している Web サーバーの応答サービスと対話する HTTP ハンドラーを使用して、次のような機能を提供する ISAPI 拡張機能より単純なプログラミング モデルです。  
  
 ASP.NET は、によって配信されるリソースを表示する、現在のユーザーが承認されていることを確認できません、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。 ASP.NET がで示されているハンドラーを直接呼び出しますが、ASP.NET の承認と認証ロジックが実行されるは、元のリソースのハンドラーが呼び出される前に、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドと、新しいリソースの認証と承認ロジックを再実行されません。 アプリケーションのセキュリティ ポリシーでは、クライアントのリソースにアクセスするために適切な承認する必要がある場合は、アプリケーションを強制またはカスタムのアクセス制御メカニズムを提供します。  
  
 使用して強制することができます、 <xref:System.Web.HttpResponse.Redirect%2A> メソッドの代わりに、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。<xref:System.Web.HttpResponse.Redirect%2A> ブラウザーが新しいリソースを要求するクライアント側リダイレクトを実行します。 このリダイレクトは、システムへの新しい要求であるために、IIS と ASP.NET のセキュリティ ポリシーのすべての認証と承認ロジックをそれが加わっています。  
  
 ユーザーが使用するカスタム承認メソッドを組み込むことにより、リソースを表示するアクセス許可を持っていることを確認できる、 <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッド アプリケーション呼び出しの前に、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">指定されたハンドラーの実行中にエラーが発生しました <paramref name="handler" />します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handler" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>前回の例外を返します。</summary>
        <returns>スローされた前回の例外。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、HTTP 出力ストリームに、アプリケーションの最後のエラーの説明を出力します。 エラーが発生しない場合は、「エラーなし」を出力します。  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">デコードする HTML 文字列。</param>
        <summary>HTML エンコードされた文字列をデコードし、デコードした文字列を返します。</summary>
        <returns>デコードされたテキスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 HTML エンコーディングは、テキストをブラウザーに正しく表示して、ブラウザーで HTML として解釈されないことを確認します。 たとえば、テキスト文字列には、不等号 \(\<\) が含まれている場合またはそれ以上不等号 \(\>\)、ブラウザーではこれらの文字として解釈開始タグまたは HTML タグの右角かっこです。 文字が HTML エンコードである場合は、文字列に変換されます `&lt;` と `&gt;`, 、それが原因で、不等号記号正しくサインインを表示するブラウザー。<xref:System.Web.HttpServerUtility.HtmlDecode%2A> サーバーに送信されたテキストをデコードします。  
  
 このメソッドにアクセスする便利な方法は、 <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> 実行時に、ASP.NET アプリケーションからのメソッドです。 このメソッドを使用して内部的には、 <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> 文字列をデコードします。  
  
 ASP.NET web ページの分離コード ファイル内のインスタンスにアクセス、 <xref:System.Web.HttpServerUtility> クラスを通じて、 `Server` プロパティです。 分離コード ファイルに含まれていないクラスで使用して `HttpContext.Current.Server` のインスタンスにアクセスする、 <xref:System.Web.HttpServerUtility> クラスです。  
  
 Web アプリケーションの外部で使用して、 <xref:System.Net.WebUtility> エンコードまたはデコードの値をクラスです。  
  
   
  
## 例  
 次の例には、関数が含まれています。 `LoadDecodedFile`, 、ファイルからデータをデコードすると、1 つの文字列にコピーします。  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">デコードする HTML 文字列。</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> 、デコードした文字列を格納している出力ストリーム。</param>
        <summary>HTML でエンコードされた文字列をデコードし、その結果に出力を送信、 <see cref="T:System.IO.TextWriter" /> 出力ストリーム。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 HTML エンコーディングは、テキストをブラウザーに正しく表示して、ブラウザーで HTML として解釈されないことを確認します。 たとえば、テキスト文字列には、不等号 \(\<\) が含まれている場合またはそれ以上不等号 \(\>\)、ブラウザーではこれらの文字として解釈開始タグまたは HTML タグの右角かっこです。 文字が HTML エンコードである場合は、文字列に変換されます `&lt;` と `&gt;`, 、それが原因で、不等号記号正しくサインインを表示するブラウザー。  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> サーバーに送信されたテキストをデコードします。  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> アクセスする便利な方法は、 <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> 実行時に、ASP.NET アプリケーションからのメソッドです。 内部的には、 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> を使用して <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> 文字列をデコードします。  
  
 Web アプリケーションの外部で値をエンコードまたはデコードするには、<xref:System.Net.WebUtility> クラスを使用してください。  
  
   
  
## 例  
 次の例では、HTTP 経由で伝送用に HTML エンコードをされている文字列をデコードします。 という名前の指定した文字列をデコード `EncodedString` テキストが含まれている"これは、&lt;文字列 &gt; をテストします。"、という名前の文字列にコピーすると `DecodedString` "これは、\< テスト文字列 \> です"です。 とします。  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">エンコードする文字列。</param>
        <summary>文字列を HTML エンコードし、エンコードされた文字列を返します。</summary>
        <returns>HTML エンコードされたテキスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 HTML エンコーディングは、テキストをブラウザーに正しく表示して、ブラウザーで HTML として解釈されないことを確認します。 たとえば、テキスト文字列には、不等号 \(\<\) が含まれている場合またはそれ以上不等号 \(\>\)、ブラウザーではこれらの文字として解釈開始タグまたは HTML タグの右角かっこです。 文字が HTML エンコードである場合は、文字列に変換されます `&lt;` と `&gt;`, 、それが原因で、不等号記号正しくサインインを表示するブラウザー。  
  
 このメソッドにアクセスする便利な方法は、 <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> 実行時に、ASP.NET アプリケーションからのメソッドです。 このメソッドを使用して内部的には、 <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> 文字列をエンコードします。  
  
 ASP.NET web ページの分離コード ファイル内のインスタンスにアクセス、 <xref:System.Web.HttpServerUtility> クラスを通じて、 `Server` プロパティです。 分離コード ファイルに含まれていないクラスで使用して `HttpContext.Current.Server` のインスタンスにアクセスする、 <xref:System.Web.HttpServerUtility> クラスです。  
  
 Web アプリケーションの外部で使用して、 <xref:System.Net.WebUtility> エンコードまたはデコードの値をクラスです。  
  
   
  
## 例  
 次の例では、方法に値を HTML エンコードする可能性のあるコードはアンセーフ コードを示します。 コードは、web ページの分離コード ファイルに存在します。 エンコードする値は、のみを例を簡略化し、HTML エンコードすることがあります値の型を表示するには、この例では、ハードコーディングです。 通常と HTML エンコードをユーザーまたは要求から受信した値です。`Result` 指す、 `Literal` コントロールです。  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 次の例は似ていますが、前の例が表示する方法を HTML エンコードするクラス内の値外にある分離コード ファイルにします。  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">エンコードする文字列。</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> エンコードの文字列を格納する出力ストリーム。</param>
        <summary>文字列を HTML エンコードし、結果の出力を <see cref="T:System.IO.TextWriter" /> 出力ストリーム。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 HTML エンコードすると、ブラウザーで、ブラウザーで HTML として解釈されないテキストが正しく表示されることにより、します。 たとえば、テキスト文字列には、不等号 \(\<\) が含まれている場合またはそれ以上不等号 \(\>\)、ブラウザーではこれらの文字として解釈開始タグまたは HTML タグの右角かっこです。 これら 2 つの文字の HTML エンコードでは `&lt;` と `&gt;`, 、それぞれ、それが原因で、不等号記号正しくサインインを表示するブラウザー。  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> アクセスする便利な方法は、 <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> 実行時に、ASP.NET アプリケーションからのメソッドです。 内部的には、 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> を使用して <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> 文字列をエンコードします。  
  
 Web アプリケーションの外部で値をエンコードまたはデコードするには、<xref:System.Net.WebUtility> クラスを使用してください。  
  
   
  
## 例  
 次の例では、HTTP で伝送用の文字列をエンコードします。 という名前の文字列をエンコード `TestString`, 、「これは \< テスト文字列 \>」をテキストが含まれ、という名前の文字列にコピーして `EncodedString` として"これは、&lt;文字列 &gt; をテストします。"です。  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバーのコンピューター名を取得します。</summary>
        <value>ローカル コンピューターの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、文字列変数として、サーバーのコンピューター名を格納します。  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">コンピューター名が見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Web アプリケーション内の仮想パス。</param>
        <summary>指定した仮想パスに対応する物理ファイル パスを返します。</summary>
        <returns>対応する Web サーバー上の物理ファイル パス <paramref name="path" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `path` は `null`, 、 <xref:System.Web.HttpServerUtility.MapPath%2A> メソッド パスの現在の要求を格納するディレクトリの完全な物理パスを返します。 相対パスは、既存のファイルまたはフォルダーの値を返すには、このメソッドを指定する必要はありません。 ただし、Web アプリケーションの外部でパスを指定することはできません。  
  
> [!IMPORTANT]
>  <xref:System.Web.HttpServerUtility.MapPath%2A> メソッドには可能性のあるホスティング環境に関する機密情報が含まれています。 戻り値をユーザーに表示しない必要があります。  
  
 Web アプリケーションに配置されている `C:\ExampleSites\TestMapPath` 次の結果が返されます。  
  
|要求します。|`path`|戻り値|  
|------------|------------|---------|  
|RootLevelPage.aspx|`null`|C:\\ExampleSites\\TestMapPath|  
|RootLevelPage.aspx|"\/DownOneLevel\/DownLevelPage.aspx"|C:\\ExampleSites\\TestMapPath\\DownOneLevel\\DownLevelPage.aspx|  
|RootLevelPage.aspx|"\/NotRealFolder"|C:\\ExampleSites\\TestMapPath\\NotRealFolder|  
|RootLevelPage.aspx|"..\/OutsideApplication"|<xref:System.Web.HttpException>|  
|\/DownOneLevel\/DownLevelPage.aspx|`null`|C:\\ExampleSites\\TestMapPath\\DownOneLevel|  
|\/DownOneLevel\/DownLevelPage.aspx|"..\/RootLevelPage.aspx"|C:\\ExampleSites\\TestMapPath\\RootLevelPage.aspx|  
  
   
  
## 例  
 次の例では、相対仮想パスの物理ファイルを取得する方法を示します。 コードは、web ページの分離コード ファイル内に存在しで既定の使用 `Server` オブジェクトです。  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 次の例は似ていますが、前の例から分離コード ファイルに含まれていないクラス内での物理パスを取得する方法を示します。  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求タイムアウト値を秒単位で取得し、設定します。</summary>
        <value>要求のタイムアウト値設定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> プロパティは、設定を Web.config ファイルで設定できる、 `executionTimeout` 要素の属性です。 プログラムでタイムアウトの設定、 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> プロパティがこの Web.config 設定より優先されます。  
  
> [!NOTE]
>  設定した場合、 `debug` する要素の属性 `true` Web.config ファイルの値で <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> は無視されます。  
  
   
  
## 例  
 次の例では、要求のタイムアウト時間を 60 秒に設定します。  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">タイムアウト時間は <see langword="null" /> またはそれ以外の場合、設定されていない可能性があります。</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">サーバー上にある、実行する新しいページの URL パス。</param>
        <summary>現在の要求に対して、現在のページの実行を終了し、指定された URL パスを使用して新しいページの実行を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 転送先のページには、別の .aspx ページをする必要があります。 たとえば、.asp ファイルまたは .asmx のページへの転送は、無効です。<xref:System.Web.HttpServerUtility.Transfer%2A> メソッドでは、 <xref:System.Web.HttpRequest.QueryString%2A> と <xref:System.Web.HttpRequest.Form%2A> コレクションです。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> 呼び出し <xref:System.Web.HttpResponse.End%2A>, 、どのスロー、 <xref:System.Threading.ThreadAbortException> 完了時に例外です。  
  
 ASP.NET は、によって配信されるリソースを表示する、現在のユーザーが承認されていることを確認できません、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドです。 ASP.NET が直接によって示されるハンドラーを呼び出しますが、ASP.NET の認証および承認ロジックを実行元のリソースのハンドラーが呼び出される前に、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドと、新しいリソースの認証と承認ロジックを再実行されません。 アプリケーションのセキュリティ ポリシーでは、クライアントのリソースにアクセスする適切な承認する必要がある場合は、アプリケーションを強制またはカスタムのアクセス制御メカニズムを提供します。  
  
 使用して強制することができます、 <xref:System.Web.HttpResponse.Redirect%2A> メソッドの代わりに、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドです。<xref:System.Web.HttpResponse.Redirect%2A> メソッドは、ブラウザーが新しいリソースを要求するクライアント側リダイレクトを実行します。 このリダイレクトは、システムへの新しい要求であるために、インターネット インフォメーション サービス \(IIS\) と ASP.NET の両方のセキュリティ ポリシーのすべての認証と承認ロジックをそれが加わっています。  
  
 ユーザーが使用するカスタム承認メソッドを組み込むことにより、リソースを表示するアクセス許可を持っていることを確認できる、 <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッド アプリケーション呼び出しの前に、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">サーバー上にある、実行する新しいページの URL パス。</param>
        <param name="preserveForm">
          <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションを保持する場合は <see langword="true" />。<see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションをクリアする場合は <see langword="false" />。</param>
        <summary>現在のページの実行を終了し、指定された URL パスを使用して新しいページの実行を開始します。 オフにするかどうかを示す、 <see cref="P:System.Web.HttpRequest.QueryString" /> と <see cref="P:System.Web.HttpRequest.Form" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 転送先のページには、別の .aspx ページをする必要があります。 たとえば、.asp ファイルまたは .asmx のページへの転送は、無効です。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> 呼び出し <xref:System.Web.HttpResponse.End%2A>, 、どのスロー、 <xref:System.Threading.ThreadAbortException> 完了時に例外です。  
  
 設定した場合、 `preserveForm` パラメーターを `true`, 、移動先のページは前のページのビュー ステートを使用してアクセスできる、 <xref:System.Web.UI.Page.PreviousPage%2A> プロパティです。  
  
 セキュリティのために、おく必要があります、 `enableViewStateMac` 属性に設定 `true`します。 ASP.NET は、によって配信されるリソースを表示する、現在のユーザーが承認されていることを確認できません、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドです。 ASP.NET が直接によって示されるハンドラーを呼び出しますが、ASP.NET の認証および承認ロジックを実行元のリソースのハンドラーが呼び出される前に、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドと、新しいリソースの認証と承認ロジックを再実行されません。 アプリケーションのセキュリティ ポリシーでは、クライアントのリソースにアクセスする適切な承認する必要がある場合は、アプリケーションを強制またはカスタムのアクセス制御メカニズムを提供します。  
  
 使用して強制することができます、 <xref:System.Web.HttpResponse.Redirect%2A> メソッドの代わりに、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドです。<xref:System.Web.HttpResponse.Redirect%2A> メソッドは、ブラウザーが新しいリソースを要求するクライアント側リダイレクトを実行します。 このリダイレクトは、システムへの新しい要求であるために、インターネット インフォメーション サービス \(IIS\) と ASP.NET の両方のセキュリティ ポリシーのすべての認証と承認ロジックをそれが加わっています。  
  
 ユーザーが使用するカスタム承認メソッドを組み込むことにより、リソースを表示するアクセス許可を持っていることを確認できる、 <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッド アプリケーション呼び出しの前に、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドです。  
  
   
  
## 例  
 次の例では、現在のページと同じディレクトリに新しいページを実行します。  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">現在のページ要求がコールバックです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">実装する HTTP ハンドラー、 <see cref="T:System.Web.IHttpHandler" /> を現在の要求を転送します。</param>
        <param name="preserveForm">
          <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションを保持する場合は <see langword="true" />。<see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションをクリアする場合は <see langword="false" />。</param>
        <summary>現在のページの実行を終了しを実装するカスタム HTTP ハンドラーを使用して、新しい要求の実行を開始、 <see cref="T:System.Web.IHttpHandler" /> インターフェイスし、オフにするかどうかを示す、 <see cref="P:System.Web.HttpRequest.QueryString" /> と <see cref="P:System.Web.HttpRequest.Form" /> コレクションです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 カスタムの HTTP ハンドラーが、定義済みの特定の種類は、共通言語仕様 \(CLS\) に準拠した言語での HTTP 要求の処理を記述することができます。 従来の \(従来の ASP とも呼ばれます\) の ASP ページや ASP.NET ページではなく HTTP ハンドラー クラスで定義されている実行可能ファイルのコードは、これらの個々 の要求に応答します。 低レベルの要求とインターネット インフォメーション サービス \(IIS\) を実行している Web サーバーの応答サービスと対話する HTTP ハンドラーを使用して、次のような機能を提供する ISAPI 拡張機能より単純なプログラミング モデルです。  
  
 設定した場合、 `preserveForm` パラメーターを `true`, 、移動先のページは前のページのビュー ステートを使用してアクセスできる、 <xref:System.Web.UI.Page.PreviousPage%2A> プロパティです。  
  
 セキュリティのために、おく必要があります、 `enableViewStateMac` 属性に設定 `true`します。 ASP.NET は、によって配信されるリソースを表示する、現在のユーザーが承認されていることを確認できません、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドです。 ASP.NET が直接によって示されるハンドラーを呼び出しますが、ASP.NET の認証および承認ロジックを実行元のリソースのハンドラーが呼び出される前に、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッド、および新規のリソースの再実行されませんが認証と承認ロジックです。 アプリケーションのセキュリティ ポリシーでは、クライアントのリソースにアクセスする適切な承認する必要がある場合は、アプリケーションを強制またはカスタムのアクセス制御メカニズムを提供します。  
  
 使用して強制することができます、 <xref:System.Web.HttpResponse.Redirect%2A> メソッドの代わりに、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドです。<xref:System.Web.HttpResponse.Redirect%2A> メソッドは、ブラウザーが新しいリソースを要求するクライアント側リダイレクトを実行します。 このリダイレクトは、システムへの新しい要求であるために、IIS と ASP.NET のセキュリティ ポリシーのすべての認証と承認ロジックをそれが加わっています。  
  
 ユーザーが使用するカスタム承認メソッドを組み込むことにより、リソースを表示するアクセス許可を持っていることを確認できる、 <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッド アプリケーション呼び出しの前に、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">現在のページ要求がコールバックです。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した URL の非同期実行を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> .NET Framework version 3.5 で導入されました。 .NET Framework の概要については、次を参照してください。 [The .NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">サーバー上にある、実行する新しいページの URL パス。</param>
        <summary>指定した URL の非同期実行を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドのオーバー ロードを呼び出す、 <xref:System.Web.HttpServerUtility.TransferRequest%2A> でオーバー ロード、 `preserveForm` パラメーターを設定する `false`, 、 `method` パラメーターを設定する `null`, 、 `headers` パラメーターを設定する `null`, 、および `preserveUser` パラメーターを設定する `true`です。 詳細については、「解説」セクションを参照してください。 <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> オーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この要求には、IIS 7.0 の統合パイプライン モードが必要です。</exception>
        <exception cref="T:System.Web.HttpException">要求を処理するサーバーが使用できません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> パラメーターが正しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">サーバー上にある、実行する新しいページの URL パス。</param>
        <param name="preserveForm">
          <see langword="true" /> 保持するために、 <see cref="P:System.Web.HttpRequest.Form" /> コレクション <see langword="false" /> をオフにする、 <see cref="P:System.Web.HttpRequest.Form" /> コレクションです。</param>
        <summary>指定した URL の非同期実行を行い、クエリ文字列パラメーターを保持します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを呼び出す、 <xref:System.Web.HttpServerUtility.TransferRequest%2A> でオーバー ロード、 `preserveForm` パラメーターは、渡された値に設定されて、 `method` パラメーターを設定する `null`, 、 `headers` パラメーターを設定する `null`, 、および `preserveUser` パラメーターを設定する `true`です。 詳細については、「解説」セクションを参照してください。 <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>します。  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[The .NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この要求には、IIS 7.0 の統合パイプライン モードが必要です。</exception>
        <exception cref="T:System.Web.HttpException">要求を処理するサーバーが使用できません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> パラメーターが正しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">サーバー上にある、実行する新しいページの URL パス。</param>
        <param name="preserveForm">
          <see langword="true" /> 保持するために、 <see cref="P:System.Web.HttpRequest.Form" /> コレクション <see langword="false" /> をオフにする、 <see cref="P:System.Web.HttpRequest.Form" /> コレクションです。</param>
        <param name="method">新しい要求の実行で使用する HTTP メソッド。</param>
        <param name="headers">A <see cref="T:System.Collections.Specialized.NameValueCollection" /> 新しい要求の要求ヘッダーのです。</param>
        <summary>指定した HTTP メソッドおよびヘッダーを使用して、指定した URL の非同期実行を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 統合パイプライン モードで実行している場合、このメソッドは使用 [!INCLUDE[iisver](~/includes/iisver-md.md)] 正しい要求コンテキストに対象の要求の実行中に別の 1 つのリソースの種類から転送される要求の処理を許可するようにします。 たとえば、使用、 <xref:System.Web.HttpServerUtility.TransferRequest%2A> XML ページに対する要求に ASPX ページに対する要求を転送する方法です。  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> メソッドは、指定された URL は次の条件の実行を非同期の子を実行します。  
  
-   場合、 `path` クエリ文字列を指定するパラメーター、これは、新しいクエリ文字列として使用します。 クエリ文字列が含まれていない場合、要求のクエリ文字列を再利用されます。  
  
-   場合、 `method` パラメーターを指定すると、それが使用されます。 ある場合 `null`, 、元の要求の HTTP メソッドを使用します。  
  
-   場合、 `preserveForm` パラメーターは `true`, 、要求の現在のエンティティ本体が対象の要求を使用できます。 これにより、フォーム ポストし、転送にアップロードします。  
  
-   ユーザー id が元の要求に設定されている場合、id は、新しい要求に転送されます。 これにより、認証された要求を新しい要求の認証の結果を再利用できます。 転送するユーザーにしたくない場合は、ユーザーを設定 `null` 転送する前に元の要求にします。  
  
-   場合、 `headers` パラメーターを指定すると、指定したヘッダーを含む新しい要求が実行されます。 これにより、要求ヘッダー、および新しい要求のための cookie を変更するために使用するか、元の要求の受信場所を指定する特殊なヘッダーを追加します。  
  
     このメソッドは、 <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> メソッドのオーバー ロードで、 `preserveUser` パラメーターを設定する `true`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この要求を実行するには、統合モードで実行している IIS 7.0 が必要です。</exception>
        <exception cref="T:System.Web.HttpException">要求を処理するサーバーが使用できません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> パラメーターが正しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="preserveUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">パス。</param>
        <param name="preserveForm">
          <see langword="true" /> 保持するために、 <see cref="P:System.Web.HttpRequest.Form" /> コレクション <see langword="false" /> をオフにする、 <see cref="P:System.Web.HttpRequest.Form" /> コレクションです。</param>
        <param name="method">新しい要求で使用する HTTP メソッド。</param>
        <param name="headers">A <see cref="T:System.Collections.Specialized.NameValueCollection" /> 新しい要求の要求ヘッダーを格納しているオブジェクト。</param>
        <param name="preserveUser">
          <see langword="true" /> ユーザー id を保持するためにそれ以外の場合、 <see langword="false" />です。 このメソッドの他のメソッド オーバー ロードは、このパラメーターを設定したこのオーバー ロードを呼び出して <see langword="true" />します。</param>
        <summary>指定した HTTP メソッド、ヘッダー、およびパスを使用して、指定した URL の非同期実行を実行します。また、任意でユーザー id とフォーム値を保持します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 詳細については、「解説」セクションを参照してください。 <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この要求には、IIS 7.0 の統合パイプライン モードが必要です。</exception>
        <exception cref="T:System.Web.HttpException">要求を処理するサーバーが使用できません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> パラメーターが正しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">デコードする文字列。</param>
        <summary>文字列を URL デコードし、デコードされた文字列を返します。</summary>
        <returns>デコードされたテキスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 URL エンコードにより、すべてのブラウザーが URL 文字列のテキストを正しく送信されます。 質問などの文字 \(?\) のマーク、アンパサンド \(&\)、スラッシュ記号 \(\/\)、および空白を切り捨てやブラウザーによっては、破損している可能性があります。 この結果、これらの文字をエンコードする必要があります `<a>` タグまたはクエリ文字列、文字列再で送信できる要求の文字列内のブラウザーです。  
  
 このメソッドにアクセスする便利な方法は、 <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName> 実行時に、ASP.NET アプリケーションからのメソッドです。 このメソッドを使用して内部的には、 <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName> 文字列をデコードします。  
  
 ASP.NET web ページの分離コード ファイル内のインスタンスにアクセス、 <xref:System.Web.HttpServerUtility> クラスを通じて、 `Server` プロパティです。 分離コード ファイルに含まれていないクラスで使用して `HttpContext.Current.Server` のインスタンスにアクセスする、 <xref:System.Web.HttpServerUtility> クラスです。  
  
 Web アプリケーションの外部で使用して、 <xref:System.Net.WebUtility> エンコードまたはデコードの値をクラスです。  
  
   
  
## 例  
 例を次に値を URL デコードするには、クエリ文字列から取得します。 コードは、web ページの分離コード ファイルに存在します。`ReturnPage` 指す、 `HyperLink` コントロールです。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 次の例は似ていますが、前の例が表示する方法を URL デコード クラス内の値外にある分離コード ファイルにします。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">デコードする HTML 文字列。</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> 、デコードした文字列を格納している出力ストリーム。</param>
        <summary>URL で受信した HTML 文字列をデコードし、その結果に出力を送信、 <see cref="T:System.IO.TextWriter" /> 出力ストリーム。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 URL エンコードにより、すべてのブラウザーが URL 文字列のテキストを正しく送信されます。 質問などの文字 \(?\) のマーク、アンパサンド \(&\)、スラッシュ記号 \(\/\)、および空白を切り捨てやブラウザーによっては、破損している可能性があります。 この結果、これらの文字をエンコードする必要があります `<a>` タグまたはクエリ文字列、文字列再で送信できる要求の文字列内のブラウザーです。  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> アクセスする便利な方法は、 <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName> 実行時に、ASP.NET アプリケーションからのメソッドです。 内部的には、 <xref:System.Web.HttpServerUtility.UrlDecode%2A> を使用して <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName> 文字列をデコードします。  
  
 Web アプリケーションの外部で値をエンコードまたはデコードするには、<xref:System.Net.WebUtility> クラスを使用してください。  
  
   
  
## 例  
 次の例は、という名前の文字列をデコード `EncodedString` \(URL で受信した\) という名前の文字列に `DecodedString`します。  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>URL を使用して Web サーバーからクライアントへ信頼性のある HTTP 伝送を行うために、文字列をエンコードします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> アクセスする便利な方法は、 <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName> 実行時に、ASP.NET アプリケーションからのメソッドです。 内部的には、 <xref:System.Web.HttpServerUtility.UrlEncode%2A> を使用して <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName> 文字列をエンコードします。  
  
 Web アプリケーションの外部で値をエンコードまたはデコードするには、<xref:System.Net.WebUtility> クラスを使用してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">URL エンコードするテキスト。</param>
        <summary>文字列を URL エンコードし、エンコードされた文字列を返します。</summary>
        <returns>URL エンコードされたテキスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 URL エンコードにより、すべてのブラウザーが URL 文字列のテキストを正しく送信されます。 質問などの文字 \(?\) のマーク、アンパサンド \(&\)、スラッシュ記号 \(\/\)、および空白を切り捨てやブラウザーによっては、破損している可能性があります。 この結果、これらの文字をエンコードする必要があります `<a>` タグまたはクエリ文字列、文字列再で送信できる要求の文字列内のブラウザーです。  
  
 このメソッドにアクセスする便利な方法は、 <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName> 実行時に、ASP.NET アプリケーションからのメソッドです。 このメソッドを使用して内部的には、 <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName> 文字列をエンコードします。  
  
 ASP.NET web ページの分離コード ファイル内のインスタンスにアクセス、 <xref:System.Web.HttpServerUtility> クラスを通じて、 `Server` プロパティです。 分離コード ファイルに含まれていないクラスで使用して `HttpContext.Current.Server` のインスタンスにアクセスする、 <xref:System.Web.HttpServerUtility> クラスです。  
  
 Web アプリケーションの外部で使用して、 <xref:System.Net.WebUtility> エンコードまたはデコードの値をクラスです。  
  
   
  
## 例  
 どの値を URL エンコードするために使用されるハイパーリンクのクエリ文字列の値として次の例を示します。 コードは、web ページの分離コード ファイルに存在します。 エンコードする値は、のみを例を簡略化し、URL エンコードすることがあります値の型を表示するには、この例では、ハードコーディングです。 通常と URL エンコードをユーザーまたは要求から受信した値です。`NextPage` 指す、 `HyperLink` コントロールです。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 次の例は似ていますが、前の例が表示する方法を URL エンコードするクラス内の値外にある分離コード ファイルにします。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">エンコードする文字列。</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> エンコードの文字列を格納する出力ストリーム。</param>
        <summary>文字列を URL エンコードし、結果の出力を <see cref="T:System.IO.TextWriter" /> 出力ストリーム。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 URL エンコードにより、すべてのブラウザーが URL 文字列のテキストを正しく送信されます。 質問などの文字 \(?\) のマーク、アンパサンド \(&\)、スラッシュ記号 \(\/\)、および空白を切り捨てやブラウザーによっては、破損している可能性があります。 この結果、これらの文字をエンコードする必要があります `<a>` タグまたはクエリ文字列、文字列再で送信できる要求の文字列内のブラウザーです。  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> アクセスする便利な方法は、 <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName> 実行時に、ASP.NET アプリケーションからのメソッドです。 内部的には、 <xref:System.Web.HttpServerUtility.UrlEncode%2A> を使用して <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName> 文字列をエンコードします。  
  
 Web アプリケーションの外部で値をエンコードまたはデコードするには、<xref:System.Net.WebUtility> クラスを使用してください。  
  
   
  
## 例  
 次の例では、HTTP で伝送用の文字列をエンコードします。 という名前の文字列をエンコード `TestString`, 、「これは \< テスト文字列 \>」をテキストが含まれ、という名前の文字列にコピーして `EncodedString` として"この \+、\+ \+ %3ctest \+ 文字列 %3e。"です。  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">URL エンコードするテキスト。</param>
        <summary>使用しないでください。ブラウザーの互換性のためだけのものです。<see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" /> を使用してください。</summary>
        <returns>URL エンコードされたテキスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">デコードする URL 文字列トークン。</param>
        <summary>URL 文字列トークンをデコードし、base 64 を使用して等価なバイト配列を作成します。</summary>
        <returns>デコードされた URL 文字列トークンが格納されたバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> メソッドでは、バイナリ データを base 64 としてエンコードされ、URL 文字列トークンを等価なバイト配列形式に変換します。 使用して、 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> トークンをデコードする方法を選択し、URL で送信を使用してエンコード、 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>です。  
  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> 場合にメソッドが空のバイト配列を返す、 `input` パラメーターが 1 未満の長さ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> パラメーターの値が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="input">エンコードするバイト配列。</param>
        <summary>Base64 形式の文字を使用して、バイト配列を等価の文字列表現にエンコードします。この文字列表現は、URL での送信で使用できます。</summary>
        <returns>トークンの場合、エンコードされたバイト配列を含む文字列 *長さ* が 1 よりも大きい場合、それ以外の場合、空の文字列 \(""\) です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> メソッドは、base 64 でエンコードされた等価の文字列形式にバイト配列を変換します。 生成される文字列トークンは、URL を送信できます。  
  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> 場合に、空の文字列を返す、 `input` パラメーターが 1 未満の長さ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> パラメーターの値が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ブラウザーに表示される文字列をエンコードします。  
  
 Web アプリケーションの外部で値をエンコードまたはデコードするには、<see cref="T:System.Net.WebUtility" /> クラスを使用してください。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のページの実行を終了し、現在の要求に対して新しいページの実行を開始します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したリソースのハンドラーを現在の要求のコンテキストで実行し、そのハンドラーを起動したページに実行を戻します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>無効な HTML 文字を排除するエンコードされた文字列をデコードします。  
  
 Web アプリケーションの外部で値をエンコードまたはデコードするには、<see cref="T:System.Net.WebUtility" /> クラスを使用してください。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>COM オブジェクトのサーバー インスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>HTTP 伝送用にエンコードされた文字列をデコードし、URL の形でサーバーに送信します。  
  
 Web アプリケーションの外部で値をエンコードまたはデコードするには、<see cref="T:System.Net.WebUtility" /> クラスを使用してください。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>