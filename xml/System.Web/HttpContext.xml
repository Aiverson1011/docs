<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>それぞれの HTTP 要求に関する HTTP 固有のすべての情報をカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 継承するクラス、 <xref:System.Web.IHttpModule> と <xref:System.Web.IHttpHandler> への参照を提供するインターフェイス、 <xref:System.Web.HttpContext> の現在の HTTP 要求に対するオブジェクトです。 オブジェクトは、組み込みへのアクセスを提供 <xref:System.Web.HttpContext.Request%2A>, 、<xref:System.Web.HttpContext.Response%2A>, 、および <xref:System.Web.HttpContext.Server%2A> 要求のプロパティです。  
  
   
  
## 例  
 ソース コードの Visual Studio の Web サイト プロジェクトはこのトピック用に使用可能な: [Download](http://go.microsoft.com/fwlink/?LinkId=192422)します。  
  
 次の例では、アクセスし、\[のプロパティを表示する方法、 <xref:System.Web.HttpContext> オブジェクトです。 現在の HTTP 要求のコンテキストのアクセスを使用して、 <xref:System.Web.UI.Page.Context%2A> のプロパティ、 <xref:System.Web.UI.Page> オブジェクトです。  
  
 [!code-csharp[System.Web.HttpContext\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-vb[System.Web.HttpContext\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">現在の HTTP 要求に対する <see cref="T:System.Web.HttpWorkerRequest" /> オブジェクト。</param>
        <summary>指定したワーカー要求オブジェクトを使用する <see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" /> オブジェクト。</param>
        <param name="response">現在の HTTP 要求に対する <see cref="T:System.Web.HttpResponse" /> オブジェクト。</param>
        <summary>指定した要求オブジェクトと応答オブジェクトを使用して、<see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">ユーザー関数。</param>
        <summary>指定されたユーザー関数を使用して <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すことと同じではこのメソッドを呼び出して、 <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> メソッドのオーバー ロードを渡して `null` の `options` パラメーター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userFunc" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">要求は、 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求します。</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">ユーザー関数。</param>
        <param name="options">オプションのオブジェクト。</param>
        <summary>指定されたユーザー関数とオプション オブジェクトを使用して <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userFunc" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">要求は、 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求します。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">例外コレクションに追加する <see cref="T:System.Exception" />。</param>
        <summary>現在の HTTP 要求に対する例外コレクションに例外を追加します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">HTTP コンテキスト オブジェクト。</param>
        <summary>要求の HTTP 部分が終了するときに発生する仮想イベントを発生させます。</summary>
        <returns>サブスクリプション トークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントが発生する前に、 <xref:System.Web.WebSockets.AspNetWebSocket> 接続を開始します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理中に蓄積されたエラーの配列を取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Exception" /> オブジェクトの配列。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET 要求の一部の処理中に、それが予期されていない場合、非同期操作が許可されるかどうかを示す値を取得または設定します。</summary>
        <value>予期しない時期に非同期 API が使用されると ASP.NET が例外をスローする場合は <see langword="false" />、それ以外の場合は <see langword="true" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このフラグは設定されていない場合 `true`, 、ASP.NET アプリケーションの非同期 API を不正使用を検出した場合に例外がスローされます。 これは、要求処理パイプラインでの非同期操作が予期されていないの部分では非同期メソッドを呼び出そうとする場合、または非同期のモジュールとハンドラー完了を通知するときにまだ保留中の非同期操作がある場合に発生することができます。 この動作は、非同期コードが適合しないパターンを想定し、悪影響が出る場合がありますを記述しているかどうかを早い段階で通知するセーフティ ネットとして用意されています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplicationState" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplicationState" />。  
  
 現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" /> オブジェクトを取得するには、<see cref="P:System.Web.HttpContext.ApplicationInstance" /> を使用します。 \(ASP.NET と従来の ASP との混同を避けるために、ASP.NET は <see langword="Application" /> の代わりに <see langword="ApplicationInstance" /> をプロパティ名として使用して、現在の <see cref="T:System.Web.HttpApplication" /> インスタンスを参照します。 従来の ASP では、<see langword="Application" /> はグローバル アプリケーション状態のディクショナリを参照します\)。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" /> オブジェクトを取得または設定します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" />。  
  
 ASP.NET と従来の ASP との混同を避けるために、ASP.NET は <see langword="Application" /> の代わりに <see langword="ApplicationInstance" /> をプロパティ名として使用して、現在の <see cref="T:System.Web.HttpApplication" /> インスタンスを参照します。 従来の ASP では、<see langword="Application" /> はグローバル アプリケーション状態のディクショナリを参照します。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Web アプリケーションは、統合モードで IIS 7.0 で実行されていて、プロパティの値に null 以外の値から変更が試み <see langword="null" />します。</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>非同期プリロード モードに関係するフラグを含むオブジェクトを取得または設定します。</summary>
        <value>非同期プリロード モードに関係するフラグを含むオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティにアクセスすると、最初に非同期プリロード モードに対応するフラグを格納しているオブジェクトはから読み込まれた、 <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> 構成ファイルで設定します。  
  
 このプロパティは、プログラムで設定できますが、プロパティ値の変更のみが影響する前に、プロパティが設定されている場合、 `ExecuteRequestHandler` ASP.NET 要求パイプラインにステップ インします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーション ドメインに対する <see cref="T:System.Web.Caching.Cache" /> オブジェクトを取得します。</summary>
        <value>現在のアプリケーション ドメインに対する <see cref="T:System.Web.Caching.Cache" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを 1 つ、 <xref:System.Web.Caching.Cache> アプリケーション ドメインごとのクラスです。 結果として、 <xref:System.Web.Caching.Cache> によって返されるオブジェクト、 <xref:System.Web.HttpContext.Cache%2A> プロパティは、 <xref:System.Web.Caching.Cache> アプリケーション ドメイン内のすべての要求オブジェクトです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の HTTP 要求に対するすべてのエラーをクリアします。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpContext" /> オブジェクトを取得または設定します。</summary>
        <value>現在の HTTP リクエストに対する <see cref="T:System.Web.HttpContext" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This property is a static property of the <xref:System.Web.HttpContext> class. The property stores the <xref:System.Web.HttpContext> instance that applies to the current request. The properties of this instance are the non\-static properties of the <xref:System.Web.HttpContext> class.  
  
 You can also use the <xref:System.Web.UI.Page.Context%2A?displayProperty=fullName> property to access the <xref:System.Web.HttpContext> object for the current HTTP request.  
  
   
  
## 例  
 The following code example uses the <xref:System.Web.HttpContext.Current%2A> property to access the <xref:System.Web.HttpContext.AddError%2A?displayProperty=fullName> and <xref:System.Web.HttpContext.ClearError%2A?displayProperty=fullName> methods and the <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=fullName> property. The example creates three custom exceptions using the <xref:System.Web.HttpContext.AddError%2A> method and uses the <xref:System.Web.HttpContext.AllErrors%2A> property to load these exceptions to an array. It then writes the array to the containing page and uses the <xref:System.Web.HttpContext.ClearError%2A> method to clear all the errors from the <xref:System.Web.UI.Page.Context%2A> property.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中のハンドラーを表す <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得します。</summary>
        <value>現在実行中のハンドラーを表す <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The currently executing handler that is referenced by the <xref:System.Web.HttpContext.CurrentHandler%2A> property might be different than the handler that is referenced by the <xref:System.Web.HttpContext.Handler%2A> property. This can occur when another handler was requested by using the <xref:System.Web.HttpServerUtility.Execute%2A> method or the <xref:System.Web.HttpServerUtility.Transfer%2A> method. When the currently executing handler finishes processing, the previously determined handler is restored.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>処理中の現在の <see cref="T:System.Web.HttpApplication" /> イベントを示す <see cref="T:System.Web.RequestNotification" /> 値を取得します。</summary>
        <value>
          <see cref="T:System.Web.RequestNotification" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.CurrentNotification%2A> プロパティには、統合パイプライン モードが必要です。 [!INCLUDE[iisver](~/includes/iisver-md.md)] と少なくとも .NET Framework バージョン 3.0。 プロパティが返す有効な場合、 <xref:System.Web.RequestNotification> 値。 値、 <xref:System.Web.HttpContext.CurrentNotification%2A> プロパティでイベントを示す、 <xref:System.Web.HttpApplication> インスタンスが現在の要求を処理します。  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> プロパティを設定する必要はありません。 代わりに、によって設定された [!INCLUDE[iisver](~/includes/iisver-md.md)] ASP.NET パイプラインでの要求の処理中にします。 設定、 <xref:System.Web.HttpContext.CurrentNotification%2A> プロパティは、コンパイル エラーになります。  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[The .NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 次の例では、使用して、 <xref:System.Web.HttpContext.CurrentNotification%2A> のどのようなイベントを確認するに、 <xref:System.Web.HttpApplication> 現在の要求を処理しているオブジェクトは処理中です。 例では、イベント ハンドラーの複数のイベント、 <xref:System.Web.HttpApplication> オブジェクト、および <xref:System.Web.HttpContext.CurrentNotification%2A> プロパティは、どのようなコードが処理される各イベントに対して呼び出されるを決定します。  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">操作には、統合パイプライン モードが必要です。 IIS 7.0 と少なくとも .NET Framework バージョン 3.0。</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">要求の <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続部分が完了したときに、<see cref="M:System.IDisposable.Dispose" /> メソッドを呼び出す必要のあるオブジェクト。</param>
        <summary>この要求の <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続部分が完了したときに、オブジェクトの <see cref="M:System.IDisposable.Dispose" /> メソッドを呼び出すことができるようにします。</summary>
        <returns>サブスクリプション トークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.IDisposable.Dispose%2A> method of the target object is called after both the HTTP part of the request and the <xref:System.Web.WebSockets.AspNetWebSocket> connection have ended. The <xref:System.Web.HttpContext> object is not available for inspection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理中にエラーが蓄積された場合は、その最初のエラーを取得します。</summary>
        <value>現在の HTTP 要求または HTTP 応答の処理に対する最初の <see cref="T:System.Exception" />。HTTP 要求処理中にエラーが 1 つも蓄積されなかった場合は、<see langword="null" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">情報が要求されたアプリケーションの構成タグ。</param>
        <summary>現在のアプリケーションに対して要求された構成情報を返します。</summary>
        <returns>構成情報を格納するオブジェクト。 \(返された構成セクションは、適切な構成型にキャストしてから使用してください。\)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.GetAppConfig%2A> メソッドの使用は推奨されていません。 使用して、 <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> のメソッド、 <xref:System.Web.Configuration.WebConfigurationManager> クラスは、現在のアプリケーションの構成情報を取得します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">情報が要求された構成タグ。</param>
        <summary>現在の HTTP 要求に対して要求された構成情報を返します。</summary>
        <returns>指定した <see cref="T:System.Configuration.ConfigurationSection" />。このセクションが存在しない場合は <see langword="null" />。このセクションに実行時にアクセスできない場合は内部オブジェクト。 \(返されたオブジェクトは、適切な構成型にキャストしてから使用してください。\)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.GetConfig%2A> メソッドの使用は推奨されていません。 使用して、 <xref:System.Web.HttpContext.GetSection%2A> 現在の HTTP 要求の構成情報を取得します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティを表す文字列。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <summary>アプリケーション レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティに基づいて取得します。</summary>
        <returns>要求されたアプリケーション レベル リソース オブジェクトを表す <see cref="T:System.Object" />。リソース オブジェクトが見つからない場合、またはリソース オブジェクトが見つかってもそれが要求されたプロパティを持っていない場合は null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> メソッドで指定されているカルチャを使用してグローバル リソースを返す、 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> プロパティです。  
  
> [!NOTE]
>  編集中のいくつかの環境など [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], 、エディターがデザイン時にスローされることが <xref:System.Resources.MissingManifestResourceException> ピリオド \(.\) を使用する場合に例外 グローバル リソース キー名。 ただし、これには影響しませんを編集したり、ファイルを保存できると、エラーを無視することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定されたリソース オブジェクト <paramref name="classKey" /> パラメーターが見つかりませんでした。  
  
 または  
  
 メインのアセンブリにニュートラル カルチャのリソースが含まれていないと、適切なサテライト アセンブリが見つからないために、これらのリソースが必要です。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティを表す文字列。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <param name="culture">要求されたリソースの <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを表す文字列。</param>
        <summary>アプリケーション レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティ、および <see cref="T:System.Globalization.CultureInfo" /> オブジェクトに基づいて取得します。</summary>
        <returns>要求されたアプリケーション レベル リソース オブジェクトを表す <see cref="T:System.Object" />。これは、特定のカルチャにローカライズされます。リソース オブジェクトが見つからない場合、またはリソース オブジェクトが見つかってもそれが要求されたプロパティを持っていない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Globalization.CultureInfo> オブジェクトは、リソースのローカライズ対象のカルチャを表します。 リソースがこのカルチャにローカライズされていない場合、参照は、適切なリソースを検索するフォールバック プロセスに従います。 詳細については、「[Packaging and Deploying Resources](http://msdn.microsoft.com/ja-jp/b224d7c0-35f8-4e82-a705-dd76795e8d16)」を参照してください。  
  
> [!NOTE]
>  Visual Web Developer などの一部の編集環境で、エディターが発生するデザイン時 <xref:System.Resources.MissingManifestResourceException> ピリオド \(.\) を使用する場合に例外 グローバル リソース キー名。 ただし、これには影響しませんを編集したり、ファイルを保存できると、エラーを無視することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">リソース オブジェクトを指定した <paramref name="classKey" /> パラメーターが見つかりませんでした。  
  
 または  
  
 メインのアセンブリにニュートラル カルチャのリソースが含まれていないと、適切なサテライト アセンブリが見つからないために、これらのリソースが必要です。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">ローカル リソース オブジェクトのための <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティ。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <summary>ページ レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティに基づいて取得します。</summary>
        <returns>要求されたページ レベル リソース オブジェクトを表す <see cref="T:System.Object" />。一致するリソース オブジェクトが見つかっても <paramref name="resourceKey" /> パラメーターではない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.GetLocalResourceObject%2A> メソッドで指定されているカルチャを使用してローカル リソースを返す、 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">リソース オブジェクトが見つかりませんでした。 指定された <paramref name="virtualPath" /> パラメーター。</exception>
        <exception cref="T:System.ArgumentException">指定した <paramref name="virtualPath" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.InvalidOperationException">ページのリソース クラスは見つかりませんでした。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">ローカル リソース オブジェクトのための <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティ。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <param name="culture">要求されたリソース オブジェクトの <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを表す文字列。</param>
        <summary>ページ レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティ、および <see cref="T:System.Globalization.CultureInfo" /> オブジェクトに基づいて取得します。</summary>
        <returns>要求されたローカル リソース オブジェクトを表す <see cref="T:System.Object" />。これは、特定のカルチャにローカライズされます。一致するリソース オブジェクトが見つかっても <paramref name="resourceKey" /> パラメーターではない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 リソースがこのカルチャにローカライズされていない場合、参照は、適切なリソースを検索するフォールバック プロセスに従います。 詳細については、「[Packaging and Deploying Resources](http://msdn.microsoft.com/ja-jp/b224d7c0-35f8-4e82-a705-dd76795e8d16)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">リソース オブジェクトが見つかりませんでした。 指定された <paramref name="virtualPath" /> パラメーター。</exception>
        <exception cref="T:System.ArgumentException">指定した <paramref name="virtualPath" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.InvalidOperationException">ページのリソース クラスは見つかりませんでした。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">構成セクション パス \(XPath 形式\) および構成要素名。</param>
        <summary>現在のアプリケーションの既定構成の、指定した構成セクションを取得します。</summary>
        <returns>指定した <see cref="T:System.Configuration.ConfigurationSection" />。このセクションが存在しない場合は <see langword="null" />。このセクションに実行時にアクセスできない場合は内部オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理を実行する <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得または設定します。</summary>
        <value>HTTP 要求の処理を実行する <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.Handler%2A> プロパティには、HTTP 要求を処理するハンドラーへの参照が含まれています。 ハンドラーは、要素を使用して、またはユーザー コードで定義されているカスタム ハンドラーを使用して指定できます。 ハンドラーの詳細については、次を参照してください。 [HTTP Handlers and HTTP Modules Overview](http://msdn.microsoft.com/ja-jp/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b)します。  
  
 参照、 <xref:System.Web.HttpContext.Handler%2A> プロパティは同じサーバー側のメソッドによって、現在のページがなどに変更した後も、 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドまたは <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対してカスタム エラーが有効かどうかを示す値を取得します。</summary>
        <value>カスタム エラーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求がデバッグ モードかどうかを示す値を取得します。</summary>
        <value>要求がデバッグ モードである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.HttpApplication" /> イベントが処理を終了した直後の ASP.NET パイプライン内の現在の処理ポイントである値を取得します。</summary>
        <value>カスタム エラーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.IsPostNotification%2A> プロパティは統合モードでのみサポート [!INCLUDE[iisver](~/includes/iisver-md.md)] と少なくとも .NET Framework 3.0。 プロパティを示すブール値を返す有効な場合のイベントかどうか、 <xref:System.Web.HttpApplication> オブジェクトの処理が完了します。  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> プロパティを設定する必要はありません。 によって提供される代わりに、 [!INCLUDE[iisver](~/includes/iisver-md.md)] 通知ごとに、ASP.NET ランタイムにします。 設定、 <xref:System.Web.HttpContext.IsPostNotification%2A> プロパティは、コンパイル エラーになります。  
  
 シナリオの複数のイベント、 <xref:System.Web.HttpApplication> オブジェクトが 1 つのイベント ハンドラーによって処理される、使用することができます、 <xref:System.Web.HttpContext.IsPostNotification%2A> プロパティと組み合わせて、 <xref:System.Web.RequestNotification> 列挙体をアプリケーション ライフ サイクルで現在の要求が正確に判断します。  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> .NET Framework version 3.5 で導入されました。  詳細については、「[The .NET Framework 3.5 Architecture](http://msdn.microsoft.com/ja-jp/f75a72de-e2f2-4a7a-9574-3f278684ea90)」を参照してください。  
  
   
  
## 例  
 次の例では、使用、 <xref:System.Web.HttpContext.IsPostNotification%2A> ときのイベントを特定のプロパティ、 <xref:System.Web.HttpApplication> オブジェクトには、すべての関連するイベント ハンドラーの処理が完了しました。 この例では、カスタム イベント ハンドラーの複数のイベントを処理する、 <xref:System.Web.HttpApplication> オブジェクト、および <xref:System.Web.HttpContext.IsPostNotification%2A> プロパティを使用して、どのようなコードが呼び出される決定の特定のイベントが処理された後です。  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">操作には、統合パイプライン モードが必要です。 IIS 7.0 と少なくとも .NET Framework 3.0。</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求が <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求かどうかを示す値を取得します。</summary>
        <value>要求が <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求である場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る `true` 要求には、最初が含まれている場合 <xref:System.Web.WebSockets.AspNetWebSocket> ハンドシェイクと `WebSocket` IIS のモジュールがアクティブです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続が HTTP 接続から <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続にアップグレードされるかどうかを示す値を取得します。</summary>
        <value>接続がアップグレード中の場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求時に <see cref="T:System.Web.IHttpModule" /> インターフェイスと <see cref="T:System.Web.IHttpHandler" /> インターフェイスとの間でデータを編成および共有するために使用できるキー\/値のコレクションを取得します。</summary>
        <value>キーの指定によるコレクションの個々の値へのアクセスを実現する <see cref="T:System.Collections.IDictionary" /> キー\/値のコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要求のページ インストルメンテーション サービス インスタンスへの参照を取得します。</summary>
        <value>この要求のページ インストルメンテーション サービス インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親ハンドラーの <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Web.IHttpHandler" /> インスタンス。以前のハンドラーが見つからなかった場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.PreviousHandler%2A> プロパティは、対応最後のハンドラーの現在の要求の実行前に、。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のユーザー プロファイルの <see cref="T:System.Web.Profile.ProfileBase" /> オブジェクトを取得します。</summary>
        <value>アプリケーションの構成ファイルにプロファイルのプロパティが定義されている場合は <see cref="T:System.Web.Profile.ProfileBase" />。それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Web.HttpContext.Profile%2A> プロパティは、タイプ セーフな API を使用して構造化データの永続的なストレージとして使用します。 ときに、 <xref:System.Web.HttpContext.Profile%2A> プロパティへのアクセスが、値が存在しない、空のインスタンスが返されます。 `null` は返されません。  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">要求を処理するオブジェクト。</param>
        <summary>要求のハンドラーを指定できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定した場合 `handler` に `null`, 、既定のハンドラーは要求を処理するために使用します。 設定する `handler` 非同期ハンドラーまたは同期ハンドラー。 ハンドラーを実装する必要があります、 <xref:System.Web.IHttpHandler> インターフェイスです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> メソッドを呼び出した後、 <see cref="E:System.Web.HttpApplication.MapRequestHandler" /> イベントが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.Request%2A> プロパティを使用するプロパティとメソッドのプログラムによるアクセス、 <xref:System.Web.HttpRequest> クラスです。 ASP.NET ページには、既定値への参照が含まれているため、 <xref:System.Web> 名前空間 \(を含む、 <xref:System.Web.HttpContext> クラス\) のメンバーを参照する <xref:System.Web.HttpRequest> .aspx ページへの参照を完全修飾クラスを使用せずに <xref:System.Web.HttpContext>します。 たとえば、使用 `Request.Browser` クライアントのブラウザーの機能を取得します。 ただしのメンバーを使用する場合は、 <xref:System.Web.HttpRequest> ASP.NET 分離コード モジュールからへの参照を含める必要があります、 <xref:System.Web> モジュールで現在アクティブな要求\/応答のコンテキストとのクラスの両方への参照を完全修飾名前空間 <xref:System.Web> を使用します。 たとえば、分離コード ページ、完全修飾名指定する必要 `HttpContext.Current.Request.Browser`します。  
  
> [!NOTE]
>  このプロパティを使用しようとする場合に ASP.NET が例外をスロー時に、 <xref:System.Web.HttpRequest> オブジェクトは使用できません。 たとえば、Global.asax ファイルの Application\_Start メソッドまたは Application\_Start メソッドから呼び出されるメソッドは true。 となります。 その時点での HTTP 要求がまだ作成されていません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web アプリケーションを統合モードで IIS 7 で行われています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 応答に対する <see cref="T:System.Web.HttpResponse" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 応答の <see cref="T:System.Web.HttpResponse" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.Response%2A> プロパティを使用するプロパティとメソッドのプログラムによるアクセス、 <xref:System.Web.HttpResponse> クラスです。 ASP.NET ページには、既定値への参照が含まれているため、 <xref:System.Web> 名前空間 \(を含む、 <xref:System.Web.HttpContext> クラス\) のメンバーを参照する <xref:System.Web.HttpContext> .aspx ページへの参照を完全修飾クラスを使用せずに <xref:System.Web.HttpContext>します。 たとえば、使用 `Response.Write("some output")` HTTP 出力ストリームに出力します。 ただしのメンバーを使用する場合は、 <xref:System.Web.HttpResponse> ASP.NET 分離コード モジュールからへの参照を含める必要があります、 <xref:System.Web> モジュールで現在アクティブな要求\/応答のコンテキストと内のクラスへの参照を完全修飾名前空間 <xref:System.Web> を使用します。 たとえば、分離コード ページ、完全修飾名指定する必要 `HttpContext.Current.Response.Write("some output")`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web アプリケーションを統合モードで IIS 7 で行われています。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">内部リライト パス。</param>
        <summary>指定されたパスを使用して URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.RewritePath%28System.String%29> メソッドでは、リソースに対する要求を要求された URL で示されているものとは異なるパスにリダイレクトします。 サーバー リソースのクライアントからの要求を正しく解決できるように、仮想パスをリセットした場合は、このメソッドのオーバー ロードを使用して、 `rebaseClientPath` パラメーター、パラメーターを設定および `false`です。  
  
 Web アプリケーションでページを再構築して、いる人は、古い Url をブックマークしているように使用できますページを移動した後になっていることを確認する場合は、URL リライトすると便利です。 URL の書き換えには、新しいページの場所に要求を透過的に転送することができます。  
  
 検索エンジンにとってわかりやすくし、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、「[ASP.NET Routing](http://msdn.microsoft.com/ja-jp/892441af-8f1d-483e-ab5f-b82c23576f5a)」を参照してください。  
  
   
  
## 例  
 次の例では、使用する方法、 <xref:System.Web.HttpContext.RewritePath%2A> Web サイトのファイル構造を反映して Url に対応する Web サイトを有効にする方法です。 コードの最初のブロックは、RewritePath.aspx という ASP.NET Web ページです。 クエリ文字列が必要です。 かどうか、サイトの名前は WebSite1 URL `http://localhost/WebSite1/RewritePath.aspx?page=1` 、ブラウザーで「ページ 1」が表示されます。 Web ページを次のコード ブロックは、 `Application_BeginRequest` Global.asax ファイル内のイベント ハンドラーです。 このコードは、インターセプト要求の Url など `http://localhost/WebSite1/page1` が処理されるまでに RewritePath.aspx に必要な形式に変換します。 そのため、URL `http://localhost/WebSite1/page1` 、ブラウザーに「ページ 1」を表示するクエリ文字列パラメーターを持つ RewritePath.aspx を呼び出します。 場合など、URL `http://localhost/WebSite1/page1` 受信されるのオーバー ロード <xref:System.Web.HttpContext.RewritePath%2A> が呼び出されるの値を指定することができます、 <xref:System.Web.HttpRequest.PathInfo%2A> プロパティだけでなく、クエリ文字列パラメーターです。  
  
 [!code-csharp[HttpContext\_RewritePath\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-vb[HttpContext\_RewritePath\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext\_RewritePath\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext\_RewritePath\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">内部リライト パス。</param>
        <param name="rebaseClientPath">仮想パスをリセットする場合は <see langword="true" />。仮想パスを変更しない場合は <see langword="false" />。</param>
        <summary>指定したパスおよびサーバー リソースの仮想パスが変更されるかどうかを指定するブール値を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=fullName> メソッドは、 <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=fullName> メソッドを `rebaseClientPath` パラメーターを設定する `true`です。 リソースへのパスを構築するために使用される仮想パスが変更されていないことを確認するには設定、 `rebaseClientPath` パラメーターを `false`します。 設定する一般的なシナリオ `rebaseClientPath` に `false` は、URL の書き換えする必要があるあり、要求されたリソースとは異なるフォルダーにあるリソースへの URL のリダイレクトをテーマを使用する場合。  
  
 Web アプリケーションでページを再構築して、いる人は、古い Url をブックマークしているように使用できますページを移動した後になっていることを確認する場合は、URL リライトすると便利です。 URL の書き換えには、新しいページの場所に要求を透過的に転送することができます。  
  
 検索エンジンにとってわかりやすくし、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、「[ASP.NET Routing](http://msdn.microsoft.com/ja-jp/892441af-8f1d-483e-ab5f-b82c23576f5a)」を参照してください。  
  
   
  
## 例  
 コード例については、 <xref:System.Web.HttpContext.RewritePath%28System.String%29> メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">内部リライト パス。</param>
        <param name="pathInfo">リソースの追加パス情報。 詳細については、「<see cref="P:System.Web.HttpRequest.PathInfo" />」を参照してください。</param>
        <param name="queryString">要求クエリ文字列。</param>
        <summary>指定されたパス、パス情報、およびクエリ文字列情報を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.RewritePath%2A> メソッドは、URL を変更することがなく他のリソースにリソースの要求をリダイレクトします。  
  
 `filePath` パラメーターを含まない、 `pathInfo` パラメーター コンテンツです。 URL http:\/\/www.microsoft.com\/virdir\/page.html\/tail の `filePath` パラメーターは http:\/\/www.microsoft.com\/virdir\/page.html、および `pathInfo` パラメーターは、末尾。  
  
 Web アプリケーションでページを再構築して、いる人は、古い Url をブックマークしているように使用できますページを移動した後になっていることを確認する場合は、URL リライトすると便利です。 URL の書き換えには、新しいページの場所に要求を透過的に転送することができます。  
  
 検索エンジンにとってわかりやすくし、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、「[ASP.NET Routing](http://msdn.microsoft.com/ja-jp/892441af-8f1d-483e-ab5f-b82c23576f5a)」を参照してください。  
  
   
  
## 例  
 このメソッドのオーバー ロードの例を含むコード例については、 <xref:System.Web.HttpContext.RewritePath%28System.String%29> メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="filePath" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">要求を処理するリソースへの仮想パス。</param>
        <param name="pathInfo">URL リダイレクトで使用する追加のパス情報。 詳細については、「<see cref="P:System.Web.HttpRequest.PathInfo" />」を参照してください。</param>
        <param name="queryString">URL リダイレクトで使用する要求クエリ文字列。</param>
        <param name="setClientFilePath">クライアント リソースで使用されるファイル パスを <c>filePath</c> パラメーターの値に設定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した仮想パス、パス情報、クエリ文字列、およびクライアント ファイル パスをリライト パスに設定するかどうかを指定するブール値を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `filePath` パラメーターの内容を含まない、 `pathInfo` パラメーター。 URL http:\/\/www.microsoft.com\/virdir\/page.html\/tail の `filePath` パラメーターは http:\/\/www.microsoft.com\/virdir\/page.html、および `pathInfo` パラメーターは、末尾。  
  
 リソースへのパスを構築するために使用される仮想パスが変更されていないことを確認するには設定、 `setClientFilePath` パラメーターを `false`します。 設定する一般的なシナリオ `setClientFilePath` に `false` は、URL の書き換えする必要があるあり、要求されたリソースとは異なるフォルダーにあるリソースへの URL のリダイレクトをテーマを使用する場合。  
  
 Web アプリケーションでページを再構築して、いる人は、古い Url をブックマークしているように使用できますページを移動した後になっていることを確認する場合は、URL リライトすると便利です。 URL の書き換えには、新しいページの場所に要求を透過的に転送することができます。  
  
 検索エンジンにとってわかりやすくし、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、「[ASP.NET Routing](http://msdn.microsoft.com/ja-jp/892441af-8f1d-483e-ab5f-b82c23576f5a)」を参照してください。  
  
   
  
## 例  
 コード例については、 <xref:System.Web.HttpContext.RewritePath%28System.String%29> メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="filePath" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web 要求の処理で使用されるメソッドを提供する <see cref="T:System.Web.HttpServerUtility" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpServerUtility" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.Server%2A> プロパティを使用するプロパティとメソッドのプログラムによるアクセス、 <xref:System.Web.HttpServerUtility> クラスです。 ASP.NET ページには、既定値への参照が含まれているため、 <xref:System.Web> 名前空間 \(を含む、 <xref:System.Web.HttpContext> クラス\) のメンバーを参照する <xref:System.Web.HttpContext> .aspx ページへの参照を完全修飾クラスを使用せずに <xref:System.Web.HttpContext>します。 たとえば、使用 `Server.CreateObject("MyCOMComponent")` 、サーバー上の COM オブジェクトのインスタンスを作成します。 ただしのメンバーを使用する場合は、 <xref:System.Web.HttpServerUtility> ASP.NET 分離コード モジュールからへの参照を含める必要があります、 <xref:System.Web> モジュールで現在アクティブな要求\/応答のコンテキストとのクラスの両方への参照を完全修飾名前空間 <xref:System.Web> を使用します。 たとえば、分離コード ページ、完全修飾名指定する必要 `HttpContext.Current.Server.CreateObject("MyCOMComponent")`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.SessionState.HttpSessionState" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.SessionState.HttpSessionState" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.Session%2A> プロパティを使用するプロパティとメソッドのプログラムによるアクセス、 <xref:System.Web.SessionState.HttpSessionState> クラスです。  
  
 セッション状態を使用するのを有効にすることができます。 セッション状態を有効にする方法については、次を参照してください。 **構成セッション状態** で [ASP.NET Session State Overview](http://msdn.microsoft.com/ja-jp/6d60d381-6521-4e1d-9089-da6464f2a9bc)します。  
  
 セッション状態の値を保存する方法については、次を参照してください。 [How to: Save Values in Session State](http://msdn.microsoft.com/ja-jp/a6cb2e3a-df49-4b12-9d9a-eed45541c165)します。 セッション状態から値を読み取る方法については、次を参照してください。 [How to: Read Values from Session State](http://msdn.microsoft.com/ja-jp/2ef449bc-5c17-4785-b7cf-378c601af8f5)します。  
  
   
  
## 例  
 次の例では、セッション状態の値を保存する方法とセッション状態から値を読み取る方法を示します。  
  
 これらの例には次の項目が必要です。  
  
-   ASP.NET アプリケーションがセッション状態が有効です。  
  
-   Web フォーム ページ クラスにアクセスできる、 <xref:System.Web.UI.Page.Session%2A?displayProperty=fullName> プロパティ、またはアクセス権を持つ任意のクラス、 <xref:System.Web.HttpContext.Current%2A?displayProperty=fullName> プロパティです。  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">必要なセッション状態の動作の種類を指定する列挙値の 1 つ。</param>
        <summary>HTTP 要求をサポートするために必要なセッション状態の動作の種類を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 HTTP 要求ハンドラーが実装することでセッション状態が必要とするかどうかを示す ASP.NET の既定の実装で、 <xref:System.Web.SessionState.IRequiresSessionState> インターフェイスまたは <xref:System.Web.SessionState.IReadOnlySessionState> インターフェイスです。<xref:System.Web.HttpContext.SetSessionStateBehavior%2A> メソッドおよび <xref:System.Web.SessionState.SessionStateBehavior> 列挙体を使用して、要求を処理するために必要なのセッション状態のサポートの種類についての詳細を指定できます。 詳細については、次を参照してください。、 <xref:System.Web.SessionState.SessionStateBehavior> 列挙します。  
  
 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> する前にメソッドを呼び出す必要があります、 <xref:System.Web.HttpApplication.AcquireRequestState> パイプライン イベントです。 このイベントの前後に発生する呼び出しによって表示、 <xref:System.InvalidOperationException> 例外です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">後にメソッドが呼び出された、 <see cref="E:System.Web.HttpApplication.AcquireRequestState" /> イベントが発生します。</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.Security.UrlAuthorizationModule" /> オブジェクトが現在の要求に対する承認チェックをスキップするかどうかを指定する値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Web.Security.UrlAuthorizationModule" /> が承認チェックをスキップする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.SkipAuthorization%2A> プロパティが匿名接続を許可するページにリダイレクトする必要がある認証モジュールによる高度な使用を意図しています。 両方の設定、フォーム認証モジュールと Passport 認証モジュール <xref:System.Web.HttpContext.SkipAuthorization%2A> 構成済みのログオン ページにリダイレクトしたときにします。 設定 <xref:System.Web.HttpContext.SkipAuthorization%2A> 必要があります、 `ControlPrincipal` フラグが設定されます。 については、 `ControlPrincipal` フラグは、「 <xref:System.Security.Permissions.SecurityPermissionFlag>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">
          <see cref="T:System.Web.HttpContext" /> サービスの型。サービス プロバイダーをこの型に設定します。</param>
        <summary>現在のサービス型のオブジェクトを返します。</summary>
        <returns>
          <see cref="T:System.Web.HttpContext" />。サービスが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、基にアクセスするために <xref:System.Web.HttpWorkerRequest> オブジェクトです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がタイムアウトしたときにこの要求に対処していたスレッド上で ASP.NET ランタイムが <see cref="M:System.Threading.Thread.Abort" /> を呼び出す必要があるかどうかを指定する値を取得または設定します。</summary>
        <value>スレッドのタイムアウト時に <see cref="M:System.Threading.Thread.Abort" /> が呼び出される場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ハンドラーおよびモジュールを使用している、 <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=fullName> 連携によるキャンセルを実装するプロパティを無効にする必要がある、 <xref:System.Threading.Thread.Abort%2A?displayProperty=fullName> 要求がタイムアウトしたときに既定では、ASP.NET が実行する動作。 このプロパティを設定 `false` のキャンセル機能とクリーンアップ ルーチンが ASP.NET によって中断されることがなく実行されるかどうかを確認できます。  
  
 このプロパティを設定する場合 `false`, 、ASP.NET は自動的にページは表示されず、「要求がタイムアウトしました」エラー タイムアウトが発生する場合。 アプリケーションは、応答の内容を適切に設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求の初期タイムスタンプを取得します。</summary>
        <value>現在の HTTP 要求のタイムスタンプ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返される、タイムスタンプ、 <xref:System.Web.HttpContext.Timestamp%2A> プロパティは、サーバーのローカル時刻であり、インスタンス化時に設定、 <xref:System.Web.HttpContext> オブジェクトです。 ローカル時刻は UTC 時刻と UTC のオフセットになります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 応答に対する <see cref="T:System.Web.TraceContext" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 応答の <see cref="T:System.Web.TraceContext" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求のセキュリティ情報を取得または設定します。</summary>
        <value>現在の HTTP 要求のセキュリティ情報。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpContext.User%2A> プロパティを使用するプロパティとメソッドのプログラムによるアクセス、 <xref:System.Security.Principal.IPrincipal> インターフェイスです。  
  
 ASP.NET ページには、既定値への参照が含まれているため、 <xref:System.Web> 名前空間 \(を含む、 <xref:System.Web.HttpContext> クラス\) のメンバーを参照する <xref:System.Web.HttpContext> .aspx ページへの参照を完全修飾クラスを使用せずに <xref:System.Web.HttpContext>します。 たとえば、使用 `User.Identity.Name` を実行して、現在のプロセスの代わりに、ユーザーの名前を取得します。 ただしのメンバーを使用する場合は、 <xref:System.Security.Principal.IPrincipal> ASP.NET 分離コード モジュールからへの参照を含める必要があります、 <xref:System.Web> モジュールで現在アクティブな要求\/応答のコンテキストとのクラスの両方への参照を完全修飾名前空間 <xref:System.Web> を使用します。 たとえば、分離コード ページ、完全修飾名指定する必要 `HttpContext.Current.User.Identity.Name`します。  
  
   
  
## 例  
 次の例では、現在のユーザーからのプロパティにアクセスする方法、 <xref:System.Web.HttpContext.User%2A> プロパティです。 これらのプロパティは、Web ページのタイトルの設定に使用されます。  
  
 アプリケーションでは、Windows 認証を使用する場合、ユーザー名には、ドメインが含まれます。 たとえば、ページのタイトルは、「ドメイン \\ ユーザー名のホーム ページ」になります。  
  
 [!code-csharp[System.Web.HttpContext.User\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバーからクライアントに <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続のために送信されたネゴシエートされたプロトコルを取得します。</summary>
        <value>ネゴシエートされたプロトコル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから要求されたプロトコルの順序付きリストを取得します。</summary>
        <value>要求されたプロトコル。<see cref="T:System.Web.WebSockets.AspNetWebSocket" /> の要求でないか、リストがない場合は、<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーション レベル リソースを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ページ レベル リソースを取得します。</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リソースの要求を、要求された URL で示されているものとは別のパスにリダイレクトします。<see cref="Overload:System.Web.HttpContext.RewritePath" /> は、Cookie を使用しないセッション状態において、URL からセッション ID を取り除くために使用されます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>