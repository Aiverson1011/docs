<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>共有リソースへの排他アクセスの待機に使用するオペレーティング システム固有のオブジェクトをカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations. For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](http://msdn.microsoft.com/ja-jp/b782bcb8-da6a-4c6a-805f-2eb46d504309).  
  
 The <xref:System.Threading.WaitHandle> class itself is abstract. Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources. The classes derived from <xref:System.Threading.WaitHandle> include:  
  
-   The <xref:System.Threading.Mutex> class. See [Mutexes](http://msdn.microsoft.com/ja-jp/9dd06e25-12c0-4a9e-855a-452dc83803e2).  
  
-   The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>. See [EventWaitHandle, AutoResetEvent, and ManualResetEvent](http://msdn.microsoft.com/ja-jp/cd94fc34-ac15-427f-b723-a1240a4fab7d).  
  
-   The <xref:System.Threading.Semaphore> class. See [Semaphores](http://msdn.microsoft.com/ja-jp/7722a333-b974-47a2-a7c0-f09097fb644e).  
  
 Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.  
  
 The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity. Event wait handles \(<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>\) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore. Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.  
  
 Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.  
  
 In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.. These include:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .  
  
 The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.  
  
> [!IMPORTANT]
>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a **languageKeyword tag is not supported!!!!**  
> \/**languageKeyword tag is not supported!!!!**  
>  block. To dispose of it indirectly, use a language construct such as **languageKeyword tag is not supported!!!!**  
>  \(in C\#\) or **languageKeyword tag is not supported!!!!**  
>  \(in Visual Basic\). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  
  
 <xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern. See [Implementing Finalize and Dispose to Clean Up Unmanaged Resources](http://msdn.microsoft.com/ja-jp/31a6c13b-d6a2-492b-9a9f-e5238c983bcb). When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle. You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.  
  
   
  
## 例  
 The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.  
  
 [!code-cpp[WaitHandle\#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle\#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.WaitHandle" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> によって保持されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method for the <xref:System.Threading.WaitHandle> class and its derived classes. It provides a standard implementation that calls the **languageKeyword tag is not supported!!!!**  
 overload with a **languageKeyword tag is not supported!!!!**  
 argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method. Call this method to release all resources held by an instance of **languageKeyword tag is not supported!!!!**  
 or a derived class.  
  
 Once this method is called, references to the current instance cause undefined behavior.  
  
> [!NOTE]
>  Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.  
  
> [!NOTE]
>  Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>派生クラスでオーバーライドされると、<see cref="T:System.Threading.WaitHandle" /> によって使用されているアンマネージ リソースを解放し、オプションでマネージ リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the **parameterReference tag is not supported!!!!**  
 parameter set to **languageKeyword tag is not supported!!!!**  
.  When the **parameterReference tag is not supported!!!!**  
 parameter is **languageKeyword tag is not supported!!!!**  
, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.  
  
 The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects. When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネイティブ オペレーティング システム ハンドルを取得または設定します。</summary>
        <value>ネイティブ オペレーティング システム ハンドルを表す <see langword="IntPtr" />。 既定値は <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> フィールドの値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しい値を割り当てる、 <xref:System.Threading.WaitHandle.Handle%2A> プロパティは、前のハンドルを終了しません。 これにより、リークしているハンドル。  
  
 .NET framework version 2.0 以降、このプロパティを使用しません使用して、 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティ代わりにします。 このプロパティの設定を有効なハンドルにもセット、 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティに設定すると <xref:System.Threading.WaitHandle.InvalidHandle> リークしたハンドルで発生することができます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller to set the property value. This member cannot be set by partially trusted or transparent code.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無効なネイティブ オペレーティング システム ハンドルを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 初期化するために内部的に使用される、 <xref:System.Threading.WaitHandle.Handle%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネイティブ オペレーティング システム ハンドルを取得または設定します。</summary>
        <value>ネイティブ オペレーティング システム ハンドルを表す <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しい値を代入すると、 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティには、時に、前のハンドルを閉じるは前の <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> オブジェクトを収集します。 手動でハンドルを終了しないで、この結果であるため、 <xref:System.ObjectDisposedException> ときに、 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> ハンドルを終了しようとしています。  
  
 <xref:System.Threading.WaitHandle> 実装して、 <xref:System.IDisposable.Dispose%2A> パターンです。 「[Implementing Finalize and Dispose to Clean Up Unmanaged Resources](http://msdn.microsoft.com/ja-jp/31a6c13b-d6a2-492b-9a9f-e5238c983bcb)」を参照してください。 派生するときに <xref:System.Threading.WaitHandle>, を使用して、 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> のネイティブ ハンドルのオペレーティング システム ハンドルを格納するプロパティです。 保護されたオーバーライドする必要はありません <xref:System.Threading.WaitHandle.Dispose%2A> メソッドその他のアンマネージ リソースを使用していない場合。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</permission>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</summary>
        <returns>通知と待機の両方が正常に完了した場合は <see langword="true" />。待機が完了しない場合、メソッドから制御は戻りません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この操作はアトミックであるは保証されません。 現在のスレッド信号後 `toSignal` 待機している前に、 `toWaitOn`, 、別のプロセッサで実行されているスレッドを通知 `toWaitOn` になるか。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> メソッドのオーバー ロードは、メイン スレッドをブロックされたスレッドを通知し、スレッドがタスクを完了するまで待機できるようにします。  
  
 例では、5 つのスレッドを開始、ブロックすることができます、 <xref:System.Threading.EventWaitHandle> で作成された、 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> フラグ、および、ユーザーが ENTER キーを押したし、リリースの 1 つのスレッドにします。 例は、5 つの別のスレッド キューに配置し、すべてを使用して、解放、 <xref:System.Threading.EventWaitHandle> で作成された、 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> フラグ。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="toWaitOn" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">あるスレッドでメソッドが呼び出された <see cref="T:System.STAThreadAttribute" />です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 98 または Windows Millennium Edition ではサポートされません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> セマフォは、フル カウントされています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="millisecondsTimeout">待機する間隔を表す整数。 この値が <see cref="F:System.Threading.Timeout.Infinite" />、つまり \-1 の場合、待機は無期限となります。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し \(同期されたコンテキスト内にいる場合\)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として 32 ビット符号付き整数を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</summary>
        <returns>通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この操作はアトミックであるは保証されません。 現在のスレッド信号後 `toSignal` 待機している前に、 `toWaitOn`, 、別のプロセッサで実行されているスレッドを通知 `toWaitOn` になるか。  
  
 場合 `millisecondsTimeout` 0 の場合は、このメソッドはブロックされません。 状態をテストして、 `toWaitOn` 制御を戻しません。  
  
## コンテキストの終了時の注意  
 `exitContext` パラメーターも何も起こりませんしない限り、 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 既定以外の管理コンテキスト内から呼び出されます。 これが起こる場合、スレッドがから派生したクラスのインスタンスへの呼び出し <xref:System.ContextBoundObject>します。 派生していないクラスのメソッドを実行する現在場合でも <xref:System.ContextBoundObject>, と同様に <xref:System.String>, 、既定以外のコンテキストでサービスできる場合、 <xref:System.ContextBoundObject> が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する `true` の `exitContext` が原因で、既定以外の管理コンテキストを終了するスレッド \(は、既定のコンテキストへの移行に\) 実行する前に、 <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、 <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 この場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、 <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドを指定して `true` の `exitContext`, 、スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、 <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドが待機する必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="toWaitOn" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">メソッドは、スレッドを持つ <see cref="T:System.STAThreadAttribute" />です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 98 または Windows Millennium Edition ではサポートされません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.WaitHandle" /> その最大数を超過するために通知することはできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="timeout">待機間隔を表す <see cref="T:System.TimeSpan" />。 この値が \-1 の場合、待機は無期限となります。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し \(同期されたコンテキスト内にいる場合\)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として <see cref="T:System.TimeSpan" /> を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</summary>
        <returns>通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この操作はアトミックであるは保証されません。 現在のスレッド信号後 `toSignal` 待機している前に、 `toWaitOn`, 、別のプロセッサで実行されているスレッドを通知 `toWaitOn` になるか。  
  
 最大値 `timeout` は <xref:System.Int32.MaxValue?displayProperty=fullName>です。  
  
 場合 `timeout` 0 の場合は、このメソッドはブロックされません。 状態をテストして、 `toWaitOn` 制御を戻しません。  
  
## コンテキストの終了時の注意  
 `exitContext` パラメーターも何も起こりませんしない限り、 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 既定以外の管理コンテキスト内から呼び出されます。 これが起こる場合、スレッドがから派生したクラスのインスタンスへの呼び出し <xref:System.ContextBoundObject>します。 派生していないクラスのメソッドを実行する現在場合でも <xref:System.ContextBoundObject>, と同様に <xref:System.String>, 、既定以外のコンテキストでサービスできる場合、 <xref:System.ContextBoundObject> が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する `true` の `exitContext` が原因で、既定以外の管理コンテキストを終了するスレッド \(は、既定のコンテキストへの移行に\) 実行する前に、 <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、 <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 この場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、 <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドを指定して `true` の `exitContext`, 、スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、 <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドが待機する必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="toWaitOn" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">あるスレッドでメソッドが呼び出された <see cref="T:System.STAThreadAttribute" />です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 98 または Windows Millennium Edition ではサポートされません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> セマフォは、フル カウントされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> \-1 以外のミリ秒数が負の値に評価されます。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns>
          <paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />。それ以外の場合は、待機を続けます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system\-wide mutex, it might indicate that an application has been terminated abruptly \(for example, by using Windows Task Manager\). The exception contains information useful for debugging.  
  
 The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  
  
 Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying \-1 \(or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>\) for **parameterReference tag is not supported!!!!**  
and **languageKeyword tag is not supported!!!!**  
 for **parameterReference tag is not supported!!!!**  
.  
  
   
  
## 例  
 The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">  
<para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154)では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。  
  
</para>  
</block>  
  
 <paramref name="waitHandles" /> 配列は重複する要素を含んでいます。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
 または  
  
 <see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照 \(重複\) を含めることはできません。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <summary>
          <see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns>
          <paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If **parameterReference tag is not supported!!!!**  
 is zero, the method does not block. It tests the state of the wait handles and returns immediately.  
  
 The [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time\-out occurs. On some implementations, if more than 64 handles are passed, a [WaitAll メソッド \(WaitHandle\<xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a [WaitAll メソッド \(WaitHandle\<xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  The [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have [WaitAll メソッド \(WaitHandle\<xref:System.STAThreadAttribute>.  
  
 Calling this method overload is the same as calling the [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying **languageKeyword tag is not supported!!!!**  
 for **parameterReference tag is not supported!!!!**  
.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">  
<para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154)では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。  
  
</para>  
</block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
 または  
  
 <see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、\-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>
          <see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns>
          <paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If **parameterReference tag is not supported!!!!**  
 is zero, the method does not block. It tests the state of the wait handles and returns immediately.  
  
 The [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time\-out occurs. On some implementations, if more than 64 handles are passed, a [WaitAll メソッド \(WaitHandle\<xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.  
  
> [!NOTE]
>  The [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have [WaitAll メソッド \(WaitHandle\<xref:System.STAThreadAttribute>.  
  
 The maximum value for **parameterReference tag is not supported!!!!**  
 is [WaitAll メソッド \(WaitHandle\<xref:System.Int32.MaxValue?displayProperty=fullName>.  
  
 Calling this method overload is the same as calling the [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying **languageKeyword tag is not supported!!!!**  
 for **parameterReference tag is not supported!!!!**  
.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">  
<para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154)では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。  
  
</para>  
</block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
 または  
  
 <see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す \-1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照 \(重複\) を含めることはできません。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し \(同期されたコンテキスト内にいる場合\)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>
          <paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `millisecondsTimeout` 0 の場合は、このメソッドはブロックされません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドが返す `true` ミュー テックスが破棄されます。 ミュー テックスの破棄は、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックス可能性があります \(たとえば、Windows タスク マネージャーを使用して\) をアプリケーションが突然終了されたことを示します。 この例外には、デバッグに役立つ情報が含まれています。  
  
 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> 、待機が終了する、つまりすべてのハンドルがシグナル状態になるとき、またはタイムアウトが発生したときにこのメソッドを返します。 一部の実装では、64 を超えるハンドルが渡された場合に、 [WaitAll メソッド \(WaitHandle\<xref:System.NotSupportedException> がスローされます。 配列内で重複がある場合、呼び出しは、 [WaitAll メソッド \(WaitHandle\<xref:System.DuplicateWaitObjectException>です。  
  
> [!NOTE]
>  [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> を持つスレッドでメソッドがサポートされていません [WaitAll メソッド \(WaitHandle\<xref:System.STAThreadAttribute>します。  
  
## コンテキストの終了時の注意  
 `exitContext` パラメーターも何も起こりませんしない限り、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> 既定以外の管理コンテキスト内から呼び出されます。 これが起こる場合、スレッドがから派生したクラスのインスタンスへの呼び出し [WaitAll メソッド \(WaitHandle\<xref:System.ContextBoundObject>します。 派生していないクラスのメソッドを実行する現在場合でも [WaitAll メソッド \(WaitHandle\<xref:System.ContextBoundObject>, と同様に [WaitAll メソッド \(WaitHandle\<xref:System.String>, 、既定以外のコンテキストでサービスできる場合、 [WaitAll メソッド \(WaitHandle\<xref:System.ContextBoundObject> が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する `true` の `exitContext` が原因で、既定以外の管理コンテキストを終了するスレッド \(は、既定のコンテキストへの移行に\) 実行する前に、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには、 [WaitAll メソッド \(WaitHandle\<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 属性です。 この場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを指定して `true` の `exitContext`, 、スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドが待機する必要があります。  
  
   
  
## 例  
 次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループへの書き込みをする方法を示します。 個々 の書き込み操作は、作業項目および信号としてキューに登録が完了するとします。 メイン スレッドは、すべての項目からの通知を待機しして終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 1 つ以上のオブジェクトの <paramref name="waitHandles" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="waitHandles" /> 要素を持たない配列は、.NET Framework のバージョンが 2.0 以降。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles" /> 配列に重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException">オブジェクトの数 <paramref name="waitHandles" /> が超える場合、システムで許可されています。  
  
 または  
  
 <see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッドのプロシージャに適用し、 <paramref name="waitHandles" /> 複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> 要素を持たない配列は、.NET Framework のバージョンは 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> の透過的なプロキシが配列に含まれる、 <see cref="T:System.Threading.WaitHandle" /> 別のアプリケーション ドメイン。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、\-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し \(同期されたコンテキスト内にいる場合\)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>
          <paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `timeout` 0 の場合は、このメソッドはブロックされません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドが返す `true` ミュー テックスが破棄されます。 ミュー テックスの破棄は、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックス可能性があります \(たとえば、Windows タスク マネージャーを使用して\) をアプリケーションが突然終了されたことを示します。 この例外には、デバッグに役立つ情報が含まれています。  
  
 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> 、待機が終了すると、すべてのハンドルがシグナル状態になることを意味するか、タイムアウトが発生したときに、メソッドが返されます。 一部の実装では、64 を超えるハンドルが渡された場合に、 [WaitAll メソッド \(WaitHandle\<xref:System.NotSupportedException> がスローされます。 配列に重複が含まれている場合、呼び出しは失敗します。  
  
> [!NOTE]
>  [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> を持つスレッドでメソッドがサポートされていません [WaitAll メソッド \(WaitHandle\<xref:System.STAThreadAttribute>します。  
  
 最大値 `timeout` は [WaitAll メソッド \(WaitHandle\<xref:System.Int32.MaxValue?displayProperty=fullName>です。  
  
## コンテキストの終了時の注意  
 `exitContext` パラメーターも何も起こりませんしない限り、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> 既定以外の管理コンテキスト内から呼び出されます。 これが起こる場合、スレッドがから派生したクラスのインスタンスへの呼び出し [WaitAll メソッド \(WaitHandle\<xref:System.ContextBoundObject>します。 派生していないクラスのメソッドを実行する現在場合でも [WaitAll メソッド \(WaitHandle\<xref:System.ContextBoundObject>, と同様に [WaitAll メソッド \(WaitHandle\<xref:System.String>, 、既定以外のコンテキストでサービスできる場合、 [WaitAll メソッド \(WaitHandle\<xref:System.ContextBoundObject> が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する `true` の `exitContext` が原因で、既定以外の管理コンテキストを終了するスレッド \(は、既定のコンテキストへの移行に\) 実行する前に、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドです。 呼び出しの後に元の既定以外のコンテキストを返します、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには [WaitAll メソッド \(WaitHandle\<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 この場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを指定して `true` の `exitContext`, 、スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、 [WaitAll メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドが待機する必要があります。  
  
   
  
## 例  
 次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループへの書き込みをする方法を示します。 個々 の書き込み操作は、作業項目および信号としてキューに登録が完了するとします。 メイン スレッドは、すべての項目からの通知を待機しして終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 1 つ以上のオブジェクトの <paramref name="waitHandles" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="waitHandles" /> 要素を持たない配列は、.NET Framework のバージョンが 2.0 以降。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles" /> 配列に重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException">オブジェクトの数 <paramref name="waitHandles" /> が超える場合、システムで許可されています。  
  
 または  
  
 <see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッドのプロシージャに適用し、 <paramref name="waitHandles" /> 複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> 要素を持たない配列は、.NET Framework のバージョンは 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す \-1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、待機が終了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> の透過的なプロキシが配列に含まれる、 <see cref="T:System.Threading.WaitHandle" /> 別のアプリケーション ドメイン。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行するオブジェクトの配列インデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、 <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが返す `true` ミュー テックスを破棄するために、待機が終了した場合。 ミュー テックスの破棄は、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックス可能性があります \(たとえば、Windows タスク マネージャーを使用して\) をアプリケーションが突然終了されたことを示します。 この例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドでのスロー、 <xref:System.Threading.AbandonedMutexException> ミュー テックスの破棄のため、待機が完了したときにのみです。 場合 `waitHandles` 放棄されたミュー テックスよりも小さいインデックス数字がリリースされたミュー テックスを含む、 <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが正常に完了して、例外はスローされません。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 では、スレッドが終了するか明示的に解放することがなくを中止する場合よりも前のバージョンで、 <xref:System.Threading.Mutex>, 、および `Mutex` で 0 \(ゼロ\) のインデックス位置にある、 `WaitAny` 別のスレッドによって返されるインデックスで配列 `WaitAny` 0 ではなく 128 です。  
  
 このメソッドは、いずれかのハンドルがシグナルを受け取るを返します。 呼び出し時に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。 複数 64 ハンドルが渡される場合、一部の実装で、 <xref:System.NotSupportedException> がスローされます。  
  
 このメソッドのオーバー ロードを呼び出すことは、呼び出すことと同じ、 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> メソッドのオーバー ロードは、\-1 を指定する \(または <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>\) の `millisecondsTimeout`と `true` の `exitContext`です。  
  
   
  
## 例  
 呼び出しを次のコード例に示します、 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドです。  
  
 [!code-cpp[WaitHandle\#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle\#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 1 つ以上のオブジェクトの <paramref name="waitHandles" /> 配列が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">オブジェクトの数 <paramref name="waitHandles" /> が超える場合、システムで許可されています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> 要素を持たない配列は、.NET Framework のバージョンは 1.0 または 1.1 です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> 要素を持たない配列は、.NET Framework のバージョンが 2.0 以降。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> の透過的なプロキシが配列に含まれる、 <see cref="T:System.Threading.WaitHandle" /> 別のアプリケーション ドメイン。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <summary>32 ビット符号付き整数を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `millisecondsTimeout` 0 の場合は、このメソッドはブロックされません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドでのスロー、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.AbandonedMutexException> ミュー テックスの破棄のため、待機が完了したときにのみです。 場合 `waitHandles` 放棄されたミュー テックスよりも小さいインデックス数字がリリースされたミュー テックスを含む、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが正常に完了して、例外はスローされません。  
  
 このメソッドは、ハンドルがシグナル状態になるとき、またはタイムアウトが発生したときに、待機が終了するときに返します。 呼び出し時に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。 複数 64 ハンドルが渡される場合、一部の実装で、 [WaitAny メソッド \(WaitHandle\<xref:System.NotSupportedException> がスローされます。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出して、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> オーバー ロードを指定して `false` の `exitContext`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 1 つ以上のオブジェクトの <paramref name="waitHandles" /> 配列が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">オブジェクトの数 <paramref name="waitHandles" /> が超える場合、システムで許可されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> 要素を持たない配列です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> の透過的なプロキシが配列に含まれる、 <see cref="T:System.Threading.WaitHandle" /> 別のアプリケーション ドメイン。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、\-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>
          <see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `timeout` 0 の場合は、このメソッドはブロックされません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドでのスロー、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.AbandonedMutexException> ミュー テックスの破棄のため、待機が完了したときにのみです。 場合 `waitHandles` 放棄されたミュー テックスよりも小さいインデックス数字がリリースされたミュー テックスを含む、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが正常に完了して、例外はスローされません。  
  
 このメソッドは、ハンドルがシグナル状態になるとき、またはタイムアウトが発生するときに、待機が終了するときに返します。 呼び出し時に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。 複数 64 ハンドルが渡される場合、一部の実装で、 [WaitAny メソッド \(WaitHandle\<xref:System.NotSupportedException> がスローされます。  
  
 最大値 `timeout` は [WaitAny メソッド \(WaitHandle\<xref:System.Int32.MaxValue?displayProperty=fullName>です。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出して、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> オーバー ロードを指定して `false` の `exitContext`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 1 つ以上のオブジェクトの <paramref name="waitHandles" /> 配列が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">オブジェクトの数 <paramref name="waitHandles" /> が超える場合、システムで許可されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す \-1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> 要素を持たない配列です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> の透過的なプロキシが配列に含まれる、 <see cref="T:System.Threading.WaitHandle" /> 別のアプリケーション ドメイン。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し \(同期されたコンテキスト内にいる場合\)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>32 ビットの符号付き整数を使用して時間間隔を指定し、待機する前に同期ドメインを終了するかどうかを指定して、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `millisecondsTimeout` 0 の場合は、このメソッドはブロックされません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが返す `true` ミュー テックスを破棄するために、待機が終了した場合。 ミュー テックスの破棄は、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックス可能性があります \(たとえば、Windows タスク マネージャーを使用して\) をアプリケーションが突然終了されたことを示します。 この例外には、デバッグに役立つ情報が含まれています。  
  
 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドでのスロー、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.AbandonedMutexException> ミュー テックスの破棄のため、待機が完了したときにのみです。 場合 `waitHandles` 放棄されたミュー テックスよりも小さいインデックス数字がリリースされたミュー テックスを含む、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが正常に完了して、例外はスローされません。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 では、スレッドが終了するか明示的に解放することがなくを中止する場合よりも前のバージョンで、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.Mutex>, 、および `Mutex` で 0 \(ゼロ\) のインデックス位置にある、 `WaitAny` 別のスレッドによって返されるインデックスで配列 `WaitAny` 0 ではなく 128 です。  
  
 このメソッドは、ハンドルがシグナル状態になるとき、またはタイムアウトが発生したときに、待機が終了するときに返します。 呼び出し時に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。 複数 64 ハンドルが渡される場合、一部の実装で、 [WaitAny メソッド \(WaitHandle\<xref:System.NotSupportedException> がスローされます。  
  
## コンテキストの終了時の注意  
 `exitContext` パラメーターも何も起こりませんしない限り、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> 既定以外の管理コンテキスト内から呼び出されます。 これが起こる場合、スレッドがから派生したクラスのインスタンスへの呼び出し [WaitAny メソッド \(WaitHandle\<xref:System.ContextBoundObject>します。 派生していないクラスのメソッドを実行する現在場合でも [WaitAny メソッド \(WaitHandle\<xref:System.ContextBoundObject>, と同様に [WaitAny メソッド \(WaitHandle\<xref:System.String>, 、既定以外のコンテキストでサービスできる場合、 [WaitAny メソッド \(WaitHandle\<xref:System.ContextBoundObject> が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する `true` の `exitContext` が原因で、既定以外の管理コンテキストを終了するスレッド \(は、既定のコンテキストへの移行に\) 実行する前に、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには [WaitAny メソッド \(WaitHandle\<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 この場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドを指定して `true` の `exitContext`, 、スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドが待機する必要があります。  
  
   
  
## 例  
 次のコード例では、スレッド プールを使用して、同時に複数のディスク上のファイルを検索する方法を示します。 領域の構成については、各ディスクのルート ディレクトリだけが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 1 つ以上のオブジェクトの <paramref name="waitHandles" /> 配列が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">オブジェクトの数 <paramref name="waitHandles" /> が超える場合、システムで許可されています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> 要素を持たない配列は、.NET Framework のバージョンは 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> 要素を持たない配列は、.NET Framework のバージョンが 2.0 以降。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> の透過的なプロキシが配列に含まれる、 <see cref="T:System.Threading.WaitHandle" /> 別のアプリケーション ドメイン。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、\-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し \(同期されたコンテキスト内にいる場合\)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合`timeout`が 0 の場合、メソッドをブロックしません。 これにより、待機ハンドルの状態をテストされ、すぐに返されます。  
  
 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、[WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスを破棄するために、待機が終了した場合。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります \(たとえば、Windows タスク マネージャーを使用\) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、[WaitAny メソッド \(WaitHandle\<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、[WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 では、スレッドが終了したり、明示的に解放せず中止したりする場合よりも前のバージョンで、 [WaitAny メソッド \(WaitHandle\<xref:System.Threading.Mutex>、および`Mutex`で 0 \(ゼロ\) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`0 ではなく 128 です。  
  
 このメソッドは、待機が終了すると、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに返します。 1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。 一部の実装では、64 のハンドルが渡される、複数の場合で、[WaitAny メソッド \(WaitHandle\<xref:System.NotSupportedException>がスローされます。  
  
 最大値`timeout`は[WaitAny メソッド \(WaitHandle\<xref:System.Int32.MaxValue?displayProperty=fullName>します。  
  
## コンテキストの終了時の注意  
 `exitContext`パラメーター影響を及ぼしませんしない限り、[WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。 派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生[WaitAny メソッド \(WaitHandle\<xref:System.ContextBoundObject>です。 派生していないクラスのメソッドを実行されている場合でも[WaitAny メソッド \(WaitHandle\<xref:System.ContextBoundObject>と同様、 [WaitAny メソッド \(WaitHandle\<xref:System.String>、既定以外のコンテキストであることができる場合、[WaitAny メソッド \(WaitHandle\<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド \(つまり、既定のコンテキストに遷移する\) 実行する前に、[WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、[WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが完了しました。  
  
 これを利用する場合、コンテキスト バインド クラス[WaitAny メソッド \(WaitHandle\<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、[WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、[WaitAny メソッド \(WaitHandle\<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。  
  
   
  
## 例  
 次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。 容量に関する考慮事項については、各ディスクのルート ディレクトリだけが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" />要素を持たない配列であり、.NET Framework のバージョンは 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す \-1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" />要素を持たない配列であり、.NET Framework のバージョンが 2.0 以降。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</summary>
        <returns>現在のインスタンスがシグナルを受け取った場合は <see langword="true" />。 現在のインスタンスがシグナルを受け取らない場合は、<see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> はシグナルを受け取るまで待機を続けます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドが返す `true` ミュー テックスが破棄されます。 ミュー テックスの破棄は、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックス可能性があります \(たとえば、Windows タスク マネージャーを使用して\) をアプリケーションが突然終了されたことを示します。 この例外には、デバッグに役立つ情報が含まれています。  
  
 このメソッドは、現在のインスタンスまで、無期限にブロックの呼び出し元がシグナルを受信します。 このメソッドを使用するまでブロック、 <xref:System.Threading.WaitHandle> 別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるようです。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 呼び出すことと同じではこのメソッドのオーバー ロードを呼び出して、 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> メソッドのオーバー ロードは、\-1 を指定するまたは <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> 、最初のパラメーターと `false` 2 つ目のパラメーターです。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
   
  
## 例  
 次のコード例では、待機ハンドルを使用して、実行が終了するバック グラウンド スレッドを待機している間に終了してから、プロセスの状態を保持する方法を示します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">現在のインスタンスが透過的なプロキシを <see cref="T:System.Threading.WaitHandle" /> 別のアプリケーション ドメイン。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <summary>32 ビット符号付き整数を使用して時間間隔をミリ秒単位で指定し、現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで、現在のスレッドをブロックします。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `millisecondsTimeout` 0 の場合は、このメソッドはブロックされません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元が発生します。 このメソッドを使用するまでブロック、 <xref:System.Threading.WaitHandle> 別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるようです。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出して、 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> オーバー ロードを指定して `false` の `exitContext`です。  
  
   
  
## 例  
 次のコード例では、待機ハンドルを使用して、実行が終了するバック グラウンド スレッドを待機している間に終了してから、プロセスの状態を保持する方法を示します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">現在のインスタンスが透過的なプロキシを <see cref="T:System.Threading.WaitHandle" /> 別のアプリケーション ドメイン。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、\-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>
          <see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `timeout` 0 の場合は、このメソッドはブロックされません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元が発生します。 このメソッドを使用するまでブロック、 <xref:System.Threading.WaitHandle> 別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるようです。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 最大値 `timeout` は <xref:System.Int32.MaxValue?displayProperty=fullName>です。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出して、 <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> オーバー ロードを指定して `false` の `exitContext`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す \-1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">現在のインスタンスが透過的なプロキシを <see cref="T:System.Threading.WaitHandle" /> 別のアプリケーション ドメイン。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し \(同期されたコンテキスト内にいる場合\)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで現在のスレッドをブロックします。時間間隔を指定するために 32 ビット符号付き整数を使用し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 <xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります \(たとえば、Windows タスク マネージャーを使用\) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 このメソッドはブロック、現在のインスタンス シグナルを受け取るか、タイムアウトまでの呼び出し元が発生します。 このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
## コンテキストの終了時の注意  
 `exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。 派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。 派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストで、コードの実行時に指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド \(つまり、既定のコンテキストに遷移する\) 実行する前に、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが完了しました。  
  
 これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドが待機する必要があります。  
  
   
  
## 例  
 例を次にどのように<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、同期ドメイン内で呼び出された場合に動作します。 最初に、スレッドが待機する`exitContext`'éý'`false`し、待機のタイムアウト時間が経過するまでブロックします。 最初のスレッドが終了しで待機した後、2 番目のスレッドが実行される`exitContext`'éý'`true`です。 この 2 番目のスレッドの待機ハンドルの通知への呼び出しがブロックされていないと、印刷待ちタイムアウトする前に、スレッドが完了するとします。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">現在のインスタンスが透過的なプロキシを<see cref="T:System.Threading.WaitHandle" />別のアプリケーション ドメインでします。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、\-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し \(同期されたコンテキスト内にいる場合\)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `timeout` 0 の場合は、このメソッドはブロックされません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドが返す `true` ミュー テックスが破棄されます。 ミュー テックスの破棄は、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックス可能性があります \(たとえば、Windows タスク マネージャーを使用して\) をアプリケーションが突然終了されたことを示します。 この例外には、デバッグに役立つ情報が含まれています。  
  
 現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元が発生します。 このメソッドを使用するまでブロック、 <xref:System.Threading.WaitHandle> 別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるようです。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 最大値 `timeout` は <xref:System.Int32.MaxValue?displayProperty=fullName>です。  
  
## コンテキストの終了時の注意  
 `exitContext` パラメーターも何も起こりませんしない限り、 <xref:System.Threading.WaitHandle.WaitOne%2A> 既定以外の管理コンテキスト内から呼び出されます。 これが起こる場合、スレッドがから派生したクラスのインスタンスへの呼び出し <xref:System.ContextBoundObject>します。 派生していないクラスのメソッドを実行する現在場合でも <xref:System.ContextBoundObject>, と同様に <xref:System.String>, 、既定以外のコンテキストでサービスできる場合、 <xref:System.ContextBoundObject> が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する `true` の `exitContext` が原因で、既定以外の管理コンテキストを終了するスレッド \(は、既定のコンテキストへの移行に\) 実行する前に、 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 この場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを指定して `true` の `exitContext`, 、スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドが待機する必要があります。  
  
   
  
## 例  
 次のコード例では、待機ハンドルを使用して、実行が終了するバック グラウンド スレッドを待機している間に終了してから、プロセスの状態を保持する方法を示します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す \-1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">ミュー テックスを解放しないままスレッドが終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">現在のインスタンスが透過的なプロキシを <see cref="T:System.Threading.WaitHandle" /> 別のアプリケーション ドメイン。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>待機ハンドルがシグナル状態になる前に <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作がタイムアウトになったことを示します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このフィールドは、の戻り値のいずれかの `WaitAny`です。  
  
   
  
## 例  
 次のコード例では、スレッド プールを使用して、同時に複数のディスク上のファイルを検索する方法を示します。 領域の構成については、各ディスクのルート ディレクトリだけが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>