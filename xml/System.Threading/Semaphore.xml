<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>リソースまたはリソースのプールに同時にアクセスできるスレッドの数を制限します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources. Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.  
  
 The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore. When the count is zero, subsequent requests block until other threads release the semaphore. When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.  
  
 There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.  
  
 A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly. To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.  
  
 The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>. It is the programmer's responsibility to ensure that threads do not release the semaphore too many times. For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore. If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed. The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.  
  
 Semaphores are of two types: local semaphores and named system semaphores. If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating\-system semaphore of that name. Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.  
  
 A local semaphore exists only within your process. It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object. Each <xref:System.Threading.Semaphore> object is a separate local semaphore.  
  
   
  
## 例  
 The following code example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore. Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.  
  
 [!code-cpp[System.Threading.Semaphore2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">同時に許可されるセマフォの要求の初期数。</param>
        <param name="maximumCount">同時に許可されるセマフォの要求の最大数。</param>
        <summary>エントリ数の初期値と同時実行エントリの最大数を指定して、<see cref="T:System.Threading.Semaphore" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターでは、名前のないセマフォを初期化します。 このようなセマフォのインスタンスを使用するすべてのスレッドには、インスタンスへの参照が必要です。  
  
 場合 `initialCount` がより小さい `maximumCount`, 、現在のスレッドが呼び出した場合と同じ効果が <xref:System.Threading.WaitHandle.WaitOne%2A> \(`maximumCount` マイナス `initialCount`\) 回です。 セマフォを作成するスレッドのエントリを予約したくない場合は、同じ番号を使用して `maximumCount` と `initialCount`です。  
  
   
  
## 例  
 次の例では、3 つの最大数で初期のカウントが 0、セマフォを作成します。 例では、セマフォの待機をブロックする 5 つのスレッドを開始します。 メイン スレッドを使用して、 <xref:System.Threading.Semaphore.Release%28System.Int32%29> をその最大文字数は 3 つのスレッドがセマフォに入るための許可にセマフォのカウントを増やすには、メソッドのオーバー ロードします。 各スレッドを使用して、 <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> メソッドが、作業し、呼び出しをシミュレートするために、1 秒間待機する、 <xref:System.Threading.Semaphore.Release> メソッドのオーバー ロードは、セマフォを解放します。 セマフォが解放されるたびに、前のセマフォのカウントが表示されます。 コンソール メッセージ追跡セマフォを使用します。 シミュレートされた動作の間隔は、出力を読みやすくするために、スレッドごとに少し増加します。  
  
 [!code-cpp[System.Threading.Semaphore2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> が <paramref name="maximumCount" /> より大きくなっています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> 1 より小さいです。  
  
 または  
  
 <paramref name="initialCount" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">同時に許可されるセマフォの要求の初期数。</param>
        <param name="maximumCount">同時に許可されるセマフォの要求の最大数。</param>
        <param name="name">名前付きシステム セマフォ オブジェクトの名前。</param>
        <summary>エントリ数の初期値と同時実行エントリの最大数を指定し、オプションでシステム セマフォ オブジェクトの名前を指定して、<see cref="T:System.Threading.Semaphore" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクター、 <xref:System.Threading.Semaphore> 名前付きシステム セマフォを表すオブジェクト。 複数作成 <xref:System.Threading.Semaphore> 名前付きシステム セマフォの同じを表すオブジェクト。  
  
 名前付きシステム セマフォが存在しない場合は、最初の数で指定された最大数と作成 `initialCount` と `maximumCount`です。 名前付きシステム セマフォが既に存在する場合 `initialCount` と `maximumCount` を使用しないが、無効な値では例外が発生します。 使用して、かどうか、名前付きシステム セマフォが作成を決定する必要がある場合、 <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> コンス トラクター オーバー ロードの代わりにします。  
  
> [!IMPORTANT]
>  同じ番号を指定する方法を推奨は、このコンス トラクターのオーバー ロードを使用して、 `initialCount` と `maximumCount`です。 場合 `initialCount` がより小さい `maximumCount`, 、名前付きシステム セマフォが作成された場合は、現在のスレッドが呼び出した場合と同じ効果が <xref:System.Threading.WaitHandle.WaitOne%2A> \(`maximumCount` マイナス `initialCount`\) 回です。 ただし、このコンス トラクターのオーバー ロードではありません、名前付きシステム セマフォが作成されたかどうかを確認する方法です。  
  
 指定した場合 `null` または空の文字列の `name`, が呼び出した場合と、ローカル セマフォが作成された、 <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> コンス トラクター オーバー ロードします。  
  
 名前付きセマフォは、オペレーティング システム全体から参照可能であるために、プロセス境界をまたがってリソースの使用を調整に使用できます。  
  
 名前付きシステム セマフォが存在するかどうかを確認、使用するかどうか、 <xref:System.Threading.Semaphore.OpenExisting%2A> メソッドです。<xref:System.Threading.Semaphore.OpenExisting%2A> メソッドは、既存の名前付きセマフォを開こうとすると、システム セマフォが存在しない場合は、例外をスローします。  
  
   
  
## 例  
 次のコード例では、名前付きセマフォのプロセス間の動作を示します。 例では、5 つの最大数で初期カウントが 5 つの名前付きセマフォを作成します。 プログラムは、次の 3 つの呼び出し、 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドです。 このため、2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーが 3 番目の呼び出しでブロックは <xref:System.Threading.WaitHandle.WaitOne%2A>です。 2 番目のブロックを解除するプログラムの最初のコピーの 1 つまたは複数のエントリを解放します。  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> が <paramref name="maximumCount" /> より大きくなっています。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> 1 より小さいです。  
  
 または  
  
 <paramref name="initialCount" /> が 0 未満です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">ユーザーがいないと、名前付きセマフォが存在し、アクセス制御セキュリティを <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />します。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">同じ名前、名前付きセマフォを作成できません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for calling unmanaged code to create a named system semaphore. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, bool createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">同時に満たされるセマフォの要求の初期数。</param>
        <param name="maximumCount">同時に満たされるセマフォの要求の最大数。</param>
        <param name="name">名前付きシステム セマフォ オブジェクトの名前。</param>
        <param name="createdNew">このメソッドから制御が戻るときに、ローカル セマフォが作成された場合 \(<c>name</c> が <see langword="null" /> または空の文字列の場合\)、または指定した名前付きシステム セマフォが作成された場合は <see langword="true" /> が格納されます。指定した名前付きシステム セマフォが既に存在する場合は <see langword="false" /> が格納されます。 このパラメーターは初期化せずに渡されます。</param>
        <summary>エントリ数の初期値と同時実行エントリの最大数を指定し、オプションでシステム セマフォ オブジェクトの名前を指定し、新しいシステム セマフォが作成されたかどうかを示す値を受け取る変数を指定して、<see cref="T:System.Threading.Semaphore" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.  
  
 If the named system semaphore does not exist, it is created with the initial count and maximum count specified by **parameterReference tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
. If the named system semaphore already exists, **parameterReference tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
 are not used, although invalid values still cause exceptions. Use **parameterReference tag is not supported!!!!**  
 to determine whether the system semaphore was created.  
  
 If **parameterReference tag is not supported!!!!**  
 is less than **parameterReference tag is not supported!!!!**  
, and **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> \(**parameterReference tag is not supported!!!!**  
 minus **parameterReference tag is not supported!!!!**  
\) times.  
  
 If you specify **languageKeyword tag is not supported!!!!**  
 or an empty string for **parameterReference tag is not supported!!!!**  
, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload. In this case, **parameterReference tag is not supported!!!!**  
 is always **languageKeyword tag is not supported!!!!**  
.  
  
 Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.  
  
   
  
## 例  
 The following code example demonstrates the cross\-process behavior of a named semaphore. The example creates a named semaphore with a maximum count of five and an initial count of two. That is, it reserves three entries for the thread that calls the constructor. If **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method. Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>. Release one or more entries in the first copy of the program to unblock the second.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> が <paramref name="maximumCount" /> より大きくなっています。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> が 1 未満です。  
  
 または  
  
 <paramref name="initialCount" /> が 0 未満です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きセマフォが存在し、それにアクセス制御セキュリティがあり、ユーザーに <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きセマフォを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for calling unmanaged code to create a named system semaphore. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, bool createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">同時に満たされるセマフォの要求の初期数。</param>
        <param name="maximumCount">同時に満たされるセマフォの要求の最大数。</param>
        <param name="name">名前付きシステム セマフォ オブジェクトの名前。</param>
        <param name="createdNew">このメソッドから制御が戻るときに、ローカル セマフォが作成された場合 \(<c>name</c> が <see langword="null" /> または空の文字列の場合\)、または指定した名前付きシステム セマフォが作成された場合は <see langword="true" /> が格納されます。指定した名前付きシステム セマフォが既に存在する場合は <see langword="false" /> が格納されます。 このパラメーターは初期化せずに渡されます。</param>
        <param name="semaphoreSecurity">名前付きシステム セマフォに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> オブジェクト。</param>
        <summary>エントリ数の初期値と同時実行エントリの最大数を指定し、オプションでシステム セマフォ オブジェクトの名前を指定し、新しいシステム セマフォが作成されたかどうかを示す値を受け取る変数を指定し、システム セマフォのセキュリティ アクセス制御を指定して、<see cref="T:System.Threading.Semaphore" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.  
  
 This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.  
  
 If the named system semaphore does not exist, it is created with the specified access control security. If the named semaphore exists, the specified access control security is ignored.  
  
> [!NOTE]
>  The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if **parameterReference tag is not supported!!!!**  
>  denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.  
  
 If the named system semaphore does not exist, it is created with the initial count and maximum count specified by **parameterReference tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
. If the named system semaphore already exists, **parameterReference tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
 are not used, although invalid values still cause exceptions. Use the **parameterReference tag is not supported!!!!**  
 parameter to determine whether the system semaphore was created by this constructor.  
  
 If **parameterReference tag is not supported!!!!**  
 is less than **parameterReference tag is not supported!!!!**  
, and **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> \(**parameterReference tag is not supported!!!!**  
 minus **parameterReference tag is not supported!!!!**  
\) times.  
  
 If you specify **languageKeyword tag is not supported!!!!**  
 or an empty string for **parameterReference tag is not supported!!!!**  
, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload. In this case, **parameterReference tag is not supported!!!!**  
 is always **languageKeyword tag is not supported!!!!**  
.  
  
 Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.  
  
   
  
## 例  
 The following code example demonstrates the cross\-process behavior of a named semaphore with access control security. The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore. If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore. If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method. The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.  
  
 After the permissions are changed, the semaphore is opened with the rights required to enter and release. If you run the compiled example from a third command window, it runs using the new permissions.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> が <paramref name="maximumCount" /> より大きくなっています。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> が 1 未満です。  
  
 または  
  
 <paramref name="initialCount" /> が 0 未満です。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きセマフォが存在し、それにアクセス制御セキュリティがあり、ユーザーに <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きセマフォを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for calling unmanaged code to create a named system semaphore. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>名前付きシステム セマフォのアクセス制御セキュリティを取得します。</summary>
        <returns>名前付きシステム セマフォのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Semaphore.GetAccessControl%2A>メソッドは、次のフラグ \(ビットごとの OR 演算を使用して結合\) の組み合わせを使用してアクセス許可を検索する: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=fullName>、 <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=fullName>、および<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=fullName>です。  
  
 ユーザーがいる必要があります<xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=fullName>で権限を呼び出し、このメソッドと、セマフォが開かれている必要があります<xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=fullName>権限です。  
  
 ローカルのセマフォでアクセス制御セキュリティは無効です。 場合、<xref:System.Threading.Semaphore>オブジェクトは、名前付きシステム セマフォを表していません、このメソッドが戻る、<xref:System.Security.AccessControl.SemaphoreSecurity>任意のユーザーにすべての権限を付与されているオブジェクト。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きセマフォのプロセス間の動作を示します。 この例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>名前付きセマフォの存在をテストするメソッドのオーバー ロードします。  
  
 セマフォが存在しない場合、2 つのカウントの最大値と現在のユーザーに、セマフォを使用する権限を拒否読み取りし、セマフォのアクセス許可を変更する権限を付与するアクセス制御セキュリティが作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>メソッドです。 例外をキャッチし、この例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>メソッドのオーバー ロードを読み取るし、アクセス許可を変更するために必要な権限を持つ、セマフォを開きます。 使用して、システム セマフォのアクセス制御セキュリティを取得、<xref:System.Threading.Semaphore.GetAccessControl%2A>メソッドです。  
  
 アクセス許可が変更された後、セマフォは、入力し、解放に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">現在の <see cref="T:System.Threading.Semaphore" /> オブジェクトは名前付きシステム セマフォを表していますが、ユーザーには <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> 権限がありません。  
  
 または  
  
 現在の <see cref="T:System.Threading.Semaphore" /> オブジェクトは名前付きシステム セマフォを表していますが、<see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> 権限で開かれませんでした。</exception>
        <exception cref="T:System.NotSupportedException">Windows 98 または Windows Millennium Edition はサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム セマフォの名前。</param>
        <summary>既に存在する場合は、指定した名前付きセマフォを開きます。</summary>
        <returns>名前付きシステム セマフォを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Semaphore.OpenExisting%2A> メソッドは、指定した名前付きセマフォを開こうとします。 システム セマフォが存在しない場合、このメソッドは、システム セマフォを作成する代わりに例外をスローします。 既に存在しない場合は、システム セマフォを作成のいずれかの操作を使用して、 <xref:System.Threading.Semaphore.%23ctor%2A> コンス トラクターを持つ、 `name` パラメーター。  
  
 このメソッドは同じ値を使用する複数の呼び出し `name` 必ずしも返さない同じ <xref:System.Threading.Semaphore> オブジェクトを表すを返されたオブジェクト、同じ名前付きシステム セマフォにもかかわらずです。  
  
 このメソッドはオーバー ロードを呼び出すことと同じ、 <xref:System.Threading.Semaphore.OpenExisting%2A> メソッドのオーバー ロードを指定すること <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=fullName> と <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=fullName> 権限、ビットごとの OR 演算を使用して結合します。  
  
 指定する、 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=fullName> フラグにより、セマフォに入るためのスレッドを指定して、 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=fullName> フラグを呼び出すスレッドを使用する、 <xref:System.Threading.Semaphore.Release%2A> メソッドです。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きセマフォのプロセス間の動作を示します。 例では、 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> メソッドのオーバー ロードは、名前付きセマフォの存在をテストします。  
  
 セマフォが存在しない場合、2 つの最大数と、セマフォを使用する権利を現在のユーザーを拒否するが、読み取りし、セマフォのアクセス許可を変更する権限を付与するアクセス制御のセキュリティが作成されます。  
  
 2 番目のコピーはへの呼び出しでアクセス違反例外をスローして 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> メソッドのオーバー ロードします。 例外をキャッチし、例では、 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> メソッドのオーバー ロードは、読み取りし、アクセス許可を変更するために必要な権限を持つ、セマフォを開きます。  
  
 アクセス許可を変更すると、入力し、それを解放するために必要な権限を持つ、セマフォが開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きセマフォは存在しません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きのセマフォが存在するが、ユーザーには、それを使用するために必要なセキュリティのアクセスはありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for calling unmanaged code to open a named system semaphore. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム セマフォの名前。</param>
        <param name="rights">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</param>
        <summary>既に存在する場合は、必要なセキュリティ アクセスで指定した名前付きセマフォを開きます。</summary>
        <returns>名前付きシステム セマフォを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `rights` パラメーターを含める必要があります、 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=fullName> スレッドがセマフォに入ることができるようにするフラグ、および <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=fullName> を呼び出すスレッドを許可するフラグ、 <xref:System.Threading.Semaphore.Release%2A> メソッドです。  
  
 <xref:System.Threading.Semaphore.OpenExisting%2A> メソッドは、既存の名前付きセマフォを開こうとします。 システム セマフォが存在しない場合、このメソッドは、システム セマフォを作成する代わりに例外をスローします。 既に存在しない場合は、システム セマフォを作成のいずれかの操作を使用して、 <xref:System.Threading.Semaphore.%23ctor%2A> コンス トラクターを持つ、 `name` パラメーター。  
  
 このメソッドは同じ値を使用する複数の呼び出し `name` 必ずしも返さない同じ <xref:System.Threading.Semaphore> オブジェクトを表すを返されたオブジェクト、同じ名前付きシステム セマフォにもかかわらずです。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きセマフォのプロセス間の動作を示します。 例では、 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> メソッドのオーバー ロードは、名前付きセマフォの存在をテストします。  
  
 セマフォが存在しない場合、2 つの最大数と現在のユーザーに、セマフォを使用する権利を拒否の読み取りし、セマフォのアクセス許可を変更する権限を付与するアクセス制御セキュリティが作成されます。  
  
 2 番目のコピーはへの呼び出しでアクセス違反例外をスローして 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> メソッドです。 例外をキャッチし、例では、 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> メソッドのオーバー ロードは、読み取りし、アクセス許可を変更するために必要な権限を持つ、セマフォを開きます。  
  
 アクセス許可を変更すると、入力し、それを解放するために必要な権限を持つ、セマフォが開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きセマフォは存在しません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きのセマフォが存在するが、ユーザーが必要なセキュリティのアクセス権を持たない。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for calling unmanaged code to create a named system semaphore. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>セマフォから出て、前のカウントを返します。</summary>
        <returns>
          <see cref="Overload:System.Threading.Semaphore.Release" /> メソッドが呼び出される前のセマフォのカウント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 通常のスレッドを使用して、 <xref:System.Threading.WaitHandle.WaitOne%2A> とを入力、セマフォ、通常の方法では、このメソッドのオーバー ロードを使用して、終了します。  
  
 場合、 <xref:System.Threading.SemaphoreFullException> によってスローされた、 <xref:System.Threading.Semaphore.Release%2A> メソッドを呼び出し元のスレッドに問題があることはないとは限りません。 別のスレッドでのプログラミング エラーを引き起こしたそのスレッドがセマフォに他にもそれよりも入力します。  
  
 場合は、現在 <xref:System.Threading.Semaphore> オブジェクトは、名前付きシステム セマフォを表す、ユーザーが必要 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=fullName> 権限と、セマフォ必要がありますが開かれていると <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=fullName> 権限です。  
  
   
  
## 例  
 次のコード例では、3 つの最大数で初期カウントが 0 のセマフォを作成します。 例では、セマフォの待機をブロックする 5 つのスレッドを開始します。 メイン スレッドを使用して、 <xref:System.Threading.Semaphore.Release%28System.Int32%29> をその最大文字数は 3 つのスレッドがセマフォに入るための許可にセマフォのカウントを増やすには、メソッドのオーバー ロードします。 各スレッドを使用して、 <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> メソッドが、作業し、呼び出しをシミュレートするために、1 秒間待機する、 <xref:System.Threading.Semaphore.Release> メソッドのオーバー ロードは、セマフォを解放します。  
  
 セマフォが解放されるたびに、前のセマフォのカウントが表示されます。 コンソール メッセージ追跡セマフォを使用します。 シミュレートされた動作の間隔は、出力を読みやすくするために、スレッドごとに少し増加します。  
  
 [!code-cpp[System.Threading.Semaphore2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">セマフォのカウントが最大値では既にです。</exception>
        <exception cref="T:System.IO.IOException">名前付きのセマフォで Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">現在のセマフォが、名前付きシステム セマフォを表しますが、ユーザーが持っていない <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />します。  
  
 または  
  
 現在のセマフォは、名前付きシステム セマフォを表しますで開かれていない <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">セマフォから出る回数。</param>
        <summary>指定した回数だけセマフォから出て、前のカウントを返します。</summary>
        <returns>
          <see cref="Overload:System.Threading.Semaphore.Release" /> メソッドが呼び出される前のセマフォのカウント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッドがセマフォに入力する複数回のこのメソッドのオーバー ロードに 1 回の呼び出しを使用して復元する全体のセマフォのカウントが許可されます。  
  
 場合、 <xref:System.Threading.SemaphoreFullException> によってスローされた、 <xref:System.Threading.Semaphore.Release%2A> メソッドを呼び出し元のスレッドに問題があることはないとは限りません。 別のスレッドでのプログラミング エラーを引き起こしたそのスレッドがセマフォに他にもそれよりも入力します。  
  
 場合は、現在 <xref:System.Threading.Semaphore> オブジェクトは、名前付きシステム セマフォを表す、ユーザーが必要 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=fullName> 権限と、セマフォ必要がありますが開かれていると <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=fullName> 権限です。  
  
   
  
## 例  
 次のコード例では、3 つの最大数で初期カウントが 0 のセマフォを作成します。 例では、セマフォの待機をブロックする 5 つのスレッドを開始します。 メイン スレッドを使用して、 <xref:System.Threading.Semaphore.Release%28System.Int32%29> をその最大文字数は 3 つのスレッドがセマフォに入るための許可にセマフォのカウントを増やすには、メソッドのオーバー ロードします。 各スレッドを使用して、 <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> メソッドが、作業し、呼び出しをシミュレートするために、1 秒間待機する、 <xref:System.Threading.Semaphore.Release> メソッドのオーバー ロードは、セマフォを解放します。  
  
 セマフォが解放されるたびに、前のセマフォのカウントが表示されます。 コンソール メッセージ追跡セマフォを使用します。 シミュレートされた動作の間隔は、出力を読みやすくするために、スレッドごとに少し増加します。  
  
 [!code-cpp[System.Threading.Semaphore2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> 1 より小さいです。</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">セマフォのカウントが最大値では既にです。</exception>
        <exception cref="T:System.IO.IOException">名前付きのセマフォで Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">現在のセマフォが、名前付きシステム セマフォを表しますが、ユーザーが持っていない <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 権限です。  
  
 または  
  
 現在のセマフォは、名前付きシステム セマフォを表しますで開かれていない <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 権限です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">名前付きシステム セマフォに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> オブジェクト。</param>
        <summary>名前付きシステム セマフォのアクセス制御セキュリティを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 のみアクセス制御セキュリティを設定する <xref:System.Threading.Semaphore> を名前付きシステム セマフォを表すオブジェクト。  
  
 ユーザーが必要 <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=fullName> でこのメソッドは、セマフォを呼び出す権限が開かれている必要があります <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=fullName> 権限です。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きセマフォのプロセス間の動作を示します。 例では、 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> メソッドのオーバー ロードは、名前付きセマフォの存在をテストします。  
  
 セマフォが存在しない場合、2 つの最大数と現在のユーザーによるセマフォの使用を拒否の読み取りし、セマフォのアクセス許可を変更する権限を付与するアクセス制御セキュリティが作成されます。  
  
 2 番目のコピーはへの呼び出しでアクセス違反例外をスローして 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> メソッドです。 例外をキャッチし、例では、 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> メソッドのオーバー ロードは、読み取りし、アクセス許可を変更するために必要な権限を持つ、セマフォを開きます。  
  
 使用して、アクセス許可が変更した後、 <xref:System.Threading.Semaphore.SetAccessControl%2A> 、セマフォ、メソッドは入力し、解放に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.UnauthorizedAccessException">ユーザーがいない <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> 権限です。  
  
 または  
  
 セマフォが開かれていない <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> 権限です。</exception>
        <exception cref="T:System.NotSupportedException">現在 <see cref="T:System.Threading.Semaphore" /> オブジェクトは、名前付きシステム セマフォを表していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, class System.Threading.Semaphore result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム セマフォの名前。</param>
        <param name="result">このメソッドから制御が戻るときに、呼び出しに成功した場合は名前付きセマフォを表す <see cref="T:System.Threading.Semaphore" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。 このパラメーターは初期化前として処理されます。</param>
        <summary>既に存在する場合は、指定した名前付きセマフォを開き操作が成功したかどうかを示す値を返します。</summary>
        <returns>名前付きのセマフォが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a **parameterReference tag is not supported!!!!**  
 parameter.  
  
 If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.  
  
 This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=fullName> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=fullName> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きセマフォは存在しますが、ユーザーにはそれを使用するために必要なセキュリティ アクセスがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, class System.Threading.Semaphore result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム セマフォの名前。</param>
        <param name="rights">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</param>
        <param name="result">このメソッドから制御が戻るときに、呼び出しに成功した場合は名前付きセマフォを表す <see cref="T:System.Threading.Semaphore" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。 このパラメーターは初期化前として処理されます。</param>
        <summary>既に存在する場合は、必要なセキュリティ アクセスを使って指定した名前付きセマフォを開き、操作が成功したかどうかを示す値を返します。</summary>
        <returns>名前付きのセマフォが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a **parameterReference tag is not supported!!!!**  
 parameter.  
  
 If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.  
  
 The **parameterReference tag is not supported!!!!**  
 parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=fullName> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.  
  
 Multiple calls to this method that use the same value for **parameterReference tag is not supported!!!!**  
 do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きセマフォは存在しますが、ユーザーにはそれを使用するために必要なセキュリティ アクセスがありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に存在する場合は、指定した名前付きセマフォを開きます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に存在する場合は、指定した名前付きセマフォを開き操作が成功したかどうかを示す値を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>セマフォから出ます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Semaphore" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>