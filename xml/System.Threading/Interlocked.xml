<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>複数のスレッドで共有される変数に分割不可能な操作を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 このクラスのメソッドは、スケジューラが、スレッドが他のスレッドからアクセスできる変数を更新中に、コンテキストを切り替えたときに、または 2 つのスレッドが別々 のプロセッサで同時に実行するときに発生する可能性があるエラーから保護します。 このクラスのメンバーでは、例外はスローされません。  
  
 <xref:System.Threading.Interlocked.Increment%2A> と <xref:System.Threading.Interlocked.Decrement%2A> メソッドの変数を増減して、単一の操作で、結果の値を格納します。 ほとんどのコンピューターで、変数をインクリメントする、次の手順を必要とする、分割不可能な操作ではありません。  
  
1.  レジスタにインスタンス変数から値を読み込みます。  
  
2.  インクリメントまたはデクリメント値。  
  
3.  インスタンスの変数に値を格納します。  
  
 使用しない場合 <xref:System.Threading.Interlocked.Increment%2A> と <xref:System.Threading.Interlocked.Decrement%2A>, 、最初の 2 つの手順を実行した後、スレッドを横取りことができます。 別のスレッドは、3 つすべての手順を実行できます。 最初のスレッドが実行を再開インスタンス変数の値を上書きし、インクリメントまたはデクリメントが 2 番目のスレッドによって実行されるの効果が失われます。  
  
 <xref:System.Threading.Interlocked.Exchange%2A> メソッドは、指定された変数の値をアトミックに交換します。<xref:System.Threading.Interlocked.CompareExchange%2A> メソッドで、次の 2 つの操作を組み合わせて: 2 つの値を比較して、3 つ目を格納する値が比較の結果に基づいて、変数のいずれかでします。 比較および交換操作は、分割不可能な操作として実行されます。  
  
   
  
## 例  
 次のコード例では、スレッド セーフであるリソースのロック機構を示します。  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32 location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">加算する最初の値を含む変数。 2 つの値の合計が格納されている <c>location1</c>します。</param>
        <param name="value">整数に加算する値 <c>location1</c>です。</param>
        <summary>分割不可能な操作として、2 つの 32 ビット整数を加算し、最初の整数を合計で置き換えます。</summary>
        <returns>格納された新しい値 <paramref name="location1" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、ラップすることによって、オーバーフローを処理: 場合位置にある値 `location1` は <xref:System.Int32.MaxValue?displayProperty=fullName> と `value` 1 に設定されて、結果は <xref:System.Int32.MinValue?displayProperty=fullName>場合 `value` が 2 の場合、結果は \(<xref:System.Int32.MinValue?displayProperty=fullName> \+ 1\); にします。 例外をスローすることはありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64 location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">加算する最初の値を含む変数。 2 つの値の合計が格納されている <c>location1</c>します。</param>
        <param name="value">整数に加算する値 <c>location1</c>です。</param>
        <summary>分割不可能な操作として、2 つの 64 ビット整数を加算し、最初の整数を合計で置き換えます。</summary>
        <returns>格納された新しい値 <paramref name="location1" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、ラップすることによって、オーバーフローを処理: 場合位置にある値 `location1` は <xref:System.Int64.MaxValue?displayProperty=fullName> と `value` 1 に設定されて、結果は <xref:System.Int64.MinValue?displayProperty=fullName>場合 `value` が 2 の場合、結果は \(<xref:System.Int64.MinValue?displayProperty=fullName> \+ 1\); にします。 例外をスローすることはありません。  
  
 <xref:System.Threading.Interlocked.Read%2A> メソッドとの 64 ビットのオーバー ロード、 <xref:System.Threading.Interlocked.Increment%2A>, 、<xref:System.Threading.Interlocked.Decrement%2A>, と <xref:System.Threading.Interlocked.Add%2A> メソッドは、システムでのみアトミック本当にここで、 <xref:System.IntPtr?displayProperty=fullName> 64 ビット長。 他のシステムでは、これらのメソッドは、貴社とデータにアクセスするが、相互にアトミックです。 したがって、32 ビット システムでスレッド セーフにするには、64 ビット値へのアクセスできる必要のメンバーを <xref:System.Threading.Interlocked> クラスです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64 location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">値を <c>comparand</c> と比較し、場合によっては置き換える比較先。</param>
        <param name="value">比較した結果が等しい場合に比較先の値を置き換える値。</param>
        <param name="comparand">
          <c>location1</c> にある値と比較する値。</param>
        <summary>2 つの倍精度浮動小数点数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `comparand` 値と `location1` しが等しいか、 `value` に格納されて `location1`します。 それ以外の場合は演算が実行されません。 比較および交換操作は、分割不可能な操作として実行されます。 戻り値 <xref:System.Threading.Interlocked.CompareExchange%2A> の元の値は、 `location1`, 、交換が行われているかどうかを示す、します。  
  
   
  
## 例  
 次のコード例は、累計を実行中のスレッド セーフであるメソッドを示しています <xref:System.Double> 値。 2 つのスレッドの系列を追加する <xref:System.Double> 、スレッド セーフであるメソッドと通常の加算を使用して値を合計を比較する、スレッドが完了します。 デュアル プロセッサ コンピューターでは、合計に大きな違いです。  
  
 スレッド セーフな方法では、実行中の合計の初期値が保存、し、 <xref:System.Threading.Interlocked.CompareExchange%2A> メソッドを使用して、古い合計の新しく計算された合計を交換します。 戻り値が実行中の合計の保存されている値と等しくない場合は、\[別のスレッドが更新合計当面の間。 その場合は、実行中の合計を更新しようとするを繰り返す必要があります。  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32 location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">値を <c>comparand</c> と比較し、場合によっては置き換える比較先。</param>
        <param name="value">比較した結果が等しい場合に比較先の値を置き換える値。</param>
        <param name="comparand">
          <c>location1</c> にある値と比較する値。</param>
        <summary>2 つの 32 ビット符号付き整数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If **parameterReference tag is not supported!!!!**  
 and the value in **parameterReference tag is not supported!!!!**  
 are equal, then **parameterReference tag is not supported!!!!**  
 is stored in **parameterReference tag is not supported!!!!**  
. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in **parameterReference tag is not supported!!!!**  
, whether or not the exchange takes place.  
  
   
  
## 例  
 The following code example demonstrates a thread\-safe method that accumulates a running total. The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.  
  
> [!NOTE]
>  The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread\-safe running totals for integers.  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64 location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">値を <c>comparand</c> と比較し、場合によっては置き換える比較先。</param>
        <param name="value">比較した結果が等しい場合に比較先の値を置き換える値。</param>
        <param name="comparand">
          <c>location1</c> にある値と比較する値。</param>
        <summary>2 つの 64 ビット符号付き整数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If **parameterReference tag is not supported!!!!**  
 and the value in **parameterReference tag is not supported!!!!**  
 are equal, then **parameterReference tag is not supported!!!!**  
 is stored in **parameterReference tag is not supported!!!!**  
. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in **parameterReference tag is not supported!!!!**  
, whether or not the exchange takes place.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">宛先 <see cref="T:System.IntPtr" />, の値と比較値を持つ <c>comparand</c> し、場合によって置き換え <c>value</c>します。</param>
        <param name="value">
          <see cref="T:System.IntPtr" /> 、比較結果が等しい場合は、送信先の値を置き換えます。</param>
        <param name="comparand">
          <see cref="T:System.IntPtr" /> 位置にある値と比較する <c>location1</c>です。</param>
        <summary>2 つのプラットフォーム固有のハンドルまたはポインターが等しいかどうかを比較します。等しい場合は、最初の 1 つを置き換えます。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `comparand` 値と `location1` しが等しいか、 `value` に格納されて `location1`します。 それ以外の場合は演算が実行されません。 比較および交換操作は、分割不可能な操作として実行されます。 このメソッドの戻り値の元の値は、 `location1`, 、交換が行われているかどうかを示す、します。  
  
> [!NOTE]
>  <xref:System.IntPtr> プラットフォーム固有の型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">対象オブジェクトと比較される <c>comparand</c> され、場合によって置き換えられます。</param>
        <param name="value">比較結果が等しい場合は、先のオブジェクトを置き換えるオブジェクト。</param>
        <param name="comparand">位置にあるオブジェクトと比較されるオブジェクト <c>location1</c>します。</param>
        <summary>2 つのオブジェクトの参照が等値であるかどうかを比較します。等しい場合は、最初のオブジェクトを置き換えます。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `comparand` 内のオブジェクトと `location1` しが等しいか、 `value` に格納されて `location1`します。 それ以外の場合は演算が実行されません。 比較および交換操作は、分割不可能な操作として実行されます。 戻り値 <xref:System.Threading.Interlocked.CompareExchange%2A> の元の値は、 `location1`, 、交換が行われているかどうかを示す、します。  
  
 .NET Framework version 2.0 以降、 <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> メソッドのオーバー ロードは、参照型のタイプ セーフな代替手段を提供します。  
  
> [!NOTE]
>  オブジェクトの参照の等価性はなく <xref:System.Object.Equals%2A?displayProperty=fullName>です。 その結果、同じ 2 つのボックス化されたインスタンス値の型 \(たとえば、整数 3\) 常に等しくない場合に表示され、操作は実行されません。 値の型は、このオーバー ロードを使用しないでください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32 location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">値を <c>comparand</c> と比較し、場合によっては置き換える比較先。</param>
        <param name="value">比較した結果が等しい場合に比較先の値を置き換える値。</param>
        <param name="comparand">
          <c>location1</c> にある値と比較する値。</param>
        <summary>2 つの単精度浮動小数点数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `comparand` 値と `location1` しが等しいか、 `value` に格納されて `location1`します。 それ以外の場合は演算が実行されません。 比較および交換操作は、分割不可能な操作として実行されます。 戻り値 <xref:System.Threading.Interlocked.CompareExchange%2A> の元の値は、 `location1`, 、交換が行われているかどうかを示す、します。  
  
   
  
## 例  
 次のコード例は、累計を実行中のスレッド セーフであるメソッドを示しています <xref:System.Single> 値。 2 つのスレッドの系列を追加する <xref:System.Single> 、スレッド セーフであるメソッドと通常の加算を使用して値を合計を比較する、スレッドが完了します。 デュアル プロセッサ コンピューターでは、合計に大きな違いです。  
  
 スレッド セーフな方法では、実行中の合計の初期値が保存、し、 <xref:System.Threading.Interlocked.CompareExchange%2A> メソッドを使用して、古い合計の新しく計算された合計を交換します。 戻り値が実行中の合計の保存されている値と等しくない場合は、\[別のスレッドが更新合計当面の間。 その場合は、実行中の合計を更新しようとするを繰り返す必要があります。  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">使用する種類 <c>location1</c>, 、<c>value</c>, 、および <c>comparand</c>です。 この型は、参照型である必要があります。</typeparam>
        <param name="location1">値を <c>comparand</c> と比較し、場合によっては置き換える比較先。 これは参照パラメーターです \(C\# では <see langword="ref" />、Visual Basic では <see langword="ByRef" />\)。</param>
        <param name="value">比較した結果が等しい場合に比較先の値を置き換える値。</param>
        <param name="comparand">
          <c>location1</c> にある値と比較する値。</param>
        <summary>指定した参照型の 2 つのインスタンスを比較 <paramref name="T" /> 等しいかどうかが等しい場合は、最初の 1 つを置き換えます。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `comparand` 値と `location1` しが等しいか、 `value` に格納されて `location1`します。 それ以外の場合は演算が実行されません。 比較および交換は、分割不可能な操作として実行されます。 このメソッドの戻り値の元の値は、 `location1`, 、交換が行われているかどうかを示す、します。  
  
 このメソッドは、参照型のみをサポートします。 オーバー ロードがあり、 <xref:System.Threading.Interlocked.CompareExchange%2A> 値型のメソッド <xref:System.Int32>, 、<xref:System.Int64>, 、<xref:System.IntPtr>, 、<xref:System.Single>, 、および <xref:System.Double>, 、他の値型はサポートされていませんが、します。  
  
> [!NOTE]
>  このメソッドのオーバー ロードをお勧めします <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> 、後者に遅延バインディング アクセス先となるオブジェクトを必要とするためのメソッドがオーバー ロードします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32 location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">値がデクリメントされる変数。</param>
        <summary>分割不可能な操作として、指定した変数をデクリメントし、結果を格納します。</summary>
        <returns>デクリメントされた値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method handles an overflow condition by wrapping: If **parameterReference tag is not supported!!!!**  
 \= <xref:System.Int32.MinValue?displayProperty=fullName>, **parameterReference tag is not supported!!!!**  
 \- 1 \= <xref:System.Int32.MaxValue?displayProperty=fullName>. No exception is thrown.  
  
   
  
## 例  
 The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value. To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value. Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently. Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.  
  
 [!code-csharp[System.Threading.Interlocked.Decrement\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers. In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.  
  
 [!code-csharp[System.Threading.Interlocked.Decrement\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="location" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64 location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">値がデクリメントされる変数。</param>
        <summary>分割不可能な操作として、指定した変数をデクリメントしてその結果を格納します。</summary>
        <returns>デクリメントされた値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method handles an overflow condition by wrapping: if **parameterReference tag is not supported!!!!**  
 \= <xref:System.Int64.MinValue?displayProperty=fullName>, **parameterReference tag is not supported!!!!**  
 \- 1 \= <xref:System.Int64.MaxValue?displayProperty=fullName>. No exception is thrown.  
  
 The <xref:System.Threading.Interlocked.Read%2A> method and the 64\-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=fullName> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32\-bit systems, any access to a 64\-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="location" /> のアドレスは null ポインターです。</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64 location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">指定した値に設定する変数。</param>
        <param name="value">
          <c>location1</c> パラメーターに設定される値。</param>
        <summary>分割不可能な操作として、指定した値を倍精度浮動小数点数として設定し、元の値を返します。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32 location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">指定した値に設定する変数。</param>
        <param name="value">
          <c>location1</c> パラメーターに設定される値。</param>
        <summary>分割不可能な操作として、指定した値を 32 ビット符号付き整数として設定し、元の値を返します。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following code example shows a thread\-safe resource locking mechanism.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64 location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">指定した値に設定する変数。</param>
        <param name="value">
          <c>location1</c> パラメーターに設定される値。</param>
        <summary>分割不可能な操作として、指定した値を 64 ビット符号付き整数として設定し、元の値を返します。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">指定した値に設定する変数。</param>
        <param name="value">
          <c>location1</c> パラメーターに設定される値。</param>
        <summary>分割不可能な操作として、プラットフォーム固有のハンドルまたはポインターに指定した値を設定し、元の値を返します。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">指定した値に設定する変数。</param>
        <param name="value">
          <c>location1</c> パラメーターに設定される値。</param>
        <summary>分割不可能な操作として、指定した値をオブジェクトとして設定し、元のオブジェクトへの参照を返します。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type\-safe alternative for reference types.  
  
   
  
## 例  
 The following code example shows the syntax for using **languageKeyword tag is not supported!!!!**  
 with any reference type object.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32 location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">指定した値に設定する変数。</param>
        <param name="value">
          <c>location1</c> パラメーターに設定される値。</param>
        <summary>分割不可能な操作として、指定した値を単精度浮動小数点数として設定し、元の値を返します。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <c>location1</c> および <c>value</c> に使用する型。 この型は、参照型である必要があります。</typeparam>
        <param name="location1">指定した値に設定する変数。 これは参照パラメーターです \(C\# では <see langword="ref" />、Visual Basic では <see langword="ByRef" />\)。</param>
        <param name="value">
          <c>location1</c> パラメーターに設定される値。</param>
        <summary>分割不可能な操作として、指定した型 <paramref name="T" /> の変数に指定した値を設定し、元の値を返します。</summary>
        <returns>
          <paramref name="location1" /> の元の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method only supports reference types. There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.  
  
> [!NOTE]
>  This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late\-bound access to the destination object .  
  
   
  
## 例  
 The following example launches ten tasks, each of which generates  100 ten\-character part numbers. It then the part number that is first alphabetically.  
  
 [!code-csharp[System.Threading.Interlocked.Exchange\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CS/Exchange5.cs#2)]
 [!code-vb[System.Threading.Interlocked.Exchange\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/VB/Exchange5.vb#2)]  
  
 The example uses the `firstWidget` variable to store the ID that occurs first in the sort order. It compares each ID that it generates with the `firstWidget` value.  If the new value precedes the current value of `firstWidget` in the sort order, the example calls the <xref:System.Threading.Interlocked.Exchange%2A> method to assign the new value to `firstWidget`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location1" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32 location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">値がインクリメントされる変数。</param>
        <summary>分割不可能な操作として、指定した変数をインクリメントし、結果を格納します。</summary>
        <returns>インクリメントされた値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、ラップすることによって、オーバーフローを処理します。 場合 `location` \= <xref:System.Int32.MaxValue?displayProperty=fullName>, 、`location` \+ 1 \= <xref:System.Int32.MinValue?displayProperty=fullName>です。 例外をスローすることはありません。  
  
   
  
## 例  
 次の例では、中間値と 1,000 の乱数を生成する必要な範囲は 0 から 1,000 にランダムな番号の数を決定します。 中間値、変数の数を追跡するために `midpointCount`, を 0 に設定し、乱数ジェネレーターを 10,000 に達するまでに中間値を返しますたびに増分されます。 3 つのスレッド、乱数を生成するため、 <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> メソッドを呼び出して複数のスレッドが更新されないことを確認する `midpointCount` 同時にします。 乱数ジェネレーターとを保護するためのロックは使用も、 <xref:System.Threading.CountdownEvent> オブジェクトを使用していることを確認、 `Main` メソッドが 3 つのスレッドの前に実行を完了します。  
  
 [!code-csharp[System.Threading.Interlocked.Increment2\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 使用する点を除いて、次の例は、1 つ前のような 50,000 の中間値のランダムな整数を生成するスレッドのプロシージャではなく。 この例では、ラムダ式の代わりに使用、 `GenerateNumbers` スレッド プロシージャを呼び出すまで、 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> メソッドが不要、 <xref:System.Threading.CountdownEvent> オブジェクトです。  
  
 [!code-csharp[System.Threading.Interlocked.Increment2\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location" /> のアドレスは null ポインターです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64 location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">値がインクリメントされる変数。</param>
        <summary>分割不可能な操作として、指定した変数をインクリメントし、結果を格納します。</summary>
        <returns>インクリメントされた値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、ラップすることによって、オーバーフローを処理します。 場合 `location` \= <xref:System.Int64.MaxValue?displayProperty=fullName>, 、`location` \+ 1 \= <xref:System.Int64.MinValue?displayProperty=fullName>です。 例外をスローすることはありません。  
  
 <xref:System.Threading.Interlocked.Read%2A> メソッドとの 64 ビットのオーバー ロード、 <xref:System.Threading.Interlocked.Increment%2A>, 、<xref:System.Threading.Interlocked.Decrement%2A>, と <xref:System.Threading.Interlocked.Add%2A> メソッドは、システムでのみアトミック本当にここで、 <xref:System.IntPtr?displayProperty=fullName> 64 ビット長。 他のシステムでは、これらのメソッドは、貴社とデータにアクセスするが、相互にアトミックです。 したがって、32 ビット システムでスレッド セーフにするには、64 ビット値へのアクセスできる必要のメンバーを <xref:System.Threading.Interlocked> クラスです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="location" /> のアドレスは null ポインターです。</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>次のようにメモリ アクセスを同期: 現在のスレッドを実行するプロセッサが命令を並べ替えることはできませんを呼び出す前にこのような方法でそのメモリにアクセスする <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> への呼び出しの後のメモリ アクセスより後に実行 <see cref="M:System.Threading.Interlocked.MemoryBarrier" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドに追加された、 <xref:System.Threading.Interlocked> クラス、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ; しやすくするためのラッパーである、 <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=fullName> メソッドです。  
  
 <xref:System.Threading.Interlocked.MemoryBarrier%2A> 順序付け \(たとえば、複数の Intel Itanium プロセッサを採用しているシステム\) と脆弱なメモリ型マルチプロセッサ システムでのみ必要です。  
  
 ほとんどの場合、c\#、 `lock` ステートメント、Visual Basic `SyncLock` ステートメント、または <xref:System.Threading.Monitor> クラスは、簡単にデータを同期する方法を提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64 location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">読み込む 64 ビット値。</param>
        <summary>分割不可能な操作として 64 ビット値を読み込んで返します。</summary>
        <returns>読み込まれた値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Interlocked.Read%2A> メソッドは、64 ビットの読み取り操作がアトミックでは既にあるために、64 ビット システムで必要です。 32 ビット システムで 64 ビット読み取り操作を使用して実行しない限り、アトミック <xref:System.Threading.Interlocked.Read%2A>します。  
  
 <xref:System.Threading.Interlocked.Read%2A> メソッドとの 64 ビットのオーバー ロード、 <xref:System.Threading.Interlocked.Increment%2A>, 、<xref:System.Threading.Interlocked.Decrement%2A>, と <xref:System.Threading.Interlocked.Add%2A> メソッドは、システムでのみアトミック本当にここで、 <xref:System.IntPtr?displayProperty=fullName> 64 ビット長。 他のシステムでは、これらのメソッドは、貴社とデータにアクセスするが、相互にアトミックです。 したがって、32 ビット システムでスレッド セーフにするには、64 ビット値へのアクセスできる必要のメンバーを <xref:System.Threading.Interlocked> クラスです。  
  
> [!NOTE]
>  <xref:System.IntPtr> プラットフォーム固有の型。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>分割不可能な操作として、指定した変数をインクリメントし、結果を格納します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つの値が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>分割不可能な操作として、指定した変数をデクリメントし、結果を格納します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>分割不可能な操作として、2 つの整数を加算し、最初の整数を合計で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>分割不可能な操作として指定した値を変数として設定します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>