<Type Name="Thread" FullName="System.Threading.Thread">
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>スレッドを作成および制御し、その優先順位の設定およびステータスの取得を実行します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 When a process starts, the common language runtime automatically creates a single foreground thread to execute application code. Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process. These threads can execute either in the foreground or in the background. In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.  
  
 In this section  
  
 [Starting a thread](#Starting)   
 [Retrieving Thread objects](#Retrieving)   
 [Foreground and background threads](#Foreground)   
 [Culture and threads](#Culture)   
 [Getting information about and controlling threads](#Properties)   
 [Accessing the source code for the Thread class](#Source)  
  
<a name="Starting"></a>   
## Starting a thread  
 You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor. You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.  
  
 The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:  
  
-   If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor. It has the signature:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     The following example creates and starts a thread that executes the `ExecuteInForeground` method. The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds. When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.  
  
     [!code-csharp[System.Threading.Thread\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor. It has the signature:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     The method executed by the delegate can then cast \(in C\#\) or convert \(in Visual Basic\) the parameter to the appropriate type.  
  
     The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor. This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.  
  
     [!code-csharp[System.Threading.Thread\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread. The thread continues to execute until the thread procedure is complete.  
  
<a name="Retrieving"></a>   
## Retrieving Thread objects  
 You can use the static \(**languageKeyword tag is not supported!!!!**  
 in Visual Basic\)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing. The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.  
  
 [!code-csharp[System.Threading.Thread\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## Foreground and background threads  
 Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads. Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated. Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.  
  
 By default, the following threads execute in the foreground:  
  
-   The main application thread.  
  
-   All threads created by calling a <xref:System.Threading.Thread> class constructor.  
  
 The following threads execute in the background by default:  
  
-   Thread pool threads, which are a pool of worker threads maintained by the runtime.  You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.  
  
    > [!NOTE]
    >  Task\-based asynchronous operations automatically execute on thread pool threads. Task\-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task\-based asynchronous pattern](http://msdn.microsoft.com/ja-jp/8cef1fcf-6f9f-417c-b21f-3fd8bac75007).  
  
-   All threads that enter the managed execution environment from unmanaged code.  
  
 You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.  Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.  
  
 The following example illustrates the difference between foreground and background threads. It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it. As the output shows, the loop is interrupted before it executes for five seconds.  
  
 [!code-csharp[System.Threading.Thread\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## Culture and threads  
 Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.  The current culture supports such culture\-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread. The current UI culture provides for culture\-sensitive retrieval of resources in resource files.  
  
 When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created. This means, for example, that if the current system culture is English \(United States\) and the current culture of the primary application thread is French \(France\), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English \(United States\), and not French \(France\). For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.  
  
> [!IMPORTANT]
>  This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched. For more information, see the "Culture and task\-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.  
  
 You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:  
  
-   You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName> method.  
  
-   For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName> properties. Note that this is a per\-application domain setting.  
  
 For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.  
  
<a name="Properties"></a>   
## Getting information about and controlling threads  
 You can retrieve a number of property values that provide information about a thread. In some cases, you can also set these property values to control the operation of the thread. These thread properties include:  
  
-   A name. <xref:System.Threading.Thread.Name%2A> is a write\-once property that you can use to identify a thread.  Its default value is **languageKeyword tag is not supported!!!!**  
    .  
  
-   A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method. The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.  
  
-   A thread ID. The value of the read\-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.  
  
    > [!NOTE]
    >  An operating\-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads. Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.  
  
-   The thread's current state. For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.  
  
-   A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property. Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.  
  
-   The read\-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.  
  
-   The <xref:System.Threading.Thread.IsBackground%2A> property. For more information, see the [Foreground and background threads](#Foreground) section.  
  
<a name="Source"></a>   
## Accessing the source code for the Thread class  
 To view the .NET Framework source code for the <xref:System.Threading.Thread> class, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96). You can browse through the source code online, download the reference for offline viewing, and step through the sources \(including patches and updates\) during debugging; see [instructions](http://referencesource.microsoft.com/).  
  
   
  
## 例  
 The following example demonstrates simple threading functionality.  
  
 [!code-cpp[Classic Thread Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 This code produces output similar to the following:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。</param>
        <summary>スレッドの開始時にオブジェクトをスレッドに渡すことを許可するデリゲートを指定して、<see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A thread does not begin executing when it is created. To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method. To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.  
  
> [!NOTE]
>  Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread. Use the **languageKeyword tag is not supported!!!!**  
>  operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.  
  
   
  
## 例  
 The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ThreadStart" /> デリゲート。</param>
        <summary>
          <see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A thread does not begin executing when it is created. To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.  
  
> [!NOTE]
>  Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread. Use the **languageKeyword tag is not supported!!!!**  
>  operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.  
  
   
  
## 例  
 The following code example shows how to create a thread that executes a static method.  
  
 [!code-cpp[System.Threading.Thread.ctor\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 The following code example shows how to create a thread that executes an instance method.  
  
 [!code-cpp[System.Threading.Thread.ctor2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ParameterizedThreadStart" /> デリゲート。</param>
        <param name="maxStackSize">スレッドが使用する最大スタック サイズ \(バイト単位\)。実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する場合は 0。  
  
 重要: 部分的に信頼されているコードでは、既定のスタック サイズを超える <c>maxStackSize</c> は無視されます。 例外をスローすることはありません。</param>
        <summary>
          <see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化して、スレッドの開始時にオブジェクトをスレッドに渡すことを許可するデリゲートとこのスレッドの最大スタック サイズを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクター オーバー ロードを使用しないでください。 によって使用される既定のスタック サイズ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>コンス トラクター オーバー ロードは、スレッドの推奨されるスタックのサイズ。 スレッドでは、メモリに問題がある、最も一般的な原因は無限再帰などのエラーをプログラミングできます。  
  
> [!IMPORTANT]
>  以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]コード設定を完全に信頼できるのみ、`maxStackSize`が既定のスタック サイズ \(1 メガバイト\) より大きい値にします。 大きい値を指定した場合`maxStackSize`部分信頼でコードが実行されているときに`maxStackSize`は無視されますと既定のスタック サイズを使用します。 例外をスローすることはありません。 任意の信頼レベルでコードを設定できます`maxStackSize`が既定のスタック サイズより小さい値にします。  
  
> [!NOTE]
>  で部分的に信頼されたコードによって使用される完全に信頼されたライブラリを開発しているスレッドを開始する必要がある場合は、大きなスタックを必要とするまたは、スレッドを作成する前に完全な信頼をアサートする必要があります、既定のスタック サイズが使用されます。 こうしないスレッド上で実行されるコードを完全に制御しない限り、します。  
  
 場合`maxStackSize`が小さい最小のスタック サイズよりも最小のスタック サイズを使用します。 場合`maxStackSize`倍数ではない場合、ページ サイズの次に大きいページ サイズの倍数に丸められます。 など、.NET Framework version 2.0 を使用して、Windows Vista では、256 KB \(262、144 バイト\) が最小のスタック サイズし、ページ サイズは 64 KB \(65,536 バイト\)。  
  
> [!NOTE]
>  Windows XP および Windows Server 2003 以前の Microsoft Windows のバージョンで`maxStackSize`は無視され、実行可能ファイルのヘッダーで指定されたスタック サイズを使用。  
  
 非常に小さなスタック サイズを指定する場合は、スタック オーバーフローの検出を無効にする必要があります。 スタックが深刻な制約されている場合、プローブできます自体、スタック オーバーフローが発生します。 スタック オーバーフローの検出を無効にするには、アプリケーション構成ファイルに、次を追加します。  
  
```  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ThreadStart" /> デリゲート。</param>
        <param name="maxStackSize">スレッドが使用する最大スタック サイズ \(バイト単位\)。実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する場合は 0。  
  
 重要: 部分的に信頼されているコードでは、既定のスタック サイズを超える <c>maxStackSize</c> は無視されます。 例外をスローすることはありません。</param>
        <summary>
          <see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化して、スレッドの最大スタック サイズを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクター オーバー ロードを使用しないでください。 によって使用される既定のスタック サイズ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>コンス トラクター オーバー ロードは、スレッドの推奨されるスタックのサイズ。 スレッドでは、メモリに問題がある、最も一般的な原因は無限再帰などのエラーをプログラミングできます。  
  
> [!IMPORTANT]
>  以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]コード設定を完全に信頼できるのみ、`maxStackSize`が既定のスタック サイズ \(1 メガバイト\) より大きい値にします。 大きい値を指定した場合`maxStackSize`部分信頼でコードが実行されているときに`maxStackSize`は無視されますと既定のスタック サイズを使用します。 例外をスローすることはありません。 任意の信頼レベルでコードを設定できます`maxStackSize`が既定のスタック サイズより小さい値にします。  
  
> [!NOTE]
>  で部分的に信頼されたコードによって使用される完全に信頼されたライブラリを開発しているスレッドを開始する必要がある場合は、大きなスタックを必要とするまたは、スレッドを作成する前に完全な信頼をアサートする必要があります、既定のスタック サイズが使用されます。 こうしないスレッド上で実行されるコードを完全に制御しない限り、します。  
  
 場合`maxStackSize`が小さい最小のスタック サイズよりも最小のスタック サイズを使用します。 場合`maxStackSize`倍数ではない場合、ページ サイズの次に大きいページ サイズの倍数に丸められます。 たとえば、Windows Vista を .NET Framework version 2.0 を使用している場合 256 KB \(262、144 バイト\) が最小のスタック サイズとページ サイズは 64 KB \(65,536 バイト\)。  
  
> [!NOTE]
>  Windows XP および Windows Server 2003 以前の Microsoft Windows のバージョンで`maxStackSize`は無視され、実行可能ファイルのヘッダーで指定されたスタック サイズが使用されます。  
  
 非常に小さなスタック サイズを指定する場合は、スタック オーバーフローの検出を無効にする必要があります。 スタックが深刻な制約されている場合、プローブできます自体、スタック オーバーフローが発生します。 スタック オーバーフローの検出を無効にするには、アプリケーション構成ファイルに、次を追加します。  
  
```  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメソッドが呼び出された対象のスレッドで、そのスレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スローされますスレッドでこのメソッドが呼び出されると、 <xref:System.Threading.ThreadAbortException> スレッドを中止することで。`ThreadAbortException` アプリケーション コードでキャッチできる特殊な例外の最後に再スローされますが、 `catch` しない限り、ブロック <xref:System.Threading.Thread.ResetAbort%2A> が呼び出されます。`ResetAbort` 中止するには要求を取り消したを防止し、 `ThreadAbortException` がスレッドを終了します。 実行されていない `finally` 、スレッドが中止される前に、ブロックは実行されます。  
  
> [!NOTE]
>  スレッドを呼び出すと `Abort` 自体には効果は例外をスローすることに似ています、 <xref:System.Threading.ThreadAbortException> を即座に、実行され、結果は予測可能です。 ただし、1 つのスレッドを呼び出す場合 `Abort` どのようなコードが実行されているが、中止別のスレッドで中断します。 静的コンス トラクターが中断される可能性もあります。 まれなケースでは、そのアプリケーション ドメインで作成されているがそのクラスのインスタンスをしないこのあります。 スレッドを終了させる可能性がある .NET Framework バージョン 1.0 および 1.1 では、中に、 `finally` ブロックが実行されている、この場合、 `finally` ブロックが中止されました。  
  
 スレッドは、すぐに、またはまったくを中止するは保証されません。 このような状況は、スレッドが無制限で計算の場合に発生することができます、 `finally` アボート プロシージャは、無期限のために中止が遅れるの一部として呼び出されるブロックします。 スレッドが中止されるまで待機するを呼び出すことができます、 <xref:System.Threading.Thread.Join%2A> メソッドを呼び出した後、スレッド、 <xref:System.Threading.Thread.Abort%2A> メソッド、される保証はありません。  
  
> [!NOTE]
>  呼び出すスレッド <xref:System.Threading.Thread.Abort%2A> 場合は、コードの保護領域になっているなど、中止中のスレッドをブロックする可能性があります、 `catch` ブロック、 `finally` ブロック、または制約された実行領域です。 かどうかは、スレッドを呼び出す <xref:System.Threading.Thread.Abort%2A> が中止されたスレッドを必要とする、デッドロックが発生するロックを保持します。  
  
 場合 `Abort` と呼びますが開始されていないスレッドでスレッドを中止とき <xref:System.Threading.Thread.Start%2A> が呼び出されます。 場合 `Abort` と呼びますがブロックされているまたはスリープ状態のスレッドでスレッドが中断され、中止します。  
  
 場合 `Abort` 中断されたスレッドで呼び出される、 <xref:System.Threading.ThreadStateException> を呼び出したスレッドでスローされた <xref:System.Threading.Thread.Abort%2A>, 、および <xref:System.Threading.ThreadState.AbortRequested> に追加、 <xref:System.Threading.Thread.ThreadState%2A> 中止するスレッドのプロパティです。 A <xref:System.Threading.ThreadAbortException> まで中断されたスレッドではスローされません <xref:System.Threading.Thread.Resume%2A> が呼び出されます。  
  
 場合 `Abort` 、アンマネージ コードの実行中にマネージ スレッドで呼び出される、 `ThreadAbortException` 、スレッドがマネージ コードに戻るまではスローされません。  
  
 2 回の呼び出しをする場合 `Abort` ものでは、同時に 1 回の呼び出しの状態情報を設定すると、その他の呼び出しを実行することは、 `Abort`です。 ただし、アプリケーションは、このような状況を検出することはできません。  
  
 後に `Abort` が呼び出されるスレッドの状態に含まれる、スレッドで <xref:System.Threading.ThreadState.AbortRequested>します。 成功した呼び出しの結果として、スレッドが終了したら `Abort`, 、スレッドの状態に変更 <xref:System.Threading.ThreadState.Stopped>します。 十分なアクセス許可を持つスレッドがのターゲットである、 `Abort` abort を使用して、取り消すことができます、 `ResetAbort` メソッドです。 呼び出すことを示す例については、 `ResetAbort` メソッドを参照してください、 `ThreadAbortException` クラスです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">中止しようとしているスレッドが現在中断されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for advanced operations on threads. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">中止するスレッドで使用できる、状態などのアプリケーション固有の情報を格納するオブジェクト。</param>
        <summary>このメソッドが呼び出された対象のスレッドで、スレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。またスレッドの終了に関する例外情報も提供します。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スローされますスレッドでこのメソッドが呼び出されると、 <xref:System.Threading.ThreadAbortException> スレッドを中止することで。`ThreadAbortException` アプリケーション コードでキャッチできる特殊な例外の最後に再スローされますが、 `catch` しない限り、ブロック <xref:System.Threading.Thread.ResetAbort%2A> が呼び出されます。`ResetAbort` 中止するには要求を取り消したを防止し、 `ThreadAbortException` がスレッドを終了します。 実行されていない `finally` 、スレッドが中止される前に、ブロックは実行されます。  
  
> [!NOTE]
>  スレッドを呼び出すと `Abort` 自体には効果は例外をスローすることに似ています、 <xref:System.Threading.ThreadAbortException> を即座に、実行され、結果は予測可能です。 ただし、1 つのスレッドを呼び出す場合 `Abort` どのようなコードが実行されているが、中止別のスレッドで中断します。 静的コンス トラクターが中断されることはありません。 まれなケースでは、そのアプリケーション ドメインで作成されているがそのクラスのインスタンスをしないこのあります。 スレッドを終了させる可能性がある .NET Framework バージョン 1.0 および 1.1 では、中に、 `finally` ブロックが実行されている、この場合、 `finally` ブロックが中止されました。  
  
 スレッドは、すぐに、またはまったくを中止するは保証されません。 このような状況は、スレッドが無制限で計算の場合に発生することができます、 `finally` アボート プロシージャは、無期限のために中止が遅れるの一部として呼び出されるブロックします。 スレッドが中止されるまで待機するを呼び出すことができます、 <xref:System.Threading.Thread.Join%2A> メソッドを呼び出した後、スレッド、 <xref:System.Threading.Thread.Abort%2A> メソッド、待機が終了される保証はありません。  
  
> [!NOTE]
>  呼び出すスレッド <xref:System.Threading.Thread.Abort%2A> 場合は、コードの保護領域になっているなど、中止中のスレッドをブロックする可能性があります、 `catch` ブロック、 `finally` ブロック、または制約された実行領域です。 かどうかは、スレッドを呼び出す <xref:System.Threading.Thread.Abort%2A> が中止されたスレッドを必要とする、デッドロックが発生するロックを保持します。  
  
 場合 `Abort` と呼びますが開始されていないスレッドでスレッドを中止とき <xref:System.Threading.Thread.Start%2A> が呼び出されます。 場合 `Abort` と呼びますがブロックされているまたはスリープ状態のスレッドでスレッドが中断され、中止します。  
  
 場合 `Abort` 中断されたスレッドで呼び出される、 <xref:System.Threading.ThreadStateException> を呼び出したスレッドでスローされた <xref:System.Threading.Thread.Abort%2A>, 、および <xref:System.Threading.ThreadState.AbortRequested> に追加、 <xref:System.Threading.Thread.ThreadState%2A> 中止するスレッドのプロパティです。 A <xref:System.Threading.ThreadAbortException> まで中断されたスレッドではスローされません <xref:System.Threading.Thread.Resume%2A> が呼び出されます。  
  
 場合 `Abort` 、アンマネージ コードの実行中にマネージ スレッドで呼び出される、 `ThreadAbortException` 、スレッドがマネージ コードに戻るまではスローされません。  
  
 2 回の呼び出しをする場合 `Abort` ものでは、同時に 1 回の呼び出しの状態情報を設定すると、その他の呼び出しを実行することは、 `Abort`です。 ただし、アプリケーションは、このような状況を検出することはできません。  
  
 後に `Abort` が呼び出されるスレッドの状態に含まれる、スレッドで <xref:System.Threading.ThreadState.AbortRequested>します。 成功した呼び出しの結果として、スレッドが終了したら `Abort`, 、スレッドの状態に変更 <xref:System.Threading.ThreadState.Stopped>します。 十分なアクセス許可を持つスレッドがのターゲットである、 `Abort` abort を使用して、取り消すことができます、 `ResetAbort` メソッドです。 呼び出すことを示す例については、 `ResetAbort` メソッドを参照してください、 `ThreadAbortException` クラスです。  
  
   
  
## 例  
 次のコード例では、中止中のスレッドに情報を渡す方法を示します。  
  
 [!code-cpp[System.Threading.Thread.Abort2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">中止しようとしているスレッドが現在中断されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for advanced operations on threads. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>無名のデータ スロットをすべてのスレッドに割り当てます。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>すべてのスレッドに割り当てられた名前付きのデータ スロット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ \(TLS\) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド \(でマークされているフィールドは、 <xref:System.ThreadStaticAttribute> 属性\) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりもパフォーマンスが大幅に向上を提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。 [Thread Local Storage: Thread\-Relative Static Fields and Data Slots](http://msdn.microsoft.com/ja-jp/c633a4dc-a790-4ed1-96b5-f72bd968b284)します。  
  
 スロットのすべてのスレッドが割り当てられます。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ機構を使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができます、格納および取得するデータのスロット内の値し、スレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 他のスレッド \(子スレッドであっても\) はそのデータを取得できません。  
  
   
  
## 例  
 このセクションでは、2 つのコード例を示します。 最初の例でマークされているフィールドを使用する方法、 <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持する属性です。 2 番目の例では、データ スロットを使用して同じことを実現する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持します。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次のコード例では、スレッド固有の情報を格納するデータ スロットを使用する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.DataSlot\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">割り当てられるデータ スロットの名前。</param>
        <summary>名前付きのデータ スロットをすべてのスレッドに割り当てます。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>すべてのスレッドに割り当てられた名前付きのデータ スロット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ \(TLS\) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド \(でマークされているフィールドは、 <xref:System.ThreadStaticAttribute> 属性\) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりもパフォーマンスが大幅に向上を提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。 [Thread Local Storage: Thread\-Relative Static Fields and Data Slots](http://msdn.microsoft.com/ja-jp/c633a4dc-a790-4ed1-96b5-f72bd968b284)します。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ機構を使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができます、格納および取得するデータのスロット内の値し、スレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 他のスレッド \(子スレッドであっても\) はそのデータを取得できません。  
  
 使用する必要はありません、 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドなので、名前付きデータ スロットの割り当てを <xref:System.Threading.Thread.GetNamedDataSlot%2A> メソッドは、既に割り当てられていない場合に、スロットを割り当てます。  
  
> [!NOTE]
>  場合、 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドを使用して、指定した名前を使用して、スロットが既に割り当てられている場合は、例外をスローためプログラムの起動時にメイン スレッドで呼び出すようにします。 スロットが既に割り当てられているかどうかをテストする方法はありません。  
  
 このメソッドで割り当てられたスロットはによって解放する必要があります <xref:System.Threading.Thread.FreeNamedDataSlot%2A>します。  
  
   
  
## 例  
 このセクションでは、2 つのコード例を示します。 最初の例でマークされているフィールドを使用する方法、 <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持する属性です。 2 番目の例では、データ スロットを使用して同じことを実現する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持します。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
> [!NOTE]
>  例のコードで使用しない、 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッド、ため、 <xref:System.Threading.Thread.GetNamedDataSlot%2A> メソッドは、既に割り当てられていない場合に、スロットを割り当てます。 場合、 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドを使用して、プログラムの起動時にメイン スレッドで呼び出す必要があります。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された名前の名前付きデータ スロットは、すでに存在します。</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドのアパートメント状態を取得または設定します。</summary>
        <value>
          <see cref="T:System.Threading.ApartmentState" /> 値のいずれか。 初期値は <see langword="Unknown" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 **The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**  The non\-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.  
  
 In the .NET Framework versions 1.0 and 1.1, the **languageKeyword tag is not supported!!!!**  
 property marks a thread to indicate that it will execute in a single\-threaded or multithreaded apartment. This property can be set when the thread is in the **languageKeyword tag is not supported!!!!**  
 or **languageKeyword tag is not supported!!!!**  
 thread state; however, it can be set only once for a thread. If the property has not been set, it returns **languageKeyword tag is not supported!!!!**  
.  
  
 An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored. However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.  
  
> [!IMPORTANT]
>  In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=fullName> if their apartment state has not been set before they are started. The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=fullName> by default. You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=fullName> by setting the <xref:System.Threading.ApartmentState?displayProperty=fullName> property on the first line of code. Use the <xref:System.STAThreadAttribute> instead.  
  
 In the .NET Framework version 2.0, you can specify the COM threading model for a C\+\+ application using the [\/CLRTHREADATTRIBUTE \(Set CLR Thread Attribute\)](http://msdn.microsoft.com/ja-jp/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.  
  
   
  
## 例  
 The following code example demonstrates how to set the apartment state of a thread.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このプロパティを、有効ではないアパートメント状態に設定しようとしました \(シングル スレッド アパートメント \(<see langword="STA" />\) またはマルチ スレッド アパートメント \(<see langword="MTA" />\) 以外の状態\)。</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドの中止または処理されない例外の影響によりアプリケーション ドメイン内の他のタスクが悪影響を受ける可能性があるコード領域に実行が入ることをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Microsoft SQL Server 2005 などの共通言語ランタイム \(CLR\) のホストには、コードの重要な重要ではない領域のエラーはさまざまなポリシーを確立できます。 クリティカル領域でのスレッドの中止または処理されない例外の影響がありますに限定されない、現在のタスクです。 対照的に、中止またはエラー コードの致命的でない領域では、エラーが発生したタスクのみに影響します。  
  
 たとえば、ロックの保持中にメモリ割り当てを試行するタスクがあるとします。 メモリの割り当てが失敗するがの安定性を確保するのに十分で、現在のタスクを中止していますが、 <xref:System.AppDomain>, 、同じロックを待機しているドメイン内の他のタスクがあることができますあるためです。 現在のタスクが終了した場合、他のタスクがデッドロック可能性があります。  
  
 クリティカル領域で、障害が発生したときに、ホスト場合、全体をアンロード <xref:System.AppDomain> 可能性のある不安定な状態で実行を継続する危険を冒すよりもします。 コードがクリティカル領域を入力することをホストに通知、するために呼び出す <xref:System.Threading.Thread.BeginCriticalRegion%2A>します。 呼び出す <xref:System.Threading.Thread.EndCriticalRegion%2A> と実行、致命的でないコード領域を返します。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。  
  
   
  
## 例  
 次の例では、使用、 <xref:System.Threading.Thread.BeginCriticalRegion%2A> と <xref:System.Threading.Thread.EndCriticalRegion%2A> 重要および重大でない領域のコード ブロックに分割する方法です。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>マネージ コードが現在のオペレーティング システムの物理スレッドの ID に依存する命令の実行を開始することをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Microsoft SQL Server 2005 などの共通言語ランタイムの一部のホストでは、独自のスレッド管理を提供します。 独自のスレッド管理を提供するホストに移動できます実行中のタスク 1 つのオペレーティング システムの物理スレッドから別いつでも。 ほとんどのタスクは、この切り替えでは受けません。 ただし、いくつかのタスクはスレッド アフィニティを持つ \- は、オペレーティング システムの物理スレッドの id に依存します。 これらのタスクは、切り替えてはいけないのコードを実行するときをホストに通知する必要があります。  
  
 例については、オペレーティング システムを取得するアプリケーション呼び出しシステム API をロックする場合、Win32 CRITICAL\_SECTION などのスレッドの関係のあるを呼び出す必要があります <xref:System.Threading.Thread.BeginThreadAffinity%2A> 、ロックを取得する前に、 <xref:System.Threading.Thread.EndThreadAffinity%2A> ロックを解放します。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。  
  
   
  
## 例  
 次の例では、使用、 <xref:System.Threading.Thread.BeginThreadAffinity%2A> と <xref:System.Threading.Thread.EndThreadAffinity%2A> メソッドのコード ブロックは、オペレーティング システムの物理スレッドの id に依存しているホストに通知します。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドが実行されている現在のコンテキストを取得します。</summary>
        <value>現在のスレッド コンテキストを表す <see cref="T:System.Runtime.Remoting.Contexts.Context" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのカルチャを取得または設定します。</summary>
        <value>現在のスレッドでカルチャを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName> property to learn how a thread's default culture is determined, and how users set culture information for their computers.  
  
 Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture. This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values \(in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties\) now reflect the specific culture that is associated with the neutral culture. In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.  
  
   
  
## 例  
 The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  
  
 [!code-cpp[System.Threading.Thread.Culture\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティが <see langword="null" /> に設定されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for setting the property. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ロールベースのセキュリティに関する、スレッドの現在のプリンシパルを取得または設定します。</summary>
        <value>セキュリティ コンテキストを表す <see cref="T:System.Security.Principal.IPrincipal" /> 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following code example shows how to set and retrieve the principal of a thread.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、プリンシパルを設定するために必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to manipulate the principal object. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中のスレッドを取得します。</summary>
        <value>現在実行中のスレッドを表す <see cref="T:System.Threading.Thread" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.  
  
 Note that while the application runs on a foreground thread, each task runs on a thread pool thread.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実行時にカルチャ固有のリソースを検索するためにリソース マネージャーで使用される、現在のカルチャを取得または設定します。</summary>
        <value>現在のカルチャを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property to learn how a thread's default UI culture is determined.  
  
 The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture. Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName>. Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.  
  
> [!NOTE]
>  The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method throws <xref:System.ArgumentException> for the neutral cultures "zh\-Hant" \("zh\-CHT"\) and "zh\-Hans" \("zh\-CHS"\).  
  
   
  
## 例  
 The following example determines whether the language of the current thread's UI culture is French. If it is not, it sets the UI culture of the current thread to English \(United States\).  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  
  
 [!code-cpp[System.Threading.Thread.Culture\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティが <see langword="null" /> に設定されています。</exception>
        <exception cref="T:System.ArgumentException">プロパティが、リソース ファイルの検索に使用できないカルチャ名に設定されています。 リソース ファイル名に使用できるのは、文字、数字、ハイフン、またはアンダースコアのみです。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのランタイム呼び出し可能ラッパー \(RCW: Runtime Callable Wrapper\) の自動クリーンアップをオフにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 By default, the common language runtime \(CLR\) cleans up runtime callable wrappers automatically. The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:  
  
-   The application does its own message pumping.  
  
-   The application needs to control precisely when message pumping occurs.  
  
 Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.  
  
 When this method has been called on a thread, automatic cleanup cannot be re\-enabled for that thread. When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName> method to instruct the runtime to clean up all runtime callable wrappers in the current context. Message pumping occurs while the method executes.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドの中止または処理されない例外の影響が現在のタスクだけに及ぶコード領域に実行が入ることをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Hosts of the common language runtime \(CLR\), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non\-critical regions of code. A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task. By contrast, an abort or failure in a non\-critical region of code affects only the task in which the error occurs.  
  
 For example, consider a task that attempts to allocate memory while holding a lock. If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock. If the current task is terminated, other tasks could be deadlocked.  
  
 When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state. To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non\-critical region of code.  
  
 Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.  
  
   
  
## 例  
 The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non\-critical regions.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>マネージ コードが現在のオペレーティング システムの物理スレッドの ID に依存する命令の実行を完了したことをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management. A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time. Most tasks are not affected by this switching. However, some tasks have thread affinity \- that is, they depend on the identity of a physical operating system thread. These tasks must inform the host when they execute code that should not be switched.  
  
 For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL\_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.  
  
 Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.  
  
   
  
## 例  
 The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのさまざまなコンテキストに関する情報を格納する <see cref="T:System.Threading.ExecutionContext" /> オブジェクトを取得します。</summary>
        <value>現在のスレッドのコンテキスト情報を統合する <see cref="T:System.Threading.ExecutionContext" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution. This includes security context, call context, synchronization context, localization context, and transaction context.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ガベージ コレクターが <see cref="T:System.Threading.Thread" /> を再利用しているときに、リソースが解放され、他のクリーンアップ操作が確実に実行されるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ガベージ コレクター <xref:System.Threading.Thread.Finalize%2A> と現在のオブジェクトが完了する準備ができています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">解放されるデータ スロットの名前。</param>
        <summary>プロセス内のすべてのスレッドに関して、名前とスロットの関連付けを解除します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ \(TLS\) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド \(でマークされているフィールドは、 <xref:System.ThreadStaticAttribute> 属性\) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりもパフォーマンスが大幅に向上を提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。 [Thread Local Storage: Thread\-Relative Static Fields and Data Slots](http://msdn.microsoft.com/ja-jp/c633a4dc-a790-4ed1-96b5-f72bd968b284)します。  
  
 いずれかのスレッドの呼び出し後 `FreeNamedDataSlot`, を呼び出すその他のスレッド <xref:System.Threading.Thread.GetNamedDataSlot%2A> と同じ名前は、名前に関連付けられている新しいスロットを割り当てます。 後続の呼び出しに対して `GetNamedDataSlot` 任意のスレッドでは、新しいスロットを返します。 ただし、すべてのスレッドをまだ、 <xref:System.LocalDataStoreSlot?displayProperty=fullName> を以前の呼び出しで返される `GetNamedDataSlot` 引き続き古いスロットを使用できます。  
  
 名前に関連付けられているスロットが解放される場合にのみすべて `LocalDataStoreSlot` への呼び出しの前に取得された `FreeNamedDataSlot` リリースされ、ガベージ コレクションします。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ機構を使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができます、格納および取得するデータのスロット内の値し、スレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 他のスレッド \(子スレッドであっても\) はそのデータを取得できません。  
  
   
  
## 例  
 このセクションでは、2 つのコード例を示します。 最初の例でマークされているフィールドを使用する方法、 <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持する属性です。 2 番目の例では、データ スロットを使用して同じことを実現する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持します。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アパートメント状態を示す <see cref="T:System.Threading.ApartmentState" /> 値を返します。</summary>
        <returns>マネージ スレッドのアパートメント状態を示す <see cref="T:System.Threading.ApartmentState" /> 値の 1 つ。 既定値は、<see cref="F:System.Threading.ApartmentState.Unknown" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドと共に、 <xref:System.Threading.Thread.SetApartmentState%2A> メソッドおよび <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドでは、置換、 <xref:System.Threading.Thread.ApartmentState%2A> プロパティです。  
  
   
  
## 例  
 次のコード例を示しています、 <xref:System.Threading.Thread.GetApartmentState%2A>, 、<xref:System.Threading.Thread.SetApartmentState%2A>, 、および <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドです。 コード例では、スレッドを作成します。 スレッドを開始する前に <xref:System.Threading.Thread.GetApartmentState%2A> 初期が表示されます <xref:System.Threading.ApartmentState.Unknown?displayProperty=fullName> 状態と <xref:System.Threading.Thread.SetApartmentState%2A> 状態を変更して <xref:System.Threading.ApartmentState.STA?displayProperty=fullName>します。<xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドが戻ります `false` に状態を変更しようとしています。 <xref:System.Threading.ApartmentState.MTA?displayProperty=fullName> アパートメント状態が既に設定されているためです。 同じ操作を試行されていた場合 <xref:System.Threading.Thread.SetApartmentState%2A>, 、<xref:System.InvalidOperationException> がスローされました。  
  
 スレッドが開始した後、 <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドをもう一度使用されます。 スロー時刻をこの <xref:System.Threading.ThreadStateException> 、スレッドが既に開始されているためです。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのスタックをキャプチャするために使用できる <see cref="T:System.Threading.CompressedStack" /> オブジェクトを返します。</summary>
        <returns>なし。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは現在サポートされません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">すべての場合。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">値の取得元の <see cref="T:System.LocalDataStoreSlot" />。</param>
        <summary>現在のスレッドの現在のドメイン内で指定した現在のスレッドのスロットから値を取得します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>取得された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ \(TLS\) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド \(でマークされているフィールドは、 <xref:System.ThreadStaticAttribute> 属性\) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりもパフォーマンスが大幅に向上を提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。 [Thread Local Storage: Thread\-Relative Static Fields and Data Slots](http://msdn.microsoft.com/ja-jp/c633a4dc-a790-4ed1-96b5-f72bd968b284)します。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ機構を使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができます、格納および取得するデータのスロット内の値し、スレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 他のスレッド \(子スレッドであっても\) はそのデータを取得できません。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> `Shared` メソッドの呼び出しでは、別のスレッドを参照する変数を使用する場合でも常に実行中のスレッドに適用されます。 混乱を避けるためを呼び出すときに、クラス名を使って `Shared` メソッド: `Dim test As Object = Thread.GetData(testSlot)`です。  
  
   
  
## 例  
 このセクションでは、2 つのコード例を示します。 最初の例でマークされているフィールドを使用する方法、 <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持する属性です。 2 番目の例では、データ スロットを使用して同じことを実現する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持します。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、スレッド固有の情報を格納するデータ スロットを使用する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.DataSlot\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドが実行されている現在のドメインを返します。</summary>
        <returns>実行中のスレッドの現在のアプリケーション ドメインを表す <see cref="T:System.AppDomain" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例の ID と名前を取得する方法を示しています、 `AppDomain` スレッドを実行しています。  
  
 [!code-cpp[System.Threading.Thread.Domain\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>一意のアプリケーション ドメイン識別子を返します。</summary>
        <returns>アプリケーション ドメインを一意に識別する 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例の ID と名前を取得する方法を示しています、 `AppDomain` スレッドを実行しています。  
  
 [!code-cpp[System.Threading.Thread.Domain\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのハッシュ コードを返します。</summary>
        <returns>整数ハッシュ コード値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ハッシュ コードは、一意であることは保証されません。 使用して、 <xref:System.Threading.Thread.ManagedThreadId%2A> プロパティのマネージ スレッドの一意の識別子が必要な場合です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">ローカル データ スロットの名前。</param>
        <summary>名前付きデータ スロットを検索します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>このスレッドに割り当てられた <see cref="T:System.LocalDataStoreSlot" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ \(TLS\) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド \(でマークされているフィールドは、 <xref:System.ThreadStaticAttribute> 属性\) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりもパフォーマンスが大幅に向上を提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。 [Thread Local Storage: Thread\-Relative Static Fields and Data Slots](http://msdn.microsoft.com/ja-jp/c633a4dc-a790-4ed1-96b5-f72bd968b284)します。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ機構を使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができます、格納および取得するデータのスロット内の値し、スレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 他のスレッド \(子スレッドであっても\) はそのデータを取得できません。  
  
 名前付きスロットが存在しない場合は、新しいスロットが割り当てられます。 名前付きデータ スロットは、パブリックだれでも操作できます。  
  
   
  
## 例  
 このセクションでは、2 つのコード例を示します。 最初の例でマークされているフィールドを使用する方法、 <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持する属性です。 2 番目の例では、データ スロットを使用して同じことを実現する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持します。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see langword="WaitSleepJoin" /> スレッド状態のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このスレッドが待機、スリープ、または結合状態で現在ブロックされていない場合は、次にブロックを開始すると中断されます。  
  
 <xref:System.Threading.ThreadInterruptedException> 中断されたスレッドがそのスレッドはブロックまでがスローされます。 スレッドがブロックされない場合は、例外が返されないとため、スレッドが中断されることがなく完了ことがあります。  
  
   
  
## 例  
 次のコード例が中断され、その後ブロックされたときに、実行中のスレッドの動作を示します。  
  
 [!code-cpp[System.Threading.Thread.Interrupt\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for advanced operations on threads. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの実行ステータスを示す値を取得します。</summary>
        <value>このスレッドが起動していて、正常終了しておらず中止されてもいない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドがバックグラウンド スレッドであるかどうかを示す値を取得または設定します。</summary>
        <value>このスレッドがバックグラウンド スレッドである場合またはバックグラウンド スレッドになる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッドは、バック グラウンド スレッドまたはフォア グラウンド スレッドのいずれかです。 バック グラウンド スレッドは、バック グラウンド スレッドいなくても、プロセスが終了する点を除いて、フォア グラウンド スレッドと同じです。 プロセスに属するすべてのフォア グラウンド スレッドが終了すると、共通言語ランタイムは、プロセスを終了します。 残りのバック グラウンド スレッドは停止し、完了しません。  
  
 既定では、次のスレッドをフォア グラウンドで実行 \(つまり、その<xref:System.Threading.Thread.IsBackground%2A>プロパティから返される`false`\)。  
  
-   プライマリ スレッド \(またはメイン アプリケーション スレッド\)。  
  
-   呼び出して作成されたすべてのスレッド、<xref:System.Threading.Thread>クラスのコンス トラクターです。  
  
 既定では、次のスレッドがバック グラウンドで実行 \(つまり、その<xref:System.Threading.Thread.IsBackground%2A>プロパティから返される`true`\)。  
  
-   ランタイムによって管理されるワーカー スレッドのプールは、プールのスレッドをスレッドです。 スレッド プールのスレッドでスレッド プールとスケジュールの作業を構成するにを使用して、<xref:System.Threading.ThreadPool>クラスです。  
  
    > [!NOTE]
    >  タスク ベースの非同期操作は、スレッド プールのスレッドで自動的に実行します。  
  
-   すべてのスレッドをアンマネージ コードからマネージ実行環境を入力します。  
  
   
  
## 例  
 次の例では、フォア グラウンドとバック グラウンド スレッドの動作を比較します。 これは、フォア グラウンド スレッドとバック グラウンド スレッドを作成します。 フォア グラウンド スレッドを保持するまで実行中のプロセスが完了したその`for`ループし、終了します。 ただし、例からの出力では、フォア グラウンド スレッドの実行が完了しましたので、バック グラウンド スレッドの実行が完了する前のプロセスでは終了します。  
  
 [!code-cpp[System.Threading.Thread.IsBackground\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが動作していません</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドがマネージ スレッド プールに所属しているかどうかを示す値を取得します。</summary>
        <value>このスレッドがマネージ スレッド プールに所属している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 詳細については、「[The Managed Thread Pool](http://msdn.microsoft.com/ja-jp/2be05b06-a42e-4c9d-a739-96c21d673927)」を参照してください。  
  
   
  
## 例  
 次のコード例では、スレッドがスレッド プールからかどうかを判断する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスが表すスレッドが終了するまで、呼び出し元のスレッドをブロックします。標準 COM および <see langword="SendMessage" /> ポンピングの実行は継続されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.Join%2A>スレッドまで \(つまり、メソッドを呼び出すスレッド\) の呼び出し元のスレッドをブロックする同期の方法を<xref:System.Threading.Thread.Join%2A>メソッドが呼び出されたが完了しました。 このメソッドを使用して、スレッドが終了したことを確認してください。 スレッドが終了しない場合、呼び出し元が無期限にブロックされます。 次の例で、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、により、`Thread1`されるまでブロックする`Thread2`しました。  
  
 [!code-csharp[System.Threading.Thread.Join\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 スレッドが既に終了した場合場合<xref:System.Threading.Thread.Join%2A>が呼び出されると、メソッドはすぐに返します。  
  
> [!WARNING]
>  呼び出さないでの<xref:System.Threading.Thread.Join%2A>のメソッドの<xref:System.Threading.Thread>を現在のスレッドから、現在のスレッドを表すオブジェクト。 これにより、現在のスレッドはそれ自体に無期限に待機するためにハングするアプリ  
  
 このメソッドを含めるには、呼び出し元のスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=fullName>です。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState.Unstarted?displayProperty=fullName>状態です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">呼び出し元が、<see cref="F:System.Threading.ThreadState.Unstarted" /> 状態のスレッドを結合しようとしました。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">待機中にスレッドが中断されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">スレッドが終了するまでの待機時間を表すミリ秒数。</param>
        <summary>このインスタンスが表すスレッドが終了するまで、または指定された時間が経過するまで、呼び出し元のスレッドをブロックします。標準 COM\/SendMessage ポンピングの実行は継続されます。</summary>
        <returns>スレッドが終了した場合は <see langword="true" />。<paramref name="millisecondsTimeout" /> パラメーターで指定した時間が経過してもスレッドが終了していない場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.Join%28System.Int32%29>どちらスレッドまで \(つまり、メソッドを呼び出すスレッド\) の呼び出し元のスレッドをブロックする同期の方法を<xref:System.Threading.Thread.Join%2A>メソッドが呼び出された完了またはタイムアウト間隔が経過しました。 次の例で、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、により、`Thread1`までいずれかをブロックする`Thread2`完了が 2 秒が経過したか。  
  
 [!code-csharp[System.Threading.Thread.Join\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 場合<xref:System.Threading.Timeout.Infinite?displayProperty=fullName>が指定されて、`millisecondsTimeout`パラメーターでは、このメソッドの動作と同じように、<xref:System.Threading.Thread.Join>メソッドのオーバー ロードで戻り値を除く。  
  
 スレッドが既に終了した場合場合<xref:System.Threading.Thread.Join%2A>が呼び出されると、メソッドはすぐに返します。  
  
 このメソッドを含めるには、呼び出し元のスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=fullName>です。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState.Unstarted?displayProperty=fullName>状態です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> の値が負の値であり、<see cref="F:System.Threading.Timeout.Infinite" /> \(ミリ秒単位\) と等しくありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドは開始していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">スレッドが終了するのを待機する時間に設定される <see cref="T:System.TimeSpan" />。</param>
        <summary>このインスタンスが表すスレッドが終了するまで、または指定された時間が経過するまで、呼び出し元のスレッドをブロックします。標準 COM\/SendMessage ポンピングの実行は継続されます。</summary>
        <returns>スレッドが終了した場合は <see langword="true" />。<paramref name="timeout" /> パラメーターで指定した時間が経過してもスレッドが終了していない場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29>かスレッドまで \(つまり、メソッドを呼び出すスレッド\) の呼び出し元のスレッドをブロックする同期の方法が<xref:System.Threading.Thread.Join%2A>メソッドが呼び出されたが完了したか、タイムアウト間隔が経過します。 次の例で、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、これにより`Thread1`までいずれかをブロックする`Thread2`が完了した 2 秒が経過したか。  
  
 [!code-csharp[System.Threading.Thread.Join\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 場合<xref:System.Threading.Timeout.Infinite?displayProperty=fullName>が指定されて`timeout`、このメソッドの動作と同じように、<xref:System.Threading.Thread.Join>メソッドのオーバー ロードで戻り値を除く。  
  
 スレッドが既に終了した場合場合<xref:System.Threading.Thread.Join%2A>が呼び出されると、メソッドはすぐに返します。  
  
 このメソッドを含めるには、現在のスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin>です。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState.Unstarted?displayProperty=fullName>状態です。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、`TimeSpan`値と、`Join`メソッドです。  
  
 [!code-cpp[System.Threading.Thread.Timespan\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> の値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> \(ミリ秒単位\) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</exception>
        <exception cref="T:System.Threading.ThreadStateException">呼び出し元が、<see cref="F:System.Threading.ThreadState.Unstarted" /> 状態のスレッドを結合しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のマネージ スレッドの一意の識別子を取得します。</summary>
        <value>このマネージ スレッドの一意の識別子を表す整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.  
  
 The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メモリ アクセスを同期します。現在のスレッドを実行中のプロセッサは、<see cref="M:System.Threading.Thread.MemoryBarrier" /> を呼び出す前のメモリ アクセスを <see cref="M:System.Threading.Thread.MemoryBarrier" /> の呼び出し後のメモリ アクセスより後に実行するように命令を並べ替えることはできなくなります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.MemoryBarrier%2A> 脆弱なメモリの量が \(たとえば、複数の Intel Itanium プロセッサを使用しているシステム\) の順序、マルチプロセッサ システムでのみ必要です。  
  
 ほとんどの場合、c\#、 `lock` ステートメント、Visual Basic `SyncLock` ステートメント、または <xref:System.Threading.Monitor> クラスは、簡単にデータを同期する方法を提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドの名前を取得または設定します。</summary>
        <value>スレッドの名前を含む文字列。名前が設定されていない場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This property is write\-once. Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is **languageKeyword tag is not supported!!!!**  
, you can determine whether a name has already been explicitly assigned to the thread by comparing it with **languageKeyword tag is not supported!!!!**  
.  
  
 The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.  
  
   
  
## 例  
 The following example shows how to name a thread.  
  
 [!code-cpp[System.Threading.Thread.Name\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">設定操作が要求されましたが、<see langword="Name" /> プロパティは既に設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドのスケジューリング優先順位を示す値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Threading.ThreadPriority" /> 値のいずれか。 既定値は <see cref="F:System.Threading.ThreadPriority.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の優先順位のいずれかのスレッドを割り当てることができる <xref:System.Threading.ThreadPriority> 値。  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 オペレーティング システムは、スレッドの優先度を優先する必要はありません。  
  
   
  
## 例  
 次の例では、スレッドの優先度の変更の結果を示します。 3 つのスレッドが作成されると、1 つのスレッドの優先度に設定されている <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=fullName>, とに 1 秒あたりの優先順位が設定されている <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=fullName>します。 各スレッドの変数をインクリメントする、 `while` ループし、設定した時刻に実行します。  
  
 [!code-csharp[System.Threading.ThreadPriority\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが、<see cref="F:System.Threading.ThreadState.Aborted" /> などの最終状態に達しました。</exception>
        <exception cref="T:System.ArgumentException">セット操作に対して設定された値が有効な <see cref="T:System.Threading.ThreadPriority" /> 値ではありません。</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドに対して要求された <see cref="M:System.Threading.Thread.Abort(System.Object)" /> を取り消します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、適切なアクセス許可を持つコードによってのみ呼び出すことができます。  
  
 呼び出しが実行されると `Abort` がスローされますスレッドを終了する、 <xref:System.Threading.ThreadAbortException>です。`ThreadAbortException` アプリケーション コードでキャッチできるものが catch ブロックの最後に再スローされる場合を除き、特別な例外は、 `ResetAbort` が呼び出されます。`ResetAbort` 中止するには要求を取り消したを防止し、 `ThreadAbortException` がスレッドを終了します。  
  
 参照してください <xref:System.Threading.ThreadAbortException> を呼び出すことを示す例については、 `ResetAbort` メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <see langword="Abort" /> は現在のスレッドで呼び出されませんでした。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元には、現在のスレッドに対する必要なセキュリティ アクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for advanced operations on threads. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>中断されたスレッドを再開します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!CAUTION]
>  使用しないでください、 <xref:System.Threading.Thread.Suspend%2A> と <xref:System.Threading.Thread.Resume%2A> スレッドの活動を同期する方法です。 中断すると、スレッドは、どのようなコードを実行するかを知る方法があるありません。 その他のスレッドでのセキュリティ アクセス許可の評価中にロックが保持している間にスレッドを中断した場合、 <xref:System.AppDomain> されない可能性があります。 その他のスレッドでのクラスのコンス トラクターの実行中に、スレッドを中断した場合、 <xref:System.AppDomain> クラスがブロックされていることを使用しようとします。 デッドロックは、非常に簡単に発生することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが開始されていないか、実行されていません。または中断状態にはありません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for advanced operations on threads. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">新しいアパートメント状態。</param>
        <summary>スレッドを開始する前にそのアパートメント状態を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しいスレッドとして初期化 <xref:System.Threading.ApartmentState.MTA?displayProperty=fullName> のセッションが開始する前に、そのアパートメント状態が設定されていない場合。 スレッドを開始する前に、アパートメントの状態を設定する必要があります。  
  
> [!NOTE]
>  メイン アプリケーション スレッドを初期化 <xref:System.Threading.ApartmentState.MTA?displayProperty=fullName> 既定です。 メイン アプリケーション スレッドのアパートメント状態を設定する唯一の方法 <xref:System.Threading.ApartmentState.STA?displayProperty=fullName> を適用する、 <xref:System.STAThreadAttribute> 属性をエントリ ポイント メソッド。  
  
 <xref:System.Threading.Thread.SetApartmentState%2A> メソッドと共に、 <xref:System.Threading.Thread.GetApartmentState%2A> メソッドおよび <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドでは、置換、 <xref:System.Threading.Thread.ApartmentState%2A> プロパティです。  
  
   
  
## 例  
 次のコード例を示しています、 <xref:System.Threading.Thread.GetApartmentState%2A>, 、<xref:System.Threading.Thread.SetApartmentState%2A>, 、および <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドです。 コード例では、スレッドを作成します。 スレッドを開始する前に <xref:System.Threading.Thread.GetApartmentState%2A> 初期が表示されます <xref:System.Threading.ApartmentState.Unknown?displayProperty=fullName> 状態と <xref:System.Threading.Thread.SetApartmentState%2A> 状態を変更して <xref:System.Threading.ApartmentState.STA?displayProperty=fullName>します。<xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドが戻ります `false` に状態を変更しようとしています。 <xref:System.Threading.ApartmentState.MTA?displayProperty=fullName> アパートメント状態が既に設定されているためです。 同じ操作を試行されていた場合 <xref:System.Threading.Thread.SetApartmentState%2A>, 、<xref:System.InvalidOperationException> がスローされました。  
  
 スレッドが開始した後、 <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドをもう一度使用されます。 スロー時刻をこの <xref:System.Threading.ThreadStateException> 、スレッドが既に開始されているためです。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> は有効なアパートメント状態ではありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
        <exception cref="T:System.InvalidOperationException">アパートメント状態は、すでに初期化されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">現在のスレッドに適用される <see cref="T:System.Threading.CompressedStack" /> オブジェクト。</param>
        <summary>キャプチャした <see cref="T:System.Threading.CompressedStack" /> を現在のスレッドに適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは現在サポートされません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">すべての場合。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">値を設定する <see cref="T:System.LocalDataStoreSlot" />。</param>
        <param name="data">設定される値です。</param>
        <summary>現在実行中のスレッド上にある指定されたスロット内のデータを、そのスレッドの現在のドメインに設定します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ \(TLS\) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド \(でマークされているフィールドは、 <xref:System.ThreadStaticAttribute> 属性\) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりもパフォーマンスが大幅に向上を提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。 [Thread Local Storage: Thread\-Relative Static Fields and Data Slots](http://msdn.microsoft.com/ja-jp/c633a4dc-a790-4ed1-96b5-f72bd968b284)します。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ機構を使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができます、スロット内の値を格納および取得するデータと、スレッド プロシージャが終了した後の再利用するため、スロットの空き、および <xref:System.Threading.Thread> オブジェクトがガベージ コレクションによって解放されました。 データ スロットは、スレッドごとに一意です。 他のスレッド \(子スレッドであっても\) はそのデータを取得できません。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> `Shared` メソッドの呼び出しでは、別のスレッドを参照する変数を使用する場合でも常に実行中のスレッドに適用されます。 混乱を避けるためを呼び出すときに、クラス名を使って `Shared` メソッド: `Thread.SetData(testSlot, "test data")`です。  
  
   
  
## 例  
 このセクションでは、2 つのコード例を示します。 最初の例でマークされているフィールドを使用する方法、 <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持する属性です。 2 番目の例では、データ スロットを使用して同じことを実現する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します <xref:System.ThreadStaticAttribute> スレッド固有の情報を保持します。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">スレッドが中断ブロックされるミリ秒数。<c>millisecondsTimeout</c> 引数の値が 0 である場合は、スレッドは自らのタイム スライスの残りの部分を放棄し、実行する準備ができている同じ優先順位の他のスレッドに渡します。 優先順位が同じで実行する準備ができている他のスレッドが存在しない場合は、現在のスレッドの実行は中断されません。</param>
        <summary>指定したミリ秒数の間現在のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The thread will not be scheduled for execution by the operating system for the amount of time specified. This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> for the **parameterReference tag is not supported!!!!**  
 parameter to suspend the thread indefinitely. However, we recommend that you use other <xref:System.Threading?displayProperty=fullName> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.  
  
 The system clock ticks at a specific rate called the clock resolution. The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks. For more information on clock resolution and the waiting time, see the [Sleep function](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic. This method calls the [Sleep function](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx) from the Windows system APIs.  
  
 This method does not perform standard COM and SendMessage pumping.  
  
> [!NOTE]
>  If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.  
  
   
  
## 例  
 The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.  
  
 [!code-cpp[Thread.Sleep\#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep\#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">タイムアウト値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> に等しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">スレッドが中断される時間の長さ。<c>millisecondsTimeout</c> 引数の値が <see cref="F:System.TimeSpan.Zero" /> である場合は、スレッドは自らのタイム スライスの残りの部分を放棄し、実行する準備ができている同じ優先順位の他のスレッドに渡します。 優先順位が同じで実行する準備ができている他のスレッドが存在しない場合は、現在のスレッドの実行は中断されません。</param>
        <summary>指定した時間の長さにわたって現在のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The thread will not be scheduled for execution by the operating system for the amount of time specified. This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName> for the **parameterReference tag is not supported!!!!**  
 parameter to suspend the thread indefinitely. However, we recommend that you use other <xref:System.Threading?displayProperty=fullName> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.  
  
 This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in **parameterReference tag is not supported!!!!**  
. Fractional milliseconds are discarded.  
  
 This method does not perform standard COM and SendMessage pumping.  
  
> [!NOTE]
>  If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.  
  
   
  
## 例  
 The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.  
  
 [!code-cpp[Thread.Sleep\_TimeSpan\#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep\_TimeSpan\#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep\_TimeSpan\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> の値が負の値であり、<see cref="F:System.Threading.Timeout.Infinite" /> \(ミリ秒単位\) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">スレッドが待機する時間を定義する 32 ビット符号付き整数。</param>
        <summary>スレッドが、<paramref name="iterations" /> パラメーターで定義される時間だけ待機するようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.SpinWait%2A> メソッドは、ロックを実装するために役立ちます。 などの .NET framework クラス <xref:System.Threading.Monitor> と <xref:System.Threading.ReaderWriterLock>, 、このメソッドを内部的に使用します。<xref:System.Threading.Thread.SpinWait%2A> 基本的にでは、プロセッサを非常に短いループで指定されたループ カウントを含む、 `iterations` パラメーター。 この待機時間は、そのため、プロセッサの速度に依存します。  
  
 これに対し、 <xref:System.Threading.Thread.Sleep%2A> メソッドです。 呼び出すスレッド <xref:System.Threading.Thread.Sleep%2A> 、指定した間隔が 0 の場合でもプロセッサ時間の現在のスライスの残りの部分が得られます。 0 以外の間隔を指定する <xref:System.Threading.Thread.Sleep%2A> 時間間隔が経過するまで、スレッドをスレッド スケジューラによって考慮の対象から削除します。  
  
 <xref:System.Threading.Thread.SpinWait%2A> 通常のアプリケーションの一般的に使用できません。 ほとんどの場合は、.NET Framework によって提供される同期クラスを使用する必要があります。たとえば、 <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> またはラップするステートメント <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> \(`lock` C\# の場合または `SyncLock` Visual Basic で\)。  
  
> [!CAUTION]
>  呼び出しを行うことがわかっている場合、状態の変化が迫っていないかなどのコンテキストの切り替えを避けるために有効な場合もまれなケースで、 <xref:System.Threading.Thread.SpinWait%2A> 、ループ内のメソッドです。 コード <xref:System.Threading.Thread.SpinWait%2A> 実行を複数のプロセッサを搭載したコンピューターで発生する可能性のある問題を防ぐために設計されています。 たとえば、ハイパー スレッディングのテクノロジを採用して複数の Intel プロセッサを搭載したコンピューター上 <xref:System.Threading.Thread.SpinWait%2A> により、特定の状況でプロセッサが不足します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オペレーティング システムによって、現在のインスタンスの状態を <see cref="F:System.Threading.ThreadState.Running" /> に変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=fullName> state, the operating system can schedule it for execution. The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor. Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.  
  
> [!NOTE]
>  If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, **languageKeyword tag is not supported!!!!**  
>  is passed to the method executed by the thread.  
  
 Once the thread terminates, it cannot be restarted with another call to **languageKeyword tag is not supported!!!!**  
.  
  
   
  
## 例  
 The following example creates and starts a thread.  
  
 [!code-cpp[ThreadStart\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリ不足のため、このスレッドを開始できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">スレッドが実行するメソッドで使用するデータを格納するオブジェクト。</param>
        <summary>オペレーティング システムによって現在のインスタンスの状態が <see cref="F:System.Threading.ThreadState.Running" /> に変更され、オプションでスレッドが実行するメソッドで使用するデータを格納するオブジェクトが提供されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=fullName> state, the operating system can schedule it for execution. The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor. Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.  
  
 Once the thread terminates, it cannot be restarted with another call to **languageKeyword tag is not supported!!!!**  
.  
  
 This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload. A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object. For more information, see [Creating Threads](http://msdn.microsoft.com/ja-jp/52b32222-e185-4f42-91a7-eaca65c0ab6d).  
  
   
  
## 例  
 The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリ不足のため、このスレッドを開始できません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.ParameterizedThreadStart" /> デリゲートの代わりに <see cref="T:System.Threading.ThreadStart" /> デリゲートを使用して、このスレッドは作成されました。</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドを中断します。スレッドが既に中断されている場合は効果はありません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッドが既に中断されている場合は、このメソッドは影響を与えません。  
  
> [!CAUTION]
>  使用しないでください、 <xref:System.Threading.Thread.Suspend%2A> と <xref:System.Threading.Thread.Resume%2A> スレッドの活動を同期する方法です。 中断すると、スレッドは、どのようなコードを実行するかを知る方法があるありません。 その他のスレッドでのセキュリティ アクセス許可の評価中にロックが保持している間にスレッドを中断した場合、 <xref:System.AppDomain> されない可能性があります。 その他のスレッドでのクラスのコンス トラクターの実行中に、スレッドを中断した場合、 <xref:System.AppDomain> クラスがブロックされていることを使用しようとします。 デッドロックは、非常に簡単に発生することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが開始していないか、または停止しています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for advanced operations on threads. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetIDsOfNames`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfo`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 \(0 または 1\) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfoCount`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::Invoke`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの状態を示す値を取得します。</summary>
        <value>現在のスレッドの状態を示す <see cref="T:System.Threading.ThreadState" /> 値の 1 つ。 初期値は <see langword="Unstarted" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.  
  
> [!IMPORTANT]
>  Thread state is only of interest in debugging scenarios. Your code should never use thread state to synchronize the activities of threads.  
  
   
  
## 例  
 The following code example demonstrates accessing the **languageKeyword tag is not supported!!!!**  
 of a thread.  
  
 [!code-cpp[System.Threading.Thread.ThreadState\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">新しいアパートメント状態。</param>
        <summary>スレッドを開始する前にそのアパートメント状態を設定します。</summary>
        <returns>アパートメント状態が設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しいスレッドとして初期化 <xref:System.Threading.ApartmentState.MTA?displayProperty=fullName> のセッションが開始する前に、そのアパートメント状態が設定されていない場合。 スレッドを開始する前に、アパートメントの状態を設定する必要があります。  
  
> [!NOTE]
>  メイン アプリケーション スレッドを初期化 <xref:System.Threading.ApartmentState.MTA?displayProperty=fullName> 既定です。 メイン アプリケーション スレッドのアパートメント状態を設定する唯一の方法 <xref:System.Threading.ApartmentState.STA?displayProperty=fullName> を適用する、 <xref:System.STAThreadAttribute> 属性をエントリ ポイント メソッド。  
  
 <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドと共に、 <xref:System.Threading.Thread.GetApartmentState%2A> メソッドおよび <xref:System.Threading.Thread.SetApartmentState%2A> メソッドでは、置換、 <xref:System.Threading.Thread.ApartmentState%2A> プロパティです。  
  
   
  
## 例  
 次のコード例を示しています、 <xref:System.Threading.Thread.GetApartmentState%2A>, 、<xref:System.Threading.Thread.SetApartmentState%2A>, 、および <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドです。 コード例では、スレッドを作成します。 スレッドを開始する前に <xref:System.Threading.Thread.GetApartmentState%2A> 初期が表示されます <xref:System.Threading.ApartmentState.Unknown?displayProperty=fullName> 状態と <xref:System.Threading.Thread.SetApartmentState%2A> 状態を変更して <xref:System.Threading.ApartmentState.STA?displayProperty=fullName>します。<xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドが戻ります `false` に状態を変更しようとしています。 <xref:System.Threading.ApartmentState.MTA?displayProperty=fullName> アパートメント状態が既に設定されているためです。 同じ操作を試行されていた場合 <xref:System.Threading.Thread.SetApartmentState%2A>, 、<xref:System.InvalidOperationException> がスローされました。  
  
 スレッドが開始した後、 <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドをもう一度使用されます。 スロー時刻をこの <xref:System.Threading.ThreadStateException> 、スレッドが既に開始されているためです。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> は有効なアパートメント状態ではありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8 address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64 address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16 address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32 address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64 address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8 address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32 address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16 address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32 address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64 address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileRead%2A> いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8 address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64 address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16 address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32 address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64 address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8 address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32 address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16 address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32 address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64 address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A> は、同期の特殊なケースです。 通常の状況で、c\# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスは、簡単に代替手段を提供します。  
  
 マルチプロセッサ システムで <xref:System.Threading.Thread.VolatileWrite%2A> メモリ位置に書き込まれた値がすべてのプロセッサに対してすぐに表示することを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システムであっても <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> ことを確認して値を読み取るか、メモリに書き込まれます \(たとえば、プロセッサのレジスタ\) にキャッシュされていません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C\# を使用して、 `volatile` フィールドに対する修飾子により、そのフィールドにすべてのアクセスを使うこと <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出し元のスレッドから、現在のプロセッサ上で実行する準備が整っている別のスレッドに実行を切り替えます。 実行の切り替え先のスレッドは、オペレーティング システムによって選択されます。</summary>
        <returns>オペレーティング システムによって実行が別のスレッドに切り替えられた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが成功した場合、スレッドの現在のタイム スライスの残りの部分が返されます。 オペレーティング システムでは、その優先度と実行に使用できるその他のスレッドのステータスに応じて、別のタイム スライスの呼び出し元のスレッドをスケジュールします。  
  
 生成することは、呼び出し元のスレッドを実行しているプロセッサに制限されます。 オペレーティング システムがそのプロセッサがアイドル状態か、優先順位の低いスレッドが実行されている場合でも、実行を別のプロセッサに切り替えられないされます。 現在のプロセッサで実行することができるその他のスレッドがないと、オペレーティング システムが、実行も生成しないおよびこのメソッドが戻る `false`します。  
  
 このメソッドはプラットフォームを使用して呼び出しをネイティブの Win32 `SwitchToThread` 関数です。 呼び出す必要があります、 <xref:System.Threading.Thread.Yield%2A> プラットフォームを使用する代わりにメソッドを呼び出すため、プラットフォーム呼び出しのバイパス、カスタム スレッドの動作は、ホストが必要です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した時間の長さにわたって現在のスレッドを中断します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスが表すスレッドが終了するまで、呼び出し元のスレッドをブロックします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>スレッドの実行をスケジュールします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このメソッドが呼び出された対象のスレッドで、そのスレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>