<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>タスクの実行、作業項目のポスト、非同期 I\/O の処理、他のスレッドの代理で行う待機、およびタイマーの処理に使用できるスレッドのプールを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur. Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information. The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system. Examples of operations that use thread pool threads include the following:  
  
-   When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.  
  
-   Asynchronous timers use the thread pool. Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=fullName> class and raise events from the <xref:System.Timers.Timer?displayProperty=fullName> class.  
  
-   When you use registered wait handles, a system thread monitors the status of the wait handles. When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.  
  
-   When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread. You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.   The delegate has the signature  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     where **parameterReference tag is not supported!!!!**  
     is an object that contains data to be used by the delegate. The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.  
  
> [!NOTE]
>  The threads in the managed thread pool are background threads. That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are **languageKeyword tag is not supported!!!!**  
> . This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.  
  
> [!IMPORTANT]
>  When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute. Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.  
  
 You can also queue work items that are not related to a wait operation to the thread pool. To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method. This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool. There is no way to cancel a work item after it has been queued.  
  
 Timer\-queue timers and registered wait operations also use the thread pool. Their callback functions are queued to the thread pool.  
  
 There is one thread pool per process. Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space. A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads. The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method. Each thread uses the default stack size and runs at the default priority.  
  
> [!NOTE]
>  Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the **unmanagedCodeEntityReference tag is not supported!!!!**  
>  function, defined in the mscoree.h file.  
  
 The thread pool provides new worker threads or I\/O completion threads on demand until it reaches the minimum for each category. When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.  
  
> [!NOTE]
>  When demand is low, the actual number of thread pool threads can fall below the minimum values.  
  
 You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.  
  
> [!CAUTION]
>  You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own algorithm for allocating threads.  
  
   
  
## 例  
 In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  \(This         is a simple example of a race condition.\)  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">ハンドルを保持する <see cref="T:System.IntPtr" />。 ハンドルは、アンマネージ側の重複 I\/O 用に開かれている必要があります。</param>
        <summary>オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</summary>
        <returns>ハンドルがバインドされている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to call unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">オペレーティング システム ハンドルを保持する <see cref="T:System.Runtime.InteropServices.SafeHandle" />。 ハンドルは、アンマネージ側の重複 I\/O 用に開かれている必要があります。</param>
        <summary>オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</summary>
        <returns>ハンドルがバインドされている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The **parameterReference tag is not supported!!!!**  
 parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="osHandle" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to call unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">使用できるワーカー スレッドの数。</param>
        <param name="completionPortThreads">使用できる非同期 I\/O スレッドの数。</param>
        <summary>スレッド プール スレッドの最大数 \(<see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> メソッドから返される\) と現在アクティブなスレッドの数との差を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>で指定された変数を返します。`workerThreads`を開始する追加のワーカー スレッドとで指定された変数の数を表す`completionPortThreads`を起動するその他の非同期 I\/O スレッドの数が含まれています。  
  
 使用可能なスレッドがない場合は、追加のスレッド プールの要求までキューに置かれたスレッド プールのスレッドが使用可能になるです。  
  
   
  
## 例  
 次の例では、簡単なアプリが開始されたときに、ワーカー スレッドと使用可能な I\/O スレッドの数が表示されます。  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">スレッド プール内のワーカー スレッドの最大数。</param>
        <param name="completionPortThreads">スレッド プール内の非同期 I\/O スレッドの最大数。</param>
        <summary>同時にアクティブにできるスレッド プールへの要求の数を取得します。 この数を超える要求はすべて、スレッド プール スレッドが使用可能になるまでキューに置かれたままになります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> で指定された変数が返される `workerThreads` ワーカー スレッドがスレッド プールで許可されると指定された変数の最大数を格納 `completionPortThreads` スレッド プールで許可される非同期 I\/O スレッドの最大数を格納します。  
  
 使用することができます、 <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> どの時点において、スレッド プール内のスレッドの実際の数を決定する方法です。  
  
 使用することができます、 <xref:System.Threading.ThreadPool.SetMaxThreads%2A> をスレッド プールでワーカー スレッドと非同期 I\/O スレッドの最大数を設定します。  
  
 キューに配置できるようにシステム メモリが許容できる多くのスレッド プールの要求。 スレッド プールのスレッドよりも多くの要求がある場合、追加の要求は、スレッド プールのスレッドが使用可能になるまでキューに置かれたのままです。  
  
   
  
## 例  
 次のコード例では、スレッド プール内のスレッドの最大値と使用可能な数のカウントを取得する方法を示します。 使用する作業項目はキューに配置 `FileStream` 非同期に 2 つのファイルを書き込みます。 オーバー ラップは、コールバック メソッドがタイムアウトしました。 ワーカー スレッドが作業項目を処理し、コンピューター上のプロセッサの数と速度に応じて 1 つまたは 2 つの完了ポート スレッドが書き込み操作を処理します。  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">このメソッドが戻るとき、スレッド プールがオンデマンドで作成するワーカー スレッドの最小数が含まれています。</param>
        <param name="completionPortThreads">このメソッドが戻るとき、スレッド プールがオンデマンドで作成する非同期 I\/O スレッドの最小数が含まれています。</param>
        <summary>スレッドがオンデマンドで \(新しい要求の発生ごとに\) 作成するスレッド プールの数を取得します。この数を超えると、スレッドの作成と破棄を管理するためのアルゴリズムに切り替わります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッド プールは、新しいワーカー スレッドまたは I\/O 完了スレッド要求時に各カテゴリの最小値に達するまでです。 既定では、スレッドの最小数は、システム上のプロセッサの数に設定されます。 最小値に達すると、スレッド プールはそのカテゴリの追加のスレッドを作成または、いくつかのタスクが完了するまで待機できます。 以降で、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 、スレッド プールを作成し、タスクの単位時間あたりの完了数として定義されるスループットを最適化するためにスレッドを破棄します。 スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。  
  
> [!NOTE]
>  要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。  
  
   
  
## 例  
 次の例では、ワーカー スレッドの最小数を 4 に設定し、非同期 I\/O 完了スレッドの最小数の元の値が保持されます。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">実行するメソッドを表す <see cref="T:System.Threading.WaitCallback" />。</param>
        <summary>メソッドを実行するためのキューに置きます。 メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</summary>
        <returns>メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドが定義されている場合、または使用するクラスのインスタンス フィールドでキューに置かれたメソッドで必要なデータを配置する、 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> を必要なデータを格納するオブジェクトを受け入れるオーバー ロードします。  
  
> [!NOTE]
>  Visual Basic の場合は省略できます、 <xref:System.Threading.WaitCallback> コンス トラクター、および使用するだけで、 `AddressOf` 演算子がコールバック メソッドを渡すときに <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>します。 Visual Basic では、適切なデリゲート コンス トラクターは、自動的に呼び出します。  
  
## バージョン情報  
 .NET framework version 2.0 では、 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> プロパティの値がワーカー スレッドに反映されるキューを使用して、 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドです。 以前のバージョンでは、プリンシパルの情報は反映されません。  
  
   
  
## 例  
 次の例では、 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> メソッドのオーバー ロードによって表される、タスクをキューに入れ、 `ThreadProc` メソッドは、スレッドが使用可能なになったときに実行します。 このオーバー ロードでタスク情報は提供されません。 そのために提供される情報、 `ThreadProc` メソッドは、メソッドが属するオブジェクトに制限します。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">共通言語ランタイム \(CLR\) がホストされているし、ホストがこの操作をサポートしていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">実行するメソッドを表す <see cref="T:System.Threading.WaitCallback" />。</param>
        <param name="state">メソッドが使用するデータを格納したオブジェクト。</param>
        <summary>実行するためのキューにメソッドを置き、そのメソッドが使用するデータを含んだオブジェクトを指定します。 メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</summary>
        <returns>メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コールバック メソッドは、複雑なデータを必要とする場合は、データを格納するクラスを定義できます。  
  
> [!NOTE]
>  Visual Basic の場合は省略できます、 <xref:System.Threading.WaitCallback> コンス トラクター、および使用するだけで、 `AddressOf` 演算子がコールバック メソッドを渡すときに <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>します。 Visual Basic では、適切なデリゲート コンス トラクターは、自動的に呼び出します。  
  
## バージョン情報  
 .NET framework version 2.0 では、 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> プロパティの値がワーカー スレッドに反映されるキューを使用して、 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドです。 以前のバージョンでは、プリンシパルの情報は反映されません。  
  
   
  
## 例  
 次の例では、タスクの情報を含むオブジェクトを作成する方法を示します。 また、スレッド プール内にタスクが実行待ちにそのオブジェクトを渡す方法も示します。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">共通言語ランタイム \(CLR\) がホストされているし、ホストがこの操作をサポートしていません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。<see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack">
          <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</param>
        <param name="state">デリゲートに渡されるオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。<c>millisecondsTimeOutInterval</c> パラメーターが 0 \(ゼロ\) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。<c>millisecondsTimeOutInterval</c> が \-1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>ミリ秒単位のタイムアウトとして 32 ビット符号付き整数を指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</summary>
        <returns>ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 終了したらを使用して、 <xref:System.Threading.RegisteredWaitHandle> このメソッドによって返される、呼び出しの <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 待機ハンドルへの参照を解放します。 常に呼び出すことをお勧めします <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドを指定する場合でも `true` の `executeOnlyOnce`です。 ガベージ コレクションより効率的に動作を呼び出す場合、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドの代わりに登録された待機ハンドルのファイナライザーによって異なります。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッド指定のデリゲートをスレッド プール キューに配置します。 次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。  
  
-   指定したオブジェクトがシグナル状態でです。  
  
-   タイムアウト間隔が経過しました。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドの指定されたオブジェクトの現在の状態を調べ、 <xref:System.Threading.WaitHandle>です。 オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。 待機操作は、スレッド プールのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。 場合、 `timeOutInterval` パラメーターではありません 0 \(ゼロ\) と `executeOnlyOnce` パラメーターは `false`, 、イベントがシグナル状態またはタイムアウト期間が経過するたびにタイマーをリセットします。  
  
> [!IMPORTANT]
>  使用して、 <xref:System.Threading.Mutex> の `waitObject` 基になる Win32 API は、既定値を使用するため、コールバックの相互排除を行いません `WT_EXECUTEDEFAULT` フラグを設定、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。 代わりに、 <xref:System.Threading.Mutex>, を使用して、 <xref:System.Threading.Semaphore> 1 の最大数にします。  
  
 待機操作をキャンセルする、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドです。  
  
 待機スレッドが、Win32 を使用して `WaitForMultipleObjects` 登録された待機操作を監視する関数。 そのためで、同じネイティブのオペレーティング システム ハンドルを使用する場合を複数回呼び出す <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, 、Win32 を使用してハンドルを複製する必要があります `DuplicateHandle` 関数です。 渡されるイベント オブジェクトをパルスする必要がありますしないことに注意してください <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, 待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためです。  
  
 、戻る前に、関数は、一部の種類の同期オブジェクトの状態を変更します。 変更は、オブジェクトがシグナル状態には、条件が満たされる待機条件が原因となった場合にのみ発生します。 たとえば、セマフォのカウントは 1 減ります。  
  
## バージョン情報  
 以降、.NET Framework version 2.0 で、 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> プロパティの値がワーカー スレッドに反映されるキューで保持、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドです。 以前のバージョンでは、プリンシパルの情報は反映されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> パラメーターは、\-1 より小さくします。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。<see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack">
          <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</param>
        <param name="state">デリゲートに渡されたオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。<c>millisecondsTimeOutInterval</c> パラメーターが 0 \(ゼロ\) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。<c>millisecondsTimeOutInterval</c> が \-1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>64 ビット符号付き整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</summary>
        <returns>ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 終了したらを使用して、 <xref:System.Threading.RegisteredWaitHandle> このメソッドによって返される、呼び出しの <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 待機ハンドルへの参照を解放します。 常に呼び出すことをお勧めします <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドを指定する場合でも `true` の `executeOnlyOnce`です。 ガベージ コレクションより効率的に動作を呼び出す場合、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドの代わりに登録された待機ハンドルのファイナライザーによって異なります。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッド指定のデリゲートをスレッド プール キューに配置します。 次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。  
  
-   指定したオブジェクトがシグナル状態でです。  
  
-   タイムアウト間隔が経過しました。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドの指定されたオブジェクトの現在の状態を調べ、 <xref:System.Threading.WaitHandle>です。 オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。 待機操作は、スレッド プールのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。 場合、 `timeOutInterval` パラメーターではありません 0 \(ゼロ\) と `executeOnlyOnce` パラメーターは `false`, 、イベントがシグナル状態またはタイムアウト期間が経過するたびにタイマーをリセットします。  
  
> [!IMPORTANT]
>  使用して、 <xref:System.Threading.Mutex> の `waitObject` 基になる Win32 API は、既定値を使用するため、コールバックの相互排除を行いません `WT_EXECUTEDEFAULT` フラグを設定、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。 代わりに、 <xref:System.Threading.Mutex>, を使用して、 <xref:System.Threading.Semaphore> 1 の最大数にします。  
  
 待機操作をキャンセルする、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドです。  
  
 待機スレッドが、Win32 を使用して `WaitForMultipleObjects` 登録された待機操作を監視する関数。 そのためで、同じネイティブのオペレーティング システム ハンドルを使用する場合を複数回呼び出す <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, 、Win32 を使用してハンドルを複製する必要があります `DuplicateHandle` 関数です。 渡されるイベント オブジェクトをパルスする必要がありますしないことに注意してください <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, 待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためです。  
  
 、戻る前に、関数は、一部の種類の同期オブジェクトの状態を変更します。 変更は、オブジェクトがシグナル状態には、条件が満たされる待機条件が原因となった場合にのみ発生します。 たとえば、セマフォのカウントは 1 減ります。  
  
## バージョン情報  
 以降、.NET Framework version 2.0 で、 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> プロパティの値がワーカー スレッドに反映されるキューで保持、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドです。 以前のバージョンでは、プリンシパルの情報は反映されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> パラメーターは、\-1 より小さくします。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。<see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack">
          <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</param>
        <param name="state">デリゲートに渡されたオブジェクト。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> で表されるタイムアウト。<c>timeout</c> が 0 \(ゼロ\) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。<c>timeout</c> が \-1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.TimeSpan" /> 値をタイムアウトとして指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</summary>
        <returns>ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 終了したらを使用して、 <xref:System.Threading.RegisteredWaitHandle> このメソッドによって返される、呼び出しの <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 待機ハンドルへの参照を解放します。 常に呼び出すことをお勧めします <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドを指定する場合でも `true` の `executeOnlyOnce`です。 ガベージ コレクションより効率的に動作を呼び出す場合、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドの代わりに登録された待機ハンドルのファイナライザーによって異なります。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッド指定のデリゲートをスレッド プール キューに配置します。 次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。  
  
-   指定したオブジェクトがシグナル状態でです。  
  
-   タイムアウト間隔が経過しました。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドの指定されたオブジェクトの現在の状態を調べ、 <xref:System.Threading.WaitHandle>です。 オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。 待機操作は、スレッド プールのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。 場合、 `timeOutInterval` パラメーターではありません 0 \(ゼロ\) と `executeOnlyOnce` パラメーターは `false`, 、イベントがシグナル状態またはタイムアウト期間が経過するたびにタイマーをリセットします。  
  
> [!IMPORTANT]
>  使用して、 <xref:System.Threading.Mutex> の `waitObject` 基になる Win32 API は、既定値を使用するため、コールバックの相互排除を行いません `WT_EXECUTEDEFAULT` フラグを設定、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。 代わりに、 <xref:System.Threading.Mutex>, を使用して、 <xref:System.Threading.Semaphore> 1 の最大数にします。  
  
 待機操作をキャンセルする、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドです。  
  
 待機スレッドが、Win32 を使用して `WaitForMultipleObjects` 登録された待機操作を監視する関数。 そのためで、同じネイティブのオペレーティング システム ハンドルを使用する場合を複数回呼び出す <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, 、Win32 を使用してハンドルを複製する必要があります `DuplicateHandle` 関数です。 渡されるイベント オブジェクトをパルスする必要がありますしないことに注意してください <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, 待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためです。  
  
 、戻る前に、関数は、一部の種類の同期オブジェクトの状態を変更します。 変更は、オブジェクトがシグナル状態には、条件が満たされる待機条件が原因となった場合にのみ発生します。 たとえば、セマフォのカウントは 1 減ります。  
  
## バージョン情報  
 以降、.NET Framework version 2.0 で、 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> プロパティの値がワーカー スレッドに反映されるキューで保持、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドです。 以前のバージョンでは、プリンシパルの情報は反映されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> パラメーターは、\-1 より小さくします。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="timeout" /> パラメーターがより大きい <see cref="F:System.Int32.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。<see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack">
          <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</param>
        <param name="state">デリゲートに渡されたオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。<c>millisecondsTimeOutInterval</c> パラメーターが 0 \(ゼロ\) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。<c>millisecondsTimeOutInterval</c> が \-1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>32 ビット符号なし整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</summary>
        <returns>登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 終了したらを使用して、 <xref:System.Threading.RegisteredWaitHandle> このメソッドによって返される、呼び出しの <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 待機ハンドルへの参照を解放します。 常に呼び出すことをお勧めします <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドを指定する場合でも `true` の `executeOnlyOnce`です。 ガベージ コレクションより効率的に動作を呼び出す場合、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドの代わりに登録された待機ハンドルのファイナライザーによって異なります。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッド指定のデリゲートをスレッド プール キューに配置します。 次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。  
  
-   指定したオブジェクトがシグナル状態でです。  
  
-   タイムアウト間隔が経過しました。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドの指定されたオブジェクトの現在の状態を調べ、 <xref:System.Threading.WaitHandle>です。 オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。 待機操作は、スレッド プールのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。 場合、 `timeOutInterval` パラメーターではありません 0 \(ゼロ\) と `executeOnlyOnce` パラメーターは `false`, 、イベントがシグナル状態またはタイムアウト期間が経過するたびにタイマーをリセットします。  
  
> [!IMPORTANT]
>  使用して、 <xref:System.Threading.Mutex> の `waitObject` 基になる Win32 API は、既定値を使用するため、コールバックの相互排除を行いません `WT_EXECUTEDEFAULT` フラグを設定、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。 代わりに、 <xref:System.Threading.Mutex>, を使用して、 <xref:System.Threading.Semaphore> 1 の最大数にします。  
  
 待機操作をキャンセルする、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドです。  
  
 待機スレッドが、Win32 を使用して `WaitForMultipleObjects` 登録された待機操作を監視する関数。 そのためで、同じネイティブのオペレーティング システム ハンドルを使用する場合を複数回呼び出す <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, 、Win32 を使用してハンドルを複製する必要があります `DuplicateHandle` 関数です。 渡されるイベント オブジェクトをパルスする必要がありますしないことに注意してください <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, 待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためです。  
  
 、戻る前に、関数は、一部の種類の同期オブジェクトの状態を変更します。 変更は、オブジェクトがシグナル状態には、条件が満たされる待機条件が原因となった場合にのみ発生します。 たとえば、セマフォのカウントは 1 減ります。  
  
## バージョン情報  
 以降、.NET Framework version 2.0 で、 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> プロパティの値がワーカー スレッドに反映されるキューで保持、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドです。 以前のバージョンでは、プリンシパルの情報は反映されません。  
  
   
  
## 例  
 次の例では、使用する方法、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを指定した待機ハンドルがシグナル通知されたときに、指定されたコールバック メソッドを実行します。 コールバック メソッドは、この例では `WaitProc`, 、待機ハンドルは、 <xref:System.Threading.AutoResetEvent>です。  
  
 例では、定義、 `TaskInfo` を実行するときに、コールバックに渡される情報を保持するクラス。 例を作成し、 `TaskInfo` オブジェクトし、文字列データを割り当てます。<xref:System.Threading.RegisteredWaitHandle> によって返される、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> にメソッドが割り当てられている、 `Handle` のフィールド、 `TaskInfo` オブジェクトのコールバック メソッドにアクセスできるように、 <xref:System.Threading.RegisteredWaitHandle>です。  
  
 指定するだけでなく `TaskInfo` コールバック メソッドの呼び出しに渡されるオブジェクトとして、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定、 <xref:System.Threading.AutoResetEvent> 、タスクが待機する、 <xref:System.Threading.WaitOrTimerCallback> を表すデリゲート、 `WaitProc` コールバック メソッド、1 つの 2 番目のタイムアウト間隔、および複数のコールバック。  
  
 メイン スレッドに通知すると、 <xref:System.Threading.AutoResetEvent> を呼び出してその <xref:System.Threading.EventWaitHandle.Set%2A> 、メソッド、 <xref:System.Threading.WaitOrTimerCallback> デリゲートが呼び出されます。`WaitProc` メソッド テスト <xref:System.Threading.RegisteredWaitHandle> タイムアウトが発生したかどうかを決定します。 待機ハンドルがシグナル状態であるため、コールバックが呼び出された場合、 `WaitProc` メソッドの登録を解除、 <xref:System.Threading.RegisteredWaitHandle>, 、その他のコールバックを停止します。 タイムアウトの場合は、タスクは、待機を続けます。`WaitProc` メソッドは、コンソールにメッセージを印刷することで終了します。  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> パラメーターは、\-1 より小さくします。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">スレッド プール内のワーカー スレッドの最大数。</param>
        <param name="completionPortThreads">スレッド プール内の非同期 I\/O スレッドの最大数。</param>
        <summary>同時にアクティブにできるスレッド プールへの要求の数を設定します。 この数を超える要求はすべて、スレッド プール スレッドが使用可能になるまでキューに置かれたままになります。</summary>
        <returns>変更が成功した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ことはできませんワーカー スレッドまたは I\/O 完了スレッドの最大数未満に設定、数、コンピューター上のプロセッサの数。 プロセッサの数があるかを確認するには、値を取得、 <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> プロパティです。 さらに、ワーカー スレッドまたはワーカー スレッドの対応する最小数より小さい数に、I\/O 完了スレッドまたは I\/O 完了スレッドの最大数を設定することはできません。 最小のスレッド プール サイズを決定するを呼び出す、 <xref:System.Threading.ThreadPool.GetMinThreads%2A> メソッドです。  
  
 共通言語ランタイムがホストされている場合たとえばをインターネット インフォメーション サービス \(IIS\) または SQL Server ホストを制限したりスレッド プールのサイズを変更されないようにできます。  
  
 スレッド プール内のスレッドの最大数を変更する場合は、注意を使用します。 コードがメリットがあるときに、変更は、コード ライブラリを使用するに悪影響を与える可能性があります。  
  
 設定スレッド プールのサイズが大きすぎると、パフォーマンス問題が発生することができます。 スレッドが多すぎるが実行される場合、同時に、タスクの切り替えは重要な要因をオーバーヘッドになります。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to control threads. Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">スレッド プールがオンデマンドで作成するワーカー スレッドの最小数。</param>
        <param name="completionPortThreads">スレッド プールがオンデマンドで作成する非同期 I\/O スレッドの最小数。</param>
        <summary>スレッドがオンデマンドで \(新しい要求の発生ごとに\) 作成するスレッド プールの数を設定します。この数を超えると、スレッドの作成と破棄を管理するためのアルゴリズムに切り替わります。</summary>
        <returns>変更が成功した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The thread pool provides new worker threads or I\/O completion threads on demand until it reaches the minimum for each category. When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.  
  
 When demand is low, the actual number of thread pool threads can fall below the minimum values.  
  
 If you specify a negative number or a number larger than the maximum number of active thread pool threads \(obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>\), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns **languageKeyword tag is not supported!!!!**  
 and does not change either of the minimum values.  
  
> [!CAUTION]
>  By default, the minimum number of threads is set to the number of processors on a system. You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases, the thread pool will perform better with its own algorithm for allocating threads. Reducing the minimum to less than the number of processors can also hurt performance.  
  
   
  
## 例  
 The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I\/O completion threads.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to control threads. Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">キューに置く <see cref="T:System.Threading.NativeOverlapped" /> 構造体。</param>
        <summary>重複した I\/O 操作を、実行するためのキューに置きます。</summary>
        <returns>操作が I\/O 完了ポートのキューに正常に置かれた場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ラップ I\/O のネイティブ Win32 を使用する方法については、参照してください、 <xref:System.Threading.Overlapped> クラス、 <xref:System.Threading.NativeOverlapped> 構造体、および `OVERLAPPED` Win32 プラットフォーム SDK の構造体。  
  
> [!CAUTION]
>  使用して、 <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> メソッドは、セキュリティ ホールを誤って開けません。 コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可にアクセス許可のチェックを行います。 作業はスレッド プールのスレッドを使用して、\[キューに配置 <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, 、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードができるアクセス許可のチェックを避けるためにこれを利用します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">スレッド プール内のスレッドが作業項目をピック アップするときに呼び出すデリゲートを表す <see cref="T:System.Threading.WaitCallback" />。</param>
        <param name="state">スレッド プールから処理されるときにデリゲートに渡されるオブジェクト。</param>
        <summary>指定したデリゲートをスレッド プールのキューに置きます。ただし、コール スタックをワーカー スレッドに反映しません。</summary>
        <returns>メソッドが成功した場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.OutOfMemoryException" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり、 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッド、 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> 呼び出し元のスタックをワーカー スレッドには伝達されません。 これにより、呼び出し履歴が失われると、それによってセキュリティ特権を昇格するコード。  
  
> [!CAUTION]
>  使用して <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> セキュリティ ホールを誤ってを開くことでした。 コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可にアクセス許可のチェックを行います。 作業はスレッド プールのスレッドを使用して、\[キューに配置 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, 、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードができるアクセス許可のチェックを避けるためにこれを利用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.ApplicationException">メモリ不足の条件が発生しました。</exception>
        <exception cref="T:System.OutOfMemoryException">作業項目はキュー登録されていませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。<see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack">
          <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</param>
        <param name="state">デリゲートに渡されるオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。<c>millisecondsTimeOutInterval</c> パラメーターが 0 \(ゼロ\) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。<c>millisecondsTimeOutInterval</c> が \-1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>ミリ秒単位のタイムアウトとして 32 ビット符号付き整数を使用して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。 このメソッドはコール スタックをワーカー スレッドに反映しません。</summary>
        <returns>登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッド、 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 呼び出し元のスタックをワーカー スレッドには伝達されません。 これにより、呼び出し履歴が失われると、それによってセキュリティ特権を昇格するコード。  
  
> [!CAUTION]
>  使用して <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> セキュリティ ホールを誤ってを開くことでした。 コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可にアクセス許可のチェックを行います。 作業はスレッド プールのスレッドを使用して、\[キューに配置 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードができるアクセス許可のチェックを避けるためにこれを利用します。  
  
 使用して、 <xref:System.Threading.Mutex> の `waitObject` 基になる Win32 API は、既定値を使用するため、コールバックの相互排除を行いません `WT_EXECUTEDEFAULT` フラグを設定、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。  
  
 終了したらを使用して、 <xref:System.Threading.RegisteredWaitHandle> このメソッドによって返される、呼び出しの <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 待機ハンドルへの参照を解放します。 常に呼び出すことをお勧めします <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドを指定する場合でも `true` の `executeOnlyOnce`です。 ガベージ コレクションより効率的に動作を呼び出す場合、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドの代わりに登録された待機ハンドルのファイナライザーによって異なります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> パラメーターは、\-1 より小さくします。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。<see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack">
          <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</param>
        <param name="state">デリゲートに渡されるオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。<c>millisecondsTimeOutInterval</c> パラメーターが 0 \(ゼロ\) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。<c>millisecondsTimeOutInterval</c> が \-1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>64 ビット符号付き整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。 このメソッドはコール スタックをワーカー スレッドに反映しません。</summary>
        <returns>登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッド、 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 呼び出し元のスタックをワーカー スレッドには伝達されません。 これにより、呼び出し履歴が失われると、それによってセキュリティ特権を昇格するコード。  
  
> [!CAUTION]
>  使用して <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> セキュリティ ホールを誤ってを開くことでした。 コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可にアクセス許可のチェックを行います。 作業はスレッド プールのスレッドを使用して、\[キューに配置 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードができるアクセス許可のチェックを避けるためにこれを利用します。  
  
 使用して、 <xref:System.Threading.Mutex> の `waitObject` 基になる Win32 API は、既定値を使用するため、コールバックの相互排除を行いません `WT_EXECUTEDEFAULT` フラグを設定、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。  
  
 終了したらを使用して、 <xref:System.Threading.RegisteredWaitHandle> このメソッドによって返される、呼び出しの <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 待機ハンドルへの参照を解放します。 常に呼び出すことをお勧めします <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドを指定する場合でも `true` の `executeOnlyOnce`です。 ガベージ コレクションより効率的に動作を呼び出す場合、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドの代わりに登録された待機ハンドルのファイナライザーによって異なります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> パラメーターは、\-1 より小さくします。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。<see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack">
          <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</param>
        <param name="state">デリゲートに渡されるオブジェクト。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> で表されるタイムアウト。<c>timeout</c> が 0 \(ゼロ\) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。<c>timeout</c> が \-1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.TimeSpan" /> 値をタイムアウトとして指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。 このメソッドはコール スタックをワーカー スレッドに反映しません。</summary>
        <returns>登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッド、 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 呼び出し元のスタックをワーカー スレッドには伝達されません。 これにより、呼び出し履歴が失われると、それによってセキュリティ特権を昇格するコード。  
  
> [!CAUTION]
>  使用して <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> セキュリティ ホールを誤ってを開くことでした。 コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可にアクセス許可のチェックを行います。 作業はスレッド プールのスレッドを使用して、\[キューに配置 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードができるアクセス許可のチェックを避けるためにこれを利用します。  
  
 使用して、 <xref:System.Threading.Mutex> の `waitObject` 基になる Win32 API は、既定値を使用するため、コールバックの相互排除を行いません `WT_EXECUTEDEFAULT` フラグを設定、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。  
  
 終了したらを使用して、 <xref:System.Threading.RegisteredWaitHandle> このメソッドによって返される、呼び出しの <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 待機ハンドルへの参照を解放します。 常に呼び出すことをお勧めします <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドを指定する場合でも `true` の `executeOnlyOnce`です。 ガベージ コレクションより効率的に動作を呼び出す場合、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドの代わりに登録された待機ハンドルのファイナライザーによって異なります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> パラメーターは、\-1 より小さくします。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="timeout" /> パラメーターがより大きい <see cref="F:System.Int32.MaxValue" />します。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。<see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack">
          <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</param>
        <param name="state">デリゲートに渡されるオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。<c>millisecondsTimeOutInterval</c> パラメーターが 0 \(ゼロ\) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。<c>millisecondsTimeOutInterval</c> が \-1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>32 ビット符号なし整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。 このメソッドはコール スタックをワーカー スレッドに反映しません。</summary>
        <returns>登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッド、 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 呼び出し元のスタックをワーカー スレッドには伝達されません。 これにより、呼び出し履歴が失われると、それによってセキュリティ特権を昇格するコード。  
  
> [!CAUTION]
>  使用して <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> セキュリティ ホールを誤ってを開くことでした。 コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可にアクセス許可のチェックを行います。 作業はスレッド プールのスレッドを使用して、\[キューに配置 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードができるアクセス許可のチェックを避けるためにこれを利用します。  
  
 使用して、 <xref:System.Threading.Mutex> の `waitObject` 基になる Win32 API は、既定値を使用するため、コールバックの相互排除を行いません `WT_EXECUTEDEFAULT` フラグを設定、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。  
  
 終了したらを使用して、 <xref:System.Threading.RegisteredWaitHandle> このメソッドによって返される、呼び出しの <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 待機ハンドルへの参照を解放します。 常に呼び出すことをお勧めします <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドを指定する場合でも `true` の `executeOnlyOnce`です。 ガベージ コレクションより効率的に動作を呼び出す場合、 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> メソッドの代わりに登録された待機ハンドルのファイナライザーによって異なります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.WaitHandle" /> を待機しているデリゲートを登録します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メソッドを実行するためのキューに置きます。 メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。ただし、コール スタックをワーカー スレッドに反映しません。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>