<Type Name="Mutex" FullName="System.Threading.Mutex">
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>同期プリミティブは、プロセス間の同期にも使用できます。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを参照してください、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/threading/mutex.cs#29b92e0e2832a8d6)します。 ソース コードをオンラインで参照、オフライン表示のリファレンスをダウンロードおよびデバッグ中にソース \(パッチや更新を含む\) をステップsee [instructions](http://referencesource.microsoft.com/).  
  
 2 つまたは複数のスレッドは、同時に共有リソースにアクセスする必要がある場合、システムは、一度に 1 つのスレッドがリソースを使用していることを確認する同期メカニズムが必要です。<xref:System.Threading.Mutex> 同期は 1 つのスレッドを共有リソースへの排他アクセスを許可するプリミティブです。 スレッドがミュー テックス、最初のスレッドがミュー テックスを解放するまで、ミュー テックスを取得する必要のある 2 番目のスレッドが中断されます。  
  
> [!IMPORTANT]
>  この型は、 <xref:System.IDisposable> インターフェイスです。 型の使用が完了したらを直接または間接的にその破棄する必要があります。 型の直接 dispose を呼び出してその <xref:System.IDisposable.Dispose%2A> メソッドで、 `try`\/`catch` ブロックします。 直接ことのない破棄する場合など言語構成要素を使用して `using` \(c\#\) のまたは `Using` \(Visual Basic で\)。 詳細については、"を使用して、オブジェクトを実装して IDisposable"」セクションを参照してください、 <xref:System.IDisposable> インターフェイスに関するトピック。  
  
 使用することができます、 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> ミュー テックスの所有権を要求します。 呼び出し元のスレッド、次のいずれかが発生するまでをブロックします。  
  
-   ミュー テックスは、所有されていないことを示すために通知されます。 この場合、 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを返します。 `true`, 、呼び出し元のスレッドがミュー テックスの所有権と、ミュー テックスで保護されているリソースにアクセスするとします。 これには、リソースへのアクセスが完了したら、スレッドで呼び出す必要があります、 <xref:System.Threading.Mutex.ReleaseMutex%2A> 、ミュー テックスの所有権を解放します。 例では、最初の例では、このパターンを示します。  
  
-   呼び出しで指定されたタイムアウト期間、 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを持つ、 `millisecondsTimeout` または `timeout` パラメーターの有効期限が経過します。 このような場合、 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを返します。 `false`, 、呼び出し元のスレッドにミュー テックスの所有権取得を試行ではありません。 この場合、呼び出し元のスレッドにミュー テックスで保護されているリソースへのアクセスが拒否されるように、コードを構成する必要があります。 スレッドがミュー テックスの所有権を取得することはありませんのでを呼び出してはならない、 <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドです。 例では、2 番目の例では、このパターンを示します。  
  
 <xref:System.Threading.Mutex> クラスは、取得したスレッドでのみ、ミュー テックスが解放できるように、スレッド id を強制します。 これに対し、 <xref:System.Threading.Semaphore> クラスがスレッド id を適用しません。 ミュー テックスは、アプリケーション ドメインの境界を越えて渡すこともできます。  
  
 ミュー テックスを所有するスレッドは、繰り返しの呼び出しで同じミュー テックスを要求できる <xref:System.Threading.WaitHandle.WaitOne%2A> の実行をブロックすることがなく。 ただし、スレッドを呼び出す必要があります、 <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッド、同じ回数、ミュー テックスの所有権を解放します。  
  
 <xref:System.Threading.Mutex> クラスから継承 <xref:System.Threading.WaitHandle>, 、静的なを呼び出すこともできます <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> と <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> 保護されたリソースへのアクセスを同期する方法です。  
  
 ミュー テックスを所有しているスレッドが終了した場合、ミュー テックスを破棄するメンバーといいます。 ミュー テックスの状態は、シグナル状態に設定し、次の待機中のスレッドが所有権を取得します。 .NET Framework version 2.0 以降、 <xref:System.Threading.AbandonedMutexException> 放棄されたミュー テックスを取得し、次のスレッドでスローされます。 .NET Framework version 2.0 の前に例外がスローされなかった。  
  
> [!CAUTION]
>  ミュー テックスの破棄には、コードで重大なエラーが多くの場合を示します。 ミュー テックスを解放しないままスレッドの終了時に、ミュー テックスによって保護されていたデータ構造を一貫性のある状態で可能性がありますできません。 ミュー テックスの所有権を要求する次のスレッドでは、この例外を処理でき、データ構造の整合性を検証できる場合、続行することができます。  
  
 システム全体のミュー テックス、ミュー テックスの破棄は可能性があります \(たとえば、Windows タスク マネージャーを使用して\) をアプリケーションが突然終了されたことを示します。  
  
 ミュー テックスは、次の 2 種類: はであり、名前付きシステム ミュー テックス ローカル ミュー テックスです。 ローカル ミュー テックスは、プロセス内でのみ存在します。 任意のスレッドから参照されて、プロセスのために使用できる、 <xref:System.Threading.Mutex> 、ミュー テックスを表すオブジェクト。 名前のない各 <xref:System.Threading.Mutex> オブジェクトは、別のローカル ミュー テックスを表します。  
  
 名前付きシステム ミュー テックスは、オペレーティング システム全体から参照でき、プロセスの活動を同期するために使用できます。 作成することができます、 <xref:System.Threading.Mutex> を名前を受け取るコンス トラクターを使用して、名前付きシステム ミュー テックスを表すオブジェクト。 同時にオペレーティング システム オブジェクトを作成するかの作成前に存在する可能性が、 <xref:System.Threading.Mutex> オブジェクトです。 複数作成 <xref:System.Threading.Mutex> 名前付きシステム ミュー テックスを同じを表すオブジェクトと、使用することができます、 <xref:System.Threading.Mutex.OpenExisting%2A> を開くには、既存のメソッドに名前付きシステム ミュー テックスです。  
  
> [!NOTE]
>  ターミナル サービスを実行するサーバーで名前付きシステム ミュー テックス 2 レベルの可視性のことができます。 その名前は、プレフィックス「global \\」で始まっている場合、ミュー テックスはすべてのターミナル サーバー セッションに表示されます。 その名前は、プレフィックス"Local\\"で始まっている場合、ミュー テックスは、ターミナル サーバー セッションでのみが作成されました。 その場合は、同じ名前の別のミュー テックスは、それぞれのサーバー上の他のターミナル サーバー セッションに存在できます。 名前付きミュー テックスを作成するときに、プレフィックスを指定しないと、なります、プレフィックス"Local\\"。 ターミナル サーバー セッション内で名前のプレフィックスのみが異なる 2 つのミュー テックスが別個のミュー テックスにされ、両方が、ターミナル サーバー セッションですべてのプロセスに表示されます。 つまり、「global \\」と"Local\\"プレフィックス名では、プロセス相対的ではない、ターミナル サーバー セッションを基準としたミュー テックスの名前のスコープについて説明します。  
  
   
  
## 例  
 この方法を示しますローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期します。 それを呼び出す必要があります、ミュー テックスの所有権を取得するまで、各呼び出し元のスレッドがブロックされている、 <xref:System.Threading.Mutex.ReleaseMutex%2A> 、スレッドの所有権を解放します。  
  
 [!code-csharp[System.Threading.Mutex.Class\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 次の例では、各スレッドで、 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> 、ミュー テックスを取得します。 タイムアウト間隔が経過したかどうか、メソッドが返されます `false`, 、スレッドはミュー テックスを取得も、ミュー テックスを保護するリソースにアクセスするとします。<xref:System.Threading.Mutex.ReleaseMutex%2A> ミュー テックスを取得したスレッドによってのみ呼び出されます。  
  
 [!code-csharp[System.Threading.Mutex.Class\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを、既定のプロパティを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出しと同じには、このコンス トラクターのオーバー ロードを呼び出して、 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> コンス トラクター オーバー ロードを指定して `false` 、ミュー テックスの初期所有権をします。 つまり、呼び出し元のスレッドはミュー テックスを所有していません。  
  
   
  
## 例  
 次のコード例に示す方法ローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期します。 ミュー テックスを作成するスレッドが所有していない、最初にします。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">呼び出し元スレッドにミューテックスの初期所有権を与える場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値を使用して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例に示す方法ローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期します。 作成したスレッド、 <xref:System.Threading.Mutex> 最初に所有されています。  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="name">
          <see cref="T:System.Threading.Mutex" /> の名前。 値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値と、ミューテックスの名前を表す文字列を使用して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `name` は `null` と `initiallyOwned` は `true`, 、この呼び出しの結果として、名前付きシステム ミュー テックスが作成された場合にのみ、呼び出し元のスレッドがミュー テックスを所有します。 指定することをお勧め名前付きシステム ミュー テックスが作成されたかどうかを判断するためのメカニズムがないため `false` の `initiallyOwned` このコンス トラクターのオーバー ロードを呼び出すとき。 使用することができます、 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> コンス トラクターの初期所有権を確認する必要がある場合。  
  
 このコンス トラクター、 <xref:System.Threading.Mutex> 名前付きシステム ミュー テックスを表すオブジェクト。 複数作成 <xref:System.Threading.Mutex> 名前付きシステム ミュー テックスを同じを表すオブジェクト。  
  
 アクセス制御セキュリティでは、名前付きミュー テックスが既に作成されていて、呼び出し元が持っていない場合 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=fullName>, 、例外がスローされます。 既存のスレッドの活動を同期するために必要なアクセス許可のみを持つ名前付きミュー テックスを開きを参照してください、 <xref:System.Threading.Mutex.OpenExisting%2A> メソッドです。  
  
 指定した場合 `null` または空の文字列の `name`, が呼び出した場合と、ローカル ミュー テックスが作成された、 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> コンス トラクターです。 この場合、 `createdNew` は常に `true`します。  
  
 これらは、システム全体であるために、プロセス境界をまたがってリソースの使用を調整する名前付きミュー テックスを使用できます。  
  
> [!NOTE]
>  ターミナル サービスを実行するサーバーで名前付きシステム ミュー テックス 2 レベルの可視性のことができます。 その名前は、プレフィックス「global \\」で始まっている場合、ミュー テックスはすべてのターミナル サーバー セッションに表示されます。 その名前は、プレフィックス"Local\\"で始まっている場合、ミュー テックスは、ターミナル サーバー セッションでのみが作成されました。 その場合は、同じ名前の別のミュー テックスは、それぞれのサーバー上の他のターミナル サーバー セッションに存在できます。 名前付きミュー テックスを作成するときに、プレフィックスを指定しないと、なります、プレフィックス"Local\\"。 ターミナル サーバー セッション内で名前のプレフィックスのみが異なる 2 つのミュー テックスが別個のミュー テックスにされ、両方が、ターミナル サーバー セッションですべてのプロセスに表示されます。 つまり、「global \\」と"Local\\"プレフィックス名では、プロセス相対的ではない、ターミナル サーバー セッションを基準としたミュー テックスの名前のスコープについて説明します。  
  
   
  
## 例  
 次の例では、名前付きミュー テックスを使用して 2 つの個別のプロセスで実行中のスレッド間で通知する方法を示します。  
  
 このプログラムは、2 つ以上のコマンド ウィンドウから実行します。 各プロセスの作成、 <xref:System.Threading.Mutex> 名前付きミュー テックスを表す `MyMutex`します。 名前付きミュー テックスがシステム オブジェクトの有効期間に制限が有効期限を持つ、 <xref:System.Threading.Mutex> を表すオブジェクト。 最初のプロセスを作成するときに名前付きミュー テックスが作成されたその <xref:System.Threading.Mutex> オブジェクト。 この例では、名前付きミュー テックスがプログラムを実行する最初のプロセスが所有します。 名前付きミュー テックスが破棄されるときにすべて、 <xref:System.Threading.Mutex> リリースされたことを表すオブジェクト。  
  
 この例で使用するコンス トラクター オーバー ロードは、名前付きミュー テックスの初期所有権が付与されたかどうかを呼び出し元のスレッドに判断できません。 スレッドが名前付きミュー テックスを作成することを確認できましていないと、初期所有権を要求をこのコンス トラクターを使用する必要があります。  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, bool createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="name">
          <see cref="T:System.Threading.Mutex" /> の名前。 値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</param>
        <param name="createdNew">このメソッドから制御が戻るとき、ローカル ミューテックスが作成された場合 \(つまり <c>name</c> が <see langword="null" /> または空の文字列の場合\) または指定した名前付きシステム ミューテックスが作成された場合は、ブール値 <see langword="true" /> が格納されます。指定した名前付きシステム ミューテックスが既に存在する場合は <see langword="false" /> が格納されます。 このパラメーターは初期化せずに渡されます。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値、ミューテックスの名前を表す文字列、およびメソッドから戻るときにミューテックスの初期所有権が呼び出し元のスレッドに付与されたかどうかを示すブール値を指定して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If **parameterReference tag is not supported!!!!**  
 is not **languageKeyword tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the calling thread owns the named mutex only if **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
 after the call. Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A>method.  
  
 This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.  
  
 If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=fullName> rights, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.  
  
 If you specify **languageKeyword tag is not supported!!!!**  
 or an empty string for **parameterReference tag is not supported!!!!**  
, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, **parameterReference tag is not supported!!!!**  
 is always **languageKeyword tag is not supported!!!!**  
.  
  
 Because they are system\-wide, named mutexes can be used to coordinate resource use across process boundaries.  
  
> [!NOTE]
>  On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.  
  
   
  
## 例  
 The following code example shows how a named mutex is used to signal between processes or threads. Run this program from two or more command windows. Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex "MyMutex". The named mutex is a system object. In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it. The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released. The named mutex is initially owned by the first process. The second process and any subsequent processes wait for earlier processes to release the named mutex.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, bool createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="name">システム ミューテックスの名前。 値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</param>
        <param name="createdNew">このメソッドから制御が戻るとき、ローカル ミューテックスが作成された場合 \(つまり <c>name</c> が <see langword="null" /> または空の文字列の場合\) または指定した名前付きシステム ミューテックスが作成された場合は、ブール値 <see langword="true" /> が格納されます。指定した名前付きシステム ミューテックスが既に存在する場合は <see langword="false" /> が格納されます。 このパラメーターは初期化せずに渡されます。</param>
        <param name="mutexSecurity">名前付きシステム ミューテックスに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値、ミューテックスの名前を表す文字列、メソッドが戻るときにミューテックスの初期所有権が呼び出し元のスレッドに付与されたかどうかを示すブール値変数、および名前付きミューテックスに適用するアクセス制御セキュリティを指定して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If **parameterReference tag is not supported!!!!**  
 is not **languageKeyword tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the calling thread owns the named mutex only if **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
 after the call. Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.  
  
 Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.  
  
 This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex. You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.  
  
 If the named system mutex does not exist, it is created with the specified access control security. If the named mutex exists, the specified access control security is ignored.  
  
> [!NOTE]
>  The caller has full control over the newly created <xref:System.Threading.Mutex> object even if **parameterReference tag is not supported!!!!**  
>  denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.  
  
 If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=fullName>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.  
  
 If you specify **languageKeyword tag is not supported!!!!**  
 or an empty string for **parameterReference tag is not supported!!!!**  
, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. In this case, **parameterReference tag is not supported!!!!**  
 is always **languageKeyword tag is not supported!!!!**  
.  
  
 Because they are system\-wide, named mutexes can be used to coordinate resource use across process boundaries.  
  
> [!NOTE]
>  On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions. If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\". Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.  
  
   
  
## 例  
 The following code example demonstrates the cross\-process behavior of a named mutex with access control security. The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.  
  
 If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  
  
 If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.  
  
 After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>名前付きミューテックスのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクトを取得します。</summary>
        <returns>名前付きミューテックスのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Mutex.GetAccessControl%2A> メソッドは、次フラグの組み合わせ \(ビットごとの OR 演算を使用して結合\) を使用してアクセス許可を検索する: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=fullName>, 、<xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=fullName>, 、および <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=fullName>です。  
  
 ユーザーが必要 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=fullName> をこのメソッドは、ミュー テックスを呼び出す必要がありますを使用して開いた <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=fullName>します。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きミュー テックスのプロセス間の動作を示します。 例では、 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドのオーバー ロードは、名前付きミュー テックスの存在をテストします。  
  
 ミュー テックスが存在しない場合は、初期所有権と現在のユーザーに、ミュー テックスを使用する権利を拒否の読み取りし、ミュー テックスのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます <xref:System.Threading.Mutex.OpenExisting%28System.String%29>します。 例外をキャッチし、例では、 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバー ロードは、読み取りを使用して、アクセス許可を変更するために必要な権限を持つ、ミュー テックスを開き、 <xref:System.Threading.Mutex.GetAccessControl%2A> と <xref:System.Threading.Mutex.SetAccessControl%2A> メソッドです。  
  
 アクセス許可を変更すると、入力し、それを解放するために必要な権限を持つ、ミュー テックスが開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">現在 <see cref="T:System.Threading.Mutex" /> オブジェクトが、名前付きシステム ミュー テックスを表しますが、ユーザーが持っていない <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />します。  
  
 または  
  
 現在 <see cref="T:System.Threading.Mutex" /> オブジェクトは、名前付きシステム ミュー テックスを表しで開かれていない <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />します。</exception>
        <exception cref="T:System.NotSupportedException">Windows 98 または Windows Millennium Edition はサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開きます。</summary>
        <returns>名前付きシステム ミューテックスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Mutex.OpenExisting%2A> メソッドを開こうとした、指定した名前付きシステム ミュー テックスです。 システム ミュー テックスが存在しない場合、このメソッドは、システム オブジェクトを作成する代わりに例外をスローします。 既に存在しない場合にシステム ミュー テックスを作成するには、いずれかを使用、 <xref:System.Threading.Mutex.%23ctor%2A> コンス トラクターを持つ、 `name` パラメーター。  
  
 このメソッドは同じ値を使用する複数の呼び出し `name` 必ずしも返さない同じ <xref:System.Threading.Mutex> 場合でも、返されたオブジェクトは、同じ名前付きシステム ミュー テックスを表すオブジェクトします。  
  
 このメソッドはオーバー ロードを呼び出すことと同じ、 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバー ロードを指定すること <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=fullName> と <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=fullName> 権限、ビットごとの OR 演算を使用して結合します。  
  
 指定する、 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=fullName> フラグにより、ミュー テックスを待機するスレッドを指定して、 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=fullName> フラグを呼び出すスレッドを使用する、 <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドです。  
  
 このメソッドは、ミュー テックスの所有権を要求しません。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きミュー テックスのプロセス間の動作を示します。 例では、 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドのオーバー ロードは、名前付きミュー テックスの存在をテストします。  
  
 ミュー テックスが存在しない場合は、初期所有権と現在のユーザーに、ミュー テックスを使用する権利を拒否の読み取りし、ミュー テックスのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます <xref:System.Threading.Mutex.OpenExisting%28System.String%29>します。 例外をキャッチし、例では、 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバー ロードは、読み取りし、アクセス許可を変更するために必要な権限を持つ、ミュー テックスを開きます。  
  
 アクセス許可を変更すると、入力し、それを解放するために必要な権限を持つ、ミュー テックスが開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミュー テックスは存在しません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミュー テックスが存在するが、ユーザーには、それを使用するために必要なセキュリティのアクセスはありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <param name="rights">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</param>
        <summary>既に存在する場合は、必要なセキュリティ アクセスで指定した名前付きミューテックスを開きます。</summary>
        <returns>名前付きシステム ミューテックスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `rights` パラメーターを含める必要があります、 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=fullName> をミュー テックスを待機するスレッドを許可するフラグ、および <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=fullName> を呼び出すスレッドを許可するフラグ、 <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドです。  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> メソッドは、既存の名前付きミュー テックスを試みます。 システム ミュー テックスが存在しない場合、このメソッドは、システム オブジェクトを作成する代わりに例外をスローします。 既に存在しない場合にシステム ミュー テックスを作成するには、いずれかを使用、 <xref:System.Threading.Mutex.%23ctor%2A> コンス トラクターを持つ、 `name` パラメーター。  
  
 このメソッドは同じ値を使用する複数の呼び出し `name` 必ずしも返さない同じ <xref:System.Threading.Mutex> 場合でも、返されたオブジェクトは、同じ名前付きシステム ミュー テックスを表すオブジェクトします。  
  
 このメソッドは、ミュー テックスの所有権を要求しません。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きミュー テックスのプロセス間の動作を示します。 例では、 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドのオーバー ロードは、名前付きミュー テックスの存在をテストします。  
  
 ミュー テックスが存在しない場合は、初期所有権と現在のユーザーに、ミュー テックスを使用する権利を拒否の読み取りし、ミュー テックスのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます <xref:System.Threading.Mutex.OpenExisting%28System.String%29>します。 例外をキャッチし、例では、 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバー ロードは、読み取りし、アクセス許可を変更するために必要な権限を持つ、ミュー テックスを開きます。  
  
 アクセス許可を変更すると、入力し、それを解放するために必要な権限を持つ、ミュー テックスが開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミュー テックスは存在しません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミュー テックスが存在するが、ユーザーには、必要なセキュリティのアクセスはありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.Mutex" /> を一度解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッドがミュー テックスを取得するたびに \(などを呼び出してその<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド\)、後で呼び出す必要があります<xref:System.Threading.Mutex.ReleaseMutex%2A>ミュー テックスの所有権を放棄して、ミュー テックスの所有権を獲得しようとしている他のスレッドのブロックを解除します。 ミュー テックスの所有権の取得に失敗したが失敗したかどうか \(への呼び出し時などに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを`millisecondsTimeout`または`timeout`パラメーターを返します`false`要求がタイムアウトになるため\)、スレッドを呼び出すべきではありません<xref:System.Threading.Mutex.ReleaseMutex%2A>、ここでは、スレッドもことはできません、次の例として、ミュー テックスで保護されているリソースにアクセスします。  
  
 [!code-csharp[System.Threading.Mutex.Class\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ミュー テックスを所有するスレッドは、その実行をブロックすることがなく、繰り返される関数呼び出しで同じミュー テックスを指定できます。 呼び出しの数は、共通言語ランタイムによって保持されます。 スレッドを呼び出す必要があります<xref:System.Threading.Mutex.ReleaseMutex%2A>同じ回数、ミュー テックスの所有権を解放します。  
  
 スレッドがミュー テックスを所有しているときに終了と、ミュー テックスを破棄すると呼ばれます。 ミュー テックスの状態がシグナル状態に設定し、\[次へ\] の待機中のスレッドが所有権を取得します。 ミュー テックスを所有しているだれミュー テックスの状態が通知されます。 .NET Framework のバージョン 2.0 以降で、<xref:System.Threading.AbandonedMutexException>ミュー テックスを取得する次のスレッドでスローされます。 .NET Framework のバージョン 2.0 より前の例外がスローされなかった。  
  
> [!CAUTION]
>  放棄されたミュー テックスは、多くの場合、コードで深刻なエラーを示します。 ミュー テックスを解放せずに、スレッドが終了したときにミュー テックスで保護されているデータ構造体できない可能性があります一貫した状態にします。 ミュー テックスの所有権を要求する次のスレッドでは、この例外を処理でき、データ構造の整合性を検証できる場合、続行することができます。  
  
 場合は、システムのミュー テックスを放棄されたミュー テックスがある可能性があります \(たとえば、Windows タスク マネージャーを使用\) して、アプリケーションが突然終了されたことです。  
  
   
  
## 例  
 次の例は、どのローカル<xref:System.Threading.Mutex>オブジェクトは、保護されたリソースへのアクセスを同期するために使用します。 ミュー テックスを作成するスレッドが所有していない、最初にします。<xref:System.Threading.Mutex.ReleaseMutex%2A>不要になったときにミュー テックスを解放するメソッドを使用します。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">呼び出しスレッドに独自のミューテックスがありません。</exception>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">名前付きシステム ミューテックスに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</param>
        <summary>名前付きシステム ミューテックスのアクセス制御セキュリティを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ユーザーが必要 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=fullName> でこのメソッドは、ミュー テックスを呼び出す権限が開かれている必要があります <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=fullName>します。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きミュー テックスのプロセス間の動作を示します。 例では、 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドのオーバー ロードは、名前付きミュー テックスの存在をテストします。  
  
 ミュー テックスが存在しない場合は、初期所有権と現在のユーザーに、ミュー テックスを使用する権利を拒否の読み取りし、ミュー テックスのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます <xref:System.Threading.Mutex.OpenExisting%28System.String%29>します。 例外をキャッチし、例では、 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバー ロードは、読み取りを使用して、アクセス許可を変更するために必要な権限を持つ、ミュー テックスを開き、 <xref:System.Threading.Mutex.GetAccessControl%2A> と <xref:System.Threading.Mutex.SetAccessControl%2A> メソッドです。  
  
 アクセス許可を変更すると、入力し、それを解放するために必要な権限を持つ、ミュー テックスが開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.UnauthorizedAccessException">ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> がありません。  
  
 または  
  
 ミュー テックスが開かれていない <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />します。</exception>
        <exception cref="T:System.SystemException">現在 <see cref="T:System.Threading.Mutex" /> オブジェクトは、名前付きシステム ミュー テックスを表していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, class System.Threading.Mutex result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <param name="result">このメソッドから戻るときに、呼び出しに成功した場合は名前付きミューテックスを表す <see cref="T:System.Threading.Mutex" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。 このパラメーターは初期化前として処理されます。</param>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開き操作が成功したかどうかを示す値を返します。</summary>
        <returns>名前付きミューテックスが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a **parameterReference tag is not supported!!!!**  
 parameter.  
  
 If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.  
  
 Multiple calls to this method that use the same value for **parameterReference tag is not supported!!!!**  
 do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.  
  
 This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=fullName> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=fullName> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.  
  
 This method does not request ownership of the mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスは存在しますが、ユーザーにはそれを使用するために必要なセキュリティ アクセスがありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, class System.Threading.Mutex result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <param name="rights">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</param>
        <param name="result">このメソッドから戻るときに、呼び出しに成功した場合は名前付きミューテックスを表す <see cref="T:System.Threading.Mutex" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。 このパラメーターは初期化前として処理されます。</param>
        <summary>既に存在する場合は、必要なセキュリティ アクセスを使用して指定した名前付きミューテックスを開き、操作が成功したかどうかを示す値を返します。</summary>
        <returns>名前付きミューテックスが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a **parameterReference tag is not supported!!!!**  
 parameter.  
  
 If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.  
  
 The **parameterReference tag is not supported!!!!**  
 parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=fullName> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.  
  
 Multiple calls to this method that use the same value for **parameterReference tag is not supported!!!!**  
 do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.  
  
 This method does not request ownership of the mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスは存在しますが、ユーザーにはそれを使用するために必要なセキュリティ アクセスがありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開き操作が成功したかどうかを示す値を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開きます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>