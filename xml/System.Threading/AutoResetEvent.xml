<Type Name="AutoResetEvent" FullName="System.Threading.AutoResetEvent">
  <TypeSignature Language="C#" Value="public sealed class AutoResetEvent : System.Threading.EventWaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AutoResetEvent extends System.Threading.EventWaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.AutoResetEvent" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.EventWaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>イベントが発生したことを待機中のスレッドに通知します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 `AutoResetEvent` 通知することによって互いに通信するためにスレッドをできるようにします。 通常、スレッドには、リソースへの排他アクセスが必要がある場合、このクラスを使用します。  
  
> [!IMPORTANT]
>  この型は、 <xref:System.IDisposable> インターフェイスです。 型の使用が完了したらを直接または間接的にその破棄する必要があります。 型の直接 dispose を呼び出してその <xref:System.IDisposable.Dispose%2A> メソッドで、 `try`\/`catch` ブロックします。 直接ことのない破棄する場合など言語構成要素を使用して `using` \(c\#\) のまたは `Using` \(Visual Basic で\)。 詳細については、"を使用して、オブジェクトを実装して IDisposable"」セクションを参照してください、 <xref:System.IDisposable> インターフェイスに関するトピック。  
  
 呼び出して、スレッドがシグナルの待機 <xref:System.Threading.WaitHandle.WaitOne%2A> 上、 `AutoResetEvent`です。 場合、 `AutoResetEvent` 非シグナル状態の場合、スレッドを現在呼び出すことによって、リソースが利用可能なことを通知するためのリソースをコントロールを待機している、スレッドがブロックされて <xref:System.Threading.EventWaitHandle.Set%2A>します。  
  
 呼び出す `Set` 信号 `AutoResetEvent` を待機中のスレッドを解放します。`AutoResetEvent` 待機スレッドが解放され、自動的に非シグナル状態に戻るまでシグナル状態に残ります。 無期限に待機しているスレッドがない場合に、状態ままシグナルです。  
  
 スレッドが呼び出す場合 <xref:System.Threading.WaitHandle.WaitOne%2A> 中に、 <xref:System.Threading.AutoResetEvent> がシグナル状態で、スレッドはブロックしません。<xref:System.Threading.AutoResetEvent> すぐにスレッドを解放し、非シグナル状態に戻ります。  
  
> [!IMPORTANT]
>  保証はありませんがへの呼び出しごと、 <xref:System.Threading.EventWaitHandle.Set%2A> メソッドは、スレッドを解放します。 2 つの呼び出しが近すぎるが、スレッドが解放される前に、2 番目の呼び出しが行われる、1 つのスレッドが解放されます。 2 番目の呼び出しが行われなかったかのようになります。 また場合、 <xref:System.Threading.EventWaitHandle.Set%2A> 待機しているスレッドがないときに呼び出されると <xref:System.Threading.AutoResetEvent> を既にシグナル状態の呼び出しが影響を与えません。  
  
 初期状態を制御する、 `AutoResetEvent` コンス トラクターにブール値を渡すことによって: `true` 初期状態がシグナル状態になる場合と `false` それ以外の場合。  
  
 `AutoResetEvent` 使用することもできます、 `static`<xref:System.Threading.WaitHandle.WaitAll%2A> と <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドです。  
  
 スレッドの同期機構の詳細については、次を参照してください。 [AutoResetEvent](http://msdn.microsoft.com/ja-jp/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) 概念説明のドキュメントです。  
  
 .NET Framework version 2.0 で始まる <xref:System.Threading.AutoResetEvent> から、新しい派生 <xref:System.Threading.EventWaitHandle> クラスです。<xref:System.Threading.AutoResetEvent> に相当する機能は、 <xref:System.Threading.EventWaitHandle> で作成された <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName>します。  
  
> [!NOTE]
>  異なり、 <xref:System.Threading.AutoResetEvent> 、クラス、 <xref:System.Threading.EventWaitHandle> クラスは、名前付きシステム同期イベントへのアクセスを提供します。  
  
   
  
## 例  
 次の例は、使用する方法を示しています。 <xref:System.Threading.AutoResetEvent> を呼び出すことによって、一度に 1 つのスレッドを解放する、 <xref:System.Threading.EventWaitHandle.Set%2A> クラスのメソッド \(基本\) ごとにユーザーが、 **Enter** キー。 例では、3 つのスレッドで待機を開始する、 <xref:System.Threading.AutoResetEvent> シグナルの状態で作成しました。 最初のスレッドはため、すぐに解放、 <xref:System.Threading.AutoResetEvent> が既にシグナル状態にします。 これは、リセット、 <xref:System.Threading.AutoResetEvent> 非シグナル状態にその後のスレッドをブロックできるようにします。 ブロックされたスレッドは、ユーザーを解放するまでに 1 つはリリースされないキーを押して一度に、 **Enter** キー。  
  
 スレッドは、最初のリリース後に <xref:System.Threading.AutoResetEvent>, 、別の待機 <xref:System.Threading.AutoResetEvent> 非シグナル状態で作成しました。 次の 3 つのすべてのスレッドがブロック、ため、 <xref:System.Threading.EventWaitHandle.Set%2A> メソッドは、それらすべてを解放する 3 回呼び出す必要があります。  
  
 [!code-cpp[System.Threading.AutoResetEvent\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CPP/simplerisbetter.cpp#3)]
 [!code-csharp[System.Threading.AutoResetEvent\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CS/simplerisbetter.cs#3)]
 [!code-vb[System.Threading.AutoResetEvent\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/VB/simplerisbetter.vb#3)]  
  
 ]]></format>
    </remarks>
    <threadsafe>このクラスは、スレッド セーフです。</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AutoResetEvent (bool initialState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> 初期状態を設定する次のように通知します。 <see langword="false" /> を非シグナル状態初期状態を設定します。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Threading.AutoResetEvent" /> クラスに初期状態をシグナル状態に設定するかどうかを示すブール値を使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、 <xref:System.Threading.AutoResetEvent> 2 つのスレッドの活動を同期します。 アプリケーションのスレッドでは、最初のスレッドが実行する `Main`です。 保護されたリソースに値を書き込みます、 `static` \(`Shared` Visual Basic で\) という名前のフィールド `number`します。 2 番目のスレッドは、静的な `ThreadProc` によって書き込まれる値を読み取るメソッド `Main`します。  
  
 `ThreadProc` メソッドの待機、 <xref:System.Threading.AutoResetEvent>です。`Main` 呼び出し、 <xref:System.Threading.EventWaitHandle.Set%2A> メソッドを <xref:System.Threading.AutoResetEvent>, 、 `ThreadProc` メソッドは 1 つの値を読み取ります。<xref:System.Threading.AutoResetEvent> 直後にリセットされため、 `ThreadProc` メソッドがもう一度まで待機します。  
  
 プログラム ロジックは、必ず、 `ThreadProc` メソッドは、同じ値の 2 倍を読み込みは行われません。 される保証はなく、 `ThreadProc` メソッドはによって書き込まれたすべての値を読み取る `Main`します。 その保証は、1 秒あたり <xref:System.Threading.AutoResetEvent> ロックします。  
  
 個々 の書き込み操作の後に `Main` で、 <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> メソッド、2 番目のスレッドを実行することにします。 それ以外の場合、シングル プロセッサ コンピューターで `Main` 読み取り操作を 2 つのいずれかの間の多くの値を書き込むとします。  
  
 [!code-cpp[System.Threading.AutoResetEvent\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.AutoResetEvent\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CS/class1.cs#1)]
 [!code-vb[System.Threading.AutoResetEvent\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
      </Docs>
    </Member>
  </Members>
</Type>