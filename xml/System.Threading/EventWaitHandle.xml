<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>スレッドの同期イベントを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling. Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads. A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the **languageKeyword tag is not supported!!!!**  
 \(**languageKeyword tag is not supported!!!!**  
 in Visual Basic\) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=fullName> method.  
  
> [!NOTE]
>  The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.  
  
 The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode. An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> flag resets automatically when signaled, after releasing a single waiting thread. An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.  
  
 Automatic reset events provide exclusive access to a resource. If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it. The event releases the thread and immediately resets, blocking subsequent threads.  
  
 Manual reset events are like gates. When the event is not signaled, threads that wait on it will block. When the event is signaled, all waiting threads are released, and the event remains signaled \(that is, subsequent waits do not block\) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called. Manual reset events are useful when one thread must complete an activity before other threads can proceed.  
  
 <xref:System.Threading.EventWaitHandle> objects can be used with the `static`\(`Shared` in Visual Basic\) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> methods.  
  
 For more information about thread synchronization mechanisms, see [EventWaitHandle, AutoResetEvent, and ManualResetEvent](http://msdn.microsoft.com/ja-jp/cd94fc34-ac15-427f-b723-a1240a4fab7d).  
  
   
  
## 例  
 The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.  
  
 The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> flag, then releases one thread each time the user presses the ENTER key. The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> 初期状態を設定する次のように通知します。 <see langword="false" /> を非シグナル状態設定しています。</param>
        <param name="mode">いずれか、 <see cref="T:System.Threading.EventResetMode" /> イベントを自動または手動でリセットするかどうかを決定する値。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Threading.EventWaitHandle" /> かどうか、待機ハンドルは、最初にシグナル状態し、自動または手動でをリセットするかどうかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベントの初期状態が非シグナル状態の場合は、イベントを待機しているスレッドはブロックされます。 初期状態がシグナル状態になる場合、 <xref:System.Threading.EventResetMode.ManualReset> のフラグが指定されている `mode`, 、イベントを待機しているスレッドはブロックされません。 初期状態がシグナル状態になる場合と `mode` は <xref:System.Threading.EventResetMode.AutoReset>, イベントで待機する最初のスレッドがすぐに解放される、イベントがリセットされますまで、その後のスレッドがブロックされます。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> メソッドのオーバー ロードは、メイン スレッドをブロックされたスレッドを通知し、スレッドがタスクを完了するまで待機できるようにします。  
  
 例では、5 つのスレッドを開始しをブロックすることができます、 <xref:System.Threading.EventWaitHandle> で作成された、 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> フラグをし、ENTER キーを押したリリース 1 つのスレッドにします。 例は、5 つの別のスレッド キューに配置し、すべてを使用して、解放、 <xref:System.Threading.EventWaitHandle> で作成された、 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> フラグ。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> 名前付きのイベントがこの呼び出しの結果として作成されたかどうか、シグナルの初期状態を設定するには <see langword="false" /> を非シグナル状態設定しています。</param>
        <param name="mode">いずれか、 <see cref="T:System.Threading.EventResetMode" /> イベントを自動または手動でリセットするかどうかを決定する値。</param>
        <param name="name">システム全体の同期イベントの名前。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Threading.EventWaitHandle" /> シグナルかどうか待機ハンドルは、最初にこの呼び出しの結果として作成された場合に自動または手動でリセットされるかを指定し、システムの同期イベントの名前。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `name` は `null` または空の文字列、ローカル <xref:System.Threading.EventWaitHandle> が作成されます。  
  
 場合に指定された名前のシステム イベント、 `name` パラメーターが既に存在する、 `initialState` パラメーターは無視されます。  
  
> [!IMPORTANT]
>  名前付きシステムのイベントをこのコンス トラクターを使用する場合は、指定 `false` の `initialState`です。 このコンス トラクターには、指定したイベントの状態に関するどのような想定をすることはできませんので、名前付きシステム イベントが作成されたかどうかを確認する方法はありません。 指定したイベントが作成されたかどうかを確認するのには、使用、 <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> コンス トラクターまたは <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> コンス トラクターです。  
  
 イベントの初期状態が非シグナル状態の場合は、イベントを待機しているスレッドはブロックされます。 初期状態がシグナル状態になる場合、 <xref:System.Threading.EventResetMode.ManualReset> のフラグが指定されている `mode`, 、イベントを待機しているスレッドはブロックされません。 初期状態がシグナル状態になる場合と `mode` は <xref:System.Threading.EventResetMode.AutoReset>, イベントで待機する最初のスレッドがすぐに解放される、イベントがリセットされますまで、その後のスレッドがブロックされます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">ユーザーはありませんが、名前付きのイベントが存在し、アクセス制御セキュリティを <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />します。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">同じ名前、名前付きイベントを作成できません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, bool createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">名前の付いたイベントがこの呼び出しの結果として作成された場合に、初期状態をシグナル状態に設定するには <see langword="true" />、非シグナル状態に設定するには <see langword="false" />。</param>
        <param name="mode">イベントを自動または手動でリセットするかを決定する <see cref="T:System.Threading.EventResetMode" /> 値の 1 つ。</param>
        <param name="name">システム全体の同期イベントの名前。</param>
        <param name="createdNew">このメソッドから制御が戻るときに、ローカル イベントが作成された場合 \(<c>name</c> が <see langword="null" /> または空の文字列の場合\)、または指定した名前付きシステム イベントが作成された場合は <see langword="true" /> が格納されます。指定した名前付きシステム イベントが既に存在する場合は <see langword="false" /> が格納されます。 このパラメーターは初期化せずに渡されます。</param>
        <summary>
          <see cref="T:System.Threading.EventWaitHandle" /> クラスの新しいインスタンスを初期化し、待機ハンドルがこの呼び出しの結果として作成された場合に最初にシグナル状態になるかどうか、リセットは自動または手動か、システムの同期イベントの名前、呼び出しの後の値で名前の付いたシステム イベントが作成されたかどうかを示すブール値変数を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If a system event with the name specified for the **parameterReference tag is not supported!!!!**  
 parameter already exists, the **parameterReference tag is not supported!!!!**  
 parameter is ignored. After calling this constructor, use the value in the variable specified for the **languageKeyword tag is not supported!!!!**  
 parameter \(**languageKeyword tag is not supported!!!!**  
 parameter in Visual Basic\)**parameterReference tag is not supported!!!!**  
 to determine whether the named system event already existed or was created.  
  
 If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for **parameterReference tag is not supported!!!!**  
, threads that wait on the event will not block. If the initial state is signaled, and **parameterReference tag is not supported!!!!**  
 is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きイベントが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きイベントを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, bool createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">名前の付いたイベントがこの呼び出しの結果として作成された場合に、初期状態をシグナル状態に設定するには <see langword="true" />、非シグナル状態に設定するには <see langword="false" />。</param>
        <param name="mode">イベントを自動または手動でリセットするかを決定する <see cref="T:System.Threading.EventResetMode" /> 値の 1 つ。</param>
        <param name="name">システム全体の同期イベントの名前。</param>
        <param name="createdNew">このメソッドから制御が戻るときに、ローカル イベントが作成された場合 \(<c>name</c> が <see langword="null" /> または空の文字列の場合\)、または指定した名前付きシステム イベントが作成された場合は <see langword="true" /> が格納されます。指定した名前付きシステム イベントが既に存在する場合は <see langword="false" /> が格納されます。 このパラメーターは初期化せずに渡されます。</param>
        <param name="eventSecurity">名前付きシステム イベントに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> オブジェクト。</param>
        <summary>
          <see cref="T:System.Threading.EventWaitHandle" /> クラスの新しいインスタンスを初期化し、待機ハンドルがこの呼び出しの結果として作成された場合に最初にシグナル状態になるかどうか、リセットは自動または手動か、システムの同期イベントの名前、呼び出しの後の値で名前の付いたシステム イベントが作成されたかどうかを示すブール値変数、および名前の付いたシステム イベントが作成された場合は、そのイベントにアクセス制御セキュリティを適用するかどうかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.  
  
 This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event. You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.  
  
 If the system event does not exist, it is created with the specified access control security. If the event exists, the specified access control security is ignored.  
  
> [!NOTE]
>  The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if **parameterReference tag is not supported!!!!**  
>  denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.  
  
 If a system event with the name specified for the **parameterReference tag is not supported!!!!**  
 parameter already exists, the **parameterReference tag is not supported!!!!**  
 parameter is ignored. After calling this constructor, use the value in the variable specified for the **languageKeyword tag is not supported!!!!**  
 parameter \(**languageKeyword tag is not supported!!!!**  
 parameter in Visual Basic\) **parameterReference tag is not supported!!!!**  
 to determine whether the named system event already existed or was created.  
  
 If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for **parameterReference tag is not supported!!!!**  
, threads that wait on the event will not block. If the initial state is signaled, and **parameterReference tag is not supported!!!!**  
 is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.  
  
   
  
## 例  
 The following code example demonstrates the cross\-process behavior of a named system event with access control security. The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.  
  
 If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  
  
 If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.  
  
 After the permissions are changed, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きイベントが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きイベントを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトによって表される名前付きシステム イベントのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> オブジェクトを取得します。</summary>
        <returns>名前付きシステム イベントのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> メソッドは、次フラグの組み合わせ \(ビットごとの OR 演算を使用して結合\) を使用してアクセス許可を検索する: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=fullName>, 、<xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=fullName>, 、および <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=fullName>です。  
  
 ユーザーが必要 <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=fullName> でこのメソッドとイベントを呼び出す権限が開かれている必要があります、 <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=fullName> フラグ。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きシステム イベントのプロセス間の動作を示します。 例では、 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> メソッドのオーバー ロードは、指定したイベントの存在をテストします。  
  
 イベントが存在しない場合は、初期所有権と現在のユーザーに、イベントを使用する権利を拒否の読み取りし、イベントに対するアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>します。 例外をキャッチし、例では、 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドのオーバー ロードは、読み取りし、アクセス許可を変更するために必要な権限を持つイベントを待機します。  
  
 アクセス許可が読み取られるを使用して、 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> メソッドを変更すると、イベントを開く待機し、シグナル通知するために必要な権限を持つ。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合の例は、新しいアクセス許可を使用してを実行します。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">現在の <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトは名前付きシステム イベントを表していますが、ユーザーには <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> がありません。  
  
 または  
  
 現在の <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトは名前付きシステム イベントを表していますが、<see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> で開かれませんでした。</exception>
        <exception cref="T:System.NotSupportedException">Windows 98 または Windows Millennium Edition はサポートされていません。</exception>
        <exception cref="T:System.ObjectDisposedException">この <see cref="T:System.Threading.EventWaitHandle" /> で <see cref="M:System.Threading.WaitHandle.Close" /> メソッドが既に呼び出されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">開くには、システムの同期イベントの名前。</param>
        <summary>既に存在する場合は、指定された名前付きの同期イベントを開きます。</summary>
        <returns>名前付きシステム イベントを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> メソッドは、指定した名前付きシステム イベントを開こうとします。 システム イベントが存在しない場合、このメソッドは、システム イベントを作成する代わりに例外をスローします。 既に存在しない場合は、システム イベントを作成するには、いずれかの操作を使用して、 <xref:System.Threading.EventWaitHandle.%23ctor%2A> コンス トラクターを持つ、 `name` パラメーター。  
  
 このメソッドは同じ値を使用する複数の呼び出し `name` 必ずしも返さない同じ <xref:System.Threading.EventWaitHandle> 場合でも、返されたオブジェクトは、同じ名前付きシステム イベントを表すオブジェクトします。  
  
 このメソッドはオーバー ロードを呼び出すことと同じ、 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドのオーバー ロードを指定すること <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=fullName> と <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=fullName> 権限、ビットごとの OR 演算を使用して結合します。  
  
 指定すること、 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=fullName> フラグにより、名前付きシステム イベントで待機するスレッドを指定して、 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=fullName> フラグを呼び出すスレッドを使用する、 <xref:System.Threading.EventWaitHandle.Set%2A> と <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドです。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きシステム イベントのプロセス間の動作を示します。 例では、 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> メソッドのオーバー ロードは、指定したイベントの存在をテストします。  
  
 イベントが存在しない場合は、初期所有権と現在のユーザーに、イベントを使用する権利を拒否の読み取りし、イベントに対するアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>します。 例外をキャッチし、例では、 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドのオーバー ロードは、読み取りし、アクセス許可を変更するために必要な権限を持つイベントを待機します。  
  
 アクセス許可を変更すると、待機し、シグナル通知するために必要な権限を持つイベントが開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合の例は、新しいアクセス許可を使用してを実行します。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きシステム イベントが存在しません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きのイベントが存在するが、ユーザーには、それを使用するために必要なセキュリティのアクセスはありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">開くには、システムの同期イベントの名前。</param>
        <param name="rights">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</param>
        <summary>指定した同期イベントをという名前が既に存在する場合、必要なセキュリティ アクセスを開きます。</summary>
        <returns>名前付きシステム イベントを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `rights` パラメーターを含める必要があります、 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=fullName> をイベントで待機するスレッドを許可するフラグ、および <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=fullName> を呼び出すスレッドを許可するフラグ、 <xref:System.Threading.EventWaitHandle.Set%2A> と <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドです。  
  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> メソッドは、既存の名前付きシステム イベントを開こうとします。 システム イベントが存在しない場合、このメソッドは、システム イベントを作成する代わりに例外をスローします。 既に存在しない場合は、システム イベントを作成するには、いずれかの操作を使用して、 <xref:System.Threading.EventWaitHandle.%23ctor%2A> コンス トラクターを持つ、 `name` パラメーター。  
  
 このメソッドは同じ値を使用する複数の呼び出し `name` 必ずしも返さない同じ <xref:System.Threading.EventWaitHandle> 場合でも、返されたオブジェクトは、同じ名前付きシステム イベントを表すオブジェクトします。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きシステム イベントのプロセス間の動作を示します。 例では、 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> メソッドのオーバー ロードは、指定したイベントの存在をテストします。  
  
 イベントが存在しない場合は、初期所有権と現在のユーザーに、イベントを使用する権利を拒否の読み取りし、イベントに対するアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>します。 例外をキャッチし、例では、 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドのオーバー ロードは、読み取りし、アクセス許可を変更するために必要な権限を持つイベントを待機します。  
  
 アクセス許可を変更すると、待機し、シグナル通知するために必要な権限を持つイベントが開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合の例は、新しいアクセス許可を使用してを実行します。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きシステム イベントが存在しません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きのイベントが存在するが、ユーザーには、必要なセキュリティのアクセスはありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>イベントの状態を非シグナル状態に設定し、スレッドをブロックします。</summary>
        <returns>正常に操作できた場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">この <see cref="T:System.Threading.EventWaitHandle" /> で <see cref="M:System.Threading.WaitHandle.Close" /> メソッドが既に呼び出されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>イベントの状態をシグナル状態に設定し、待機している 1 つ以上のスレッドが進行できるようにします。</summary>
        <returns>正常に操作できた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.EventWaitHandle> と <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> \(を含む <xref:System.Threading.AutoResetEvent>\)、 <xref:System.Threading.EventWaitHandle.Set%2A> メソッドが 1 つのスレッドを解放します。 待機中のスレッドが存在しない場合は、待機ハンドル シグナル状態のままスレッドが、上になるか待機しようとするまでその <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドが呼び出されます。  
  
> [!IMPORTANT]
>  保証はありませんをへの呼び出しごと、 <xref:System.Threading.EventWaitHandle.Set%2A> メソッドはからのスレッドを解放、 <xref:System.Threading.EventWaitHandle> がリセット モードは <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName>です。 2 つの呼び出しが近すぎるが、スレッドが解放される前に、2 番目の呼び出しが行われる、1 つのスレッドが解放されます。 2 番目の呼び出しが行われなかったかのようになります。 また場合、 <xref:System.Threading.EventWaitHandle.Set%2A> 待機しているスレッドがないときに呼び出されると <xref:System.Threading.EventWaitHandle> を既にシグナル状態の呼び出しが影響を与えません。  
  
 <xref:System.Threading.EventWaitHandle> と <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> \(を含む <xref:System.Threading.ManualResetEvent>\)、呼び出し元、 <xref:System.Threading.EventWaitHandle.Set%2A> メソッドのまま待機ハンドルに、シグナル状態になるまでその <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドが呼び出されます。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> メソッドのオーバー ロードは、メイン スレッドをブロックされたスレッドを通知し、スレッドがタスクを完了するまで待機できるようにします。  
  
 例では、5 つのスレッドを開始しをブロックすることができます、 <xref:System.Threading.EventWaitHandle> で作成された、 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName> フラグをし、ENTER キーを押したリリース 1 つのスレッドにします。 例は、5 つの別のスレッド キューに配置し、すべてを使用して、解放、 <xref:System.Threading.EventWaitHandle> で作成された、 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName> フラグ。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">この <see cref="T:System.Threading.EventWaitHandle" /> で <see cref="M:System.Threading.WaitHandle.Close" /> メソッドが既に呼び出されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">名前付きシステム イベントに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> オブジェクト。</param>
        <summary>名前付きシステム イベントのアクセス制御セキュリティを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ユーザーが必要 <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=fullName> でこのメソッドとイベントを呼び出す権限が開かれている必要があります、 <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=fullName> フラグ。  
  
   
  
## 例  
 次のコード例では、アクセス制御セキュリティを名前付きシステム イベントのプロセス間の動作を示します。 例では、 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> メソッドのオーバー ロードは、指定したイベントの存在をテストします。  
  
 イベントが存在しない場合は、初期所有権と現在のユーザーに、イベントを使用する権利を拒否の読み取りし、イベントに対するアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>します。 例外をキャッチし、例では、 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドのオーバー ロードは、読み取りし、アクセス許可を変更するために必要な権限を持つイベントを待機します。  
  
 使用して、アクセス許可が変更した後、 <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> メソッド、イベントは待機し、シグナル通知に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合の例は、新しいアクセス許可を使用してを実行します。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.UnauthorizedAccessException">ユーザーに <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> がありません。  
  
 または  
  
 イベントが <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> で開かれませんでした。</exception>
        <exception cref="T:System.SystemException">現在の <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトは名前付きシステム イベントを表していません。</exception>
        <exception cref="T:System.ObjectDisposedException">この <see cref="T:System.Threading.EventWaitHandle" /> で <see cref="M:System.Threading.WaitHandle.Close" /> メソッドが既に呼び出されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, class System.Threading.EventWaitHandle result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム同期イベントの名前。</param>
        <param name="result">このメソッドから制御が戻るときに、呼び出しに成功した場合は名前付き同期イベントを表す <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。 このパラメーターは初期化前として処理されます。</param>
        <summary>既に存在する場合は、指定した名前付き同期イベントを開き操作が成功したかどうかを示す値を返します。</summary>
        <returns>名前付き同期イベントが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a **parameterReference tag is not supported!!!!**  
 parameter.  
  
 If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.  
  
 This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=fullName> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=fullName> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.  
  
 Multiple calls to this method that use the same value for **parameterReference tag is not supported!!!!**  
 do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きイベントが存在しますが、ユーザーに必要なセキュリティ アクセスがありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, class System.Threading.EventWaitHandle result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム同期イベントの名前。</param>
        <param name="rights">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</param>
        <param name="result">このメソッドから制御が戻るときに、呼び出しに成功した場合は名前付き同期イベントを表す <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。 このパラメーターは初期化前として処理されます。</param>
        <summary>既に存在する場合は、必要なセキュリティ アクセスを使って指定した名前付き同期イベントを開き、操作が成功したかどうかを示す値を返します。</summary>
        <returns>名前付き同期イベントが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a **parameterReference tag is not supported!!!!**  
 parameter.  
  
 If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.  
  
 The **parameterReference tag is not supported!!!!**  
 parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=fullName> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.  
  
 Multiple calls to this method that use the same value for **parameterReference tag is not supported!!!!**  
 do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列です。  
  
 または  
  
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きイベントが存在しますが、ユーザーに必要なセキュリティ アクセスがありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>存在する場合、既に操作が成功したかどうかを示す値を返す場合、指定された名前付きの同期イベントを開きます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.EventWaitHandle" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に存在する場合は、指定された名前付きの同期イベントが開きます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>