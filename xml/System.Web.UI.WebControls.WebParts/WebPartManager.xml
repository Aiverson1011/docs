<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Web パーツのコントロール、機能、および Web ページ上で発生するイベントのすべてを管理する、Web パーツ コントロール セットの中心的なクラスとして機能します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは、ハブまたはコントロール センターの Web パーツ アプリケーションとして機能します。 必要があります\-\-を 1 つ\-\-<xref:System.Web.UI.WebControls.WebParts.WebPartManager> Web パーツ コントロールを使用するすべてのページにコントロールのインスタンス。 Web パーツのアプリケーションのほとんどの側面と同様、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは認証されたユーザーでのみ機能します。 さらに、その機能を継承する Web パーツ ゾーン内に存在するサーバー コントロールのほとんどすべてが、<xref:System.Web.UI.WebControls.WebParts.WebZone>クラスです。 これらのゾーンの外部でページ上に存在するサーバー コントロールは、ほとんどの Web パーツ機能またはとの対話を持つことができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。  
  
 ハブのページでは、Web パーツ機能として、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールでは、次の表で説明したタスクの種類を実行します。  
  
|タスク カテゴリ|どのようなコントロールを使用してください。|  
|--------------|---------------------------|  
|Web パーツ コントロールの追跡|など、Web パーツの機能を提供するページ上のコントロールのさまざまな種類の追跡<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、接続、ゾーン、およびその他のユーザーです。|  
|追加して、Web パーツ コントロールを削除します。|追加、削除、および終了のメソッドを提供<xref:System.Web.UI.WebControls.WebParts.WebPart>ページ上のコントロールです。|  
|接続の管理|コントロール間の接続を作成し、接続性を追加して、それらを削除するプロセスを監視します。|  
|コントロールとページのカスタマイズ|ページでは、別の場所にコントロールを移動することができ、外観、プロパティ、およびコントロールの動作のユーザーが編集ビューを起動します。 各ページ上のユーザーに固有の個人用設定を保持します。|  
|別のページ ビューの切り替え|ユーザーがページ レイアウトの変更やコントロールの編集などの特定のタスクを実行できるように、ページの異なる特殊なビュー間のページに切り替えます。|  
|Web パーツのライフ サイクル イベントを発生させる|発生し、およびとコントロールの追加、移動、接続されている、または削除などの Web パーツ コントロールのライフ サイクル イベントの処理にすれば、開発者に定義します。|  
|コントロールのインポートとエクスポートを有効にします。|プロパティの状態を格納する XML ストリームをエクスポート<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、およびその他のページまたはサイト内の複雑なコントロールのカスタマイズで利便性のためのファイルをインポートすることができます。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスには、大規模な一連のプロパティです。 一貫性のある、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>他のコントロールの追跡のロール、Web パーツ コントロールまたはその他の特別な Web パーツのオブジェクトのいずれかのコレクションを参照するプロパティの数があります。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>プロパティは、すべてのコレクションで使用される、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>の追跡と他の管理タスクを制御します。  
  
 プロパティの別のグループには、Web パーツ アプリケーションで発生する特定の状況で適用されるカスタマイズ可能な警告が含まれています。 ように、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>プロパティです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスは、多くの Web サーバー コントロールで使用される基本継承されたプロパティの一部をオーバーライドします。 ように、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>プロパティです。  
  
 さらに、プロパティのグループ、アプリケーションの現在の状態にアクセスするために役立ちます。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>プロパティ ページでは、現在の表示モードを示します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>プロパティでは、ユーザーのブラウザーは異なる機能を持つまたはになっているスクリプトがある可能性がありますの状況に関連するクライアント側スクリプトを表示するために、コントロールが許可されているかどうかを示します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>プロパティがいくつかの機能拡張の場合に使用される重要なの Web パーツ メソッドへの呼び出しを含むユーティリティ クラスを参照するのに役立ちます。 別のクラスでこれらのメソッドへの呼び出しを非表示にして \(、<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>クラス\) では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの API が簡素化されます。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティはユーザーの個人用設定を保存、永続ストレージにデータを保持するパーソナル化オブジェクトへのアクセスを提供します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>プロパティかを示します<xref:System.Web.UI.WebControls.WebParts.WebPart>ページ上のコントロールは、ユーザーまたはアプリケーションが現在選択されています。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>プロパティを示すかどうかのカスタムのパーソナル化データ、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールが変更されました。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールでは、5 つ含まれている組み込みの表示モード、または Web ページのビューです。 開発者はこの機能を拡張できるように型を拡張することによってカスタムの表示モードの作成、<xref:System.Web.UI.WebControls.WebParts.WebZone>クラスまたは<xref:System.Web.UI.WebControls.WebParts.ToolZone>クラスです。 ユーザーは、する適切な種類の特定の表示モードに対応するコントロールがページ上に存在、さまざまな表示モードにページを切り替えることができます。  
  
> [!NOTE]
>  できるように、ユーザーが、しなくても、ページ上のゾーンに対応するカスタム表示モードに切り替えることができます、この機能を拡張することができます。 ただし、既定の動作は、表示モードがゾーンに対応することはできます。  
  
 標準の表示モードがのパブリック フィールドで表される、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスです。 次の表に、フィールドとを参照している表示モードを示します。 ページの現在の表示モード、上に示したように常にで参照される、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>プロパティ、および特定のページは、ページ上に存在するゾーンの種類を指定された使用可能な表示モードのセットに含まれる、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティです。  
  
|フィールド|モードの詳細を表示|  
|-----------|---------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|Web ページの通常のユーザーのビュー既定値と最も一般的な表示モード。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|ユーザーが再配置またはページ レイアウトを変更するコントロールを削除するビューです。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|編集のユーザー インターフェイス \(UI\) が表示されるビューユーザーには、外観、プロパティ、および通常のブラウズ モードで表示されるコントロールの動作を編集できます。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|カタログの UI が表示されるビューユーザーは、使用可能なコントロールのカタログからのページにコントロールを追加できます。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|接続の UI が表示されるビューユーザーは、接続、管理、またはコントロール間の接続を切断できます。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールには、複数の Web パーツ ページおよびコントロールのライフ サイクルで重要なイベントも含まれています。 これらのイベントは、Web パーツ コントロールの動作を正確にプログラムによる制御を提供します。 ほとんどのメソッドは直接関係<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール \(またはその他のサーバーまたはユーザー コントロールに配置されている<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>として動作できるようにゾーン<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール\)。 ただし、いくつかのイベントは、ページまたはページ上の接続の状態に関連します。 次の表は、使用可能なイベントとその用途をまとめたものです。  
  
> [!NOTE]
>  「コントロール」という単語を指す次の表に常に、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールまたはゾーン内に存在しでラップされます。 サーバー コントロール、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>実行時にオブジェクト。  
  
|イベント|説明|  
|----------|--------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|権限があることを確認する ページにコントロールを追加する前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|ページ上のすべての接続がアクティブ化された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|ページ上のすべての接続をアクティブ化するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|ページの現在の表示モードが変更された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|ページの表示モードを変更する処理の直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|コントロールの選択が取り消された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|コントロールの選択を解除のプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|コントロールがゾーンに追加した後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|ゾーンにコントロールを追加する処理の直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|\(ページから削除される\)、コントロールが閉じられた後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|コントロールの終了のプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|\(1 つがプログラムによって作成されたか、カタログから追加される\) 動的コントロールのインスタンスが完全に削除された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|ダイナミック コントロールを削除する処理の直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|そのゾーン内または別のゾーンにコントロールが移動した後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|コントロールを移動するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|接続の参加を選択した 2 つのコントロールの接続が確立した後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|2 つのコントロールを接続するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|2 つの接続されているコントロールが切断された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|2 つのコントロールを切断する処理の直前に発生します。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールに Web パーツ ページを管理するための多数のメソッドがあります。 ここでは、表示されていない、メソッドの大規模なセットは、メソッドの名前を持つが On の形式を取る*EventName*です。 これらのメソッドは通常、関連付けられたイベントを発生させるし、種類のハンドラーにイベントを提供<xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>です。 継承する開発者がこれらのメソッドのほとんどをオーバーライドすることができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスです。 また、ページの開発者は、これらのメソッドに関連付けられているイベントのカスタム ハンドラーを指定できます。 たとえばの場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>イベント、ページの開発者の追加でした、`OnWebPartAdded`属性を`<asp:webpartmanager>`カスタム メソッド名は、属性、イベントのカスタム処理を提供する Web ページと、割り当てのマークアップ内の要素。 属性に対応して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>メソッド、およびイベント処理のほとんどの Web パーツのイベントとその関連するメソッドのしくみの基本的なパターンです。  
  
 さらに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールに管理するためのタスクに固有のメソッドがある<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール \(として使用されるサーバーまたはユーザー コントロールと<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール\)。 These methods include <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>, and <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>.  
  
 別の一連のメソッドは、接続に特化します。 This includes methods such as <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>, and <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>.  
  
 最後に、いくつか<xref:System.Web.UI.WebControls.WebParts.WebPartManager>メソッドは、パーソナル化の機能に注目します。 These include <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>, and <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>.  
  
 その他の詳細については<xref:System.Web.UI.WebControls.WebParts.WebPartManager>経由でアクセスできるメソッド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>プロパティ、ドキュメントを参照して、<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>クラスです。  
  
   
  
## 例  
 次のコード例を示しますの宣言とプログラムの両方を使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。  
  
 このコード例では、4 つの部分があります。  
  
-   ユーザー コントロール \[Web パーツ\] ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含む Web ページ<xref:System.Web.UI.WebControls.WebParts.WebPart>接続可能なコントロールと`<asp:webpartmanager>`要素。  
  
-   2 つのカスタムを含むソース コード ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、およびカスタム インターフェイスです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 ユーザー コントロールには、ページでは、ページ上に存在する Web パーツ コントロールの指定可能な表示モードを示すドロップダウン リスト コントロールがあります。 このコード例については、Web ページでこのユーザー コントロールは、以下に宣言されただけ、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ページのマークアップ内の要素があると、`Register`コントロールを登録する Web ページの上部にあるディレクティブです。 詳細については、このコントロールでモードと、ソース コードの説明を表示を参照してください[Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 [!code-csharp[WebParts\_WebPartManager\_SimpleConnection\#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-vb[WebParts\_WebPartManager\_SimpleConnection\#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Web ページの宣言型マークアップを含む`Register`ユーザー コントロールとカスタム コントロールの両方のディレクティブ。`<asp:webpartmanager>`要素、`<asp:webpartzone>`カスタム コントロールを追加する要素と`<asp:connectionszone>`要素。 ページにもいくつかの接続に関連するイベントを処理するインライン コードが含まれています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>制御; 接続のコントロールを切断すると、このコードの効果を確認できます。  
  
 [!code-csharp[WebParts\_WebPartManager\_SimpleConnection\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_SimpleConnection\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 例では、3 番目の部分では、コントロールのソース コードを示します。 という名前のインターフェイスがあることに注意してください`IZipCode`でこのインターフェイスを実装し、`ZipCodeWebPart`クラスです。 このクラスは、という名前の特殊なコールバック メソッドを持つ`ProvideIZipCode`プロバイダーとして機能します。 他の種類、名前付き`WeatherWebPart`、という名前の特殊なメソッドにも実装されています`GetIZipCode`、他のコントロールのコンシューマーとして機能するコントロールを有効にします。  
  
 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 代わりに、ここで動的にコンパイルされる実行時に、サイトの App\_Code フォルダーにソース コードを配置できます。 このコード例では、アセンブリに、ソースをコンパイルして、 `Register` Web ページのディレクティブは、アセンブリ名を参照します。 コンパイルする方法について説明するチュートリアルでは、次を参照してください。[Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[WebParts\_WebPartManager\_SimpleConnection\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts\_WebPartManager\_SimpleConnection\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 ブラウザーで Web ページが読み込まれた後にをクリックして、**表示モード**ドロップダウン リスト コントロールと選択**接続**接続モードをページに切り替えます。 接続モードでは使用、`<asp:connectionszone>`要素を使用すると、コントロール間の接続を作成します。 接続モードのタイトル バーの下向き矢印をクリックして、**郵便**の動詞メニューをアクティブに制御し、をクリックして**接続**です。 接続の UI が表示されたら、クリックして、**コンシューマーへの接続を作成する**リンクします。 ドロップダウン リスト コントロールを含むセルが表示されます。 選択**気象コントロール**をクリックしてドロップダウン リスト、**接続**2 つのコントロールの接続を完了します。 をクリックして**閉じる**、しを使用して、**表示モード**ドロップダウン リストに、ページを通常のブラウズ モードに戻ります。 ZIP コードを入力して、コンシューマー コントロールは、入力した値で更新されます。`ZipCode`プロパティとして設定されていた、`Personalizable`ソース コードでこのプロパティの値の属性がブラウザー セッション間で保持されますので、ユーザーが入力した値を保存します。 高度なコンシューマー コントロールでは、郵便番号情報を取得、コードに基づく天気情報を検索、およびユーザーに表示可能性があります。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> control is designed to be extended. Because it is so central to Web Parts applications, when you want to extend some specific type or control in the Web Parts control set, in many cases you must also extend the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class, because it is likely to have some property or method that is required to make your custom type work in the context of a Web Parts application. The Web Parts reference documentation (see <see cref="N:System.Web.UI.WebControls.WebParts" />), when discussing how to extend a Web Parts type, frequently mentions what needs to be done to extend the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class as well, or shows how to extend it in a code example.</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> コンス トラクターが使用するいくつかの重要な変数を初期化します、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 すべての Web パーツ ページに直接影響を与える 1 つの割り当ては既定のページの表示モードはブラウズ モードに設定されているファクト \(<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>\)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web ページ上で現在アクティブなすべての接続をアクティブになります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 間の既存の接続をアクティブ化するページには、各要求に対してメソッドが呼び出された <xref:System.Web.UI.WebControls.WebParts.WebPart> 内にある他のサーバー コントロールと <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンです。 場合によっては、競合する場合は、このメソッドのアクティブ化されている接続でさらに、インスタンスの呼び出しに対する、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドを問題のある接続を終了します。 接続解除の処理中に、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントが発生します。 通常開発者がこのイベントを取り消すことができますがの場合は、このため、接続が取り消されることはできませんとの間に競合については、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、接続をアクティブ化するプロセスを完了するために、競合を解決する必要があります。 詳細については、「 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> \(またはサーバーまたはユーザー コントロール\) を Web ページに追加したり、ページに開いたりします。</param>
        <param name="zone">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> を <c>webPart</c> に追加されます。</param>
        <param name="zoneIndex">序数を表す整数を配置する <c>webPart</c> で占める <c>zone</c>, の他のコントロールからの相対 <c>zone</c>します。</param>
        <summary>追加するための標準的なプログラムによる方法は、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> Web ページへのコントロールです。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ページに追加されたコントロール。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> メソッドを使用して新しい動的に追加する <xref:System.Web.UI.WebControls.WebParts.WebPart> ページ、およびページに既に閉じられている静的または動的のコントロールを再度開くを制御します。 参照されているコントロールのコピーを実際に作成して新しいコントロールを追加するメソッドが呼び出されると、 `webPart` パラメーター。 新しい ID は、コントロールのコピーに対して生成される開発者を参照する必要がありますので、 <xref:System.Web.UI.WebControls.WebParts.WebPart> 新しい ID 値を取得するメソッドから制御が返されます。 によって参照される、コントロールへの直接の参照を返します以前に閉じられたコントロールを再度開くには、メソッドが呼び出されると、 `webPart` パラメーター。  
  
> [!IMPORTANT]
>  常に使用する必要があります、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> メソッドではなく、 <xref:System.Web.UI.ControlCollection.Add%2A> によって参照されるコントロールのコレクションのメソッド、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=fullName> プロパティを追加する <xref:System.Web.UI.WebControls.WebParts.WebPart> にコントロールをプログラムで、ページを使用しているため、 <xref:System.Web.UI.ControlCollection.Add%2A> メソッドは例外をスローします。 ないコントロールを追加する、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール \(つまりでラップする、サーバー コントロールを <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 実行時にコントロール\)、最初に呼び出す必要があります、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> をコントロールを作成し、呼び出すメソッド、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> コントロールを追加するメソッドをします。 この方法のデモについては、「使用例」を参照してください。  
  
   
  
## 例  
 次のコード例では使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> ページにプログラムを使用してサーバー コントロールを追加します。 ページのマークアップを含む空 `<asp:webpartzone>` 要素、および `<asp:webpartmanager>` 要素。 初めて、 **予定表の追加** ボタンがクリックされる、コードは、イベント ハンドラーを作成、 <xref:System.Web.UI.WebControls.Calendar> を制御しとゾーンに追加、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトを呼び出して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> メソッドです。  
  
 [!code-csharp[WebParts\_WebPartManager\_DeleteWebPart\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_DeleteWebPart\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="zone" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="zone" /> 登録されていない、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ゾーンのコントロールのコレクション。  
  
 または  
  
 <paramref name="webPart" /> 既に <paramref name="zone" />します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> の値が 0 未満です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときに、 <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> を判断するメソッドが呼び出されるかどうか、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> サーバー コントロールをページに追加できることができます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントが発生するたびに、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールがページに追加されています。 ページにコントロールを追加できる一般的なシナリオの数があります。 これらの詳細については、「解説」セクションを参照してください、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドです。 コントロールが追加されると、表示するチェックする必要があるかどうか、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティが設定されているため、必要な場合は、かどうか、コントロールは承認ページに追加します。  
  
 開発者は、イベント ハンドラーを作成できる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントをフィルター コントロールを提供します。 コントロールの場合 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティの値は、イベント ハンドラーのコードで条件を満たしていない、コントロールがないページに追加します。  
  
   
  
## 例  
 次のコード例では、カスタム イベント ハンドラーを設定、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントで、既定値が自動的に上書き <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドです。  
  
 内のコード、 `mgr1_AuthorizeWebPart` メソッドでは、ページ上のコントロールが、それぞれがいるかどうかをチェック <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティの値に設定 `user` し、必要な場合を返します `true`, が承認され、ページに追加することを意味します。 これは、既定のアプローチは、ユーザーのパーソナル化スコープ内のページにコントロールを表示できるようにすると仮定します。 注意してください、ただし、あるコントロールのいずれかの例では、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティ値に設定 `admin`します。 開発者は、管理ユーザーのみを表示するために設計された特殊なコントロールに、このフィルターをかける場合があります。 このコントロールの中に承認チェックが失敗、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベント、表示されません。 プロパティの設定がないコントロールが同様に表示されることに注意してください。判断しないフィルター処理の一部であるため、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティが設定されていません。  
  
 [!code-csharp[WebParts\_WebPartManager\_AuthorizeWebPart\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_AuthorizeWebPart\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コレクションを取得 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> される利用可能なオブジェクトは、サーバー コントロールの間の Web パーツ接続の作成に使用します。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> のセットを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> コレクションを作成します。 既定では、アプリケーション構成ファイルから使用可能なトランスフォーマーを読み取ります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続が作成されるコントロールです。</param>
        <summary>2 つの接続処理を開始 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> メソッドが存在できるように、接続プロセスをより詳細に制御を開発者に提供、独立した段階で、プロセス コントロール間の接続を構成するを実行できます。 メソッドが、一連のことを確認する初期チェックを実行 `webPart` 、接続が作成することができます正当な状態にします。 場合 `webPart` すべてのチェックに合格し、現在選択されているコントロールとして設定されて \(を参照してください、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> プロパティ\)、および接続の処理を続行できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">ページで、現在の表示モードでは <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 閉じています。  
  
 または  
  
 <paramref name="webPart" /> 一部ではなく、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクションです。  
  
 または  
  
 <paramref name="webPart" /> 等しい、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールです。</exception>
        <block subset="none" type="overrides">
          <para>Developers who need to extend the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> control might want to override this method in a derived class. One approach would be to call the base method, and then add some additional custom handling; or you might want to completely customize the process of starting a connection between controls. For example, you might want to verify that certain data is available before creating the connection.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">編集しようとするコントロール。</param>
        <summary>編集のプロセスを開始、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> メソッドが存在できるように、コントロールの編集のプロセスを開発者にプロセスをより詳細に制御を提供する、独立した段階で実行できます。 メソッドが、一連のことを確認する初期チェックを実行 `webPart` が編集できる状態にします。 場合 `webPart` すべてのチェックに合格し、現在選択されているコントロールとして設定されて \(を参照してください、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> プロパティ\)、および編集の処理を続行できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">ページで、現在の表示モードでは <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 閉じています。  
  
 または  
  
 <paramref name="webPart" /> 一部ではなく、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクションです。  
  
 または  
  
 <paramref name="webPart" /> 等しい、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールです。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールを含むページの既定の表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> フィールドが参照するカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> が作成されに含まれているオブジェクト、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 これは、静的オブジェクトであるため、できるトークンを参照する経由で直接、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラス、コントロールのインスタンスを必要はありません。  
  
 Web パーツを含むページ コントロールを最初に読み込むときになっています <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> \(ブラウズ モード\) 既定では。 通常の Web ページの場合と、ユーザーが単に参照、ブラウズ モードのページが削除されません。 使用できる特殊な表示モードのいずれかに、ページを切り替える必要があります、ページのレイアウト、コントロール、外観、または動作をカスタマイズする必要がある場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティです。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> プログラムを使用してフィールドです。 コードでは、サポートされている表示モード、ここでは、参照、デザインのドロップダウン リストを追加します。 いることを確認、 `Page_PreRender` メソッドは、コードのチェックするかどうか、現在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> にプロパティが設定されている <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>します。 場合は、 `Label1` 、表示される、存在しない場合 `Label1` 非表示にします。  
  
 [!code-csharp[WebParts\_WebPartManager\_BrowseDisplayMode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_BrowseDisplayMode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、既定ではブラウズ モードでは。 ブラウズ モードでを示すページ上のラベルに注意してください。 ドロップダウン リスト コントロールを使用して、ページをデザイン モードに切り替えます。 \[コードのためいることを確認、 `Page_PreRender` メソッド、ラベルが非表示です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>チェック、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> それらが接続できるかどうかを判断への接続に参加しているコントロール。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドを使用して、2 つあるかどうかを判断 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールが接続されていることができます。 メソッドは通常呼び出しの前にチェックを条件として使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> メソッドです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドは、複数の 2 つのコントロールが接続を構成する前に満たす必要がある条件をチェックします。 次に、接続を行うための主な条件をまとめます。 メソッドが戻るかどうかは、これらすべての条件 \(およびその他の内部条件\) が満たされて、 `true`, 、コントロールが接続することを意味します。  
  
-   プロバイダーとコンシューマー コントロールにすることはできません `null`, 、によって参照されるコントロールのコレクション内に含まれる必要があります、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティです。  
  
-   プロバイダーとコンシューマーは、同じコントロールをすることはできません。 つまり、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール自体に接続することはできません。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> プロバイダーとコンシューマーの両方のオブジェクト \(接続ポイント\) にすることはできません `null`します。  
  
-   プロバイダーとコンシューマーを閉じることができません \(どちらのコントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A> プロパティを指定できます `true`\)。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A> 接続ポイントのコントロールのプロパティがコンシューマーとプロバイダーの両方のコントロールの種類と一致する必要があります。  
  
-   コネクション ポイントを共に有効にする必要があります \(その <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A> 両方メソッド `true`\)。  
  
-   各接続ポイントことはできません、独自に指定する内容よりもより多くの接続を形成する <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A> プロパティです。  
  
-   場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクト \(transformer\) は必要で互換性のないコントロールを接続することはできません `null`します。 ただし、コントロールに互換性が既にトランスフォーマーあります `null`します。  
  
-   使用する場合、\(トランスフォーマーを\) が有効にする必要がある、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> コレクションです。  
  
-   トランスフォーマー \(使用する場合\) には、2 つのコントロール間のデータを変換できるように、プロバイダーとコンシューマーと互換性のあるインターフェイスが必要です。 コンシューマーとプロバイダーのセカンダリのインターフェイスも互換性がある場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">データを提供するコントロール <c>consumer</c> コントロールが接続されています。</param>
        <param name="providerConnectionPoint">A <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> できる <c>provider</c> の接続に参加します。</param>
        <param name="consumer">コントロールからデータを受信する <c>provider</c> コントロールが接続されています。</param>
        <param name="consumerConnectionPoint">A <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> として機能するコールバック メソッドのでを <c>consumer</c> 接続に参加できます。</param>
        <summary>チェック、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールがコンシューマーとプロバイダーのコントロールは、互換性のあるインターフェイスを持つ場合、接続できるかどうかを判断への接続に参加する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> オブジェクトは必要ありません。</summary>
        <returns>示すブール値かどうか <paramref name="provider" /> と <paramref name="consumer" /> 接続することができます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して接続を `provider` と `consumer` 両方のコントロール ポイントの種類、互換性のある接続しているときにできるように、 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクトは必要ありません。 このメソッドを使用して、2 つのコントロールを呼び出す前に接続できることを確認する <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> プログラムによる接続を作成します。  
  
 このオーバー ロードと同じ実装を使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> メソッド オーバー ロードのこのオーバー ロードがトランスフォーマーを必要としないことをする唯一の例外を使用します。  
  
   
  
## 例  
 次のコード例では、このメソッドを使用する方法を示します。  
  
 このコード例には、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含む Web ページ <xref:System.Web.UI.WebControls.WebParts.WebPart> 接続可能なコントロール、 `<asp:webpartmanager>` 要素、およびいくつかのイベント処理コードを使用して接続を作成する、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドです。  
  
-   ソース コード ファイルを含む 2 つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、およびカスタム インターフェイスです。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 このコード例の最初の部分は、表示モードを変更するユーザー コントロールです。 使用例」セクションからユーザー コントロールのソース コードを取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 表示モードおよびユーザー コントロールの動作方法の詳細については、次を参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 Web ページの宣言型マークアップを含む `Register` ユーザー コントロールとカスタム コントロールの両方のディレクティブです。`<asp:webpartmanager>` 要素、 `<asp:webpartzone>` カスタム コントロールを格納する要素と `<asp:connectionszone>` 要素。 ある、 `Page_Load` メソッド、コードをチェックするかどうか、接続可能であると場合は、プロバイダー、コンシューマーがそれぞれのコネクション ポイントを定義し、によって参照される静的な接続のセットに新しい接続を追加、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティです。  
  
 [!code-csharp[WebParts\_WebPartManager\_StaticConnections\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_StaticConnections\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 例の 3 番目の部分では、コントロールのソース コードを示します。 インターフェイスと 2 つのカスタムが含まれている <xref:System.Web.UI.WebControls.WebParts.WebPart> には、プロバイダー、およびコンシューマーとして、その他の役割を果たす 1 です。 互換性のある接続ポイントがあるため \(これらの両方を認識、 `IZipCode` インターフェイス\)、トランスフォーマーが接続するために必要ありません。 このコード例を実行するには、このソース コードをコンパイルする必要があります。 明示的にコンパイルし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに、生成されたアセンブリを配置できます。 また、ここで、動的にコンパイル実行時に、サイトの App\_Code フォルダーにソース コードを配置することができます。 コンパイルする方法について説明するチュートリアルは、次を参照してください。 [Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)します。  
  
 [!code-csharp[WebParts\_WebPartManager\_StaticConnections\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts\_WebPartManager\_StaticConnections\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 クリックして、ブラウザーで Web ページが読み込まれた後、 **表示モード** ドロップダウン リスト コントロールと選択 **接続** 接続モードをページに切り替えます。 接続モードは、 `<asp:connectionszone>` 要素を使用すると、コントロール間の接続を作成します。 接続モードなどのタイトル バーの下向きの矢印をクリックして、 **郵便** の動詞メニューをアクティブに制御し、をクリックして **接続**します。 接続のユーザー インターフェイス \(UI\) が表示されたら、接続が既にに含まれるコードによって作成されたことに注意してください、 `Page_Load` メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">データを提供するコントロール <c>consumer</c> コントロールが接続されています。</param>
        <param name="providerConnectionPoint">A <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> として機能するコールバック メソッドのでを <c>provider</c> 接続に参加できます。</param>
        <param name="consumer">コントロールからデータを受信する <c>provider</c> コントロールが接続されています。</param>
        <param name="consumerConnectionPoint">A <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> として機能するコールバック メソッドのでを <c>consumer</c> 接続に参加できます。</param>
        <param name="transformer">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> により、互換性のない <c>provider</c> と <c>consumer</c> に接続します。</param>
        <summary>チェック、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを使用して、それらが接続されているのかどうかを判断への接続に参加する、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 互換性のないコンシューマーとプロバイダー間の接続を作成するオブジェクト。</summary>
        <returns>示すブール値かどうか <paramref name="provider" /> と <paramref name="consumer" /> の接続を構成することができます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して接続を `provider` と `consumer` 両方のコントロール ポイントの種類、互換性のない接続しているときにできるように、 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクトが必要です。 このメソッドを使用して、2 つのコントロールを呼び出す前に接続できることを確認する <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> プログラムによる接続を作成します。  
  
 このオーバー ロードと同じ実装を使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> トランスフォーマーが必要であるこのオーバー ロードされている唯一の例外で、メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページにコントロールのカタログからサーバー コントロールを追加するために使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> フィールドが参照するカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> が作成されに含まれているオブジェクト、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 これは、静的オブジェクトであるため、できるトークンを参照する経由で直接、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラス、コントロールのインスタンスを必要はありません。  
  
 ページを切り替えることができますユーザーは、サーバー コントロールのカタログが利用可能な場合、ページにコントロールを追加する場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> \(カタログ モード\)、およびカタログのユーザー インターフェイス \(UI\) が表示されます。 Web パーツのカタログの UI がによって提供される、 <xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> ゾーンのコントロールです。 開発者は、デザイン時にページにこのゾーンを追加し、ユーザーが実行時にそれらのコントロールをそれらのページに追加できるようにサーバー コントロールをゾーンに追加します。 開発者がこれらのコントロールを追加した後は、カタログ モードを有効にするために必要なコントロールがあるため、ページ上でサポートされている表示モードがカタログ モードになります。  
  
 切り替えた場合、モード、ゾーン、および表示すると、それに追加されたすべてのサーバー コントロールのカタログ ページと、ユーザーは、ページに追加するか、コントロールをページから削除するカタログからコントロールを選択することができます。 コントロールがページに追加した後は、通常のブラウズ モードで表示される、ページが更新されます。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> プログラムを使用してフィールドです。 コードでは、参照、設計、およびカタログをここでは、ページのサポートされている表示モードのドロップダウン リストを生成します。 カタログ モードはのために使用できる、 `<asp:CatalogZone>` 要素と、Web ページには、その子要素です。 いることを確認、 `Page_PreRender` メソッドは、コードのチェックするかどうか、現在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> にプロパティが設定されている <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>します。 場合は、 `Label1` 、表示される、存在しない場合 `Label1` 非表示にします。  
  
 [!code-csharp[WebParts\_WebPartManager\_CatalogDisplayMode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_CatalogDisplayMode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、既定ではブラウズ モードでは。 ページ上のラベルが非表示であることを確認します。 ドロップダウン リスト コントロールを使用して、ページをカタログ モードに切り替えます。 \[コードのためいることを確認、 `Page_PreRender` メソッドをラベルが表示されるようになりました。 カタログでコントロールを選択し、ページ上の 2 つのゾーンのいずれかに追加します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>値、要求を行うブラウザーの機能のチェック、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> クライアント スクリプトを表示するかどうかを判断するにします。</summary>
        <returns>クライアント スクリプトを表示するかどうかを示すブール値。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはユーザーが接続で他のコントロールにプロバイダーとして機能しているコントロールを閉じるときに表示される警告を設定します。</summary>
        <value>警告メッセージを含む文字列です。 既定では、.NET Framework で提供されるカルチャに固有のメッセージです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ユーザーが閉じたときに、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを通常メッセージは表示されません。 コントロールを終了する意味の詳細については、次を参照してください。、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドです。  
  
 ただし、コントロールでは、別のコントロールに接続されているし、その他のコントロールへのデータ プロバイダーとして機能している、既定の警告メッセージが表示されます、ユーザーがコントロールを終了しようとしたとき。 メッセージは、プロバイダー コントロールがされた閉じるには、コンシューマーが使用する任意のデータがあるなくなるようを制御する手段がこのプロバイダーに接続するユーザーを指示します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> プロパティにより、開発者はユーザーに表示される警告メッセージをカスタマイズします。  
  
 場合は、ページの開発者には、このプロパティに文字列が空または null 値が割り当てられ、警告メッセージ ボックスは表示されません、ユーザーが閉じるときに、 <xref:System.Web.UI.WebControls.WebParts.WebPart> プロバイダーであるコントロール。  
  
   
  
## 例  
 次のコード例では、使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> プロパティをユーザーにカスタム警告を表示します。  
  
 このコード例には、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   ソース コード ファイルを含む 2 つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタム インターフェイスです。  
  
-   2 つのカスタムを含む Web ページ <xref:System.Web.UI.WebControls.WebParts.WebPart> 接続可能なコントロールと `<asp:webpartmanager>` 要素。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 次のコードには、例の Web ページの部分のみが含まれています。 上記で説明したカスタム コントロールのソース コードとカスタム ユーザー コントロールも必要になります。 使用例」セクションから 2 つの項目を取得、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。  
  
 次の Web ページ コードは、カスタムの警告メッセージを割り当てる方法の例、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> プロパティ内の宣言型マークアップで、 `<asp:webpartmanager>` 要素。  
  
 [!code-csharp[WebParts\_WebPartManager\_CloseProviderWarning\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_CloseProviderWarning\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 クリックして、ブラウザーで Web ページが読み込まれた後、 **表示モード** ドロップダウン リスト コントロールと選択 **接続** 接続モードをページに切り替えます。 接続モードは、 `<asp:connectionszone>` 要素を使用すると、コントロール間の接続を作成します。 接続モードなどのタイトル バーの下向きの矢印をクリックして、 **郵便** の動詞メニューをアクティブに制御し、をクリックして **接続**します。 接続のユーザー インターフェイス \(UI\) が表示されたら、クリックして、 **コンシューマーへの接続を作成する** リンクします。 ドロップダウン リスト コントロールを含むセルが表示されます。 選択 **Weather Control** ドロップダウン リストをクリック **接続** 2 つのコントロールの接続を完了します。 をクリックして **閉じる**, をクリックして、 **表示モード** ドロップダウン リストに、ページを通常のブラウズ モードに戻ります。 動詞メニューをクリックし、 **郵便** \(これは、プロバイダー コントロールでも\) コントロールを選択 **閉じる**します。 カスタム メッセージに割り当てられている、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> プロパティが表示されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> やサーバー コントロールでは停止されますが、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />です。</param>
        <summary>閉じる、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> Web ページには表示されませんが、再度開くことができます、このような方法で制御します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドの削除、 <xref:System.Web.UI.WebControls.WebParts.WebPart> またはその他のサーバー コントロールを含んでいた Web ページではレンダリングされません。 終了したコントロールを追加、 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> オブジェクトでは、終了したコントロールへの参照を保持し、ページを復元するコントロールできるようになります。 閉じた <xref:System.Web.UI.WebControls.WebParts.WebPart> によって参照されるコレクションにコントロールが表示されたまま、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティです。  
  
 コントロールの終了は、削除すると異なります。 終了したコントロールは、ページを復元する引き続き使用できますが、削除されたコントロールのインスタンスは完全に削除しは復元できません。 かどうかに関係なく、 <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバー コントロールが \(ページのマークアップで宣言\) 静的または動的 \(ページに追加、またはユーザーがプログラムを使用して Web パーツのカタログから\)、閉じるし、ページで再度開くことができます。  
  
 通常、ユーザーが閉じることができます、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール動詞メニューをクリックして閉じる動詞を選択します。 コントロールを直接呼び出すことで終了することもできます。、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドおよびへの参照を渡した `webPart`します。  
  
 ページで、 <xref:System.Web.UI.WebControls.WebParts.WebPart> 開発者を宣言する場合のコントロールが閉じられた、 `<asp:catalogzone>` 要素内に追加し、 `<asp:pagecatalogpart>` 要素、実行時に終了したコントロールをページに復元するユーザー向けのシンプルなユーザー インターフェイス \(UI\) を提供しています。 ユーザーを使用して、ページをカタログ表示モードに切り替えることができ、ページ、カタログ内に終了したコントロールが表示されます。 ユーザーは、終了したコントロールを選択し、追加の任意の位置のページに戻ると、選択したコントロールが、ページに復元され、通常どおり表示されます。  
  
 ときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドが呼び出されると、いくつかのイベントを発生させます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, 、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> \(があれば、複数のコントロール\)、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> \(接続されているコントロールがある\) 場合。 通常開発者がこれらのイベントを取り消すことができますが、場合によってはキャンセルすることです。 詳細については、ドキュメントを参照して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, 、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>, 、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントです。  
  
   
  
## 例  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドの使用方法を示します。  
  
 このコード例には、4 つの部分があります。  
  
-   ユーザー コントロールをページの表示モードを変更することができます。  
  
-   カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。  
  
-   Web ページ。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 このコード例の最初の部分は、表示モードを変更するユーザー コントロールです。 使用例」セクションからユーザー コントロールのソース コードを取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 表示モードおよびユーザー コントロールの動作方法の詳細については、次を参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 コード例の 2 つ目は、カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 このコード例を実行するには、このソース コードをコンパイルする必要があります。 明示的にコンパイルし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに、生成されたアセンブリを配置できます。 また、ここで、動的にコンパイル実行時に、サイトの App\_Code フォルダーにソース コードを配置することができます。 この例は、動的コンパイルのアプローチを使用してください。したがってない `Assembly` 属性、 `Register` ディレクティブ、Web ページの上部にあるこのコントロールをします。 コンパイルする方法について説明するチュートリアルは、次を参照してください。 [Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)します。  
  
 [!code-csharp[WebParts\_WebPartManager\_CloseWebPart\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts\_WebPartManager\_CloseWebPart\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 コード例の 3 番目の部分は、Web ページです。 ページには、 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> ゾーンで、\<`asp:pagecatalogpart>` 内に要素が宣言されています。 これは、閉じた内容 <xref:System.Web.UI.WebControls.WebParts.WebPart> を制御し、ページに追加するユーザーを有効にします。`Button1_Click` メソッドを直接呼び出す、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> カスタムを終了するメソッド <xref:System.Web.UI.WebControls.WebParts.WebPart> 動詞メニューを使用してコントロールを閉じることも、ユーザーを制御します。  
  
 [!code-csharp[WebParts\_WebPartManager\_CloseWebPart\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_CloseWebPart\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後閉じますカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> 、コントロールのヘッダーの動詞メニュー \(矢印\)\] をクリックしてコントロール **閉じる**します。 これでページを変更するカタログ モードを選択して **カタログ** で、 **表示モード** ドロップダウン リスト コントロールです。 終了したコントロールがページのカタログが表示されます。 終了したコントロールの横にあるチェック ボックスを選択して \[ **追加** クリックして、ページに追加する **閉じる** ブラウズ モードをページに戻ります。 コントロールがページに戻ります。 これで閉じるをもう一度クリックして、 **web パーツを閉じる** \] ボタンをクリックします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 含まれていない、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクションです。  
  
 または  
  
 <paramref name="webPart" /> 共有コントロール、および他のユーザーが既に閉じられています。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーの間の接続を管理する特殊なユーザー インターフェイス \(UI\) を表示するための表示モードを表す <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> フィールドが参照するカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> が作成されに含まれているオブジェクト、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 これは、静的オブジェクトであるため、できるトークンを参照する経由で直接、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラス、コントロールのインスタンスを必要はありません。  
  
 ユーザーが間の接続を管理する <xref:System.Web.UI.WebControls.WebParts.WebPart> されている場合、Web ページ上の制御、 <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> ゾーンは、ページに宣言されているにページを切り替えることができます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> モードです。 接続の表示モードには、接続や、コントロールを切断して、既存の接続の詳細を編集する機能も含まれます接続を管理するための特別な UI が表示されます。  
  
 Web パーツ コントロール セットによって提供される UI で接続を管理する権限をユーザーに提供するかどうかは、宣言する必要あります、 `<asp:connectionszone>` ページのマークアップ内の要素。 他の種類の要素とは異なり <xref:System.Web.UI.WebControls.WebParts.WebZone> ゾーンの場合、この要素内の他のすべてのタグを追加する必要はありません; 単独で要素を宣言するだけです。  
  
   
  
## 例  
 次のコード例は、の使用法を示しています、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> モードです。  
  
 このコード例には、3 つの部分があります。  
  
-   インターフェイスとユーザー設定を含むソース ファイル <xref:System.Web.UI.WebControls.WebParts.WebPart> の接続を構成できます。  
  
-   UI の接続を提供しの使用について説明する Web ページ、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> モードです。  
  
-   この例を実行する方法の説明です。  
  
 このコード例の最初の部分は、インターフェイスと 2 つのカスタムを含むソース ファイル <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを接続できるように設計されています。 このコード例を実行するには、このソース コードをコンパイルする必要があります。 明示的にコンパイルし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに、生成されたアセンブリを配置できます。 また、ここで、動的にコンパイル実行時に、サイトの App\_Code フォルダーにソース コードを配置することができます。 このコード例では、動的なコンパイル アプローチを使用します。 コンパイルする方法について説明するチュートリアルは、次を参照してください。 [Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)します。  
  
 [!code-csharp[WebParts\_WebPartManager\_ConnectDisplayMode\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts\_WebPartManager\_ConnectDisplayMode\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 例の 2 番目の部分は、カスタム コントロールをホストする Web ページです。 サーバー内で `<script>` \] ページでのタグは、いくつかの方法\] ページで利用可能な表示モードのドロップダウン リストに設定します。 ユーザーは、これらのページの表示モードを変更するドロップダウン リストから選択します。 使用可能な表示モードのいずれかが表示モードを接続するため、 `<asp:connectionszone>` 要素が、ページのマークアップで宣言されています。 この要素に、その他の子要素が含まれていないことに注意してください。ユーザーの接続の管理 UI を有効にする場合にのみ存在します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> モードは、この例では、2 つの場所に表示されます。 最初に、 `Page_Init` メソッド、接続の表示モードが追加表示モードのドロップダウン リストとして、コードがで参照されるコレクションをループ処理、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティです。 2 番目、 `Page_PreRender` メソッドは、ページ上の現在の表示モードをチェックし、現在のモードの場合 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>, でメッセージが表示されます、 <xref:System.Web.UI.WebControls.Label> コントロールです。  
  
 [!code-csharp[WebParts\_WebPartManager\_ConnectDisplayMode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_ConnectDisplayMode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 ブラウザーでページを読み込むと、ドロップダウン リストをクリックし、選択 **接続** 接続表示モードに切り替えるにします。 メッセージが表示し、表示モードを接続するに、ページがあるということを確認します。 ここでの 1 つのタイトル バーに動詞メニュー \(矢印\) をクリックして、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、およびクリック **接続** 動詞メニューにします。 接続を作成するリンクをクリックして、接続された後で、UI が表示されます。 接続に表示される UI 内でのドロップダウン リストを使用して、その他のコントロールは、接続に参加し、クリックを選択、 **接続** \] ボタンをクリックします。 接続が確立します。 クリックして、 **閉じる** ボタンをクリックし、表示モードを参照するページを返すため、ページの上部にあるドロップダウン リストを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上のすべての接続のコレクションへの参照を取得します。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> のセットを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> プロパティはページ上の接続の現在のセットにアクセスする手段を提供します。 コレクション自体は読み取り専用コレクションから特定の接続を操作する開発者に使用して <xref:System.Web.UI.WebControls.WebParts.WebPartManager> などのメソッド <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> と <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>です。  
  
   
  
## 例  
 次のコード例では宣言型およびプログラムによる使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。  
  
 このコード例には、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含む Web ページ <xref:System.Web.UI.WebControls.WebParts.WebPart> 接続可能なコントロールと `<asp:webpartmanager>` 要素。  
  
-   ソース コード ファイルを含む 2 つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタム インターフェイスです。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 次のコードには、例の Web ページの部分のみが含まれています。 上記で説明したカスタム コントロールのソース コードとカスタム ユーザー コントロールも必要になります。 使用例」セクションから 2 つの項目を取得、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。  
  
 次の Web ページ コードを使用する方法の例、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> プロパティ ページで現在の接続の数を取得するには、プログラムを使用しています。 注意してください、 `<script>` タグのセクションでは、の 2 つのイベントを処理するコード、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> へのアクセスを制御、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> 数を取得するプロパティです。  
  
 [!code-csharp[WebParts\_WebPartManager\_SimpleConnection\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_SimpleConnection\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 クリックして、ブラウザーで Web ページが読み込まれた後、 **表示モード** ドロップダウン リスト コントロールと選択 **接続** 接続モードをページに切り替えます。 接続モードは、 `<asp:connectionszone>` 要素を使用すると、コントロール間の接続を作成します。 接続モードなどのタイトル バーの下向きの矢印をクリックして、 **郵便** の動詞メニューをアクティブに制御し、をクリックして **接続**します。 接続のユーザー インターフェイス \(UI\) が表示されたら、クリックして、 **コンシューマーへの接続を作成する** リンクします。 ドロップダウン リスト コントロールを含むセルが表示されます。 選択 **Weather Control** ドロップダウン リストをクリック **接続** 2 つのコントロールの接続を完了します。 をクリックして **閉じる**, をクリックして、 **表示モード** ドロップダウン リストに、ページを通常のブラウズ モードに戻ります。 接続の数との数に、ラベルを今すぐ表示ことに注意してください <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 今すぐにコントロールするのには、2 つを切り、接続モード、ブラウズ モードに戻ると返された場合、ラベルの内容を更新する必要があり、接続ことはありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ上のすべての現在の Web パーツ接続はのみ接続されておらずがアクティブに接続するたびに関係するコンシューマーとプロバイダーのコントロール間でデータの共有を開始してもに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続のライフ サイクルでは、このイベントは、ページの読み込みプロセスの完了後に発生します。 後にも発生、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> ことを示すだけイベント、 <xref:System.Web.UI.WebControls.WebParts.WebPart> または特定の接続に関連するサーバー コントロールが正常に接続されています。 場合は、ページ上の複数の接続が存在する、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> メソッド表示されるページ上のすべての有効な Web パーツ接続今すぐ active、データを共有することです。 すべての接続がアクティブである理解していれば、開発者を実行できます任意の数などのすべての接続の状態のユーザーに通知する、タスクの処理し、プロバイダーからのデータが表示されにコンシューマー コントロールに通知します。  
  
 このイベントに関連付けられて、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> メソッドは、イベントを発生させるイベントのカスタム ハンドラーを作成できます。  
  
 ページの開発者は、追加することで、イベントのカスタム ハンドラーを作成できます、 `OnConnectionsActivated` 属性を `<asp:webpartmanager>` 内の要素\] ページで、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページで確立されているすべての Web パーツ接続をアクティブ化するプロセス中に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続のライフ サイクルのこのイベントが含まれるページは、プロセスが完了したら、読み込み、直前に、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> メソッドが呼び出されます。 異なる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 間で特定の接続を含むイベント <xref:System.Web.UI.WebControls.WebParts.WebPart> またはその他のサーバー コントロール。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> イベントは、ページ上のすべての可能な接続が接続されたし、アクティブ化しようとしている場合に発生します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> にイベントが関連付けられている、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> メソッドで、イベントを発生させます。 ページに追加できる接続の種類を拡張するコントロールの開発者は、保護されたオーバーライドでした <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> メソッドおよびその他の種類の接続をアクティブ化します。  
  
 ページの開発者は、追加することで、イベントのカスタム ハンドラーを作成できます、 `OnConnectionsActivating` 属性を `<asp:webpartmanager>` 内の要素\] ページで、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つの接続を作成 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 内に置かれているコントロール \(またはその他のサーバー コントロールの接続を構成できる\)、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> メソッドは、2 つの間の接続を形成 <xref:System.Web.UI.WebControls.WebParts.WebPart> 接続可能なコントロールです。 接続を作成するには、このメソッドを呼び出す前にすることもを呼び出して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> コントロールが接続の構成の要件を満たしていることを確認する条件の確認方法です。  
  
> [!NOTE]
>  2 つのサーバー コントロールの間の接続を作成することも <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 2 つのコントロールをカスタム サーバー コントロールである必要が一般に、\(から継承するコントロールなどの <xref:System.Web.UI.WebControls.WebControl> または既存の ASP.NET サーバー コントロール\)、必要なメンバーを追加することができるようにします。 コントロールを次に示す要件を満たすためにも必要があります。  
  
 任意の種類の 2 つのコントロール間の接続シナリオでは、接続できるようにするには、次の要件を満たす必要があります。  
  
-   各コントロールが存在する、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーン \(同じゾーンするは必要ありません\)。  
  
-   接続のプロバイダーのコントロールが、プロバイダーへのコールバックとして機能を持つパブリック メソッドとしてインターフェイスを実装して、Web パーツ コントロール セットに実装された、 `ConnectionProvider` プロバイダー接続ポイントとして識別するために、メソッドのメタデータ属性です。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 取得プロバイダー接続ポイントが仮想であるメソッドは、派生 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールとは限りませんが、同じメタデータ属性を使用します。  
  
-   Web パーツ コントロール セットに実装した場合、接続のコンシューマー コントロールもは、プロバイダーのコールバック メソッドで公開されるインターフェイスへの参照を取得できるようにする特殊なメソッドがあり、コンシューマー、 `ConnectionConsumer` コンシューマー接続ポイントとして識別するために、メソッドのメタデータ属性です。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 取得コンシューマー接続ポイントが仮想であるメソッドは、派生 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールとは限りませんが、同じメタデータ属性を使用します。  
  
-   コールバック メソッドは互換性がなければなりませんか、プロバイダーのコールバック メソッドが \(つまり、コンシューマーとプロバイダーを共有できることデータ直接\)、または開発者に提供されているインターフェイスを使用する必要がありますが、コンシューマーの種類を使用できる、 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> コンシューマーが使用できるように、プロバイダーからデータを変換するオブジェクト。  
  
    > [!IMPORTANT]
    >  トランスフォーマーを不要にするときに使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> メソッドのオーバー ロードします。 トランスフォーマーを必要なときに使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 権利をお客様のデータを他の役割を持つコントロールには、コントロールが接続されています。</param>
        <param name="providerConnectionPoint">接続のコールバック メソッドとして機能する方法。 これは、パブリック メソッド、Web パーツ コントロール セットに実装された <c>provider</c> でマークされる、 <see langword="ConnectionProvider" /> メタデータ属性です。</param>
        <param name="consumer">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールからデータを受信する役割を持つ <c>provider</c>, 、処理するか、それを表示します。</param>
        <param name="consumerConnectionPoint">メソッドを使用して接続を <c>providerConnectionPoint</c> データ接続を受信します。 これは、パブリック メソッド、Web パーツ コントロール セットに実装された <c>consumer</c> でマークされる、 <see langword="ConnectionConsumer" /> メタデータ属性です。</param>
        <summary>2 つの接続を作成する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> または <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロールと、指定したへの参照だけを使用して制御 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> オブジェクトです。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> プロバイダーとの接続に必要なコンシューマーに関するさまざまな情報を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用して、接続ポイントが使用することがなく接続できることを十分に互換性のある場合に、コントロールを接続する、 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクトです。 メソッドのこのオーバー ロードが呼び出されると、単に渡し、メソッドの他のオーバー ロードされたバージョンへの呼び出し、渡します `null` を必要とするパラメーターの <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクトです。  
  
 2 つのコントロールをプログラムで接続するときは、使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> コントロールを直接接続するかどうかを判断する条件の確認方法です。  
  
   
  
## 例  
 次のコード例では、このメソッドを使用してプログラムを使用して接続を作成する方法を示します。 例を実行するために必要な完全なコードの例」のセクションを参照してください、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 その例の必要があります\] ページで、表示モードを変更できるユーザー コントロールのソース コードと、ソース コードの 2 つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。  
  
 2 つをホストする Web ページのコードでは、次のようを制御します。 ページを使用して `Register` 上部にあるディレクティブは、ユーザー コントロールとカスタム コントロールを宣言します。 カスタム コントロールは、参照されている宣言で内、 `<asp:webpartzone>` 要素。 処理するコード、 `Button1_Click` メソッドを使用してコントロール間の接続を作成する、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> メソッドです。  
  
 [!code-csharp[WebParts\_WebPartManager\_ConnectWebParts1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_ConnectWebParts1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後、 **web パーツ コントロールの接続** 、接続を構成する\] ボタンをクリックします。 テキスト ボックスにデータを入力し、をクリックして、 **5 桁の郵便番号を入力** コントロールが接続されている場合、2 つ目の最初のコントロールに入力されたデータが更新されることを示すためのボタンをクリックします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 動的コレクションのコントロールのコレクションは読み取り専用です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 接続されている別のコントロールにデータを提供の役割を持ちます。</param>
        <param name="providerConnectionPoint">パブリック メソッド <c>provider</c> でマークされる、 <see langword="ConnectionProvider" /> メタデータ属性の場合は、接続のコールバック メソッドとして機能していません。</param>
        <param name="consumer">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> からデータを受け取るの役割を持つ <c>provider</c> または <c>transformer</c>, 、処理するか、それを表示します。</param>
        <param name="consumerConnectionPoint">パブリック メソッド <c>consumer</c> でマークされる、 <see langword="ConnectionConsumer" /> メタデータ属性を使用して接続し、 <c>providerConnectionPoint</c> データ接続を受信します。</param>
        <param name="transformer">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> からデータを変換することで 2 つのコントロール間の接続を有効にする <c>provider</c> 形式にする <c>consumer</c> を処理できます。</param>
        <summary>2 つの接続を作成する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> または <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロールに、指定された参照の使用を制御 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> オブジェクト、および <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> オブジェクトです。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> プロバイダー、コンシューマー、および接続のために必要な変換に関する情報を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを使用すると、コントロールを接続ポイントは、互換性がない場合に接続できます。 非互換性が発生したときに `consumer` よりも異なるインターフェイスを実装する `provider` の接続ポイントとして。 によって認識できる型にデータをトランスフォーマー `consumer`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">接続が既にで <see cref="E:System.Web.UI.Control.PreRender" />です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのコレクションを取得 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, 、サーバー、またはユーザー コントロールに含まれている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> Web ページ上のゾーンであると、によって管理される、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。</summary>
        <value>A <see cref="T:System.Web.UI.ControlCollection" /> によって管理されるすべてのコントロールを含む、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> プロパティによって参照されているその他のコントロールを参照しない、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> を制御するなど、さまざまなゾーンのコントロール、 <xref:System.Web.UI.WebControls.WebParts.EditorPart> または <xref:System.Web.UI.WebControls.WebParts.CatalogPart> コントロール、およびその他のユーザーです。  
  
 このプロパティはコードから呼び出されるものではありません、ほとんどの開発状況で Web パーツ コントロール セットによって使用されます。 このため、プロパティがパブリックでも非表示にされて IntelliSense からです。 コレクションにアクセスする開発者向け <xref:System.Web.UI.WebControls.WebParts.WebPart> またはによって管理されるその他のサーバー コントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールを使用してその <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはコピーするサーバー コントロール。</param>
        <summary>設定のコピーを作成する Web パーツ コントロールによって使用される、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> または Web ページにコントロールを追加するためにサーバー コントロール。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ページに追加します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すことができない、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> コードから直接メソッドです。 このメソッドがによって内部的に呼び出されます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 新しい動的に追加するプロセスの一部としてコントロール <xref:System.Web.UI.WebControls.WebParts.WebPart> またはページにサーバー コントロール。 ダイナミック コントロールが追加ページにプログラムから、または Web パーツのユーザー インターフェイス \(UI\) から次に例を直接ページのマークアップで宣言されている静的コントロールではなく、コントロールのカタログからコントロールを追加するユーザーがされます。  
  
> [!NOTE]
>  メソッドは、開発者は、その他のコントロールのシナリオのコピーを処理するメソッドを有効にする場合、派生クラスでオーバーライドできます。 詳細については、継承元のセクションへのメモを参照してください。  
  
 追加する場合、新しい動的コントロールがである場合、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> メソッドは、コントロールの新しいインスタンスを返します。 追加するコントロールが他の種類 \(ユーザー コントロール、カスタム コントロールでは、ASP.NET コントロールなど\) のサーバー コントロールの場合は、コントロールは既にラッピングされていると、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Web パーツ コントロール セットでのオブジェクト。 ときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> メソッドを検出した、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 、コントロールの新しいインスタンスを返します、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 内にラップした子コントロールの新しいインスタンスを制御します。  
  
 ときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> メソッドを返すコントロールの新しいコピーを作成、既定値にも、すべてのプロパティの値をリセットします。 新しいコントロール インスタンスにコピーしたをパーソナル化できるプロパティの値を保持している場合は、呼び出す必要があります、 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> メソッドもします。 実行される最後の手順、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> メソッドを呼び出すには、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A> メソッドは、コントロールの新しい ID を取得します。  
  
> [!NOTE]
>  参照先のページに、元の ID によって追加されるダイナミック コントロールにしないで、メソッドにコピーしたコントロールの新しい ID が取得されるため 代わりに、このメソッドによって返されるコントロールの新しいインスタンスを参照してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The method is declared as <see langword="virtual" /> so that developers could inherit from the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class, override the method, and provide for additional scenarios in which it could create copies of controls. For example, the method could optionally receive as input a control that has been serialized into an XML file. The method could deserialize the XML (if present), and then call the base method to handle the existing cases and to return a new instance of a <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> control.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web サイトの構成ファイルで指定の変換機能のセットを作成し、によって参照される変換のコレクションに追加、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> プロパティです。</summary>
        <returns>Web サイトの構成ファイルに指定のコレクションです。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>This method can be overridden to add additional transformers that can be used by the application. For example, the method could be written to retrieve a list of available transformers from a Web service.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>管理されているすべてのコントロールのコレクションを返す、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Web ページ上のコントロールです。 このクラスは継承できません。</summary>
        <returns>A <see cref="T:System.Web.UI.ControlCollection" /> によって管理されるすべてのさまざまな Web パーツ コントロールで構成される、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Because this method is protected and sealed, it is visible to classes that inherit from the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class, but it cannot be overridden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web パーツ アプリケーションのすべての可能な表示モードのセットを作成します。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> はサポートされているすべての表示モードを格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、特定のページにサポートされている表示モードだけでなく、すべての可能な表示モードの一覧を作成します。 サポートされている表示モードの詳細については、次を参照してください。、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティです。  
  
 既定では、Web パーツ コントロール セットには、次の Web パーツ ページに使用される表示モードのセットが作成されます。  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 開発者は、カスタム表示モードを作成できますかにかかわらずから派生するカスタムのゾーンに付属する、 <xref:System.Web.UI.WebControls.WebParts.WebZone> または <xref:System.Web.UI.WebControls.WebParts.ToolZone> クラスです。 カスタム表示モードを作成するから継承する必要があります、 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> クラス、ページでサポートされているモードとして、表示モードを追加するから継承する必要があります、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスさせ、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> メソッドです。  
  
 使用して表示モードを追加すると、 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A> メソッドを追加ことはすべてのユーザー インターフェイス \(UI\) コントロールに表示される順序で \(など、 <xref:System.Web.UI.WebControls.ListBox> コントロール\) に提供するユーザーの表示モード、ページ上。  
  
   
  
## 例  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> メソッドの使用方法を示します。  
  
 このコード例には、5 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   その他のコントロールをホストする Web ページ。  
  
-   ユーザー コントロール内にある、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Web ページ上のゾーンを入力し、ラベルのテキストを表示することができます。  
  
-   2 つのコントロールを含むソース コード ファイル。 1 つは、カスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 制御、およびその他は、カスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 、ページの既定の表示モードに追加するオブジェクト。  
  
-   ソース コード ファイルを含む 2 つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、およびカスタム インターフェイスです。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 このコード例の最初の部分は、表示モードを変更するユーザー コントロールです。 使用例」セクションからユーザー コントロールのソース コードを取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 表示モードおよびユーザー コントロールの動作方法の詳細については、次を参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 この例の 2 番目の部分は、Web ページです。 2 つ含まれている <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ユーザー コントロールとカスタムの両方を制御 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 通知、 `Register` ユーザー コントロールとコンパイル済みのコントロールの名前空間を参照するページの上部にあるディレクティブです。  
  
 [!code-csharp[Webparts\_WebPartManager\_CreateDisplayModes\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-vb[Webparts\_WebPartManager\_CreateDisplayModes\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 例の 3 番目の部分は、ユーザー コントロールを入力してテキストを表示するためです。 使用して、 <xref:System.Web.UI.WebControls.MultiView> コントロールを UI の複数のビューを作成します。 1 つのビューが表示されます、 `Button1` \] ボタン、もう一方にないです。 は、オーバーライドされた `OnPreRender` メソッド、コードを確認するかどうか、ページのカスタム表示モードでは現在し場合は、最初のボタンを含むユーザー コントロールのビューが表示されます。 ページのページが参照またはデザイン モードの場合の例については、カスタム表示モードでない場合、ボタンは表示されません。  
  
 [!code-csharp[Webparts\_WebPartManager\_CreateDisplayModes\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-vb[Webparts\_WebPartManager\_CreateDisplayModes\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 この例の 4 番目の部分は、2 つのカスタム クラスのソース ファイルです。 注意して、カスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスのオーバーライド、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> メソッド、および、最初に追加の既定の表示モードでは、基本メソッドを呼び出したし、カスタム表示モードを追加します。 カスタム表示モード クラス `InLineEditDisplayMode`, 、単に継承 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>, 、コンス トラクターでの表示モードの名前を設定、およびさまざまなカスタムの表示の特性を確立するために基本プロパティをオーバーライドします。  
  
 このコード例を実行するには、このソース コードをコンパイルする必要があります。 明示的にコンパイルし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに、生成されたアセンブリを配置できます。 また、ここで、動的にコンパイル実行時に、サイトの App\_Code フォルダーにソース コードを配置することができます。 コンパイルする方法について説明するチュートリアルは、次を参照してください。 [Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)します。  
  
 [!code-csharp[Webparts\_WebPartManager\_CreateDisplayModes\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts\_WebPartManager\_CreateDisplayModes\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 コード例を実行するには、ブラウザーでページを読み込みます。 このページはブラウズ モードで現在はあり、ボタンが表示されていないことに注意してください。 使用して、 **表示モード** ドロップダウン コントロールの一覧で、ページを変更 **インライン編集表示** モード、および通知ことになった、 `Button1` ボタンは、下のユーザー コントロールで表示します。 一部のテキストを追加し、コントロールを更新\] ボタンをクリックします。 いるページの表示はブラウズ モードに戻り、入力したテキストが表示されますおよびのカスタム表示モードでページが不要になったために、もう一度ボタンが非表示に注意してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>動的な接続の ID として使用される一意の値を取得します。</summary>
        <returns>接続の一意の ID を表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> メソッドは、GUID 値を生成して、接続の一意の ID として使用する文字列に変換します。 動的な接続が作成されるたびに呼び出されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers can override this method in a derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class to change the implementation for generating a unique ID.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">
          <see cref="T:System.Type" /> の ID を生成するコントロール。</param>
        <summary>動的なの一意の ID が生成されます <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</summary>
        <returns>コントロールの一意の ID を表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPart> Web ページにコントロールを追加、\(つまり、コントロールがページのマークアップで宣言されている\) 静的または動的な \(つまりプログラムで追加される\) でことができます。 どのような状況で、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 一意の ID を生成するには、このメソッドを呼び出して、ページに追加する新しい動的なコントロールがコントロールの作成  
  
 メソッドが仮想の開発者 ID を生成するためのカスタム実装を提供する場合は、オーバーライドにできるようにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartType" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">障害が発生したコントロールの id を指定する文字列。 場合、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />が関係する、エラーを ID がその子サーバー コントロールの ID。</param>
        <param name="originalTypeName">示す文字列の名前、<see cref="T:System.Type" />失敗したコントロール。 場合、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />が関係する、障害発生時に、型名は、子サーバー コントロールの種類。</param>
        <param name="originalPath">場合に、ユーザー コントロールへのパスを格納する文字列、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />子を格納しているユーザー コントロールが原因で失敗します。</param>
        <param name="genericWebPartID">ID を表す文字列、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />その種類のコントロールが読み込みまたはコントロールの作成の失敗に関係している場合、します。</param>
        <param name="errorMessage">ページに表示するエラー メッセージを含む文字列です。</param>
        <summary>ページに挿入され、エンドユーザーの読み込みまたは動的な作成を試みるときに表示される特殊なコントロールを作成<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />コントロールが何らかの理由により失敗します。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />読み込みまたは作成に失敗したコントロールの代わりに、ページに挿入します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> Web パーツ コントロール セットの試行を読み込むか、動的なのインスタンスを作成するときに、メソッドは呼び出される<xref:System.Web.UI.WebControls.WebParts.WebPart>またはサーバー コントロールと、何らかの理由により失敗した場合します。 このメソッドを作成、<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>オブジェクトをエラー メッセージを代入し、それを取得します。<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>コントロールが、失敗したコントロールの代わりに挿入され、ページにそのエラー メッセージが表示されます。  
  
 呼び出すことはできません、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>コードから直接メソッドです。 ただしから継承することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスおよびメソッドを拡張します。 詳細については、継承元のセクションのノートを参照してください。  
  
 最後のユーザーが操作できる、<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>で制御ページ大部分は、通常の場合と同じように<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 削除するには、エラー メッセージに、コントロールを追加する時点で、閉じる動詞 をクリックしてコントロールを閉じることができます、<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>閉じられた他のコントロールと同様のオブジェクト。 エンド ユーザーを削除した場合、<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>コントロールを読み込めませんでした。 サーバー コントロールは、ページからも削除されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If you want to customize the information that is returned in the <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> control, you can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" /> method, call the base method, assign different values to the parameters passed to the base method, and then return the resulting <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> control. For example, if you do not want end users to see the <paramref name="originalPath" /> value (which would show the virtual directory path of a user control), when you call the base method you could pass an empty string ("") for that parameter.  
  
 You can also customize the behavior of the <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> control itself, by inheriting from it. For example, you might want to override its <see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" /> or <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" /> property.</para>
        </block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の Web ページのユーザーの個人用設定データを格納するパーソナル化オブジェクトを返します。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> ユーザーの個人用設定データを格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A> および現在のページのユーザーの個人用設定を管理するオブジェクトが返されます。<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールがこのオブジェクトを管理します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">サーバー コントロールがない場合、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</param>
        <summary>サーバー コントロールがない場合のラップ、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> オブジェクト、コントロールは、Web パーツ機能を得られるようにします。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> をラップする <paramref name="control" /> として機能するようにして <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> メソッドがないサーバー コントロールを有効にするための主なメカニズムは、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールと同じ機能に、実行する、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、および Web パーツ アプリケーションに完全に参加します。 開発者は、このメソッドを大幅を使用して Web パーツ アプリケーションで使用可能なサーバー コントロールの数を増やす、標準の ASP.NET コントロール、ユーザー コントロールおよびカスタム コントロールというを使用することができますので、事実上すべてのサーバー コントロールの種類します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールもメソッドを使用してこの他の 2 つのシナリオで使用してサーバー コントロールをラップする、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトです。 ユーザー コントロールを追加とサーバー ページを使用して、 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 制御、インポートされたコントロールがいない場合、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> メソッドが呼び出されます。 内の永続化の形式でサーバー コントロールが宣言されている場合も、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Web ページ上のゾーン、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> れていない任意のコントロールのメソッドが呼び出された <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。  
  
 一般的なアプローチを使用してプログラムを使用してゾーンをサーバー コントロールを追加すると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> コントロールをラップするメソッド、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトし、しを呼び出す、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> コントロールをすべてのコレクションに追加するメソッドを <xref:System.Web.UI.WebControls.WebParts.WebPart> から参照されていると、ページ上のコントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティです。  
  
   
  
## 例  
 次のコード例では使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> メソッドです。`Button2_Click method`, 、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> をラップするメソッドが呼び出される、 <xref:System.Web.UI.WebControls.Calendar> コントロールを <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> をゾーンに追加する前にオブジェクトです。  
  
 [!code-csharp[WebParts\_WebPartManager\_DeleteWebPart\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_DeleteWebPart\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This method can be overridden to use a derived <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> class instead of the base class provided with the Web Parts control set.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロールを削除した場合に、エンドユーザーに表示されるカスタムの警告メッセージを設定します。</summary>
        <value>警告メッセージのテキストを含む文字列です。 既定値は、ローカライズされた警告メッセージです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ユーザーを削除すると、 <xref:System.Web.UI.WebControls.WebParts.WebPart> 制御、通常、既定の警告メッセージが表示されます。 ユーザーに警告するコントロールのこのインスタンスが削除されると、削除は恒久的です。 ページの開発者は、ページに、コントロールの新しいインスタンスを追加する方法をユーザーに提供があります \(などのカタログを <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、または一部のプログラムによる方法で\) が削除されるコントロールの現在のインスタンスは完全に削除します。 警告が表示されるダイアログ ボックスには、必要な場合、ユーザーが、削除をキャンセルするためのボタンが含まれます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> プロパティには、開発者がユーザーに表示される警告メッセージの設定ができるようにします。  
  
 ページの開発者には、空の文字列が割り当てられる場合 \(""\)、ユーザーを削除すると、このプロパティのない警告\] ダイアログ ボックスに値を表示する、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> プロパティは静的の場合は表示されません <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとサーバー コントロール。 静的コントロールは、サーバー内で宣言されている、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Web ページのマークアップにします。 このようなコントロールは静的であるため、削除できません、ため、削除の警告メッセージがその場合に表示されることはありません。 静的コントロールは、ユーザーが閉じてもかまいませんが、元となる追加できますページに戻り、ユーザーが削除されたコントロールを回復できない一方、ページのカタログに終了したコントロールを追加します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> プロパティの宣言でとプログラムを使用しています。  
  
 このコード例に 4 つの部分があります。  
  
-   ユーザー コントロールをページの表示モードを変更することができます。  
  
-   カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。  
  
-   Web ページ。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 このコード例の最初の部分は、表示モードを変更するユーザー コントロールです。 使用例」セクションからユーザー コントロールのソース コードを取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 表示モードおよびユーザー コントロールの動作方法の詳細については、次を参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 コード例の 2 つ目は、カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 このコード例を実行するには、このソース コードをコンパイルする必要があります。 明示的にコンパイルし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに、生成されたアセンブリを配置できます。 また、ここで、動的にコンパイル実行時に、サイトの App\_Code フォルダーにソース コードを配置することができます。 この例は、動的コンパイルのアプローチを使用してください。したがってない `Assembly` 属性、 `Register` ディレクティブ、Web ページの上部にあるこのコントロールをします。 コンパイルする方法について説明するチュートリアルは、次を参照してください。 [Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)します。  
  
 [!code-csharp[WebParts\_WebPartManager\_DeleteWarning\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts\_WebPartManager\_DeleteWarning\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 コード例の 3 番目の部分は、Web ページです。 このページには、 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> をカスタムのゾーン <xref:System.Web.UI.WebControls.WebParts.WebPart> ユーザー追加できるように、ページに実行時に、ゾーンでは、コントロール宣言されています。 ページからダイナミック コントロール \(プログラムから、またはこのようなカタログからページに追加されるコントロール\) を削除できることに注意してください。 静的コントロール \(内で宣言されているコントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ページのマークアップ内のゾーン\) を閉じるが削除されないことができます。`<asp:webpartmanager>` 要素のカスタム値を宣言して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> プロパティを使用して、 `DeleteWarning` 属性です。`Button1_Click` メソッドに別のカスタム値を代入、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> プロパティです。  
  
 [!code-csharp[WebParts\_WebPartManager\_DeleteWarning\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_DeleteWarning\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 追加する場合、ブラウザーでページを読み込んだ後、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールをページです。 使用して、 **表示モード** ドロップダウン リスト コントロール、カタログの選択モード。 カタログが表示されたら、カスタム コントロールの横にあるチェック ボックスをオン\] をクリックして **追加** ページに追加し、クリックを **閉じる** ブラウズ モードをページに戻ります。 これで、コントロールが表示されているを削除することができます。 使用して、 **表示モード** もう一度コントロールをページに \(コントロールを削除できません、ページは、ブラウズ モードでは\) デザイン モードに切り替えます。 動詞メニュー \(矢印\) のヘッダーをクリックして、 <xref:System.Web.UI.WebControls.WebParts.WebPart> 、コントロールを選択 **削除**します。 設定した警告、 `DeleteWarning` 属性が表示されます。**\[キャンセル\]** をクリックします。 今すぐというボタンをクリックして **変更削除の警告**, 、プログラムを使用してプロパティ値を変更します。 コントロールの \[動詞\] メニューから選択 **削除** ここでもとが今度はその他の警告メッセージが表示されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">削除するサーバー コントロール。</param>
        <summary>動的インスタンスを完全に削除、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> Web ページから管理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> メソッドによって表されるコントロールを完全に削除する、 `webPart` ページからのパラメーターです。 追加が終了したコントロールとは異なり、 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> を制御し、追加できますページに移動して削除されたコントロールのインスタンスは、ページには追加できません。  
  
> [!NOTE]
>  Web パーツ コントロールによって実装される設定、ユーザーが動的に削除する機能 <xref:System.Web.UI.WebControls.WebParts.WebPart> 制御は、ユーザーと、ページに追加したコントロールのパーソナル化スコープに依存します。 コントロールを追加した場合、ページが共有スコープ内に \(アクセス許可を持つユーザー\)、し、コントロールで削除できない個々 のユーザー、ページがユーザーのスコープ内にします。  
  
 ダイナミック コントロールだけを削除できます。 ダイナミック コントロールは、プログラムまたはユーザー カタログからコントロールを追加して、ページに追加されます。 静的コントロールは、マークアップ、または永続化の形式で宣言によってページに追加されます。 宣言型のタグは、マークアップで永続的に存在であるため、静的コントロールが削除することはありませんが、閉じ、再度開くことができます。  
  
   
  
## 例  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> メソッドの使用方法を示します。 最初に、 **予定表の追加** ボタンがクリックされる、コードは、イベント ハンドラーを作成、 <xref:System.Web.UI.WebControls.Calendar> を制御しとゾーンに追加、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトです。 ダイナミック コントロールにコントロールがプログラムによって追加されるため、削除ため。 ユーザーがクリックしたとき、 **カレンダーの削除** ボタン コードにより、コントロールが存在してを呼び出してから、削除、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> メソッドです。  
  
 [!code-csharp[WebParts\_WebPartManager\_DeleteWebPart\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_DeleteWebPart\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールを含む Web ページのレイアウトを変更するために使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> フィールドが参照するカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> が作成されに含まれているオブジェクト、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 これは、静的オブジェクトであるため、できるトークンを参照する経由で直接、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラス、コントロールのインスタンスを必要はありません。  
  
 Web パーツを含むページ コントロールを最初に読み込むときになっています <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> \(ブラウズ モード\) 既定では。 ページを最初にする必要があります切り替えますユーザーは、コントロールのゾーンまたは現在のゾーン内で移動することで、ページのレイアウトを変更する場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> \(デザイン モード\)。 デザイン モードでゾーンについては、さまざまなユーザー インターフェイス \(UI\) が表示され、ユーザーは、レイアウトを変更するコントロールをドラッグできます。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> プログラムを使用してフィールドです。 コードでは、参照と設計をここでは、ページのサポートされている表示モードのドロップダウン リストを生成します。 いることを確認、 `Page_PreRender` メソッドは、コードのチェックするかどうか、現在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> にプロパティが設定されている <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>します。 場合は、 `Label1` 、表示される、存在しない場合 `Label1` 非表示にします。  
  
 [!code-csharp[WebParts\_WebPartManager\_DesignDisplayMode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_DesignDisplayMode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、既定ではブラウズ モードでは。 ページ上のラベルが非表示であることを確認します。 ドロップダウン リスト コントロールを使用して、ページをデザイン モードに切り替えます。 \[コードのためいることを確認、 `Page_PreRender` メソッドをラベルが表示されるようになりました。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> を切断するコントロール。</param>
        <summary>削除、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはサーバーであるコントロールが閉じているかに関与しているすべての接続から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドは、設定すると、コントロールがページで閉じられましたか、ページから削除する Web パーツ コントロールによって内部的に呼び出されます。 このようなシナリオで、メソッド コンシューマーまたはプロバイダーと関係しているコントロールを削除する、すべての接続から呼び出されます。 すべての接続からコントロールを削除する場合、このメソッドも呼び出します、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドをすべての接続を終了する `webPart` 携わっていました。  
  
 ときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドが呼び出されるを生成、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントです。 通常このイベントは取り消すことができますが、2 つのケースで取り消すことができません。 1 つのケースが、ページを要求中に発生したときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> メソッドが呼び出されます。 既存の接続の間で競合がある場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドの呼び出しにこのインスタンスと競合している接続のいずれかを閉じる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントは、競合を解決する必要があるために、取り消すことはできません。  
  
 その他のケースが発生するときに、 <xref:System.Web.UI.WebControls.WebParts.WebPart> または現在接続されているサーバー コントロールが終了または削除します。 この場合は、制御のでが削除されるページで、デザインをキャンセルすることはできませんが同様に、そのため終了するには、その接続必要、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 接続を終了プロセスを中断するイベントです。 詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントを参照してください。  
  
   
  
## 例  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドの使用方法を示します。 2 つのカスタムを使用して <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、Web ページで別のボタンを使用すると、コントロールの接続を切断中に、ボタンをクリックしてコントロール間の接続を作成できます。 ページは、ブラウズ モードでは、コントロールが接続されている場合、コントロールのいずれかの閉じた場合のオーバーライド、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドが終了したコントロールの接続が切断、接続を終了し、メッセージを表示します。  
  
 このコード例には、4 つの部分があります。  
  
-   表示モードを変更するユーザー コントロールです。  
  
-   ユーザー設定を含むソース ファイル <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。  
  
-   コントロールをホストする Web ページ。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 このコード例の最初の部分は、表示モードを変更するユーザー コントロールです。 使用例」セクションからユーザー コントロールのソース コードを取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 表示モードおよびユーザー コントロールの動作方法の詳細については、次を参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 2 番目の部分は、2 つのカスタムのソース コードを含むファイル <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール接続して、カスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 このコード例を実行するには、このソース コードをコンパイルする必要があります。 明示的にコンパイルし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに、生成されたアセンブリを配置できます。 また、ここで、動的にコンパイル実行時に、サイトの App\_Code フォルダーにソース コードを配置することができます。 この例は、動的なコンパイルを使用して、 `Register` Web ページでこれらのコンポーネントを参照するディレクティブがそれに従って宣言されている Web ページの上部にあります。 コンパイル オプションについて説明するチュートリアルは、次を参照してください。 [Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)します。  
  
 ソース コードで、継承されたコントロールに注意してください。 `MyWebPartManager` をオーバーライドする、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドです。 このメソッドをチェックするかどうか、コントロールが閉じられますが、接続に参加して場合は、呼び出しを参照してください\] ページ内の各接続、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドを接続を終了します。 これは、メソッドの基本実装と同じ、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 オーバーライドされたメソッドは、ページにメッセージを記述して、基本実装をカスタマイズします。  
  
 [!code-csharp[WebParts\_WebPartManager\_DisconnectWebParts\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts\_WebPartManager\_DisconnectWebParts\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 コード例の 3 番目の部分は、Web ページです。 最上部近くが含まれていることを確認 `Register` ユーザー コントロールとで動的にコンパイルされたアセンブリを登録するディレクティブ、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 ページには、2 つの主要なメソッドがあります。`Button1_Click` メソッドは、コントロール間の接続を作成中に、 `Button2_Click` メソッドは、コントロールを切断します。  
  
 [!code-csharp[WebParts\_WebPartManager\_DisconnectWebParts\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_DisconnectWebParts\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 ページを読み込んだ後、 **接続** コントロールを接続する\] ボタンをクリックします。 コントロール \(ヘッダー コントロールの下向きの矢印\) のいずれかの動詞メニューをクリックし、選択 **閉じる** 動詞メニューからです。 コントロールを終了しようとすると、オーバーライドされたメソッドが呼び出された、接続を終了すると、およびページに、メッセージが書き込まれます。 終了したコントロールを復元し、その他のオプションを試して、ページをリセットする場合、 **ユーザー状態のリセット** へのリンクのパーソナル化データを削除して、ページの元の状態を復元します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> サーバー コントロールの間の接続を表します。</param>
        <summary>Web ページに接続されているサーバー コントロールの接続を解除するプロセスを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドは、完全なプロセスの間の接続を終了 <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバー コントロールを渡すときに、 `connection` パラメーター。  
  
 このメソッドを使用してコントロールを配置すると、切断を `<asp:connectionszone>` 接続を管理するユーザー インターフェイス \(UI\) を提供する、Web ページ内の要素。 ページを表示モードを接続 \(<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>\)、現在の接続が存在して、ユーザーを呼び出すボタンをクリックして、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドを接続を終了します。  
  
 呼び出すことも、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドをプログラムで必要とせずに追加するコントロールを切断する場合、コードから直接、 `<asp:connectionszone>` ページに要素。  
  
   
  
## 例  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドの使用方法を示します。 2 つのカスタムを使用して <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、Web ページで別のボタンを使用すると、コントロールの接続を切断中に、ボタンをクリックしてコントロール間の接続を作成できます。  
  
 このコード例には、4 つの部分があります。  
  
-   表示モードを変更するユーザー コントロールです。  
  
-   ユーザー設定を含むソース ファイル <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。  
  
-   コントロールをホストする Web ページ。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 このコード例の最初の部分は、表示モードを変更するユーザー コントロールです。 使用例」セクションからユーザー コントロールのソース コードを取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 表示モードおよびユーザー コントロールの動作方法の詳細については、次を参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 2 番目の部分は、2 つのカスタムのソース コードを含むファイル <xref:System.Web.UI.WebControls.WebParts.WebPart> 接続されているコントロール。 このコード例を実行するには、このソース コードをコンパイルする必要があります。 明示的にコンパイルし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに、生成されたアセンブリを配置できます。 また、ここで、動的にコンパイル実行時に、サイトの App\_Code フォルダーにソース コードを配置することができます。 この例は、動的なコンパイルを使用して、 `Register` Web ページでこれらのコンポーネントを参照するディレクティブがそれに従って宣言されている Web ページの上部にあります。 コンパイル オプションについて説明するチュートリアルは、次を参照してください。 [Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)します。  
  
 [!code-csharp[WebParts\_WebPartManager\_DisconnectWebParts\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts\_WebPartManager\_DisconnectWebParts\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 コード例の 3 番目の部分は、Web ページです。 最上部近くが含まれていることを確認 `Register` ユーザー コントロールとで動的にコンパイルされたアセンブリを登録するディレクティブ、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 ページには、2 つの主要なメソッドがあります。`Button1_Click` メソッドは、コントロール間の接続を作成し、 `Button2_Click` メソッドは、コントロールを切断します。  
  
 [!code-csharp[WebParts\_WebPartManager\_DisconnectWebParts\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_DisconnectWebParts\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 クリックして、ページの読み込み後、 **接続** コントロールを接続する\] ボタンをクリックします。 、テキスト ボックス コントロールにテキストを入力し、をクリックして、 **Enter** ボタン \(には表示されないこと、コントロールの接続が切断された場合\)、接続されているコントロールでテキストが表示されます。 クリックすると、 **切断** ボタン、コントロールは切断されます。 使用して、コントロールの接続の状態を確認することができます、 **表示モード** ドロップダウン リスト コントロールをページに切り替えます **接続** モードです。 実行後は、コントロールの 1 つのタイトル バーに \(矢印で表される\) の動詞メニューをクリックし、選択、 **接続** 項目。 接続の UI が表示されます。使用可能な場合があるため、 `<asp:connectionszone>` ページに要素が宣言されています。 接続し、\[この UI からコントロールを切断することもできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> いずれかに含まれていない <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> または <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> は読み取り専用です。  
  
 または  
  
 <paramref name="connection" /> 既にから切断されている <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />します。  
  
 または  
  
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> は読み取り専用です。  
  
 または  
  
 <paramref name="connection" /> 既にから切断されている <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />します。</exception>
        <block subset="none" type="overrides">
          <para>You can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" /> method if you want to change the default implementation for disconnecting <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> controls. If you do override the method, and you simply want to add some implementation to the existing method, you can call the base method prior to executing your own code.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または Web パーツ コントロールを含む Web ページのアクティブな表示モードを設定します。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> ページの表示モードを決定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web パーツ コントロールを含むページは常にいくつかの可能な表示モードのいずれか。 表示モードの詳細については、「 [Web Parts Page Display Modes](http://msdn.microsoft.com/ja-jp/cc106284-82dc-4770-98cb-673dbc4ed4c4)します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスは、Web ページの表示モードを作成します。 情報の使用方法 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 、クラス、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは Web パーツ コントロールを含むページで使用できるいくつかの標準的な表示モードのオブジェクトを作成します。 これらの標準的な表示モードには、 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> クラスの概要です。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 制御も Web パーツ コントロールを使用しているページの表示モードを管理します。 使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 、プロパティ、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールがページに現在の表示モードへの参照を保持します。 使用することも、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティ ページをさまざまな表示モードに切り替えをします。 Web パーツ コントロールを使用するページに表示モードの変更の例は、次を参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 表示モードの管理の一部として、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、イベントと、表示モードなどに関連するイベント ハンドラーにも提供、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> メソッドおよび <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> メソッドです。 これらのメソッドは、ページの動作をカスタマイズし、カスタム表示モードを追加するためもメカニズムを提供します。  
  
   
  
## 例  
 次のコード例に示しますのプログラムでの使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティです。 ブラウザーでページを読み込んだ後は、表示モードを切り替える、ページの下部付近にあるボタンを使用できます。 読み込み時に、ページが既定ではブラウズ モードです。 デザイン モードに切り替えた場合は、ゾーンを 1 つから、サーバー コントロールをドラッグします。 または、1 つのゾーン内の 2 つのコントロールを配置します。 編集モードに切り替えた場合は、サーバー コントロールでは、select のいずれかのヘッダーの動詞メニューをクリックする **編集**, 、および指定された編集ユーザー インターフェイス \(UI\) を使用して、コントロールを編集します。  
  
> [!NOTE]
>  非常に一般的な Web パーツ アプリケーションの表示モードの切り替えは、これを行う Web パーツ コントロールを含むすべてのページ上の一貫性があり、再利用可能な方法を提供することができます。 モードとする変更が表示されるユーザー コントロールの例は、多くのページで再利用することができますを参照してください [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 [!code-csharp[WebParts\_WebPartManager\_DisplayMode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_DisplayMode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトは、このプロパティに割り当てられている <see langword="null" />します。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトのプロパティに割り当てられているはサポートされている表示モードのいずれかです。  
  
 または  
  
 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトのプロパティに割り当てられているが無効になっています。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のページが変更された Web パーツの表示モードに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 表示モードは、Web パーツ アプリケーションの不可欠な部分です。 ユーザー、Web ページ上の別の表示モードに切り替えると、ページでは、新しい表示モードの目的に応じたのまったく異なる外観に処理が多くの場合。 表示モードが変更された後するユーザー インターフェイス \(UI\) で特定の変更を行うなど、特定のコントロールを表示または非選択の UI 要素の外観を変更して、します。  
  
> [!NOTE]
>  表示モードの詳細については、次を参照してください。 [Web Parts Page Display Modes](http://msdn.microsoft.com/ja-jp/cc106284-82dc-4770-98cb-673dbc4ed4c4)します。 イベントの使用の詳細については、次を参照してください。 [How to: Consume Events in a Web Forms Application](http://msdn.microsoft.com/ja-jp/73bf8638-c4ec-4069-b0bb-a1dc79b92e32)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが別の表示モードを変更するプロセスを開始する Web ページ上の動詞をクリックした後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 表示モードは、Web パーツ アプリケーションの不可欠な部分です。 ユーザー、Web ページ上の別の表示モードに切り替えると、ページでは、新しい表示モードの目的に応じたのまったく異なる外観に処理が多くの場合。 使用するユーザー インターフェイス \(UI\) で特定の変更を実行する場合、動詞をクリックして、表示モードを変更するプロセスを開始した後、 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> プロパティの表示モードはどのくらい、およびさまざまな UI 要素を適宜変更します。 これを行う便利な方法は、オーバーライドする、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> UI をカスタマイズする方法です。  
  
> [!NOTE]
>  表示モードの詳細については、次を参照してください。 [Web Parts Page Display Modes](http://msdn.microsoft.com/ja-jp/cc106284-82dc-4770-98cb-673dbc4ed4c4)します。 イベントの使用の詳細については、次を参照してください。 [How to: Consume Events in a Web Forms Application](http://msdn.microsoft.com/ja-jp/73bf8638-c4ec-4069-b0bb-a1dc79b92e32)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられているすべての表示モードの読み取り専用コレクションを取得、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> のセットを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトに関連付けられている、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> プロパティ参照がすべて関連付けられている、表示モードとは異なり、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> \(サポートされている\) 現在のページに表示される表示モードのみを参照するプロパティです。  
  
 提供されている表示モード、参照とデザイン、2 つのリソースは、ページで必ずしもサポートされています。 ページに操作する特定の表示モードに必要なゾーンの対応する型がある場合にのみ、その他の 3 つの表示モード、編集、カタログ、および接続がサポートされています。 たとえば、ページが含まれていない場合、 <xref:System.Web.UI.WebControls.WebParts.EditorZone> ゾーン、編集の表示モードが表示されますが参照するコレクション、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> プロパティには、によって参照されるコレクションには表示されませんが、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティです。  
  
   
  
## 例  
 次のコード例のプログラムから使用を示しています、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> プロパティです。 コードでは、このプロパティを使用して、現在のページでサポートされていない場合でも、Web パーツ コントロール セットで使用できるすべての表示モードの一覧に表示します。 この場合、カタログと接続モードがサポートされていない表示ページにゾーンが含まれていないために必要な対応するためです。  
  
 他の 3 つの表示モード \- ページで \[参照\]、設計、および編集\-\-をサポートします。 編集モードは、ページが含まれているために、サポート、 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 参照中に、ゾーンし、デザイン モードが常にサポートされています。  
  
 ブラウズ モードからページをデザイン モードに切り替えることをドロップダウン リスト コントロールを使用するには、ブラウザーでページを読み込んだ後し編集モードにします。 編集モードでサーバー コントロールの 1 つのヘッダーにドロップダウン動詞メニューをクリックして選択 **編集** コントロールを編集します。 選択した場合 **カタログ** または **接続** ドロップダウン リストでは、エラー ページが生成されます。  
  
 [!code-csharp[WebParts\_WebPartManager\_DisplayModes\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_DisplayModes\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在、Web ページ上に存在するすべての動的な接続のコレクションを取得します。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> ページ上のすべての動的接続への参照を格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 動的接続は、プログラムではなく静的に作成される接続です。 静的な接続を作成するには、Web フォーム ページのマークアップで宣言します。 動的接続は、プログラムから、または接続のユーザー インターフェイス \(UI\) を使用して接続を作成するユーザーが形成されます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> コレクション、読み取り専用はおよびその内容を変更することはできませんは、動的な接続オブジェクトごとにプログラムでアクセスを提供します。  
  
> [!NOTE]
>  接続または切断などの一般的な操作を実行する <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、開発者は、使用のパブリック メソッドで、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスなど、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> と <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, での接続オブジェクトを直接変更する代わりに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> コレクションです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エンドユーザーの編集や、サーバー コントロールを変更するための表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> フィールドが参照するカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> が作成されに含まれているオブジェクト、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 これは、静的オブジェクトであるため、できるトークンを参照する経由で直接、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラス、コントロールのインスタンスを必要はありません。  
  
 Web パーツを含むページ コントロールを最初に読み込むときになっています <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> \(ブラウズ モード\) 既定では。 ページを最初にする必要があります切り替えますユーザーは、編集、または、サーバー コントロールを変更する場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> \(編集モード\)。 第 2 に、そのコントロールのヘッダーの動詞メニューの edit 動詞をクリックして編集します。 特定のサーバー コントロールを選択して、必要があります。 コントロールは、編集モードでは、選択したコントロールを編集するため、編集のユーザー インターフェイス \(UI\) が表示されます。  
  
 ページの編集モードを有効にする、ページには少なくとも 1 つ <xref:System.Web.UI.WebControls.WebParts.EditorZone> などのゾーンを含む 1 つ以上の指定された編集コントロール、 <xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> コントロール、またはカスタムの編集コントロールです。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> プログラムを使用してフィールドです。 コードでは、参照、設計、および編集をここでは、ページのサポートされている表示モードのドロップダウン リストを生成します。 編集をサポートするために、 `<asp:EditorZone>` 要素はページです。 いることを確認、 `Page_PreRender` メソッドは、コードのチェックするかどうか、現在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> にプロパティが設定されている <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>します。 場合は、 `Label1` 、表示される、存在しない場合 `Label1` 非表示にします。  
  
 [!code-csharp[WebParts\_WebPartManager\_EditDisplayMode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_EditDisplayMode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、既定ではブラウズ モードでは。 ページ上のラベルが非表示に注意してください。 ドロップダウン リスト コントロールを使用して、ページを編集モードに切り替えます。 \[コードのためいることを確認、 `Page_PreRender` メソッドをラベルが表示されるようになりました。 クリックして、 **編集** その特定のコントロールの編集できるように、コントロールのいずれかの動詞メニューの動詞です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を含む Web ページでクライアント側のスクリプトを有効にするかどうかを決定する値、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。</summary>
        <value>ページで、クライアント スクリプトを実行できるかどうかを示すブール値。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> プロパティは、開発者はクライアント スクリプトを無効にするための手段を提供します。 クライアントのセキュリティのために、スクリプトを無効にするか、さまざまなブラウザーを使用している場合でも、ページのすべてのユーザーは、のようなユーザー エクスペリエンスにいることを確認することができます。  
  
 クライアントを追加してスクリプトを無効にすることができます、 `EnableClientScript` 属性を <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 次の宣言型のコード行に示すように、Web ページ上の要素。  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 また、開発者はから継承することでこのプロパティを取り除くことができます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスとの既定の設定値を `false`します。  
  
 Web パーツ コントロール セットは、クライアント ユーザー インターフェイス \(UI\) と個人用設定機能は、クライアントの一部を提供するスクリプトを使用します。 クライアントを無効にした場合、Web パーツをスクリプト コントロール機能しますが、一部の機能が無効になっています。 \(動詞は、コントロールのタイトル バーにリンクとして代わりに表示されます\)、コントロールのタイトル バーにドロップダウン動詞メニューの動詞をレンダリングする機能と共に、別のゾーンにコントロールをドラッグする機能は無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページにテーマの使用が有効になっていることを示す値を取得します。</summary>
        <value>テーマが有効になっているかどうかを示すブール値。 常に <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールが、情報をオーバーライド <xref:System.Web.UI.Control.EnableTheming%2A> プロパティの値を常に返すことを確認 `true`します。 これは、Web パーツ コントロール セットは、Web パーツをレンダリングするテーマの使用を制御する必要がありますが子コントロールのため、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 制御し、Web ページのユーザー インターフェイス \(UI\) を形成します。 さまざまなゾーンを表示するためのテーマやなどのさまざまな種類のゾーンに存在するコントロールのコントロールのパーツなどの \(から継承するコントロール、 <xref:System.Web.UI.WebControls.WebParts.Part> クラス\)、ユーザー コントロール、ASP.NET サーバー コントロール、およびカスタム サーバー コントロール。  
  
 ただし、オーバーライドされた <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A> プロパティは、基本プロパティに従って、読み取り\/書き込みプロパティとして実装は、仕様を値は常に返す必要があるため、プロパティを設定することはできません `true`します。 プロパティを設定しようとする場合、 <xref:System.NotSupportedException> 例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">プロパティの値を設定しようとしています。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>接続するプロセスが完了すると、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 別のコントロールにコントロールできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> メソッドを接続するプロセスが完了すると、 <xref:System.Web.UI.WebControls.WebParts.WebPart> 別のコントロールにコントロールできます。 相当するものである、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> メソッドです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> メソッドは、パーソナル化オブジェクトがによって参照されることを確認、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティは変更できますが、個人用設定の種類自体が接続を形成するために必要なです。 メソッド、確実に、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> オブジェクトは `null`, 、し、最後に呼び出され、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">によって参照される、コントロール、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> プロパティは <see langword="null" />です。</exception>
        <block subset="none" type="overrides">
          <para>Developers who need to extend the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> control might want to override this method in a derived class. One approach would be to call the base method and then add some additional custom handling, or you might want to completely customize the entire process of completing a connection between controls.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>編集のプロセスが完了すると、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> メソッドを編集するプロセスが完了すると、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 相当するものである、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> メソッドです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> メソッドは、パーソナル化オブジェクトがによって参照されることを確認、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティは変更できますが、個人的な変更を必要とするプロセスは、コントロールの編集のために必要なです。 メソッド、確実に、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> オブジェクトではありません `null`, ように、現在選択されている <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを変更できる、および最後に呼び出され、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">によって参照される、コントロール、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> プロパティは <see langword="null" />です。</exception>
        <block subset="none" type="overrides">
          <para>Developers who need to extend the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> control might want to override this method in a derived class. One approach would be to call the base method and then add some additional custom handling, or you might want to completely customize the entire process of completing the editing of a control. For example, in the override method, you could call the base method first, and then add some code that determines what editing changes were made, and displays the list of changes back to the end user as a confirmation.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが機密性の高い状態データをエクスポートしようとしたときに表示される警告メッセージのテキストを設定、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</summary>
        <value>警告メッセージを含む文字列です。 既定のメッセージは、.NET Framework によって提供されるカルチャに固有の値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ユーザーが機密性の高い状態データをエクスポートしようとしたときに、 <xref:System.Web.UI.WebControls.WebParts.WebPart> 制御、機密データをエクスポートすることを指示して、エクスポートをキャンセルする機会を提供する、メッセージ ボックスにユーザーに警告メッセージが表示されるソース コードに機密としてマークされたメンバーからのデータをエクスポートする場合、します。 開発者を設定して機密情報として特定のメンバーのデータをマークすることができます、 `isSensitive` のパラメーター、 `[Personalizable]` 属性を `true` メンバーにします。 この属性およびパラメーターの詳細については、次を参照してください。、 <xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute> クラスです。  
  
> [!IMPORTANT]
>  Web パーツのエクスポート機能を使用するときに機密データは承認されていないユーザーに可能性のあるエクスポートでした。 この上の脅威から保護する方法の詳細については、「 [Securing Web Parts Pages](http://msdn.microsoft.com/ja-jp/8ada6210-ed00-4157-b3e9-a7e87e77caa2)します。  
  
 ユーザーをエクスポートしようとするたびに、既定のメッセージが表示されます。 値を割り当てるを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> プロパティには、カスタムの警告メッセージを指定することができます。  
  
   
  
## 例  
 宣言型の使用を次のコード例に示します、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> プロパティです。  
  
 次の Web ページのコードは、標準を使用して <xref:System.Web.UI.WebControls.BulletedList> を制御し、ゾーンに配置します。 コントロールをラップするが、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> として機能するように、実行時にコントロール <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 コントロールをエクスポート可能にする、 `ExportMode` 属性が追加、 `<asp:bulletedlist>` 要素、および属性値に設定されている <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>, 、エクスポートするため、データ機密性の高いと、機密情報の両方を行うことができます。 なおで、 `<asp:webpartmanager>` 要素、 `ExportSensitiveDataWarning` 属性には、カスタムの値が割り当てられます。  
  
 コード例を実行することに注意してください、Web パーツの記述ファイルをエクスポートできるようにするために Web.config ファイルに追加する必要がある設定されます。 このコード例については、Web ページと同じディレクトリに Web.config ファイルがあることを確認します。 内で、 `<system.web>` セクションであることを確認、 `<webParts>` を持つ要素、 `enableExport` 属性に設定 `true`, マークアップを次のようにします。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-csharp[WebParts\_WebPartManager\_ExportSensitiveData\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_ExportSensitiveData\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、リンクが含まれているコントロールのタイトル バーに \(下向きの矢印で表される\) の動詞メニューをクリックします。 動詞メニューに次のように選択します。 **エクスポート**, 、およびメッセージ ボックスを表示し、カスタムの警告に注意してください。 エクスポートを継続する場合は、クリックして **OK**, 、コントロールに関するすべてのデータと XML 記述ファイルのローカル コピーを保存できるようにします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">データのエクスポート元となるコントロール。</param>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> からエクスポートされたデータを書き込む <c>webPart</c> XML 記述ファイルにします。</param>
        <summary>サーバー コントロールの状態とプロパティのデータを含む XML 記述ファイルを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> メソッドのさまざまな状態とプロパティのデータをアセンブルする `webPart` が XML ファイルにします。 データには、そのアセンブリ、状態データ、およびプロパティのデータを含め、コントロール自体に関する情報が含まれます。 エクスポートを開始したユーザーは、ローカル コンピューターまたはネットワーク、ディスクに XML ファイルを保存できます。 他のユーザーを別のページまたは Web サイトの説明ファイルをインポートし、状態、およびプロパティのデータを別のインスタンスに適用 `webPart`します。 これを共有し、サーバー コントロールで、設定を再利用のユーザーに対して高速で便利な機構を提供し、エクスポートおよびインポートしたコントロールの動作と外観を制御するための手段を開発者にも提供します。  
  
 プロパティを `webPart` は既定ではエクスポートされません。 プロパティのエクスポートを有効にするを使用してマークする必要があります、 `[Personalizable]` ソース コード内の属性です。 また、必要に応じてされたエクスポート可能なプロパティを設定して、機密データを格納するいるとをマークすることができます、 `isSensitive` のパラメーター、 `[Personalizable]` 属性を `true`します。 既定では、 `isSensitive` は `false`です。 開発者は、パラメーターを設定できる `true` データが機密であることを示します。  
  
 有効にする `webPart` 開発者の設定をエクスポートできる、 <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> プロパティの値をいずれかの <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All> \(を含むすべてのパーソナル化できると機密性の高いプロパティ\) をまたはに <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>, 、機微なプロパティを除くすべてをエクスポートします。  
  
> [!IMPORTANT]
>  ユーザー コントロールからデータをエクスポートし、その他のコントロールにデータをインポートするには、セキュリティ リスクもする必要があります。 開発者は、機密データを保護する上で説明した方法を使用する必要があり、データを完全に公開するリスクを回避する場合は、それらを有効にしないでエクスポートで `webPart` まったくします。 Web パーツのセキュリティの問題の詳細については、「 [Securing Web Parts Pages](http://msdn.microsoft.com/ja-jp/8ada6210-ed00-4157-b3e9-a7e87e77caa2)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="writer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 参照されているコントロールのコレクションに含まれない <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />します。  
  
 または  
  
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> の <paramref name="webPart" /> の値に設定されている <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" />, のエクスポートが無効になっていることを意味する <paramref name="webPart" />です。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォーカスがこれまでに設定されていることを防止するためにオーバーライド、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 制御、ユーザー インターフェイス \(UI\) を持たないためです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> メソッドは、ベース <xref:System.Web.UI.Control.Focus%2A?displayProperty=fullName> メソッド、例外がスローされる場合は、呼び出し元がメソッドを呼び出します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロール UI を持たないユーザーに表示されることはありません、フォーカスをそれ自体で設定を決して許可することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出し元を呼び出そうとすると、 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> メソッドで、UI を持たないコントロールでサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続でコンシューマーとして機能しているサーバー コントロール。</param>
        <summary>コレクションを取得 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> Web パーツの接続内のコンシューマーとして動作してあるサーバーからの接続ポイントとして機能できるコントロールです。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" /> コンシューマー内のすべての接続ポイントを格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web パーツの接続常ににはでは、いずれかのデータ、データのコンシューマーとしてのプロバイダーとして機能する 2 つのコントロールが含まれます。 各コントロールの接続ポイントとして定義されている 1 つまたは複数のメソッドが必要です。 コンシューマー コントロールの場合、接続ポイントは、 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> オブジェクトです。 Web パーツ接続の構成に必要な手順は、コンシューマー接続ポイントを取得します。  
  
 コンシューマーには、接続を確立できるようにするには、少なくとも 1 つの接続ポイントが常に必要です。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> メソッドは、コンシューマー コントロールをチェックし、そのすべてのコネクション ポイントのコレクションを取得します。 場合、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールに接続ポイントがない、空のコレクションが返されます。  
  
   
  
## 例  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> メソッドの使用方法を示します。  
  
 このコード例には、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含む Web ページ <xref:System.Web.UI.WebControls.WebParts.WebPart> 接続可能なコントロールと `<asp:webpartmanager>` 要素。  
  
-   ソース コード ファイルを含む 2 つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタム インターフェイスです。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 このコード例の最初の部分は、表示モードを変更するユーザー コントロールです。 使用例」セクションからユーザー コントロールのソース コードを取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 表示モードおよびユーザー コントロールの動作方法の詳細については、トピックを参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 Web ページの宣言型マークアップを含む `Register` ユーザー コントロールとカスタム コントロールの両方のディレクティブです。`<asp:webpartmanager>` 要素、 `<asp:webpartzone>` カスタム コントロールを格納する要素と `<asp:connectionszone>` 要素。 ある、 `Page_Load` メソッド、コードを確認するかどうか、接続が既に存在し、ない場合は、プロバイダー、およびを定義、コンシューマーがそれぞれのコネクション ポイント、およびによって参照される静的な接続のセットに新しい接続を追加、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティです。 注意してください、 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> を使用して取得されるオブジェクト、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> メソッドに渡されます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドを次の 2 つのコントロール間の接続を作成できるかどうかを決定します。  
  
 [!code-csharp[WebParts\_WebPartManager\_StaticConnections\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_StaticConnections\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 例の 3 番目の部分では、コントロールのソース コードを示します。 このコード、および手順については、例」のセクションからコンパイルするために取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。  
  
 クリックして、ブラウザーで Web ページが読み込まれた後、 **表示モード** ドロップダウン リスト コントロールと選択 **接続** 接続モードをページに切り替えます。 接続モードは、 `<asp:connectionszone>` 要素を使用すると、コントロール間の接続を作成します。 接続モードなどのタイトル バーの下向きの矢印をクリックして、 **郵便** の動詞メニューをアクティブに制御し、をクリックして **接続**します。 接続のユーザー インターフェイス \(UI\) が表示されたら、接続が既にに含まれるコードによって作成されたことに注意してください、 `Page_Load` メソッドです。 以降のブラウザー セッションでこのページに戻り、この静的な接続が確立されていると、ページが読み込まれるたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">インスタンスを含む Web ページ、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />です。</param>
        <summary>現在のインスタンスへの参照を取得、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ページへのコントロールです。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ページ上のコントロールの現在のインスタンスを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> メソッドは現在の参照を取得する状況役に立つ <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 これが発生する一般的なシナリオは、の ID を開発中に確認できないカスタム コントロールを作成するかどうか、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> そのページ上のコントロールになります。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> メソッドは静的なのインスタンスを必要とすることがなく、直接呼び出すことができますので、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。  
  
 Web パーツの一部のコントロールなどのセットの制御 <xref:System.Web.UI.WebControls.WebParts.WebPart> 、コントロールが、 <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> 現在への参照を取得するプロパティ <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 そのため、このようなコントロールを使用する場合は、このプロパティを使用して、その参照を取得する必要があります。  
  
 ID を確認するコンテキストでコーディングしているかどうか、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> など、Web ページ内にインラインのコードを記述することは最も簡単なかつ最も効率的に直接参照する、制御、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> その ID を使用するコントロール  
  
   
  
## 例  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> メソッドの使用方法を示します。 この例は、2 つの部分。 カスタム サーバー コントロールとコントロールをホストする Web ページです。  
  
 カスタム <xref:System.Web.UI.WebControls.Label> コントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> の ID を取得するメソッドを <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロール、現在のページと、ID が表示されます  
  
 [!code-csharp[WebParts\_WebPartManager\_GetCurrentWebPartManager\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts\_WebPartManager\_GetCurrentWebPartManager\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 次のコード例でコントロールをホストする Web ページが用意されています、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーンです。  
  
 [!code-csharp[WebParts\_WebPartManager\_GetCurrentWebPartManager\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_GetCurrentWebPartManager\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 ブラウザーでページを読み込むことに注意して、現在の ID <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 内でのカスタム コントロールが表示される <xref:System.Web.UI.WebControls.Label> コントロールです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">メソッドがの値を返すコントロール <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />します。</param>
        <summary>値を表す文字列を取得、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> のプロパティ、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</summary>
        <returns>計算値を表す文字列 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> の <paramref name="webPart" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 計算値を取得、 <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> プロパティ `webPart`します。 ときに開発者に値を代入は、 <xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> のプロパティ、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールでは、このメソッドは、タイトルとして表示する値を生成します。 タイトルのないコントロールの計算値は、現在のゾーン内のコントロールの順序を示す番号が付加された文字列、数値で構成されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 含まれていない、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクションです。</exception>
        <block subset="none" type="overrides">
          <para>This method can be overridden to change how the default display title is calculated.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> がエクスポートされています。</param>
        <summary>相対仮想パスと、ユーザーがエクスポートしようとした場合、要求の一部であるクエリ文字列を取得、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</summary>
        <returns>相対仮想パスとクエリを含む文字列には、まとめてフォーム コントロールのエクスポート要求が文字列です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 によって返される値、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> メソッドは、コントロールを含むページのサーバーの場所への相対仮想パスとエクスポート要求を形成する追加のクエリ文字列の値をサーバーに送信します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> メソッドは、要求を送信する、悪意のあるスクリプト攻撃に対する保護を許可する前に、文字列をエンコードします。  
  
> [!NOTE]
>  Web パーツ アプリケーションのセキュリティ保護に関する詳細については、次を参照してください。 [Securing Web Parts Pages](http://msdn.microsoft.com/ja-jp/8ada6210-ed00-4157-b3e9-a7e87e77caa2)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">内に存在するサーバー コントロール、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> の子コントロールとしてラップされ、 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 実行時にします。</param>
        <summary>インスタンスへの参照を取得、 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> サーバー コントロールを格納しているコントロール。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> をラップする <paramref name="control" /> 子コントロールとして。 このメソッドを返します <see langword="null" /> 場合 <paramref name="control" /> に含まれていない、 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 一般に、開発者に配置するコントロールの 2 つのカテゴリがある <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Web パーツ アプリケーションに参加するゾーン: <xref:System.Web.UI.WebControls.WebParts.WebPart> から継承するコントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPart> 基本クラス、およびその他のサーバー コントロール、標準の ASP.NET コントロール、カスタム コントロールまたはユーザー コントロールを指定できます。 配置するとこれらのコントロールは、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> の機能にかかる、ゾーン、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 A <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールに本質的に、この機能があるが、その他の種類のサーバー コントロールにはありません。 として機能する他のサーバー コントロールを有効にする <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールに配置されますが、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーン、ASP.NET でラップ、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールです。<xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールがから直接継承、 <xref:System.Web.UI.WebControls.WebParts.WebPart> クラスは、Web パーツ機能の場合は true。 コントロールの子コントロールを提供しています。  
  
 実行時に多くの場合、ページ開発者は取得することもへの参照、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> ゾーン内のサーバー コントロールのいずれかを格納しているコントロール。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> への参照を取得することにより、メソッド、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールです。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> メソッドです。 コード例では、 <xref:System.Web.UI.WebControls.Calendar> 内で宣言されたコントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーンです。`Button1_Click` メソッドは、最初の ID を出力、 <xref:System.Web.UI.WebControls.Calendar> ラベル、および、使用するコントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> への参照を取得するメソッドを <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> カレンダーをラップするコントロール。 ID、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロール、およびその子コントロールの ID \(これは、 <xref:System.Web.UI.WebControls.Calendar> コントロール\)、両方は 2 番目のラベルに出力します。  
  
 [!code-csharp[WebParts\_WebPartManager\_GetGenericWebPart\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_GetGenericWebPart\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続でプロバイダーとして機能しているサーバー コントロール。</param>
        <summary>コレクションを取得 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> サーバーからの接続ポイントとして動作可能なオブジェクトであるコントロール、Web パーツ接続内でのプロバイダーとして機能します。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" /> プロバイダー内のすべての接続ポイントを格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web パーツの接続常ににはでは、いずれかのデータ、データのコンシューマーとしてのプロバイダーとして機能する 2 つのコントロールが含まれます。 各コントロールの接続ポイントとして定義されている 1 つまたは複数のメソッドが必要です。 その接続ポイントは、プロバイダー コントロールの場合 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> オブジェクトです。  
  
 プロバイダーには、接続を確立できるようにするには、少なくとも 1 つの接続ポイントが常に必要です。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> メソッドは、プロバイダー コントロールをチェックし、そのすべてのコネクション ポイントのコレクションを取得します。 Web パーツ接続の構成に必要な手順は、プロバイダー接続ポイントを取得します。  
  
   
  
## 例  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> メソッドの使用方法を示します。  
  
 この例では、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含む Web ページ <xref:System.Web.UI.WebControls.WebParts.WebPart> 接続可能なコントロールと `<asp:webpartmanager>` 要素。  
  
-   ソース コード ファイルを含む 2 つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタム インターフェイスです。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 このコード例の最初の部分は、表示モードを変更するユーザー コントロールです。 使用例」セクションからユーザー コントロールのソース コードを取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 表示モードおよびユーザー コントロールの動作方法の詳細については、次を参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 Web ページの宣言型マークアップを含む `Register` ユーザー コントロールとカスタム コントロールの両方のディレクティブです。`<asp:webpartmanager>` 要素、 `<asp:webpartzone>` カスタム コントロールを格納する要素と `<asp:connectionszone>` 要素。 ある、 `Page_Load` メソッド、コードを確認するかどうか、接続が既に存在し、ない場合は、プロバイダー、およびを定義、コンシューマーがそれぞれのコネクション ポイント、およびによって参照される静的な接続のセットに新しい接続を追加、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティです。 注意してください、 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> を使用して取得されるオブジェクト、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> メソッドに渡されます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドを次の 2 つのコントロール間の接続を作成できるかどうかを決定します。  
  
 [!code-csharp[WebParts\_WebPartManager\_StaticConnections\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_StaticConnections\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 例の 3 番目の部分では、コントロールのソース コードを示します。 このコード、および手順については、例」のセクションからコンパイルするために取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。  
  
 クリックして、ブラウザーで Web ページが読み込まれた後、 **表示モード** ドロップダウン リスト コントロールと選択 **接続** 接続モードをページに切り替えます。 接続モードは、 `<asp:connectionszone>` 要素を使用すると、コントロール間の接続を作成します。 接続モードなどのタイトル バーの下向きの矢印をクリックして、 **郵便** の動詞メニューをアクティブに制御し、をクリックして **接続**します。 接続のユーザー インターフェイス \(UI\) が表示されたら、接続が既にに含まれるコードによって作成されたことに注意してください、 `Page_Load` メソッドです。 以降のブラウザー セッションでこのページに戻り、この静的な接続が確立されていると、ページが読み込まれるたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> 状態、およびプロパティのデータがインポートされている XML 記述ファイルから読み取る。</param>
        <param name="errorMessage">A <see cref="T:System.String" /> のインポート中にエラーが発生した場合、ユーザーに対して表示されます。</param>
        <summary>状態とプロパティのデータを含む XML 記述ファイルをインポート、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> を制御して、データをコントロールに適用します。</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> \(またはサーバー コントロールによってラップされる、 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 元となる、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />\) インポート済みの XML 記述ファイルで参照されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> メソッドによって作成された XML 記述ファイルをインポートする、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> サーバー コントロールのメソッドです。 できませんが、インポートされると、実際のサーバー コントロール、コントロールに関する状態とプロパティのデータを含む記述ファイルのみ。 コントロールと記述ファイルで参照されるアセンブリは、ユーザーが記述ファイルをインポートしようとした、サーバーで利用できるおく必要があります。  
  
 開発者をコントロールのインポートを有効にするのには、追加する必要があります、 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> インポートを有効にするページ上のコントロールです。 ゾーン内で、 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> コントロールを追加する必要があります。 このコントロールは、ユーザーに移動し、記述ファイルをインポートできるようにするファイル\] ダイアログ ボックスを表示します。  
  
 記述ファイルを読み取るユーザー インポートを開始、記述ファイルを検索して、後に、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> メソッドです。 エラーがない、サーバー コントロールが、カタログ内に追加されるアセンブリとコントロールがある場合と、 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 制御、および記述ファイルで指定されたさまざまなプロパティと状態データをコントロールに適用します。 ユーザーは、コントロールを選択し、ページに追加します。  
  
> [!IMPORTANT]
>  ように、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 、メソッド、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> メソッドのセキュリティ リスクが発生する可能性を持ちます。 Web サイトにデータをインポートすることでは、悪意のあるユーザーでしたがインポートされる記述ファイルに不適切なデータやスクリプト コードを挿入しようとします。 ページ、またはデータベースでは、不適切なデータが表示される可能性がありますし、または挿入されたスクリプトを実行できます。 インポートの説明ファイル、およびそれらのリスクを回避する方法に関連する潜在的なリスクの概要については、次を参照してください。 [Securing Web Parts Pages](http://msdn.microsoft.com/ja-jp/8ada6210-ed00-4157-b3e9-a7e87e77caa2)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <paramref name="reader" /> ファイルを読み取れませんでした。  
  
 または  
  
 <paramref name="reader" /> インポート エラー メッセージを表示する必要が見つけることができずいずれかのファイルになります。  
  
 または  
  
 <paramref name="reader" /> エクスポートされたデータを含む XML 要素を検索せず、ファイルの末尾に達しています。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照を取得、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> に結合しで実際に実装されるメソッドのセットを分離するために使用するクラス、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスが、ほとんどの場合コントロールの開発者に便利です。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />, 、使用される、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> に分割されているさまざまな方法を参照できる、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> プロパティには、Api のセットへの呼び出しを <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 機能拡張の場合も多くの場合に使用されるメソッドです。  
  
 これらの内部メソッドを使用するデザイン方法は、によってアクセスする、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> プロパティです。 プロパティが保護されているためだけにアクセスしてのインスタンス内でメソッドを呼び出して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> クラスから継承することで、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスです。  
  
> [!NOTE]
>  このプロパティを非表示では、IntelliSense [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]します。 ただし、派生で <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラス、プロパティとそのさまざまなメンバーにアクセスできます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>決定するかどうか、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはその他のサーバー コントロールをページに追加できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web パーツの機能の柔軟性の一部は、実行時にサーバー コントロールを Web ページに追加する機能です。 サーバーを制御する一般的なシナリオのいくつか \(カスタムこともある <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、カスタム サーバー コントロール、ユーザー コントロール、または ASP.NET コントロール\) を追加できます。  
  
 次の一般的なシナリオで Web パーツ コントロール セット、サーバー コントロールをページに追加しようと <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> に承認するために呼び出されます。  
  
-   内の Web ページのマークアップで宣言することで、サーバー コントロールが追加された場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンです。  
  
-   サーバー コントロールをゾーンにプログラムを使用して追加するとします。  
  
-   ときに、ユーザーはサーバー コントロールをコントロールの Web パーツのカタログにインポートします。  
  
-   既存のサーバー コントロールがデータにパーソナル化ストアから読み込まれます。  
  
-   サーバー コントロールを追加するときに、 <xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart> サーバー コントロールのカタログで使用可能にするコントロール。  
  
 コントロールが追加される各シナリオで、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドが呼び出され、追加するコントロールを許可するようにすべての承認条件を満たしていることを確認します。 コントロールが承認されるとと、は、フィルター処理がないかどうかにも見られるように正常に追加されます。 コントロールが承認されていない場合は、Web パーツ コントロール セットが、状況に応じて、いくつかの方法で対応できます。 コントロール セットには \(ユーザーに通知する必要はありません\) の場合は、承認されていない部分を追加できないことが何も行わずに、エラー メッセージを表示できるまたはのインスタンスを追加して、 <xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart> プレース ホルダーとしてクラスです。 このプレース ホルダー オブジェクトは\] ページで、表示されませんが、許可されていないコントロールが除外されたことを示すためにページのソース コードに表示されます。  
  
 コントロールが承認されているかどうかの決定要因は、承認フィルターです。 承認フィルターは、開発者は、指定した条件を満たしていないすべてのコントロールをページから除外する Web パーツ コントロール セットの機能です。  
  
 フィルター処理を作成するには、開発者は 2 つの処理を行う必要があります。 最初に、\(値は任意になることができます\) を文字列値を割り当てることも必要があります、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> の各プロパティ <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのシナリオで使用する予定です。 れないサーバー コントロールの他の種類には、このプロパティに値を割り当てることも、 <xref:System.Web.UI.WebControls.WebParts.WebPart> を制御するために置かれている場合 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンの場合、このようなコントロールでラップされて、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 、実行時にコントロールし、このコントロールの継承、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティです。  
  
 フィルター処理を作成するための 2 番目のために必要な手順は、いずれかにオーバーライド、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> メソッド、またはイベント ハンドラーを作成、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントです。 これらのメソッドで、開発者が確認できます、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティには、値は、コントロールを承認されていないことを示している場合、開発者されることを保証、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドの値を返す `false`します。  
  
> [!NOTE]
>  コード例と、カスタマイズされたフィルターを使用してシナリオを設定する方法の説明、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッド、メソッドのオーバー ロードは、トピックを参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> または承認を確認している他のサーバー コントロール。</param>
        <summary>コントロールがページに追加する承認されているかどうかを決定する際の初期手順を実行します。</summary>
        <returns>示すブール値かどうか <paramref name="webPart" /> ページに追加することができます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドは、最初のメソッドに対する承認をチェックする設定の Web パーツ コントロールにより呼び出されます、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 受け入れる `webPart` をパラメーターとして最終的には、コントロールをページに追加するかどうかを決定するプロセスを開始します。 メソッドを呼び出すこのコードから直接、特定のコントロールを承認するかどうかを判断する必要がある場合。  
  
 このメソッドからコントロールを継承するかどうかを決定する最初のタスクを実行、 <xref:System.Web.UI.WebControls.WebParts.WebPart> クラスか、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> を制御し、必要な場合は、どのような種類の子コントロールが含まれています。 呼び出しの承認のタスクを完了するには <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> メソッドをオーバー ロードします。  
  
   
  
## 例  
 次のコード例では、呼び出し、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> コントロールがページに追加する承認されているかどうかを決定するコードからメソッドです。  
  
 このコード例には、3 つの部分があります。  
  
-   カスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> をオーバーライドするコントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドです。  
  
-   フィルターを作成する Web ページ、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。  
  
-   コード例を実行する方法の説明です。  
  
 このコード例は、カスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> をオーバーライドするコントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> のカスタム処理を提供するメソッドをオーバー ロード、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティです。 このコントロールのプロパティの値をチェック `admin` と、値が存在する場合は、コントロールを承認します。 コントロールに異なる値がある場合は、承認されません。プロパティ値のないコントロールは、フィルター処理の一部であるが見なされるため、同様に、承認されます。  
  
 このコード例を実行するには、このソース コードをコンパイルする必要があります。 明示的にコンパイルし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに、生成されたアセンブリを配置できます。 また、ここで、動的にコンパイル実行時に、サイトの App\_Code フォルダーにソース コードを配置することができます。 このコード例では、動的コンパイルの方法を使用します。 コンパイルする方法について説明するチュートリアルは、次を参照してください。 [Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)します。  
  
 [!code-csharp[WebParts\_WebPartManager\_IsAuthorized\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts\_WebPartManager\_IsAuthorized\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 コード例の 2 番目の部分では、コントロールを除外できるフィルターを作成します。 次の Web ページにはで、次の 3 つの ASP.NET サーバー コントロールが含まれています、 `<asp:webpartzone>` 要素。 最初と 2 番目のコントロールがあることを確認、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティが別の値に設定され、3 つ目は、プロパティは割り当てられません。 実行時にこの承認値をチェックすることができ、フィルターが開発者によって設定される条件に一致する場合は、ページにコントロールを追加できます。 またでことに注意して、 `Page_Load` メソッドは、コードの呼び出し、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> かどうか、コントロールの各が承認されていると、かどうか各コントロールのために、その設定を確認するメソッド <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> プロパティです。  
  
 [!code-csharp[WebParts\_WebPartManager\_IsAuthorized\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_IsAuthorized\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 あるコード例を実行するには、必要があります設定を追加する Web パーツの記述ファイルをエクスポートできるようにするために Web.config ファイルに注意してください。 このコード例については、Web ページと同じディレクトリに Web.config ファイルがあることを確認します。 内で、 `<system.web>` セクションであることを確認、 `<webParts>` を持つ要素、 `enableExport` 属性に設定 `true`, マークアップを次のようにします。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 ブラウザーでページを読み込んだ後に注意してください最初のコントロールが表示されること、オーバーライド対象メソッドで条件に一致するためです。 フィルターで除外されるため、2 つ目のコントロールは、ページに追加されません。 ないため、3 番目のコントロールを追加も、その <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティ セット。 どちらかのコントロールのタイトル バーに動詞メニューのアイコンをクリックすることが両方に注意してください、エクスポート、それぞれ <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> プロパティ値が割り当てられます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>This method is called directly from your code. If you want to gain greater programmatic control over the authorization process, you can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" /> overload method.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> の承認を確認しているコントロール。</param>
        <param name="path">コントロールがユーザー コントロールの場合は、承認されているコントロールのソース ファイルに相対アプリケーション パス。</param>
        <param name="authorizationFilter">割り当てられている任意の文字列値、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> のプロパティ、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをページに追加できるかどうかを承認するために使用されるコントロール。</param>
        <param name="isShared">承認を確認しているコントロールは、アプリケーションの複数またはすべてのユーザーに表示されることを示して、共有コントロールであるかどうかを示すとその <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> にプロパティの値が設定されている <see langword="true" />します。</param>
        <summary>コントロールがページに追加する承認されているかどうかを決定する際の最後の手順を実行します。</summary>
        <returns>コントロールがページに追加する承認済みかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> オーバー ロード メソッドでは、コントロールがページに追加する承認されるかどうかを決定する際の最後の手順を実行します。 メソッドにより `type` は有効な型とする `path` チェック対象のコントロールがユーザー コントロールである場合にのみ値を持ちます。 重要な呼び出し <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> を生成するメソッド、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントです。  
  
   
  
## 例  
 次のコード例では、オーバーライド、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> コントロールがページに追加する承認されているかどうかを決定する方法です。  
  
 最初の手順では、コントロールを除外できるフィルターを作成します。 次の Web ページにはで、次の 3 つの ASP.NET サーバー コントロールが含まれています、 `<asp:webpartzone>` 要素。 最初と 2 番目のコントロールがあることを確認、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティが別の値に設定され、3 つ目は、プロパティは割り当てられません。 実行時にこの承認値をチェックすることができ、フィルターが開発者によって設定される条件に一致する場合は、ページにコントロールを追加できます。  
  
 [!code-csharp[WebParts\_WebPartManager\_IsAuthorized\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_IsAuthorized\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 オーバーライドする 2 番目の手順では、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> メソッド、カスタム承認フィルターの処理を作成します。 コードはまず、プロパティの値があるかどうかをいずれかが制御できるようにメモを割り当てません、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティが自動的に追加されます。 コントロールしているかどうか、フィルター、コードに戻る `true` フィルター値に等しい場合にのみ `admin`します。 これは、ロールによって、特定のユーザーに特定のコントロールを表示するために使用する単純なメカニズムを示します。 ロールを使用して完全な例は、このトピックの範囲外ですが、する点を除いて、現在のユーザーが承認フィルター値に一致するロールし、そのユーザーにのみ、コントロールを追加するかどうかをチェックすることが、このコード例ではオーバーライドされたメソッドとして同じロジックを使用できます。 ここでは、いくつかのユーザーには、すべてのコントロールが表示し、は、その他のユーザーには選択したコントロールだけが表示ページを作成することができます。 これは、フィルターをチェックするロジックが検索する方法の役割を使用した場合です。  
  
 \[Visual Basic\]  
  
```  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
 \[C\#\]  
  
```  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 このコード例を実行するには、このソース コードをコンパイルする必要があります。 明示的にコンパイルし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに、生成されたアセンブリを配置できます。 また、ここで、動的にコンパイル実行時に、サイトの App\_Code フォルダーにソース コードを配置することができます。 このコード例では、動的コンパイルの方法を使用します。 コンパイルする方法について説明するチュートリアルは、次を参照してください。 [Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)します。  
  
 [!code-csharp[WebParts\_WebPartManager\_IsAuthorized\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts\_WebPartManager\_IsAuthorized\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 ブラウザーでページを読み込んだ後に注意してください最初のコントロールが表示されること、オーバーライド対象メソッドで条件に一致するためです。 2 つ目のコントロールは、そのフィルター値が除外されているため、ページには追加されません。 ないため、3 番目のコントロールが追加、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティ セット。 一致する最初のコントロールのページを再度実行して 2 つ目のコントロールのプロパティ値を変更する場合にも 2 つ目のコントロールが追加されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ユーザー コントロールと <paramref name="path" /> か <see langword="null" /> または空の文字列 \(""\) です。  
  
 または  
  
 <paramref name="type" /> ユーザー コントロールではありませんし、 <paramref name="path" /> がそれに割り当てられた値。</exception>
        <block subset="none" type="overrides">
          <para>This method can be overridden by inheriting from the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class, if you want to provide additional handling when checking authorization. You might want to override the method to check for certain values in the <paramref name="authorizationFilter" /> parameter, and based on the value, return a Boolean value that determines whether the control will be added to a page.  
  
 For page developers who also want to check for authorization filters and provide custom handling, there is an option for doing this inline in an .aspx page, or in a code-behind file, without having to inherit from any classes. You can declare an alternate event handler in the page for the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> method of the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> control. For more details and an example, see the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> method.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>によって制御されるページごとの個人用設定の詳細情報に影響を与える個人的な変更が加えられたかどうかを示す値を取得、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。</summary>
        <value>個人的な変更が加えられたかどうかを示すブール値。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> かどうかを管理するページごとの個人用設定データのいずれかを追跡するために内部的にプロパティが変更されました。 ユーザーが追加や削除など、ページ レベルでのさまざまなパーソナル化処理を実行時に、個人用設定データが変更された <xref:System.Web.UI.WebControls.WebParts.WebPart> 接続または切断コントロール、およびその他のアクションを移動して、ページのレイアウトを変更するコントロールのコントロールです。  
  
> [!NOTE]
>  ユーザーは、特定のコントロールに個人的な変更を加える、つまり、コントロール レベルのパーソナル化も実行でき、そのコントロールのみを変更します。 例をコントロールを編集し、そのタイトルのテキストまたはその背景色を変更します。 コントロール レベルのパーソナル化ではによって追跡されるページごとの個人用設定データには影響しません、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロール、ため、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> にプロパティ値が変更されない `true` コントロール レベルのパーソナル化が発生したとき。  
  
 メソッドが保護されており、呼び出し元が直接アクセスすることはできませんが、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティは、呼び出し元が直接アクセスすることができ、このプロパティの値が返されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">読み込まれる永続化された状態データが含まれています。</param>
        <summary>負荷は、前のページ要求を保存し、後続の要求で復元する必要がある状態データを制御します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A> メソッドは、ページのポストバック間で永続化するプロパティのデータを復元するために役立つ場合でも、 <xref:System.Web.UI.Control.EnableViewState%2A> にプロパティが設定されている `false`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="savedState" /> は有効な <see cref="P:System.Web.UI.PageStatePersister.ControlState" /> ではありません。</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary>初期化プロセス中に後で使用するためにパーソナル化オブジェクトによって <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに渡されたカスタムのパーソナル化データを格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> method provides saved state data in the form of a <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> object. This data is eventually used to load personalization data into the Web Parts controls and to perform other initialization tasks.  
  
> [!NOTE]
>  This method is called by a sequence of methods that begins when the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A> method initially requests the associated <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> object to supply personalization data to the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control.  
  
 You cannot call this method directly from your code. You can, however, directly call the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A> method, which itself calls the <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> method and returns the personalization data.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> method in a derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Security.PermissionSet" /> オブジェクトのみを許可する <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> アクセス許可と <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 権限です。</summary>
        <value>A <see cref="T:System.Security.PermissionSet" /> オブジェクトのみを許可する <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> アクセス許可と <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 権限です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Security.PermissionSet> 型の逆シリアル化のインポート中にこのプロパティによって返されるオブジェクトを使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Security.PermissionSet" /> オブジェクトのみを許可する <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> アクセス許可と <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 権限です。</summary>
        <value>取得、 <see cref="T:System.Security.PermissionSet" /> オブジェクトのみを許可する <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> アクセス許可と <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 権限です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Security.PermissionSet> 逆シリアル化を入力する点を除いてすべてのインポート中にこのプロパティによって返されるオブジェクトを使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはその他のサーバー コントロールを移動します。</param>
        <param name="zone">ターゲット <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> する <c>webPart</c> を移動します。</param>
        <param name="zoneIndex">インデックスを示す整数を <c>webPart</c> 内の他のコントロールを基準とした <c>zone</c>します。</param>
        <summary>移動、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはいずれかからサーバー コントロール <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンどうし、または同じゾーン内の新しい位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> メソッドに移動する `webPart` を新しい場所に同じゾーンまたはゾーンが異なります。 コードから直接このメソッドを呼び出すことができ、ユーザー コントロールを Web パーツのユーザー インターフェイス \(UI\) にさまざまなオプションを使用して新しい位置に移動するときにも呼び出されます。  
  
 前に、多くの条件を満たす必要がある `webPart` 移動でき、これらのほとんどは、このトピックの「例外」に示されている項目で示されます。 場合 `webPart` 内に含まれていない、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンのゾーンにまず始めに、移動することはできません。  
  
 次の順序を移動が発生した条件が満たされると後 `webPart`:  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> イベントを発生させます。  
  
2.  `webPart` 現在のゾーン \(必要な場合\) から削除され、新しいゾーンまたは現在のゾーン内の新しい位置に追加します。  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントを発生させます。  
  
4.  `zoneIndex` の各 <xref:System.Web.UI.WebControls.WebParts.WebPart> 送信元と送信先の両方のゾーン内のコントロールが移動を反映するようにリセットします。  
  
   
  
## 例  
 次のコード例では、呼び出し、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> メソッドに移動するコードから直接、 <xref:System.Web.UI.WebControls.WebParts.WebPart> からゾーンを 1 つのコントロールです。  
  
 このコード例には、3 つの部分があります。  
  
-   表示モードを変更するユーザー コントロールです。  
  
-   コントロールをホストする Web ページ。  
  
-   コード例を実行する方法の説明です。  
  
 このコード例の最初の部分は、表示モードを変更するユーザー コントロールです。 使用例」セクションからユーザー コントロールのソース コードを取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 表示モードおよびユーザー コントロールの動作方法の詳細については、次を参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 例の 2 番目の部分は、2 つのサーバー コントロールを含む 2 つのゾーンを含む Web ページです。 ユーザーがクリックしたとき、 **web パーツの移動** 内のコード ページで、ボタン、 `Button1_Click` メソッドは、最初のゾーンからコントロールを 2 番目のゾーン内の新しい位置に移動します。 まず、コードを呼び出す必要がありますに注意してください、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> を取得するメソッド、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> をラップするオブジェクト、 `list1` コントロールです。 これは、必要なための最初のパラメーター、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> メソッドが必要です、 <xref:System.Web.UI.WebControls.WebParts.WebPart> 制御し、 `list1` ASP.NET サーバー コントロールします。  
  
 [!code-csharp[WebParts\_WebPartManager\_MoveWebPart\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_MoveWebPart\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 ページが表示されたら、クリックして、 **web パーツの移動** \] ボタン、リンクが含まれているコントロールを 2 つ目のゾーンでは、中央の位置に移動することを確認します。 コントロールの移動をプログラムで呼び出すことにより実現、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> メソッドです。 使用することも、 **表示モード** ドロップダウン リスト コントロールをデザイン モードにし、デザイン モードでページを切り替える、コントロールを別のゾーンまたはゾーン内の別の位置にドラッグすることができます。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 、メソッドを呼び出しても、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> をユーザーが開始したはこのような処理コントロールが移動します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 含まれていない、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> のコレクション、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。  
  
 または  
  
 <paramref name="zone" /> 含まれていない、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> のコレクション、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。  
  
 または  
  
 によって参照されるゾーン、 <paramref name="webPart" /> コントロールの <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> プロパティは、 <see langword="null" />, 、つまり <paramref name="webPart" /> ゾーンに現在含まれていません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> または <paramref name="zone" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> が 0 未満です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" /> イベント データを格納します。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> イベントが存在する場合、イベントのハンドラーを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドときに、 <xref:System.Web.UI.WebControls.WebParts.WebPart> ページに追加する承認の制御をチェックしています。 ときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドが呼び出されるを生成、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベント、イベントのハンドラー メソッドがある場合、ハンドラーを呼び出します。  
  
 承認する処理の <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールは、Web パーツの重要な機能です。 各 <xref:System.Web.UI.WebControls.WebParts.WebPart> またはでゾーンに追加されているサーバー コントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールがコントロールを追加できるかどうかを決定する承認プロセスを通過します。 既定では、Web パーツ コントロール セットにコントロールがゾーンに追加されないようにするためのフィルター条件は提供されません。 コントロール セットは開発者が独自のフィルター条件を作成するときに必要なメカニズムを提供します。 これらのメカニズムを使用すると、カスタムのフィルター処理シナリオを作成できます。 たとえば、されるため、ゾーンに特定のコントロールを追加すると、ユーザーが管理者ロールの場合は、ページがレンダリングされ、ユーザーがユーザー ロールの場合は、それらのコントロールを追加しない場合は、フィルターを作成します。  
  
 承認プロセス中にコントロールをフィルター処理メカニズムは、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティを <xref:System.Web.UI.WebControls.WebParts.WebPart> 、コントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> と <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッド、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> でイベントを <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。  
  
 フィルター処理を作成するには、基本的に 2 つのタスクです。 最初に、文字列を割り当てる、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> の各プロパティ <xref:System.Web.UI.WebControls.WebParts.WebPart> フィルターを適用するコントロール。 これらの文字列値を任意で指定できますが、フィルターを適用する条件を含める必要があります。 たとえば、特定の制御したい場合、管理者の場合にのみゾーンに追加するユーザーが、ページを表示しの文字列値を割り当てることができます `admin` プロパティにします。 そして、ASP.NET のロールの機能を使用し、管理者、マネージャー、およびユーザーなどさまざまなロールに、サイトのすべてのユーザーを追加でした。 フィルター処理コードはユーザーのロールを確認、チェック対象のコントロールの承認フィルター値を比較して、ページの読み込み時に、ユーザーが管理者ロールには \(たとえば\) と、コントロールを設定していた場合、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 値を `admin`, 、コントロールを追加する可能性があります。  
  
 フィルター処理を作成するのには、2 番目の手順は確認するコードを記述、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティの値 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、およびのゾーンに追加される前に各コントロールを承認するかどうかを判断します。 このフィルター処理のコードを配置する場所についての 2 つのオプションがあります。 最初のオプションは、ページの開発者向けの推奨されるオプションです。 処理するメソッドを作成する、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> コード分離ファイルまたは Web ページのサーバー スクリプト コード内で直接イベントです。 イベントに追加することで、メソッドを関連付ける、 `OnAuthorizeWebPart` 属性のタグを <xref:System.Web.UI.WebControls.WebParts.WebPartManager> \] ページで、次のマークアップ コードの例のようにを制御します。  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 各チェックは、カスタム メソッドを行うにはすべて <xref:System.Web.UI.WebControls.WebParts.WebPart> 、フィルター処理条件を制御し、次に、ブール値を割り当てる、結果に基づき、 <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> のプロパティ、 <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> を示すためにオブジェクトかどうか、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを追加することができます。 使用例」のコードでは、これを行う方法を示します。  
  
 継承する、フィルター処理コードを配置する場所については、2 番目のオプションは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラス、およびフィルター条件をチェックするメソッドをオーバーライドします。 2 つのメソッドはオーバーライドすることができます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=fullName> メソッドまたは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドです。 どちらの方法でも機能しますが、ほとんどの場合は上書きすることをお勧め、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドを提供するため、全体の承認プロセスをより詳細なプログラムによる制御が、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドでは、イベントとハンドラーの確認を生成する 1 つだけの特定のタスクです。 カスタムのコード例については <xref:System.Web.UI.WebControls.WebParts.WebPartManager> をオーバーライドするクラス、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドを参照してください、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=fullName> 、メソッドのオーバー ロードします。  
  
   
  
## 例  
 次のコード例では、カスタム イベント ハンドラーを設定、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 、イベント ハンドラー用のカスタムのフィルタ リング コードを提供できるように、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドです。 この例は、フィルター処理のシナリオとの認証を提供するページの開発者の一般的な方法になります <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールをページに追加されます。  
  
 Web ページで、 `<asp:webpartmanager>` 要素には、 `OnAuthorizeWebPart` に割り当てられているイベント ハンドラーの名前を持つ属性です。 このメソッドは、ページ上のコントロールが、それぞれがあるかどうかをチェック <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティの値に設定 `admin` し、必要な場合を返します `true`, 、つまりが承認され、ページに追加することです。  
  
> [!NOTE]
>  コントロールをメモに割り当てられている任意の値がない、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> がフィルター処理の一部であると判断するため、プロパティは同様に、追加します。 フィルター処理シナリオで一般的なアプローチになります。 一部のコントロールはフィルター選択すると、他のユーザーはありません、ため、すべてのユーザーに利用できるように見なされるためです。  
  
 [!code-csharp[WebParts\_WebPartManager\_AuthorizeWebPart\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_AuthorizeWebPart\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ロールのユーザーの設定は、このトピックの範囲外ですが、ために、このコード例は、フィルター処理でのユーザー ロールを調べません。 ただし、ユーザー ロールに基づいてコントロールのフィルター処理シナリオは、このフィルター処理機能の最も一般的な用途の 1 つをする可能性があります。 サイトの役割を持つコントロールをフィルター処理するには、このメソッドでユーザーのロールを確認する場合は、メソッドは次のコード ブロックではなく前のコードの例は、ロールを使用しない単純なアプローチ\) ようになります。  
  
 \[Visual Basic\]  
  
```  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
 \[C\#\]  
  
```  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> ページとそのコントロールが読み込まれたら、そのデータの共有を開始するページ上の接続がアクティブになったことを示すイベント。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> ページには、読み込みプロセスが完了した後にイベントです。 このメソッドは、イベントのハンドラーを追加する方法を提供します。  
  
 ページの開発者は、追加することで、イベントのカスタム ハンドラーを追加できます、 `OnConnectionsActivated` 属性を `<asp:webpartmanager>` 属性にカスタム メソッドの名前を割り当てる、ページにある要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" /> method in a derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> ことページとそのコントロールが読み込まれ、接続をアクティブ化するプロセスを開始できることを示すイベント。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> イベントで、プログラムを使用して接続をアクティブ化するプロセスをカスタマイズするためのメカニズムが用意されています。  
  
 ページの開発者は、追加することで、イベントのカスタム ハンドラーを追加できます、 `OnConnectionsActivating` 属性を `<asp:webpartmanager>` 属性にカスタム メソッドの名前を割り当てる、ページにある要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" /> method in a derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" /> 表示の変更モードに関連するイベント データを格納します。</param>
        <summary>発生させます、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> ことを示す、イベント、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールには、1 つの表示モードから別の Web ページへの切り替えの処理が完了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> ベースのメソッドを発生させるだけを形成する、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> イベントです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" /> method. For example, after a change of display mode, you might want to change something in the appearance of the user interface (UI), depending on which display mode is contained in the <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" /> property. Or you might want to hide certain content, or display a certain control.  
  
 When you override the method, you should normally call the base method as the last step of the overridden method, so that your custom code runs first, and the event is raised last, indicating that the mode change is complete.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> 表示モードの変更に関連付けられているイベント データを格納します。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> ことを示す、イベント、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールの 1 つの表示モードから別の Web ページへの切り替え中にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> ベースのメソッドを発生させるだけを形成する、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> イベントです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" /> method. For example, as a display mode is changing, you might want to check what the new display mode will be (by using the <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" /> property) and change something in the user interface (UI) based on what the new display mode will be. If you had a custom display mode, you might want to make certain controls visible if the custom mode is going to be the new display mode.  
  
 When you override this method, you should normally call the base method as the first step of the overridden method, so that the event is raised to indicate a display mode is starting to change. Then, your custom code can make changes in the user interface (UI) before the new display mode is actually displayed.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>生成、 <see cref="E:System.Web.UI.Control.Init" /> 最初のイベントは、イベントで、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールの有効期間。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> メソッドを生成する基本メソッドを呼び出す、 <xref:System.Web.UI.Control.Init> 制御、および、1 つだけの実現することなどのいくつかの準備手順が実行用のイベント、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> ページでは、制御し、個人用設定データを読み込んでいます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">他 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ページ上のコントロール</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.Control.PreRender" /> 直前に発生するイベントの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールを Web ページに表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A> メソッドを生成する基本メソッドを呼び出す、 <xref:System.Web.UI.Control.PreRender> 制御、および、レジスタのイベントが Web パーツを含むページで必要ないくつかのクライアント スクリプトを制御します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>発生させます、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 後に発生するイベント、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールが新しく選択されたか、またはが、選択範囲をクリアします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> ユーザー インターフェイス \(UI\) の外観を変更する、開発者が先には通常、ポイント イベントです。 たとえば、新しい <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを選択し、Web パーツ コントロール セットを新しく選択したコントロールのレンダリングが変更されます。 コントロールの選択を解除すると、レンダリングが正常に返されます。  
  
 ユーザーが選択して、特定後 <xref:System.Web.UI.WebControls.WebParts.WebPart> 、編集のためのコントロール、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドが呼び出されます。 ユーザーがコントロールの編集を終了するし、コントロールの選択がクリアされている結果を閉じ、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドがもう一度呼び出されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>There are several options related to the <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> event, to allow developers to customize the rendering that occurs after the selected control has changed. In declarative code, within the <see langword="&lt;asp:webpartmanager&gt;" /> element you could set the <see langword="OnSelectedWebPartChanged" /> attribute, and assign to it the name of a custom method. In the custom method, you could modify the rendering of the selected controls when the event occurs. Another option is to inherit from the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class and override the method. A third option is to customize the rendering at the zone level; for example, you can inherit from the <see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" /> class, and override its <see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" /> method, to customize the rendering of controls selected and cleared during the editing process.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> の変更の処理中に発生するイベントの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールが現在選択されています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> の変更の処理中に発生するイベントの <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールで現在選択されています。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、選択したコントロールを変更するプロセスをキャンセルする機会を与えるのため、このメソッドと関連のイベントを使用します。 内で、メソッドが呼び出さなど、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> メソッド、および内、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> メソッドは、プロセスをキャンセルする方法を提供します。 ユーザーには、編集されているコントロールの \[キャンセル\] 動詞がクリックすると、コントロールが選択されていないと、ため、編集変更は保存されませんが、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> メソッドでは、編集をキャンセルすることです。  
  
> [!NOTE]
>  開始し、接続するプロセスを終了中に、メソッドを呼び出す同様に、 <xref:System.Web.UI.WebControls.WebParts.WebPart> そのプロセスのキャンセルを有効にする別のコントロールにコントロールできます。  
  
 ページの開発者には、カスタム ハンドラーを作成、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> イベントを追加することで、 `OnSelectedWebPartChanging` 属性を `<asp:webpartmanager>` 内の要素宣言ページ マークアップ、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">コントロールの削除に関連付けられているイベント データ。</param>
        <summary>基数を発生させます <see cref="E:System.Web.UI.Control.Unload" /> イベントと削除、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Web ページからのインスタンス。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>生成、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> 後に発生するイベント、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールがページに追加されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> メソッドは追加の処理中に、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール \(またはその他のサーバー コントロールに追加されている、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーン\) ページにします。  
  
 ページの開発者には、カスタム ハンドラーを作成、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> イベントを追加することで、 `OnWebPartAdded` 属性を \<`asp:webpartmanager>` 要素、および属性にカスタム メソッド名を割り当てることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />。</param>
        <summary>生成、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> を追加するプロセス中に発生するイベント、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール \(またはサーバーまたはユーザー コントロール\) に、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> コントロールが追加されていることを示すイベント。 このメソッドは、追加の処理をキャンセルするオプションも提供します。 コントロールが正しく追加された場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> イベントに依存します。  
  
 ページの開発者は追加することで、関連するイベントのカスタム ハンドラーを用意することができます、 `OnWebPartAdding` 属性を `<asp:webpartmanager>` Web ページと、その属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers who create derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> method to customize the event handling.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> コントロールがページから削除されたことを通知するイベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> ことを示す、イベント、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール \(またはその他のサーバーまたはユーザー コントロール\) が正常に閉じられたページ上。  
  
 閉じるには、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールではレンダリングされませんしも特別なに配置するオブジェクトを保持するいると呼ばれるページ カタログようにページから削除することを意味します。 対応するページ カタログ、 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 終了への参照の管理、制御 <xref:System.Web.UI.WebControls.WebParts.WebPart> 各ページのコントロールです。 場合、 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 内のページにコントロールが宣言されている、 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> ゾーン、ユーザーがカタログ表示モードに切り替えるし、ページに戻る閉じられていたすべてのコントロールを追加します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> メソッドは、開発者がカスタム ハンドラーを作成する機会を提供、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> イベントです。 ページの開発者は、追加することで、イベントのカスタム ハンドラーを追加できます、 `OnWebPartClosed` 属性を `<asp:webpartmanager>` 属性にカスタム メソッドの名前を割り当てる、ページにある要素。 開発者がこのメソッドで実行が 1 つの有用なタスクでは、終了したコントロールの代わりにプレース ホルダーを表示するのには、コントロールをページに追加する方法をユーザーに通知するためのヒントが完了します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>発生させます、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> の処理中に発生するイベント、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはサーバー コントロールがページから削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> コントロールが終了またはページから削除される処理を行っていることを示すイベント。 このメソッドは、終了プロセスをキャンセルするオプションも提供します。 コントロールがページから、正常に削除された場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> イベントに依存します。  
  
 ページの開発者は追加することで、関連するイベントのカスタム ハンドラーを用意することができます、 `OnWebPartClosinging` 属性を `<asp:webpartmanager>` Web ページと、その属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers who create derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> method to customize the event handling.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> 後に発生するイベント、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールがページから完全に削除されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> の削除処理中に呼び出されます、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール \(またはその他のサーバー コントロールに追加されている、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーン\) ページからです。  
  
 ページの開発者には、カスタム ハンドラーを作成、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> イベントを追加することで、 `OnWebPartDeleted` 属性を \<`asp:webpartmanager>` 要素、および属性にカスタム メソッド名を割り当てることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>発生させます、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> あることを示すイベント動的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール \(またはに格納されているサーバーまたはユーザー コントロール、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーン\) 削除されている処理を行っています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 動的 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを削除してコントロールが削除されると、コントロール インスタンス ページからは完全に削除は復元できません。 動的 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールは、プログラムを使用して、追加されたまたは Web パーツのカタログから静的コントロールではなくが宣言されている Web ページのマークアップにします。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> コントロールはそのゾーンから完全に削除されていることを示すイベント。 このメソッドは、削除プロセスをキャンセルすることも提供します。 コントロールがページから、正常に削除された場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> イベントに依存します。  
  
 ページの開発者は追加することで、関連するイベントのカスタム ハンドラーを用意することができます、 `OnWebPartDeleting` 属性を `<asp:webpartmanager>` Web ページと、その属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers who create derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> method to customize the event handling.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> 後に発生するイベント、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールがページ上の別の場所に移動しました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> の最後のイベント、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> メソッドにより、コード、イベント ハンドラーを実行する前に、コントロールを移動するプロセスが完了します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントは、コントロールを移動すると、現在のゾーン内または別のゾーンにおよび、動きが実行されるは、プログラムを使用して、またはユーザーがコントロールをドラッグするかどうかは関係ありません。  
  
 ページの開発者には、カスタム ハンドラーを作成、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントを追加することで、 `OnWebPartMoved` 属性を \<`asp:webpartmanager>` 要素、および属性にカスタム メソッド名を割り当てることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> あることを示すイベント、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはサーバーまたはユーザー コントロールに、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンが移動しています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> メソッドを発生させます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 発生するイベントのときに、 <xref:System.Web.UI.WebControls.WebParts.WebPart> か、または別のゾーンに対応するゾーン内でその他のサーバー コントロールを移動します。 このメソッドでは、移動プロセスをキャンセルする機会も提供します。 移動が正常に完了している場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントに依存します。  
  
 ページの開発者は追加することで、関連するイベントのカスタム ハンドラーを用意することができます、 `OnWebPartMoving` 属性を `<asp:webpartmanager>` Web ページと、その属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers who create derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> method to customize the event handling.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> 間の接続の確立後に発生するイベント <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> メソッドの最後に対応するイベントを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> メソッドで、イベント ハンドラー内のコードが実行される前に、2 つのコントロールの接続に必要な手順が完了したことを確認します。  
  
 メソッドは、接続の作成のプロセスをプログラムで制御を提供し、関連のイベントは、ユーザー インターフェイス \(UI\) を更新または接続が確立されているユーザーに通知する位置を示す便利なポイントです。  
  
 ページの開発者には、カスタム ハンドラーを作成、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> イベントを追加することで、 `OnWebPartsConnected` 属性を \<`asp:webpartmanager>` 要素、および属性にカスタム メソッド名を割り当てることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> 2 つの接続を確立するプロセス中に発生するイベントの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはに格納されているサーバーまたはユーザー コントロール、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> イベントで、2 つのコントロールの接続を確立しようとするときに発生します。 このメソッドは、接続の試行をキャンセルする機会を提供します。 接続が成功した場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> イベントに依存します。  
  
 ページの開発者は追加することで、関連するイベントのカスタム ハンドラーを用意することができます、 `OnWebPartsConnecting` 属性を `<asp:webpartmanager>` Web ページと、その属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers who create derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> method to customize the event handling.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> 間の接続後に発生するイベントの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールが終了しました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> メソッドの最後に対応するイベントを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドで、2 つのコントロール間の接続を終了するプロセスを実行します。  
  
 ユーザー インターフェイス \(UI\) に変更を加えるか、アプリケーションへの変更を行った開発者がユーザーに通知できるように、メソッドは、接続を終了するプロセスをプログラムで制御を提供します。  
  
 ページの開発者には、カスタム ハンドラーを作成、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> イベントを追加することで、 `OnWebPartsDisconnected` 属性を \<`asp:webpartmanager>` 要素、および属性にカスタム メソッド名を割り当てることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> を 2 つを示すイベント <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはサーバーまたはユーザー コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンが接続を終了処理を行っています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> メソッドを発生させる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントが 2 つのコントロールは、接続を終了するときに発生します。 このメソッドは、切断されたときのプロセスをキャンセルする機会を提供します。 接続が正常に削除された場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> イベントに依存します。  
  
 ページの開発者は追加することで、関連するイベントのカスタム ハンドラーを用意することができます、 `OnWebPartsDisconnecting` 属性を `<asp:webpartmanager>` Web ページと、その属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers who create derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes can override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> method to customize the event handling.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページのパーソナル化データを格納しているオブジェクトへの参照を取得します。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 個人用設定データを格納します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティにアクセスする手段を提供する、 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> をページに関連付けられているオブジェクト、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 このプロパティを使用するには、パーソナル化オブジェクトのさまざまなメンバーにアクセスすることができます。 たとえば、使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> メソッドから、ページのパーソナル化スコープの切り替えをユーザーのスコープ、またはその逆を共有します。 ページで、個人用設定データのプロバイダーが使用されている個人設定が有効かどうかは、また、ページの現在のパーソナル化スコープを検索することができます。  
  
 によって参照されるデータを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティはによって追跡されるページごとの個人用設定データのみ、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールです。 パーソナル化できるプロパティの値などのコントロールに固有の個人用設定データ <xref:System.Web.UI.WebControls.WebParts.WebPart> 制御の一部ではなく、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティです。  
  
> [!NOTE]
>  Web パーツのパーソナル化の詳細については、次を参照してください。 [Web Parts Personalization Overview](http://msdn.microsoft.com/ja-jp/7dc34f74-52aa-4082-b98d-2bcf9e07e320)します。  
  
   
  
## 例  
 次のコード例では、使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティ プログラムを使用しています。  
  
 次の Web ページでは、ユーザーが編集モードの特定の側面を入力する、 <xref:System.Web.UI.WebControls.Calendar> コントロールです。**切り替えスコープ** ボタンは、ユーザーまたは共有のパーソナル化スコープに、ページを切り替えます。**編集モードの** と **Browse Mode** 各ボタンでは、適切な表示モードに切り替えます。 ある、 `<script>` イベントの使用を処理するメソッドの 2 つのファイルのセクションにタグ付け、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティを基になるオブジェクトの便利なメンバーにアクセスします。 具体的には、これらのメソッドを使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> メソッドおよび <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> プロパティを介してアクセスするオブジェクトを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティです。  
  
 [!code-csharp[WebParts\_WebPartManager\_Personalization\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_Personalization\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 コード例を実行するには、また必要があります有効にするユーザーまたはユーザーが共有スコープ内のページを個人用に設定します。 内の Web.config ファイルにエントリを追加、 `<system.web>` セクションは、次のマークアップのようになります。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 ブラウザーでページを読み込んだ後、 **切り替えスコープ** \] ボタン、および伝えるページ、スコープが共有されることを確認します。 クリックして **編集モードの** 表示モードを変更するに表示されているコントロールの動詞メニューをクリックし、選択 **編集** \] メニューからです。 両方の編集コントロールのユーザー インターフェイス \(UI\) が表示されることに注意してください。 今すぐ\] をクリックして **Browse Mode** を通常の参照を返します。 ページという共有スコープ内にある場合はクリックして **表示\/非表示のスコープ** ページがユーザー スコープのことを確認してもう一度にします。 次に、コントロールをもう一度、編集が、UI では、編集、いるようになりましたことを確認するには、同じ手順に従う、 <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> コントロールは表示されません。 このコントロールは、ページが共有のパーソナル化スコープ内にある場合にのみ機能するためです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>により、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールをドラッグするなど、さまざまな個人用設定機能に使用されるクライアント側\-スクリプトを出力する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> Web ページのコントロールにします。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> ページへの書き込み先のコントロールの内容を受け取る。</param>
        <summary>防ぐためにオーバーライドされる、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 、コンテンツの表示を制御します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>状態のデータの保存、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールを含む Web ページへの今後の要求でデータを復元できるようにを制御します。</summary>
        <returns>
          <see cref="T:System.Object" /> コントロールを配置の保存された状態データ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> メソッド ページ ポストバック間で永続化するプロパティの状態データを保存する場合でも、 <xref:System.Web.UI.Control.EnableViewState%2A> にプロパティが設定されている `false`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> 読み込まれる状態データが含まれています。</param>
        <summary>管理されているカスタムのパーソナル化の状態データを保存、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 制御、ページが再度読み込まれるたびに、このデータをロードできるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A> メソッドは、パーソナル化、プロセスで重要なにより、個人用に設定されたユーザー設定を今後のブラウザー セッションを保存するページへのアクセスします。 次のアイテムを含むカスタムのパーソナル化状態データをこのメソッドは保存: 動的 <xref:System.Web.UI.WebControls.WebParts.WebPart> またはページに追加またはページはページに移動されたコントロールと動的接続を作成または削除されたから削除されたサーバー コントロール。  
  
 このメソッドは、コードから直接呼び出すことはできません。 ただし、呼び出すことができます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 自体メソッドは、個人用設定データを保存するには、このメソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Developers can override this method in a derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class to customize the process of saving personalization data.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照を取得、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはその他のサーバー コントロールを編集するため、または別のコントロールとの接続を作成するために現在選択されています。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> の編集または接続の構成の現在選択されているコントロール。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> プロパティへの参照を返す、 <xref:System.Web.UI.WebControls.WebParts.WebPart> またはその他のサーバー コントロールを編集するため、または別のコントロールとの接続を作成するために現在選択されています。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールのコントロールを選択するプロセスを処理するためのいくつかの便利なメソッドとイベントの提供します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> イベントは、コントロールが選択した直後に、変更を加える前に発生します。 選択された後、コントロールで何らかの操作を実行して、オーバーライド、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> メソッドです。 たとえば、コントロールが選択されているがまだ変更していない、視覚的に強調するためにどのコントロールが選択されているの外観を変更することができます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> イベント、選択したコントロールが変更された直後に発生します。 変更された後、コントロールで何らかの操作を実行して、オーバーライド、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>1 つを選択した後に発生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールが変更し、Web ページ上の別のコントロールに移動します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントと組み合わせて使用できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 選択コントロールのユーザー インターフェイス \(UI\) を変更するメソッドです。 など、ユーザーがページをデザイン モードに切り替える場合 \(<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>\)、し、選択、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの新しい位置にドラッグすることの目的ではの境界線の色を変更することで、選択したコントロールの表示を次に例を変更または背景が選択されている間に共通します。  
  
> [!NOTE]
>  イベントの使用の詳細については、次を参照してください。 [How to: Consume Events in a Web Forms Application](http://msdn.microsoft.com/ja-jp/73bf8638-c4ec-4069-b0bb-a1dc79b92e32)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これを変更するプロセス中に発生した <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> サーバー コントロールが Web ページで現在選択されているか。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントと組み合わせて使用できる、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> メソッドです。 ページの開発者は追加することで、コードでイベント ハンドラーを作成することができます、 `OnSelectedWebPartChanging` 属性を `<asp:webpartmanager>` カスタム メソッドの名前に、属性の値を設定\] ページにある要素は、イベントを処理します。  
  
 このイベントは、先頭または末尾の開始とコントロールの編集を終了するときや、コントロール間への接続の処理中に発生します。 詳細については、「、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> メソッドです。  
  
 通常、ときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> イベントは、選択したコントロールを変更するユーザーの操作の直接の結果として、イベントを取り消すことができます。 ただし、これにはイベントをキャンセルできないシナリオがあります。 場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> コントロールが削除されると、 <xref:System.Web.UI.WebControls.WebParts.WebPart> が含まれているコントロールをすべて閉じる、それ以外の場合、孤立とします。 この場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 制御が閉じ、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、いない、ユーザーおよびにする必要がありますかどのコントロールが現在選択されているおよびの中断の可能性は一切選択を変更するときにすべてのコントロールのクリーンアップのプロセスを完了できるようにします。 そのため、仕様により、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> メソッドは、このシナリオではキャンセルできません。 キャンセルできる関連イベントの表示、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> イベントです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>場合は、そのカスタムのパーソナル化データを示すフラグを設定、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールが変更されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> メソッドが最終的に更新された個人用設定データを保存する Web パーツ コントロールでのパーソナル化コンポーネントが発生するフラグを設定します。 によって追跡のパーソナル化データに対する変更を引き起こす可能性のあるシナリオの詳細については、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 制御を参照してください、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> メソッドは、コードから直接呼び出すことができないし、Web パーツ コントロール セットにより Web パーツのパーソナル化機能の一部として内部的に使用されるため、オーバーライドすることはできません。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The method can be called by a derived <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class. This would be useful if you want to customize the personalization components of the Web Parts control set, and thus need to control the process of setting flags for personalization data.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> または選択したサーバー コントロール。</param>
        <summary>セット、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> プロパティの値が現在選択されているのと同じ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはサーバー コントロール。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> メソッドは最初の文字で指定されたコントロールの編集を終了したりするプロセス中に、 `webPart` パラメーターと、最初の文字を含む接続を終了したりその `webPart`します。  
  
 編集し、接続のプロセスの先頭にある `webPart` 編集しようとする、接続を入力または選択したコントロールです。  
  
 編集し、接続のプロセスの最後に `null` に渡される、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> メソッドは、その結果、現在選択されているコントロールが選択されていません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、空の文字列 \(""\) にスキンを適用しないように、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。</summary>
        <value>空の文字列を妨げる、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロール スキンを割り当てる必要がなくなります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> プロパティの継承されたオーバーライド <xref:System.Web.UI.Control.SkinID%2A?displayProperty=fullName> 防ぐためにプロパティ、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> スキンを使用してから、コントロールを非表示にあるコントロール。 プロパティの実装、スキンに割り当てられなくから空の文字列を常に返すことによって、 `get` アクセサー、および常の値を設定しようとした場合、例外をスローすること、 `set` アクセサー。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">プロパティの値を設定しようとしています。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのコレクションへの参照を取得 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 静的接続として定義されている Web ページ上のオブジェクト。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> ページ上のすべての静的な接続を格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティを使って、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールを追跡し、ページ上のすべての静的な接続を管理します。 動的な接続とは異なり、静的な接続は、ページがレンダリングされるたびに、ページに追加する必要はありません。  
  
 このプロパティによって参照されるコレクションには、プログラムで作成またはで指定されているかどうか、ページ上に存在するすべての静的な接続が含まれています。、 `<asp:webpartconnection>` ページのマークアップ内の要素。  
  
   
  
## 例  
 次のコード例に示しますのプログラムでの使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティです。  
  
 このコード例には、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   ソース コード ファイルを含む 2 つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタム インターフェイスです。  
  
-   2 つのカスタムを含む Web ページ <xref:System.Web.UI.WebControls.WebParts.WebPart> 接続可能なコントロールと `<asp:webpartmanager>` 要素。  
  
-   ブラウザーでの例のしくみの説明です。  
  
 次のコードには、例の Web ページの部分のみが含まれています。 使用例」セクションから例 \- カスタム ユーザー コントロールとカスタム コントロールおよびインターフェイスのソース コードの最初の 2 つの部分を取得する必要がありますも、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 このトピックでは、コンパイルするためのオプションについても説明、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。  
  
 コード例の 3 番目の部分は、Web ページです。 ページの宣言型マークアップを含む `Register` ユーザー コントロールとカスタム コントロールの両方のディレクティブです。`<asp:webpartmanager>` 要素、 `<asp:webpartzone>` カスタム コントロールを格納する要素と `<asp:connectionszone>` 要素。 ある、 `Page_Load` メソッド、コードを確認するかどうか、接続が既に存在し、ない場合は、プロバイダー、およびを定義、コンシューマーがそれぞれのコネクション ポイント、およびによって参照される静的な接続のセットに新しい接続を追加、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティです。  
  
 [!code-csharp[WebParts\_WebPartManager\_StaticConnections\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_StaticConnections\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 クリックして、ブラウザーで Web ページが読み込まれた後、 **表示モード** ドロップダウン リスト コントロールと選択 **接続** 接続モードをページに切り替えます。 接続モードは、 `<asp:connectionszone>` 要素を使用すると、コントロール間の接続を作成します。 接続モードなどのタイトル バーの下向きの矢印をクリックして、 **郵便** の動詞メニューをアクティブに制御し、をクリックして **接続**します。 接続のユーザー インターフェイス \(UI\) が表示されたら、接続が既にに含まれるコードによって作成されたことに注意してください、 `Page_Load` メソッドです。 以降のブラウザー セッションでこのページに戻り、この静的な接続が確立されていると、ページが読み込まれるたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の Web ページで使用可能なすべての表示モードの読み取り専用コレクションを取得します。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> のセットを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 特定の Web ページで利用できるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティには、実際には、ページに存在するゾーン制御の種類を指定したページで使用可能な表示モードだけが含まれています。  
  
> [!NOTE]
>  表示モードを無効にすることができますとに追加されていない表示モードが無効にすると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> その表示モードをサポートするゾーンの対応する型が、ページに存在する場合も、コレクションです。  
  
 ブラウズ モードとデザイン モードは常にサポートします。 異なる可能性がある表示モードは、編集、カタログ、および接続モードです。 これらの各表示モードは、特定の種類の関連付け <xref:System.Web.UI.WebControls.WebParts.ToolZone> コントロールです。 によって参照されるコレクションに追加する特定の表示モードを原因となる Web ページに特別に型指定されたそのゾーンの存在は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティです。 たとえば、Web ページが含まれている場合、 <xref:System.Web.UI.WebControls.WebParts.EditorZone> ゾーンしない場合は、 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> ゾーンの編集の表示モードは、そのページで、サポートされているモードのいずれかが、カタログの表示モードがサポートされていません。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティと異なります、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> プロパティは、現在利用できるすべての表示モードを格納するコレクションの参照を <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 制御する場合に、特定のページでサポートされていないものも含めています。  
  
   
  
## 例  
 次のコード例のプログラムから使用を示しています、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティです。 コードでは、このプロパティを使用して、現在の Web ページで利用可能な表示モードだけで、一覧に表示します。  
  
 このページでサポートされている 3 つの表示モードがある: 参照、設計、および編集します。 最初の 2 つが常に表示、および編集モードは、ページが含まれているために、このコード例で使用可能な <xref:System.Web.UI.WebControls.WebParts.EditorZone> コントロールです。 カタログと接続表示モードは表示されませんが、このページに対応するゾーンが含まれていないためです。  
  
 [!code-csharp[WebParts\_WebPartManager\_SupportedDisplayModes\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_SupportedDisplayModes\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 ブラウズ モードからページをデザイン モードに切り替えることをドロップダウン リスト コントロールを使用するには、ブラウザーでページを読み込んだ後し編集モードにします。 編集モードでサーバー コントロールの 1 つのヘッダーにドロップダウン動詞メニューをクリックして選択 **編集** コントロールを編集します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カスタムのパーソナル化の状態データを管理するかどうかを示す値を取得、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールが Web ページ上で変更します。</summary>
        <value>パーソナル化の状態データが変更されたかどうかを示すブール値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティ呼び出し元を決定するための手段を提供するパーソナル化状態で管理されているデータであるかどうか、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールが変更されます。 ユーザーがパーソナル化ページ レベルの詳細については、たとえばページ レイアウトを変更する、作成するか、接続を削除して、個人用設定データは管理、追加やコントロールを削除したり、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> の変更を制御します。 これは、パススルー メソッドを呼び出し元に、保護対象の値を返す <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> プロパティで、呼び出し元が直接アクセスできることはできません。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> があるかどうかパーソナル化できるプロパティの値、または個々 の外観に影響するプロパティを個別 <xref:System.Web.UI.WebControls.WebParts.WebPart> 、コントロールが変更されています。 コントロール レベルのパーソナル化は、コントロールごとに個別に追跡されます。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティを示しますのみかどうかのパーソナル化データをページ レベルで管理される、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールが変更されます。  
  
 次に示しますされる原因となるパーソナル化の一般的な複数のインスタンス、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティの値を返す `true`, を示すを <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールが変更された個人用設定データの一部。  
  
-   静的なを閉じる <xref:System.Web.UI.WebControls.WebParts.WebPart> ページのコントロール \(またはサーバーまたはユーザー コントロール\)。  
  
-   閉じた静的を復元する <xref:System.Web.UI.WebControls.WebParts.WebPart> ページ カタログからのコントロールをページに戻します。  
  
-   そのゾーン内または別のゾーンには、任意のコントロールを移動します。  
  
-   カタログからコントロールを追加する <xref:System.Web.UI.WebControls.WebParts.WebPart> サーバー コントロール、またはプログラムを使用してコントロールを追加します。  
  
-   2 つの接続を作成する <xref:System.Web.UI.WebControls.WebParts.WebPart> プログラムを使用してまたは接続のユーザー インターフェイス \(UI\) を使用して、いずれかを制御します。  
  
-   2 つの接続を削除する <xref:System.Web.UI.WebControls.WebParts.WebPart> プログラム、または接続の UI を使用して、制御します。  
  
 このプロパティの値にアクセスするにキャストする必要があります、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールのインスタンスを <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> インターフェイス; 読んで場合があります、 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> プロパティの値。  
  
   
  
## 例  
 次のコード例の簡単な使用法を示します、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> を示すいくつかの一般的なページの個人用設定のプロパティをインスタンス化の原因、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの個人用設定データを変更します。  
  
 このコード例には、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ コントロールを含むページに表示モードを変更することができます。  
  
-   2 つのカスタムのコードを含むソース ファイル <xref:System.Web.UI.WebControls.WebParts.WebPart> 接続可能なコントロールとインターフェイスします。  
  
-   すべてのコントロールをホストする Web ページ。  
  
-   コード例の動作についての説明です。  
  
 このコード例の最初の部分は、表示モードを変更するユーザー コントロールです。 使用例」セクションからユーザー コントロールのソース コードを取得できます、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要です。 表示モードとユーザー コントロールの動作方法については、次を参照してください。 [Walkthrough: Changing Display Modes on a Web Parts Page](http://msdn.microsoft.com/ja-jp/24e42f74-82dc-4c13-8574-130398985fc0)します。  
  
 この例の 2 番目の部分は、カスタム コントロールとインターフェイスによるソース ファイルです。 注意して、 `IZipCode` インターフェイスは 1 つのメソッドを公開およびとしてには、このメソッドは、カスタム実装 `ZipCodeWebPart` コントロールが有効にするコールバック メソッドとして機能 `ZipCodeWebPart` 接続シナリオでのプロバイダーとして機能します。 その他のコントロール `WeatherWebPart`, 、接続では、コンシューマーとして機能を制御; によって提供される特定のインターフェイスを利用できる `ZipCodeWebPart`です。 実際のアプリケーションで `WeatherWebPart` でした、プロバイダーから個人用に設定された ZIP コードの値を使用して、ユーザーにグラフィカル気象情報を提供します。  
  
 このコード例を実行するには、このソース コードをコンパイルする必要があります。 明示的にコンパイルし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに、生成されたアセンブリを配置できます。 また、ここで、動的にコンパイル実行時に、サイトの App\_Code フォルダーにソース コードを配置することができます。 このコード例は、動的なコンパイルを使用します。そのため、ことに注意して、 `Register` のみ、Web ページの上部にあるこのコンポーネントのディレクティブを含む `TagPrefix` と `Namespace` 属性せず、 `Assembly` 属性です。 コンパイルする方法について説明するチュートリアルは、次を参照してください。 [Walkthrough: Developing and Using a Custom Server Control](http://msdn.microsoft.com/ja-jp/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)します。  
  
 [!code-csharp[WebParts\_WebPartManager\_IsDirty\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts\_WebPartManager\_IsDirty\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 コード例の 3 番目の部分は、Web ページです。 2 つが含まれている通知 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> が最初の 2 つのユーザー設定を格納しているもののゾーン <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。<xref:System.Web.UI.WebControls.WebParts.CatalogZone> 標準を含まれているゾーン <xref:System.Web.UI.WebControls.Calendar> コントロールをページにユーザーを追加できます。`<asp:connectionszone>` 要素は、接続のコントロール間の接続を作成するユーザー用に UI を提供します。`Page_PreRender` メソッドがあれば、および個人用設定データが変更されたかどうかを確認することを確認する通知のテキストを更新する `Label1`です。  
  
 [!code-csharp[WebParts\_WebPartManager\_IsDirty\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_IsDirty\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、いくつかの個人用設定データを変更すること、このトピックの「解説」セクションで説明したシナリオを作成してみます。 によって追跡パーソナル化シナリオの 1 つの変更が含まれている場合は、さまざまな変更を行うと、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> のテキストを制御する、 `Label1` 個人用設定データが変更されたことを示すためにコントロールが表示されます。 たとえば、次のように操作できます。  
  
-   クリックしてコントロール間の接続を作成、 **web パーツ コントロールの接続** \] ボタンをクリックします。  
  
-   使用して、 **表示モード** にページをカタログ モードに切り替えて、追加のドロップダウン リスト コントロール、 **個人用の予定表** 2 番目の制御 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーンです。  
  
-   ページに戻るをブラウズ モードでは、メニューの \[動詞 \(タイトル バーの矢印で表示\) の変更、 **個人用の予定表** 、コントロールを選択 **閉じる** を閉じたり、ページのカタログに追加します。  
  
-   カタログ モード、ページを返すし、追加、 **個人用の予定表** コントロール、ページに戻します。  
  
-   使用して、 **表示モード** コントロールをデザイン モードに切り替えるし、または同じゾーン内の別の位置に別のゾーンには、これらの環境変数をドラッグして、コントロールのレイアウトを再配置します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに読み込む必要がある、以前に保存したカスタムのパーソナル化状態データを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is an implementation of the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=fullName> method, which provides a way for the Web Parts control set to directly access the protected <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=fullName> method. When this method is called, it stores the custom personalized data that is managed by the <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control, and that was previously saved in the permanent data store for use later in the initialization process.  
  
> [!NOTE]
>  In most cases, page and control developer code does not need to call this method, because it is primarily used by the Web Parts control set as its mechanism for retrieving personalization data.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>One scenario in which developers would use this method is if they are developing a custom personalization framework to use in place of the one provided by the Web Parts control set. In such cases, developers could inherit from the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class and override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> method to return a custom implementation of a <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> object. The custom <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> object would call the implementation of the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> method at the proper time to load custom personalization data.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> 状態データ保存するにはことが含まれています。</param>
        <summary>管理されているカスタムのパーソナル化の状態データを保存、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> メソッドの実装は、 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=fullName> 、Web パーツ コントロール セットは直接アクセスするため、保護されているためにの手段を提供するメソッド <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=fullName> メソッドです。 このメソッドが呼び出されるで管理されているすべての個人用設定のデータを保存、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Web パーツ アプリケーション用に構成された永続的なデータ ストアを制御します。  
  
> [!NOTE]
>  ほとんどの場合、ページとコントロール開発者コード必要はありません、このメソッドを呼び出すが、Web パーツ コントロール セットにより個人用設定データを保存するためのメカニズムとして、主に使用されるためです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>One scenario in which developers would work with this method is if they are developing a custom personalization framework to use in place of the one provided by the Web Parts control set. In such cases, developers could inherit from the <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> class and override the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> method to return a custom implementation of a <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> object. The custom <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> object would call the implementation of the <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> method at the proper time to save the custom personalization data.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>パーソナル化の状態データの適用、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロール、およびコントロールのビュー ステート データの変更を追跡できるように、基本メソッドの呼び出しです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ビュー ステートのデータに対する変更が保存されている、 <xref:System.Web.UI.StateBag> オブジェクト、およびコントロールの経由でアクセスできる <xref:System.Web.UI.Control.ViewState%2A> プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示されるように子コントロールを有効にする値を取得します。</summary>
        <value>示すブール値かどうか、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールとその子コントロールが表示されます。 常に <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロール基数がオーバーライド <xref:System.Web.UI.Control.Visible%2A?displayProperty=fullName> プロパティの値を常に返す `true` の <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> プロパティです。 にもかかわらず、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロール自体が表示されない、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> プロパティに設定する必要があります `true` すべての子コントロールが既定で表示されるようにします。  
  
 値を設定しようとすると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> プロパティには、あるために、常にエラーが発生して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、基本のプロパティの動作をオーバーライドし、プロパティに任意の値を割り当てることを防止します。  
  
 このプロパティは、ビジュアル デザイナーでバインドできるではありませんが、実行時にバインドされます。 詳細については、「<xref:System.ComponentModel.BindableAttribute>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">プロパティに値を代入しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的な後に発生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはその他のサーバー コントロールに追加されて、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールが正常に追加されたことを示すために、ゾーンです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> イベントは、ゾーンに動的コントロール \(ページのマークアップで宣言するのではなく、プログラムで追加されたコントロール\) が正しく追加されたことを示すのに役立ちます。 組み合わせて、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> メソッド、イベントは、ユーザー インターフェイス \(UI\) を更新またはコントロールが正しく追加されたユーザーをそれ以外の場合に通知すると、開発者を提供します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的に追加するプロセス中に発生した <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> やその他のサーバー コントロールに、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> によってイベントが発生した、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> コントロールをゾーンに追加するプロセスが開始された後にします。 このイベントは、処理が完了する前にキャンセルする機会を提供します。 このイベントは、後に追加の処理が成功した場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> イベントです。  
  
 ページの開発者は、イベントのカスタム ハンドラーを追加することで提供できます、 `OnWebPartAdding` 属性を `<asp:webpartmanager>` 内の要素\] ページでは、および属性にカスタム メソッドの名前が割り当てられています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときに、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール \(またはサーバーまたはユーザー コントロール\) がページから削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> イベントは、コントロールが閉じられている正常に、ユーザー、またはプログラムを示します。 閉じるには、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールではレンダリングされませんしも特別なに配置するオブジェクトを保持するいると呼ばれるページ カタログようにページから削除することを意味します。 対応するページ カタログ、 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 終了への参照の管理、制御 <xref:System.Web.UI.WebControls.WebParts.WebPart> 各ページのコントロールです。 場合、 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 内のページにコントロールが宣言されている、 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> ゾーン、ユーザーが、カタログの表示モードに切り替えるし、ページに返す閉じられていたすべてのコントロールを追加します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> にイベントが関連付けられている、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> イベントを発生させるし、ハンドラーは、その両方を行うメソッドです。  
  
 ページの開発者は、追加することで、イベントのカスタム ハンドラーを追加できます、 `OnWebPartClosed` 属性を `<asp:webpartmanager>` 属性にカスタム メソッドの名前を割り当てる、ページにある要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>削除した場合の処理中に発生する、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール \(またはサーバーまたはユーザー コントロール\) のページからです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> によってイベントが発生した、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> メソッドと、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールがコントロールの終了処理を行っています。 コントロールの削除が成功した場合は、このイベントが続く、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> イベントです。  
  
 ページの開発者は追加することで、イベントのカスタム ハンドラーを提供することができます、 `OnWebPartClosed` 属性を \<`asp:webpartmanager>` 内の要素\] ページでは、および属性にカスタム メソッドの名前が割り当てられています。  
  
 通常、ときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> ユーザー決算の直接の結果としてイベントが発生した、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、イベントを取り消すことができます。 ただし、これにはイベントをキャンセルできないシナリオがあります。 場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> コントロールが削除されると、 <xref:System.Web.UI.WebControls.WebParts.WebPart> が含まれているコントロールをすべて閉じる、それ以外の場合、孤立とします。 ここでは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 終了の制御、 <xref:System.Web.UI.WebControls.WebParts.WebPart> ユーザーではなくを制御します。 いつ、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの呼び出し中に、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 各コントロールを終了するメソッドと <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> イベントは、デザインで、イベントをキャンセルできません、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> ゾーンのすべてのコントロールのクリーンアップのタスクを完了する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>後に発生、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> から他のサーバー コントロールが削除されたか、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> イベントは、ダイナミック コントロール \(ページのマークアップで宣言するのではなく、プログラムで追加されたコントロール\) が、ゾーンから正常に削除されたことを示すに便利です。 組み合わせて、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> メソッド、イベントは、ユーザー インターフェイス \(UI\) を更新またはコントロールが正常に削除するユーザーをそれ以外の場合に通知すると、開発者を提供します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的なインスタンスを完全に削除の処理中に発生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはその他のサーバー コントロールから、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> によってイベントが発生した、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> 動的コントロール \(プログラムまたは Web パーツのユーザー インターフェイスを使用してユーザーによって追加されたもの\) の削除のプロセス中のメソッドです。 イベントが終わる前に、プロセスをキャンセルする機会を提供します。 このイベントが続く場合は、削除プロセスが正常に完了すると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> イベントです。  
  
 ページの開発者は、イベントのカスタム ハンドラーを追加することで提供できます、 `OnWebPartDeleting` 属性を `<asp:webpartmanager>` 内の要素\] ページでは、および属性にカスタム メソッドの名前が割り当てられています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>後に発生する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> かサーバー コントロールを Web ページ上の別の場所に移動されています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、\(Web ページのマークアップで宣言\) 静的および動的コントロールの両方に適用されます。 関連付けられた、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> メソッドです。 イベントが発生したは、移動が完了した後、ために、開発者は、ユーザー、いくつかの検証またはその他のいくつかの操作に何らかの通知を提供するイベント ハンドラーを含めることができます。 イベント ハンドラーを追加するには、追加することができます、 `OnWebPartMoved` 属性を `<asp:webpartmanager>` 内の要素\] ページで、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>移動するプロセス中に発生した、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはその他のサーバー コントロールに含まれている、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> イベントが発生したときに、 <xref:System.Web.UI.WebControls.WebParts.WebPart> か、または別のゾーンに、独自のゾーン内でその他のサーバー コントロールを移動します。 これは、プログラムによる移動がある場合にも、コントロールをドラッグすると発生します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> によってイベントが発生した、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> メソッド、およびそれが完了する前に、移動プロセスをキャンセルする機会を提供します。 移動が完了し、コントロールでは、新しい位置に配置される、このイベントが続く場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントです。  
  
 ページの開発者は、追加することで、イベントのカスタム ハンドラーを作成できます、 `OnWebPartMoving` 属性を `<asp:webpartmanager>` 要素、および属性にカスタム メソッドの名前が割り当てられています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべての参照を取得 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> によってコントロールが追跡される、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Web ページ上のコントロールです。</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" /> のセットへの参照を格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティを使用、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールすべてを追跡する <xref:System.Web.UI.WebControls.WebParts.WebPart> 内に含まれるコントロール <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 、ページの領域です。 個別にアクセスすることができます、コレクションは読み取り専用では、 <xref:System.Web.UI.WebControls.WebParts.WebPart> プログラムを使用して、コレクションに変更を加えることを制御します。  
  
> [!NOTE]
>  持つことが、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、ページの外部に配置されます、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> によって追跡されていないコントロールにつながるゾーン、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 制御またはで参照されているその <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> コレクションです。 ただし、使用する理由はほとんどがある、 <xref:System.Web.UI.WebControls.WebParts.WebPart> しその Web パーツ機能が動作しなく、通常のサーバー コントロールとして機能するために、ゾーンの外部で制御します。  
  
 任意の種類を格納するゾーン内かどうか、カスタム コントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、標準の ASP.NET コントロール、ユーザー コントロールまたはカスタム サーバー コントロールは、として扱うことが、 <xref:System.Web.UI.WebControls.WebParts.WebPart> 実行時にコントロールできます。 コントロールがない場合にある場合、 <xref:System.Web.UI.WebControls.WebParts.WebPart> でコントロールが配置されます、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ASP.NET コントロールをラップする実行時に、ゾーン、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトをコントロールとして動作できるように <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 使用して、そのため、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティには、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールから派生しているかどうかに関係なく、サーバー コントロールの任意の型を追跡できる、 <xref:System.Web.UI.WebControls.WebParts.WebPart> クラスです。  
  
   
  
## 例  
 次のコード例では、使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> アクセス ユーザーにプログラムを使用してプロパティ <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 Web ページの宣言型マークアップに内に、 `<asp:webpartzone>` 要素が 2 つの標準的な ASP.NET サーバー コントロール。 これらを継承しませんが、 <xref:System.Web.UI.WebControls.WebParts.WebPart> クラスでラップするは、ゾーン内にあるため、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトの実行時にされ、したがってによって参照されるコレクションに含まれないが、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティです。 ユーザー設定を追加することも <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、ユーザー コントロール、またはカスタム サーバーをこのゾーンで制御し、同じ方法を処理するとします。  
  
 [!code-csharp[WebParts\_WebPartManager\_WebParts\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_WebParts\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 あるコード例を実行するには、必要があります設定を追加する Web パーツの記述ファイルをエクスポートできるようにするために Web.config ファイルに注意してください。 このコード例については、Web ページと同じディレクトリに Web.config ファイルがあることを確認します。 内で、 `<system.web>` セクションであることを確認、 `<webParts>` を持つ要素、 `enableExport` 属性に設定 `true`, マークアップを次のようにします。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 クリックすると、ブラウザーにページを読み込んだ後、 **web パーツ数** ボタン コードを使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> コレクション内のコントロールの数を返すプロパティ。 クリックすると、 **予定表のタイトルを非表示に** のみ枠線とタイトルではなくにレンダリングするようカレンダーをボタンのコードに変更します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>間で特定の接続が確立された後に発生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール \(またはサーバーまたはユーザー コントロール\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> にイベントが関連付けられている、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> メソッドです。 イベントは、接続が完了したことがわかって後は、ページのユーザー インターフェイス \(UI\) を変更したり、ファクトをユーザーに通知することができますので便利です。 たとえば、2 つのコントロール間の接続に成功を示すグラフィック イメージを表示するまたはブラウズ モードに戻して、簡単なメッセージを表示するページの表示モードを変更します。  
  
 ページの開発者は、このイベントでカスタム イベント ハンドラーを追加することで関連付けることができます、 `OnWebPartsConnected` 属性を `<asp:webpartmanager>` 内の要素\] ページで、および属性にカスタム メソッドの名前が割り当てられています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続の作成プロセス中に発生した <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール \(に配置されたサーバーまたはユーザー コントロール、または、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーン\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> によってイベントが発生した、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> メソッドでは、接続プロセスが開始したことを通知し、\(たとえば、ユーザーがコントロールを選択 connect 動詞がクリックされた\) がまだ完了していません。 イベントは、完了する前に、接続をキャンセルする機会を提供します。 このイベントが続く場合は、接続が正常に完了すると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> イベントです。  
  
 ページの開発者は、追加することで、イベントのカスタム ハンドラーを追加できます、 `OnWebPartsConnecting` 属性を `<asp:webpartmanager>` 要素、および属性にカスタム メソッドの名前が割り当てられています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの接続後に発生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> か、サーバー コントロールを終了しました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> にイベントが関連付けられている、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> メソッドです。 イベントは、接続が終了されることがわかっている後は、ユーザーに知らせる、コードでは、一部のクリーンアップ操作を実行またはユーザー インターフェイス \(UI\) での変更を行うことができますので便利です。  
  
 ページの開発者は、このイベントでカスタム イベント ハンドラーを追加することで関連付けることができます、 `OnWebPartsDisConnected` 属性を `<asp:webpartmanager>` 内の要素\] ページで、および属性にカスタム メソッドの名前が割り当てられています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続を終了するプロセス中に発生した間で接続されていた <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはサーバー コントロール。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> によってイベントが発生した、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> メソッド、およびその事実を通知、ユーザーが切断動詞をクリックしたこと、または <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドが呼び出されてそれ以外の場合。 イベントは、完了する前に、接続を終了するプロセスをキャンセルする機会を提供します。 このイベントは、後に、接続が正常に終了した場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> イベントです。  
  
 ページの開発者は、追加することで、イベントのカスタム ハンドラーを追加できます、 `OnWebPartsDisconnecting` 属性を `<asp:webpartmanager>` 要素、および属性にカスタム メソッドの名前が割り当てられています。  
  
 通常、ときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 接続を終了したユーザーの動作の直接の結果としてイベントが発生した、イベントを取り消すことができます。 ただし、ような場合は、イベントをキャンセルできません。 最初のシナリオは場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> コントロールが削除されると、 <xref:System.Web.UI.WebControls.WebParts.WebPart> が含まれているコントロールをすべて閉じる、それ以外の場合、孤立とします。 この場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 終了の制御、 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、いない、ユーザー、およびそのできる必要がありますも、中断することがなく接続されているコントロールの接続を終了するクリーンアップして、すべてのコントロールを終了するプロセスを完了できるようにします。 そのため、仕様により、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> メソッドは、このシナリオではキャンセルできません。 キャンセルできる関連イベントの表示、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> イベントです。  
  
 2 番目のシナリオ、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントをキャンセルできない場合は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> メソッドを呼び出して \(この例のページへの各要求中に呼び出されます\)、およびいくつかの種類のページ上の既存の接続での競合があります。 たとえば、おそらくコントロール x をコントロール y に接続するが、共有のユーザーがコントロール x、z の制御を接続し、まだコントロール x は許可されていない複数の接続を形成するします。 この場合、接続の個々 のユーザーの設定の優先順位、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールを呼び出して、競合を解決する、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドとの間の接続を終了 x、z の特定のユーザーです。 この切断が設計によって、競合を解決するために不可欠であるため、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントは、このシナリオで取り消すことはできません。  
  
 3 番目のシナリオを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> メソッドはキャンセルできませんの場合は、 <xref:System.Web.UI.WebControls.WebParts.WebPart> または現在接続されているサーバー コントロールが削除済みまたは終了します。 コントロールがページから削除すると確実であるためには、必然的にその接続を削除します。 したがって、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールを呼び出す、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドを生成します、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> デザインがありますが、イベントのイベントをキャンセルする可能性がします。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのコレクションへの参照を取得、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> Web ページの領域。</summary>
        <value>A<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" />のセットを参照する<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />ゾーンです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>プロパティを使用、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールを追跡する、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Web ページの領域。 プロパティが、すべての種類のゾーンを参照しないことに注意してください。派生するゾーンのみを参照して、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>クラスを含む<xref:System.Web.UI.WebControls.WebParts.WebPartZone>ゾーンです。  
  
 プロパティによって参照されるコレクションは読み取り専用では、コレクション内の個々 のオブジェクトにアクセスし、プログラムで操作を使用します。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>プロパティ個々 のアクセスをプログラムで<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン コントロール。 Web ページの宣言型のマークアップが含まれている 2 つ`<asp:webpartzone>`サーバー コントロールを含む要素です。`<script>`コードは、ページのセクションで、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>すべてのゾーンの Id を一覧表示して、2 番目のゾーンの背景色を変更する個別のゾーンにアクセスするプロパティです。  
  
 [!code-csharp[WebParts\_WebPartManager\_Zones\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-vb[WebParts\_WebPartManager\_Zones\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 コード例を実行する必要があります設定を追加する Web パーツの記述ファイルをエクスポートできるようにするために Web.config ファイルに注意してください。 このコード例の Web ページと同じディレクトリ内の Web.config ファイルがあることを確認します。 内で、`<system.web>`セクションであることを確認、`<webParts>`要素を`enableExport`属性に設定`true`マークアップを次のように、します。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 をクリックすると、ブラウザーにページを読み込んだ後、**一覧ゾーン Id**ボタン コードを使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>コレクション内のすべてのゾーンの Id を一覧表示するプロパティです。 クリックした場合、**変更ゾーン BackColor**ボタン、コードは、2 番目のゾーンの背景色を変更します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>