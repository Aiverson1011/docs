<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>アダプターをアタッチする、既定のマークアップまたは特定のブラウザーの動作を変更する派生したコントロールの表示をカスタマイズ、アダプターが継承するすべてのコントロールから、基本クラスです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロール アダプターは、特定のオーバーライド コンポーネント <xref:System.Web.UI.Control> クラスのメソッドおよびブラウザーまたはマークアップ固有の処理を許可するように、実行のライフ サイクルのイベントです。 .NET Framework がマップに 1 つの派生コントロール アダプター、 <xref:System.Web.UI.Control> クライアント要求ごとのオブジェクト。  
  
 アダプターでは、特定のブラウザーまたはブラウザーのクラスの対応するコントロールを変更するか、一部の機能に対しては任意のフィルターとして機能します。 通常、アダプターは、\(たとえば、XHTML や HTML 3.2\)、ブラウザーを使用するマークアップ言語によって定義されます。 表示動作の適応性の多くから派生する特殊なクラスにカプセル化できます、 <xref:System.Web.UI.HtmlTextWriter> クラスです。 したがって、さまざまなブラウザー クラスの動作、またはその適応性を含めることの 1 つのアダプターを使用できることがあるは、 <xref:System.Web.UI.HtmlTextWriter> クラスを不要なコントロール アダプターを使用する使用する可能性があります。  
  
 コントロール クラスのアダプターは、専用のアダプターが存在しない限り、そのクラスから継承するすべてのコントロールに適用されます。 たとえば、アダプターの <xref:System.Web.UI.WebControls.BaseValidator> すべてのクラスを使用することができます `Validator` オブジェクトです。  
  
 アダプター通常を継承しませんから直接、 <xref:System.Web.UI.Adapters.ControlAdapter> コントロールの種類とターゲットがブラウザーに固有の追加機能を提供するクラスを基本がターゲット固有のアダプターのいずれかのクラス、または特定の表示が必要です。  
  
 コントロール自体では、アダプターは必ずしも必要はありません。 コントロールは、構成で拡張されている場合、通常、子コントロールのアダプターで十分です。  
  
 各コントロールでは、.browser 定義ファイルからアダプターへの明示的なマッピングがあります。 そのため、いずれかのアクセス、 <xref:System.Web.UI.Control.Adapter%2A?displayProperty=fullName> プロパティで使用、 <xref:System.Web.HttpBrowserCapabilities> コントロールにアダプターのマッピングの参照を実行するブラウザー定義ファイルから抽出されるオブジェクト。  
  
 処理中に、.NET Framework はターゲット固有の可能性があるコントロールのオーバーライド可能なメソッドの呼び出しをインターセプトします。 コントロール アダプターが接続されている場合、.NET Framework は、関連付けられているアダプターのメソッドを呼び出します。  
  
 アダプターが使用してコントロールのレンダリングを実行、 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> メソッドです。 オーバーライドされると場合、 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 可能性のある呼び出さないでください。 基本クラスの実装に呼び出しを実行するため、 <xref:System.Web.UI.Control.Render%2A?displayProperty=fullName> メソッドです。 アダプターが 1 回、1 回はコントロールによって、2 回発生するレンダリングする可能性があります。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> メソッドの呼び出しを基、 <xref:System.Web.UI.Control.Render%2A?displayProperty=fullName> コントロールのメソッドです。 したがって、オーバーライドする場合は <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, を実装するレンダリングがそれだけでによって提供される場合を除きは、基本クラスの実装を呼び出さないで <xref:System.Web.UI.Control.Render%2A?displayProperty=fullName> コントロールのです。  
  
 .NET Framework が子コントロールのアダプターのインターセプトを実行することを確認する必要があります。 呼び出すことによってこれを行う、 <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> 基本メソッドを呼び出す、 <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=fullName> 、コントロールのメソッドから、 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> をオーバーライドします。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> と <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> コントロールの呼び出しをそれぞれの前後にすぐに、メソッドは、コントロールにより呼び出されます、 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> メソッドです。 前と後のレンダリングの場合は唯一のブラウザー専用処理タスクを使用して、必要な <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> と <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> をオーバーライドする必要がない可能性がありますように <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>します。 既定の動作、 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> と <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> メソッドは、の対応するメソッドを呼び出すこと、 <xref:System.Web.UI.HtmlTextWriter>です。  
  
 コントロール アダプターには、独自の状態情報を保持するには、オーバーライド、 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, 、<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, 、<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, 、および <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> メソッドです。<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, 、<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, 、<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, 、および <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> プライベート コントロールとビューの状態が保存され、読み込まれると、それぞれ時に呼び出されます。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, 、<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, 、<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, 、および <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> に対応するメソッドの呼び出しを基本 <xref:System.Web.UI.Control> クラスのメソッドです。 したがって、次のいずれか <xref:System.Web.UI.Adapters.ControlAdapter> のオーバーライド メソッドは、基本メソッドを呼び出す必要があります。 イベントに関連付けられているそれ以外の場合、 <xref:System.Web.UI.Control> クラスのメソッドは発生しません。  
  
 コントロールとアダプターが必要に応じて実装、 <xref:System.Web.UI.IPostBackDataHandler> と <xref:System.Web.UI.IPostBackEventHandler> インターフェイスです。 .NET Framework では、アダプターが存在するかどうかと、アダプターがこれらのインターフェイスを実装するかどうかを決定します。 アダプターをオーバーライドする場合は、 <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, 、<xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, 、および <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> メソッドは、必要に応じて。 ポストバックのデータが、アダプターで認識されない場合は、それを処理するコントロールにコールバックする必要があります。 後続のイベント ハンドラーは、コントロールに戻る呼び出す必要があります。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, a control that requires general adapter functionality should have a corresponding adapter base class, named in the pattern <paramref name="ControlType" /><see langword="Adapter" /> (for example, <see langword="TextBoxAdapter" />). The adapter should at a minimum return a strongly-typed instance of the control through its <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> property.  
  
1.  Control adapters for a given control type and markup language should be named in the pattern <paramref name="MarkupControlType" /><see langword="Adapter" /> (for example, <see langword="XhtmlTextBoxAdapter" />). Adapters for a control should be implemented in an <see langword="Adapters" /> subnamespace.  
  
 Control adapters should inherit from the appropriate base class and follow the same inheritance model as the control. For example, an adapter for a control inheriting from the <see cref="T:System.Web.UI.Control" /> base class should inherit from either the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class or the relevant <paramref name="ControlType" /><see langword="Adapter" /> class.  
  
 Any specialized adapters should be defined for the specialized control under all of the device nodes in configuration .browser files.  
  
 A properly implemented control should not assume that an adapter is attached, or that the attached adapter implements a specific interface. Instead, it should check for these before calling.  
  
 It is possible to simulate overriding protected event methods in the control, such as the <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method of the <see cref="T:System.Web.UI.WebControls.LinkButton" />. First, create an adapter class with an <c>OnClick</c> method. Then create a new control derived from <see cref="T:System.Web.UI.WebControls.LinkButton" /> and override the <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method. The overriden <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method calls the <c>OnClick</c> method of the adapter. The adapter object is available through the protected <see cref="P:System.Web.UI.Control.Adapter" /> property of the <see cref="T:System.Web.UI.Control" /> class. The <see cref="P:System.Web.UI.Control.Adapter" /> property of the control is <see langword="null" /> when there is no associated adapter, so any code should check for that condition before calling methods of the adapter.</para>
    </block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework は、対応するを作成するときに、内部的にこのアダプターを構築 <xref:System.Web.UI.Control> オブジェクトです。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> ターゲット固有の出力を表示するメソッドを含みます。</param>
        <summary>コントロールの表示する前に呼び出されます。 アダプターの派生クラスでは、特定のターゲットで必要な HTML ブラウザーを必要としませんが、開始タグを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> メソッドは直前に、 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> メソッド、コントロールのレンダリングの前にターゲットに固有の処理を実行するために使用します。  
  
 使用して、 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> メソッドと組み合わせて、 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> タグの整合性を開いたり、閉じたりすることを確認します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> method. Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> method.</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求を行っているクライアントのブラウザーの機能への参照を取得します。</summary>
        <value>
          <see cref="T:System.Web.HttpBrowserCapabilities" /> クライアント ブラウザーとマークアップの機能を指定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Web.UI.Adapters.ControlAdapter> オブジェクトからクライアント ブラウザーの性能を決定する、 <xref:System.Web.HttpBrowserCapabilities> によって返されるオブジェクト、 <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> プロパティです。 これにより、 <xref:System.Web.UI.Adapters.ControlAdapter> ブラウザー固有のマークアップをレンダリングまたはそれ以外の場合の動作を変更するオブジェクト、 <xref:System.Web.UI.Control>です。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> プロパティを要求しているブラウザーの詳細情報にアクセスします。 この例では、ブラウザーが、JavaScript と互換性のあるし、により、開発者は、その場合にカスタマイズされた出力を表示するかどうかを確認するコードをチェックします。  
  
 [!code-cpp[ControlAdapter\_Browser\#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter\_Browser\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter\_Browser\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールのアダプターが接続されているコントロールへの参照を取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.Control" /> の割り当て先である <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生コントロールがコントロールに関連付けられている場合、.NET Framework は、コントロールのメンバーではなく特定のアダプター メンバーを呼び出します。  
  
   
  
## 例  
 次のコード例からのカスタム コントロールを派生させる方法を示しています、 <xref:System.Web.UI.Control> クラス、および継承された対応するアダプターを作成、 <xref:System.Web.UI.Adapters.ControlAdapter> クラスです。 アダプターのオーバーライド、 <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> プロパティをコントロールに厳密に型指定された参照を返します。  
  
 [!code-cpp[ControlAdapter.Control\#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, at a minimum, you should implement a <see langword="Control" /> property to return a strongly-typed instance of the control, as shown in the Example section.</para>
        </block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>複合コントロールのコントロールをターゲットに固有の子に作成されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生コントロール アダプターに接続されているがある場合、 <xref:System.Web.UI.Control> オブジェクトおよび <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> メソッドはオーバーライドが呼び出されての代わりに、 <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=fullName> メソッドです。 したがって、 <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> ターゲット固有の子コントロールのセットを作成するために使用できます。  
  
 詳細については、新しいコントロールを作成するコントロールを組み合わせて、次を参照してください。 [Composite Controls](http://msdn.microsoft.com/ja-jp/fb174677-d845-467c-8bf3-cc096b2490b0)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If you create an inheriting class and override the <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> method, do not call the base method unless you want to add controls to those created by the base method. Otherwise you could create two sets of child controls.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> ターゲット固有の出力を表示するメソッドを含みます。</param>
        <summary>コントロールのレンダリング後に呼び出されます。 アダプターの派生クラスで特定のターゲットで必要な HTML ブラウザーを必要としませんが、終了タグを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> の直後にメソッドが呼び出された、 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> メソッド、コントロールのレンダリング後にターゲットに固有の後処理を実行するために使用します。  
  
 使用して、 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> メソッドと組み合わせて、 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> タグの整合性を開いたり、閉じたりすることを確認します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> method. Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> method.</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> とアダプターのコントロールの状態情報を格納している、 <see cref="T:System.Web.UI.StateBag" />です。</param>
        <summary>によって保存されたアダプター コントロールの状態情報を読み込みます <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> このコントロールのアダプターに関連付けられているコントロールが存在するページへの以前の要求時にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロールの状態は、ビュー ステートが無効になっている場合でも必要な重要な状態情報です。 アダプターは、独自のコントロールの状態情報を維持する必要があるときは、オーバーライドして、 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> と <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> メソッドです。  
  
 アダプターは、状態を要求、関連付けられたコントロールの状態から独立して間で維持する必要がある機能がある場合は、コントロールの状態情報を維持する必要があります。 大規模なテキスト形式で表示およびのグループから成る複合コントロールなどの <xref:System.Web.UI.WebControls.RadioButton> コントロールはデスクトップ コンピューターのブラウザーの 1 つのビューとしてレンダリング可能性があります。 他のブラウザーで、分割表示: テキストの表示と他のオプション ボタン グループの 1 つのビューです。 アダプターは、現在アクティブなビューに関する独自のターゲット固有情報を保持する必要があります。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> 直後後にメソッドが呼び出される、 <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=fullName> メソッドで、 `LoadState` ライフ サイクルの段階です。 アダプターのコントロールの状態は、独立したコントロールのコントロールの状態だけでなくです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> とアダプターのビュー状態情報を格納している、 <see cref="T:System.Web.UI.StateBag" />です。</param>
        <summary>によって保存されたアダプターのビュー状態情報を読み込みます <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> このコントロールのアダプターに関連付けられているコントロールが存在するページへの以前の要求時にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アダプターは、独自のビュー状態情報を保持する必要があるときは、オーバーライドして、 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> と <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> メソッドです。  
  
 アダプターは、データが関連付けられたコントロールのビュー ステートから独立して要求間で保持する必要があるときに、状態情報の表示を維持する必要があります。 たとえば、デスクトップ コンピューターのブラウザー上のグリッド コントロールは、行の 1 つのビューとの値の列として表示可能性があります。 他のブラウザーで、分割行と 1 つの行の詳細の一覧などの複数のビューに表示します。 アダプターは、現在アクティブなビュー状態にないビューのデータを保持する必要があります。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> の直前に呼び出されます、 <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=fullName> メソッドで、 `LoadState` ライフ サイクルの段階です。 アダプターのビュー状態は、独立しただけでなく、コントロールのビュー ステートです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>上書き、 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 関連付けられたコントロールのメソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アダプターが接続がある場合、 <xref:System.Web.UI.Control> オブジェクトおよび <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> メソッドはオーバーライド メソッドが呼び出されての代わりに、 <xref:System.Web.UI.Control.OnInit%2A?displayProperty=fullName> メソッドです。  
  
 オーバーライド <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> でターゲットに固有の処理を実行する、 `Initialize` コントロールのライフ サイクルの段階です。 通常、これらは、コントロールの作成時に実行される関数です。  
  
   
  
## 例  
 次のコード サンプルから、カスタム コントロール アダプタの派生、 <xref:System.Web.UI.Adapters.ControlAdapter> クラスです。 \[よりも優先、 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> メソッドに関連付けられたコントロールのプロパティを設定し、コントロールの初期化を完了する基本メソッドを呼び出します。  
  
 [!code-cpp[ControlAdapter\_OnInit\#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter\_OnInit\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter\_OnInit\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method. If the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method is not called, the <see cref="E:System.Web.UI.Control.Init" /> event will not be raised.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>上書き、 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 関連付けられたコントロールのメソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アダプターが接続がある場合、 <xref:System.Web.UI.Control> オブジェクトおよび <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> メソッドはオーバーライド メソッドが呼び出されての代わりに、 <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=fullName> メソッドです。  
  
 オーバーライド、 <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> でターゲットに固有の処理を実行するメソッド、 `Load` コントロールのライフ サイクルの段階です。 通常、これらはクライアント要求ごとに実行される関数です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> method. If <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> is not called, the <see cref="E:System.Web.UI.Control.Load" /> event will not be raised.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>上書き、 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 関連付けられたコントロールのメソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アダプターが接続がある場合、 <xref:System.Web.UI.Control> オブジェクトおよび <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> メソッドはオーバーライド メソッドが呼び出されての代わりに、 <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=fullName> メソッドです。  
  
 オーバーライド、 <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> でターゲットに固有の処理を実行するメソッド、 `PreRender` コントロールのライフ サイクルの段階です。 通常、これらは、コントロールの出力のレンダリングの直前にある機能です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method. If the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method is not called, the <see cref="E:System.Web.UI.Control.PreRender" /> event will not be raised.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>上書き、 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 関連付けられたコントロールのメソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アダプターが接続がある場合、 <xref:System.Web.UI.Control> オブジェクトおよび <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> メソッドはオーバーライド メソッドが呼び出されての代わりに、 <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=fullName> メソッドです。  
  
 オーバーライド、 <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> ターゲット固有の処理を実行するメソッドを `Unload` コントロールのライフ サイクルの段階です。 通常、これらは、コントロールの破棄の前に、クリーンアップの機能です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> method. If <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> is not called, the <see cref="E:System.Web.UI.Control.Unload" /> event will not be raised.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアダプターに関連付けられているコントロールが存在するページへの参照を取得します。</summary>
        <value>A <see cref="T:System.Web.UI.Page" /> 関連付けられたコントロールの配置場所 page インスタンスへのアクセスを提供します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> プロパティへのアクセスを提供する、 <xref:System.Web.UI.Page?displayProperty=fullName> オブジェクト、コントロールを配置します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたコントロールが存在するページのページのアダプターへの参照を取得します。</summary>
        <value>A <see cref="T:System.Web.UI.Adapters.PageAdapter" /> 、現在のコントロールが関連付けられているページの <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> に配置します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> プロパティへのアクセスを提供する、 <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=fullName> オブジェクトの <xref:System.Web.UI.Page> オブジェクトで、 <xref:System.Web.UI.Control> オブジェクトに現在関連付けられている <xref:System.Web.UI.Adapters.ControlAdapter> オブジェクトに配置します。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> ページ アダプター レベルのページ上のいくつかのコントロール型に適用できる共通のターゲットに固有の機能などの他の項目にアクセスするプロパティを使用できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> ターゲット固有の出力のレンダリングに使用します。</param>
        <summary>コントロール アダプターがアタッチされるコントロール用にターゲット固有のマークアップを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバーライド、 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> クライアント ブラウザーに送信するターゲット固有のマークアップを生成します。<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> の代わりにメソッドが呼び出された、 <xref:System.Web.UI.Control.Render%2A?displayProperty=fullName> メソッド場合、 <xref:System.Web.UI.Adapters.ControlAdapter> オブジェクトにアタッチされて、 <xref:System.Web.UI.Control> オブジェクトです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method. Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method.  
  
 For a composite control, the adapter developer must ensure that the child controls are rendered. If the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method causes the child controls to be rendered but does not generate markup, it might be appropriate for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method to call its base method. If target-specific rendering of the child controls is necessary, the adapter should implement the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method and call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method from the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> ターゲット固有の出力のレンダリングに使用します。</param>
        <summary>コントロール アダプターが接続されている複合コントロールで子コントロールのターゲット固有のマークアップを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバーライド、 <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> メソッドは、個々 の子コントロールのマークアップにさらに複合コントロールの子コントロールのセットのターゲットに固有のマークアップを生成する必要があるとします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, for a composite control, the adapter developer must ensure that the child controls are rendered. If the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method, it should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method from an override of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method.  
  
 If the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method causes the child controls to be rendered but itself does not generate markup, it might be appropriate for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method to call its base method, which calls the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method, instead of implementing an override for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存は、コントロール アダプタの状態情報を制御します。</summary>
        <returns>
          <see cref="T:System.Object" /> とアダプターのコントロールの状態情報を格納している、 <see cref="T:System.Web.UI.StateBag" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロールの状態は、ビュー ステートが無効になっている場合でも必要な重要な状態情報です。 アダプターは、独自のコントロールの状態情報を維持する必要があるときは、オーバーライドして、 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> と <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> メソッドです。  
  
 アダプターは、状態を要求、関連付けられたコントロールの状態から独立して間で維持する必要がある機能がある場合は、コントロールの状態情報を維持する必要があります。 大規模なテキスト形式で表示およびのグループから成る複合コントロールなどの <xref:System.Web.UI.WebControls.RadioButton> コントロールはデスクトップ コンピューターのブラウザーの 1 つのビューとしてレンダリング可能性があります。 他のブラウザーで、分割表示: テキストの表示と他のオプション ボタン グループの 1 つのビューです。 アダプターは、現在アクティブなビューに関する独自のターゲット固有情報を保持する必要があります。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> 直後後にメソッドが呼び出される、 <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=fullName> メソッドで、 `SaveState` ライフ サイクルの段階です。 アダプターのコントロールの状態は、独立したコントロールのコントロールの状態だけでなくです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存は、コントロール アダプタの状態情報を表示します。</summary>
        <returns>
          <see cref="T:System.Object" /> とアダプターのビュー状態情報を格納している、 <see cref="T:System.Web.UI.StateBag" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アダプターは、独自のビュー状態情報を保持する必要があるときは、オーバーライドして、 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> と <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> メソッドです。  
  
 アダプターは、データがコントロールの関連付けられているビュー ステートから独立して要求間で保持する必要があるときに、状態情報の表示を維持する必要があります。 たとえば、デスクトップ コンピューターのブラウザー上のグリッド コントロールは、行の 1 つのビューとの値の列として表示可能性があります。 他のブラウザーで、分割行と 1 つの行の詳細の一覧などの複数のビューに表示します。 アダプターは、現在アクティブなビュー状態にないビューのデータを保持する必要があります。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> の直前に呼び出されます、 <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=fullName> メソッドで、 `SaveState` ライフ サイクルの段階です。 アダプターのビュー状態は、独立しただけでなく、コントロールのビュー ステートです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>