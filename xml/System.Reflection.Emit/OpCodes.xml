<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>による出力を Microsoft 中間言語 \(MSIL\) のフィールド表現を提供、 <see cref="T:System.Reflection.Emit.ILGenerator" /> クラス メンバー \(よう <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />\)。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 メンバー オペコードの詳細については、共通言語基盤 \(CLI\) ドキュメント、特に「Partition III: CIL Instruction Set」と「Partition II:: メタデータ Definition and Semantics」を参照してください。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) Ecma International Web サイトにします。  
  
   
  
## 例  
 次の例では、動的メソッドを使用して、構築 <xref:System.Reflection.Emit.ILGenerator> を出力する `OpCodes` に、 <xref:System.Reflection.Emit.MethodBuilder>です。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を加算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|58|add|2 つの数値があり、新しい数値を返すことを追加します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value1` に追加 `value2`します。  
  
4.  結果は、スタックにプッシュされます。  
  
 整数演算のオーバーフローが検出されない \(適切なオーバーフロー処理では、次を参照してください。 <xref:System.Reflection.Emit.OpCodes.Add_Ovf>\)。  
  
 整数の加算飽和するのではなく、ラップします。 たとえば、8 ビット整数と仮定している `value1` 255 に設定されていると `value2` 設定されている 256 ではなく 0 を 1 に、ラップされた結果は、です。  
  
 浮動小数点オーバーフロー `+inf` \(`PositiveInfinity`\) または `-inf` \(`NegativeInfinity`\)。  
  
 使用可能なオペランドの型と、対応する結果のデータ型は、次の表に一覧表示されます。 特定の型の組み合わせのエントリがないかどうか \(たとえば、 `int32` と `float`; `int32` と `int64`\) に無効な Microsoft 中間言語 \(MSIL\) は、エラーを生成します。  
  
|オペランド|value1 型|value2 の種類|結果の型|  
|-----------|--------------|----------------|----------|  
|追加|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|追加|`*`|`native int`|`*`|  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `add` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの整数値を加算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|D6|add.ovf のトピック|2 つの符号付き整数値、オーバーフロー チェックを追加します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value1` に追加 `value2` と、オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていない場合にスローされます。  
  
 符号付き整数でこの操作を実行することができます。 浮動小数点値を使用して <xref:System.Reflection.Emit.OpCodes.Add>します。  
  
 使用可能なオペランドの型と、対応する結果のデータ型は、次の表に一覧表示されます。 特定の型の組み合わせのエントリがないかどうか \(たとえば、 `int32` と `float`; `int32` と `int64`\)、無効な Microsoft 中間言語 \(MSIL\) 命令がなり、エラーが発生します。  
  
|オペランド|value1 型|value2 の種類|結果の型|  
|-----------|--------------|----------------|----------|  
|追加|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|追加|`*`|`native int`|`*`|  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `add.ovf` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を加算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|D7|add.ovf.un など|2 つの符号なし整数値、オーバーフロー チェックを追加します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value1` に追加 `value2` と、オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていない場合にスローされます。  
  
 符号付き整数でこの操作を実行することができます。 浮動小数点値を使用して <xref:System.Reflection.Emit.OpCodes.Add>します。  
  
 使用可能なオペランドの型と、対応する結果のデータ型は、次の表に一覧表示されます。 特定の型の組み合わせのエントリがないかどうか \(たとえば、 `int32` と `float`; `int32` と `int64`\)、無効な Microsoft 中間言語 \(MSIL\) 命令がなり、エラーが発生します。  
  
|オペランド|value1 型|value2 の種類|結果の型|  
|-----------|--------------|----------------|----------|  
|追加|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|追加|`*`|`native int`|`*`|  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `add.ovf.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値のビットごとの AND を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|命令|説明|  
|--------|--------|--------|  
|5F|および|2 つの整数値のビットごとの AND を決定します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value1` `value2` スタックからポップされます。 2 つの値のビットごとの AND を計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `and` 命令がスタックの上位 2 値のビットごとの AND を計算し、結果をスタックに残します。  
  
 `And` 整数固有操作です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `and` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドの引数リストへのアンマネージ ポインターを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 00|arglist|現在のメソッドの引数リスト ハンドルを返します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `arglist` 命令が不透明なハンドルを返します \(型のアンマネージ ポインターを `native int`\) を表す現在のメソッドの引数リスト。 このハンドルは、現在のメソッドの有効期間中にのみ有効です。 ただし、現在のメソッドがコントロールのスレッドである限り、ハンドルを他のメソッドに渡すことができます。 のみを実行することができます、 `arglist` を可変個の引数を受け取るメソッド内の命令です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `arglist` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値が等しい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|3B \< `int32` \>|beq `target`|オフセットでターゲット命令に分岐 `target` 2 つの値が等しい場合。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` に等しい `value2`, 、分岐操作を実行します。  
  
 `beq` 命令が場合に、指定したターゲット命令に制御を転送 `value1` に等しい `value2`します。 効果は、実行すると同じ、 `ceq` 命令を実行して、 `brtrue` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 以下は、許容可能なオペランドの型がカプセル化します。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません \(このような移動は重大な障害に制限されており、使用する必要があります、 <xref:System.Reflection.Emit.OpCodes.Leave> 命令代わりに\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `beq` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値が等しい場合は、ターゲット命令 \(短い形式\) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|2E \< `int8` \>|続く `target`|オフセットでターゲット命令に分岐 `target` の場合、短い形式|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` に等しい `value2`, 、分岐操作を実行します。  
  
 `beq.s` 命令が場合に、指定したターゲット命令に制御を転送 `value1` に等しい `value2`します。 効果は、実行すると同じ、 `ceq` 命令を実行して、 `brtrue` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 以下は、許容可能なオペランドの型がカプセル化します。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません \(このような移動は重大な障害に制限されており、使用する必要があります、 <xref:System.Reflection.Emit.OpCodes.Leave> 命令代わりに\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `beq.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以上の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|3C `<int32>`|bge `target`|最初の値が 2 番目の値以上の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` 以上の値には、 `value2`, 、分岐操作を実行します。  
  
 `bge` 命令が場合に、指定したターゲット命令に制御を転送 `value1` に以上 `value2`します。 この効果を実行するのには、 `clt.un` 命令を実行して、 `brfalse` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `bge` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以上の場合は、ターゲット命令 \(短い形式\) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|2 F `<int8>`|bge.s `target`|最初の値が短い形式として、2 番目の値以上である場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` 以上の値には、 `value2`, 、分岐操作を実行します。  
  
 `bge.s` 命令が場合に、指定したターゲット命令に制御を転送 `value1` に以上 `value2`します。 この効果を実行するのには、 `clt.un` 命令を実行して、 `brfalse` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `bge.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|41 `<int32>`|bge.un `target`|最初の値が 2 番目の値 \(符号なしの値\) 以上である場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` 以上の値には、 `value2`, 、分岐操作を実行します。  
  
 `bge.un` 命令が場合に、指定したターゲット命令に制御を転送 `value1` に以上 `value2`, 符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するのには、 `clt` 命令を実行して、 `brfalse` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `bge.un` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 \(短い形式\) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The following table lists the instruction's hexadecimal and Microsoft Intermediate Language \(MSIL\) assembly format, along with a brief reference summary:  
  
|Format|Assembly Format|Description|  
|------------|---------------------|-----------------|  
|34 \< **languageKeyword tag is not supported!!!!**<br /> \>|bge.un.s **parameterReference tag is not supported!!!!**|Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value \(unsigned values\), short form.|  
  
 The stack transitional behavior, in sequential order, is:  
  
1.  `value1` is pushed onto the stack.  
  
2.  `value2` is pushed onto the stack.  
  
3.  `value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.  
  
 The **languageKeyword tag is not supported!!!!**  
 instruction transfers control to the specified target instruction if **parameterReference tag is not supported!!!!**  
 is greater than or equal to **parameterReference tag is not supported!!!!**  
, when compared using unsigned integer or unordered float values. The effect is identical to performing a **languageKeyword tag is not supported!!!!**  
 instruction followed by a **languageKeyword tag is not supported!!!!**  
 branch to the specific target instruction. The target instruction is represented as a 1\-byte signed offset from the beginning of the instruction following the current instruction.  
  
 If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, and **languageKeyword tag is not supported!!!!**  
 blocks cannot be performed by this instruction.  
  
 The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the **languageKeyword tag is not supported!!!!**  
 opcode:  
  
-   ILGenerator.Emit\(OpCode, Label\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|3D \< `int32` \>|で `target`|最初の値が 2 番目の値より大きい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` よりも大きい `value2`, 、分岐操作を実行します。  
  
 `bgt` 命令が場合に、指定したターゲット命令に制御を転送 `value1` よりも大きい `value2`します。 この効果を実行するのには、 `cgt` 命令を実行して、 `brtrue` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `bgt` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値を超える場合は、ターゲット命令 \(短い形式\) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|30 \< `int8` \>|続く `target`|最初の値が 2 番目の値では、短縮形より大きい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` よりも大きい `value2`, 、分岐操作を実行します。  
  
 `bgt.s` 命令が場合に、指定したターゲット命令に制御を転送 `value1` よりも大きい `value2`します。 この効果を実行するのには、 `cgt` 命令を実行して、 `brtrue` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `bgt.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|42 \< `int32` \>|bgt.un `target`|最初の値が 2 番目の値 \(符号なしの値\) より大きい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` よりも大きい `value2`, 、分岐操作を実行します。  
  
 `bgt.un` 命令が場合に、指定したターゲット命令に制御を転送 `value1` よりも大きい `value2`, 符号なし整数値または順序なし float 値を使用して比較するとします。 この効果を実行するのには、 `cgt.un` 命令を実行して、 `brtrue` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `bgt.un` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 \(短い形式\) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|35 \< `int8` \>|bgt.un `target`|最初の値が 2 番目の値 \(符号なしの値\)、短縮形より大きい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` よりも大きい `value2`, 、分岐操作を実行します。  
  
 `bgt.un.s` 命令が場合に、指定したターゲット命令に制御を転送 `value1` よりも大きい `value2`, 符号なし整数値または順序なし float 値を使用して比較するとします。 この効果を実行するのには、 `cgt.un` 命令を実行して、 `brtrue` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `bgt.un.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|3 E `<int32>`|ble `target`|最初の値が 2 番目の値以下である場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合、スタックからポップされます。 `value1` をと同じかそれよりも少ない `value2`, 、分岐操作を実行します。  
  
 `ble` 命令が場合に、指定したターゲット命令に制御を転送 `value1` と同じかそれよりも少ない `value2`します。 この効果を実行するのには、 `cgt` 命令 \(`cgt.un` 浮動小数点値の\) 後に、 `brfalse` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ble` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以下の場合は、ターゲット命令 \(短い形式\) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language \(MSIL\) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|31 `<int8>`|ble.s`target`|最初の値が短い形式として、2 番目の値に等しいまたはそれよりも小さい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`をと同じかそれよりも少ない`value2`、分岐操作を実行します。  
  
 `ble.s`命令が場合に、指定したターゲット命令に制御を転送`value1`と同じかそれよりも少ない`value2`です。 この効果を実行するため、`cgt`命令 \(`cgt.un`浮動小数点数の\) 命令を実行して、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ble.s`オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|43 `<int32>`|ble.un `target`|最初の値が \(符号なしの値\) の 2 番目の値以下である場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合、スタックからポップされます。 `value1` をと同じかそれよりも少ない `value2`, 、分岐操作を実行します。  
  
 `ble.un` 命令が場合に、指定したターゲット命令に制御を転送 `value1` と同じかそれよりも少ない `value2`, 符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するのには、 `cgt.un` 命令 \(`cgt` 浮動小数点値の\) 後に、 `brfalse` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ble.un` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令 \(短い形式\) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|36 `<int8>`|ble.un `target`|最初の値が 2 番目の値 \(符号なしの値\)、短い形式として以下の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合、スタックからポップされます。 `value1` をと同じかそれよりも少ない `value2`, 、分岐操作を実行します。  
  
 `ble.un.s` 命令が場合に、指定したターゲット命令に制御を転送 `value1` と同じかそれよりも少ない `value2`, 符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するのには、 `cgt.un` 命令 \(`cgt` 浮動小数点値の\) 後に、 `brfalse` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ble.un.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|3 F \< `int32` \>|blt `target`|2 番目の値より小さい場合は最初の値が、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` がより小さい `value2`, 、分岐操作を実行します。  
  
 `blt` 命令が場合に、指定したターゲット命令に制御を転送 `value1` と同じかそれよりも少ない `value2`します。 この効果を実行するのには、 `clt` 命令を実行して、 `brtrue` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `blt` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値より小さい場合は、ターゲット命令 \(短い形式\) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|32 \< `int8` \>|blt.s `target`|短い形式として、2 番目の値より小さい場合は最初の値が、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` がより小さい `value2`, 、分岐操作を実行します。  
  
 `blt.s` 命令が場合に、指定したターゲット命令に制御を転送 `value1` がより小さい `value2`します。 この効果を実行するのには、 `clt` 命令を実行して、 `brtrue` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `blt.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|44 \< `int32` \>|blt.un `target`|2 番目の値 \(符号なしの値\) 未満の場合は最初の値が、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` がより小さい `value2`, 、分岐操作を実行します。  
  
 `blt.un` 命令が場合に、指定したターゲット命令に制御を転送 `value1` がより小さい `value2`, 、符号なし整数値または順序なし float 値を使って比較した場合。 この効果を実行するのには、 `clt.un` 命令を実行して、 `brtrue` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `blt.un` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令 \(短い形式\) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The following table lists the instruction's hexadecimal and Microsoft Intermediate Language \(MSIL\) assembly format, along with a brief reference summary:  
  
|Format|Assembly Format|Description|  
|------------|---------------------|-----------------|  
|37 \< **languageKeyword tag is not supported!!!!**<br /> \>|blt.un.s **parameterReference tag is not supported!!!!**|Branch to the target instruction at the specified offset if the first value is less than the second value \(unsigned values\), short form.|  
  
 The stack transitional behavior, in sequential order, is:  
  
1.  `value1` is pushed onto the stack.  
  
2.  `value2` is pushed onto the stack.  
  
3.  `value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.  
  
 The **languageKeyword tag is not supported!!!!**  
 instruction transfers control to the specified target instruction if **parameterReference tag is not supported!!!!**  
 is less than **parameterReference tag is not supported!!!!**  
, when compared using unsigned integer or unordered float values. The effect is identical to performing a **languageKeyword tag is not supported!!!!**  
 instruction followed by a **languageKeyword tag is not supported!!!!**  
 branch to the specific target instruction. The target instruction is represented as a 4\-byte signed offset from the beginning of the instruction following the current instruction.  
  
 If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, and **languageKeyword tag is not supported!!!!**  
 blocks cannot be performed by this instruction.  
  
 The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the **languageKeyword tag is not supported!!!!**  
 opcode:  
  
-   ILGenerator.Emit\(OpCode, Label\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The following table lists the instruction's hexadecimal and Microsoft Intermediate Language \(MSIL\) assembly format, along with a brief reference summary:  
  
|Format|Assembly Format|Description|  
|------------|---------------------|-----------------|  
|40 \< **languageKeyword tag is not supported!!!!**<br /> \>|bne.un **parameterReference tag is not supported!!!!**|Branch to the target instruction at the specified offset if two unsigned integer values are not equal \(unsigned values\).|  
  
 The stack transitional behavior, in sequential order, is:  
  
1.  `value1` is pushed onto the stack.  
  
2.  `value2` is pushed onto the stack.  
  
3.  `value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.  
  
 The **languageKeyword tag is not supported!!!!**  
 instruction transfers control to the specified target instruction if **parameterReference tag is not supported!!!!**  
 is not equal to **parameterReference tag is not supported!!!!**  
, when compared using unsigned integer or unordered float values. The effect is identical to performing a **languageKeyword tag is not supported!!!!**  
 instruction followed by a **languageKeyword tag is not supported!!!!**  
 branch to the specific target instruction. The target instruction is represented as a 4\-byte signed offset from the beginning of the instruction following the current instruction.  
  
 If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, and **languageKeyword tag is not supported!!!!**  
 blocks cannot be performed by this instruction.  
  
 The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the **languageKeyword tag is not supported!!!!**  
 opcode:  
  
-   ILGenerator.Emit\(OpCode, Label\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令 \(短い形式\) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|33 \< `int8` \>|続く `target`|分岐命令 2 つの符号なし整数値の場合は、指定したオフセットではない同じ \(符号なしの値\)、短縮形をターゲットにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 場合に、スタックからポップ `value1` と等しくない `value2`, 、分岐操作を実行します。  
  
 `bne.un` 命令が場合に、指定したターゲット命令に制御を転送 `value1` と等しくない `value2`, 符号なし整数値または順序なし float 値を使用して比較するとします。 この効果を実行するのには、 `ceq` 命令を実行して、 `brfalse` 特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `bne.un.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値型のオブジェクト参照に変換 \(型 <see langword="O" />\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|8C \< `T` \>|ボックス `valTypeToken`|値の型変換 \(で指定された型の `valTypeToken`\) を真のオブジェクト参照です。|  
  
 履歴の移行動作を順番には。  
  
1.  値型は、スタックにプッシュされます。  
  
2.  値の型がスタックからポップされます。 `box` 操作を実行します。  
  
3.  結果の「ボックス化された」値型へのオブジェクト参照は、スタックにプッシュされます。  
  
 値型では、共通言語基盤 \(CLI\) 内に 2 つの別個の形式があります。  
  
-   値の型が別のオブジェクト、スタックの上に埋め込まれている場合に使用される「生」のフォームです。  
  
-   ここで値型のデータは事前にラップ \(ボックス化\) オブジェクトに個別のエンティティとして存在する可能性が 'ボックス化' の形式です。  
  
 `box` 命令が、オブジェクト参照に「生」\(ボックス化解除された\) 値の型を変換 \(型 `O`\)。 これは、新しいオブジェクトを作成し、新しく割り当てられたオブジェクトに値型からデータをコピーして行います。`valTypeToken` スタックに値型の型を示すメタデータ トークン。  
  
 <xref:System.OutOfMemoryException> メモリ不足のため、要求を満たす場合にスローされます。  
  
 <xref:System.TypeLoadException> クラスが見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 \(MSIL\) が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `box` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無条件でターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The following table lists the instruction's hexadecimal and Microsoft Intermediate Language \(MSIL\) assembly format, along with a brief reference summary:  
  
|Format|Assembly Format|Description|  
|------------|---------------------|-----------------|  
|38 \< **languageKeyword tag is not supported!!!!**<br /> \>|br **parameterReference tag is not supported!!!!**|Branches to a target instruction at the specified offset.|  
  
 No evaluation stack behaviors are performed by this operation.  
  
 The **languageKeyword tag is not supported!!!!**  
 instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 4\-byte signed offset from the beginning of the instruction following the current instruction.  
  
 If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, and **languageKeyword tag is not supported!!!!**  
 blocks cannot be performed by this instruction.  
  
 The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the **languageKeyword tag is not supported!!!!**  
 opcode:  
  
-   ILGenerator.Emit\(OpCode, Label\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無条件でターゲット命令に制御を転送します \(短い形式\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|2B \< `int8` \>|br.s `target`|短い形式として、指定したオフセットで、ターゲット命令に分岐します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `br.s` 命令をターゲット命令に制御を移します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `br.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブレークポイントがトリップしたことをデバッガーに通知するように、共通言語基盤 \(CLI\) に通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The following table lists the instruction's hexadecimal and Microsoft Intermediate Language \(MSIL\) assembly format, along with a brief reference summary:  
  
|Format|Assembly Format|Description|  
|------------|---------------------|-----------------|  
|01|break|inform a debugger that a breakpoint has been reached.|  
  
 No evaluation stack behaviors are performed by this operation.  
  
 The **languageKeyword tag is not supported!!!!**  
 instruction is for debugging support. It signals the CLI to inform the debugger that a break point has been tripped. It has no other effect on the interpreter state.  
  
 The **languageKeyword tag is not supported!!!!**  
 instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.  
  
 The **languageKeyword tag is not supported!!!!**  
 instruction can trap to a debugger, do nothing, or raise a security exception. The exact behavior is implementation\-defined.  
  
 The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the **languageKeyword tag is not supported!!!!**  
 opcode:  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>場合に、ターゲット命令に制御を転送 <paramref name="value" /> は <see langword="false" />, 、null 参照 \(<see langword="Nothing" /> Visual Basic で\)、または 0。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|39 \< `int32` \>|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|場合は、指定したオフセットでターゲット命令に分岐 `false`します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` 前の操作によってスタックにプッシュされます。  
  
2.  `value` スタックからポップされます。場合 `value` は `false`, 、分岐する `target`です。  
  
 `brfalse` 命令 \(とそのエイリアス `brnull` と `brzero`\) 場合は、指定したターゲット命令に制御を転送 `value` \(型の `int32`, 、`int64`, 、オブジェクト参照 `O`, 、マネージ ポインター `&`, 、一時的なポインター `*`, 、`native int`\) は 0 \(`false`\)。 場合 `value` ゼロ以外 \(`true`\)、次の命令実行が続けられます。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `brfalse` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>場合に、ターゲット命令に制御を転送 <paramref name="value" /> は <see langword="false" />, 、null 参照または 0。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|2C \<`int8` \>|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|場合は、指定したオフセットでターゲット命令に分岐 `false`, 、短縮形です。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` 前の操作によってスタックにプッシュされます。  
  
2.  `value` スタックからポップされます。場合 `value` は `false`, 、分岐する `target`です。  
  
 `brfalse.s` 命令 \(とそのエイリアス `brnull` と `brzero`\) 場合は、指定したターゲット命令に制御を転送 `value` \(型の `int32`, 、`int64`, 、オブジェクト参照 `O`, 、マネージ ポインター `&`, 、一時的なポインター `*`, 、`native int`\) は 0 \(`false`\)。 場合 `value` ゼロ以外 \(`true`\)、次の命令実行が続けられます。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `brfalse.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>場合に、ターゲット命令に制御を転送 <paramref name="value" /> は <see langword="true" />, 、null でない、または 0 以外。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|3 A \< `int32` \>|brtrue `target`<br /><br /> brinst `target`|0 以外の場合は、指定したオフセットで、ターゲット命令に分岐 \(`true`\)。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` 前の操作によってスタックにプッシュされます。  
  
2.  `value` スタックからポップされます。場合 `value` は `true`, 、分岐する `target`です。  
  
 `brtrue` 命令が場合に、指定したターゲット命令に制御を転送 `value` \(型 `native int`\) がゼロ以外 \(`true`\)。 場合 `value` ゼロ \(`false`\)、次の命令実行が続けられます。  
  
 場合 `value` はオブジェクト参照です \(型 `O`\) し、 `brinst` \(エイリアスを `brtrue`\) オブジェクトのインスタンスを表す場合は、制御を転送 \(たとえば、ない場合は、null オブジェクト参照を参照してください <xref:System.Reflection.Emit.OpCodes.Ldnull>\)。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `brtrue` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>場合に、ターゲット命令 \(短い形式\) に制御を転送 <paramref name="value" /> は <see langword="true" />, 、null でない、または 0 以外。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|2 D \< `int8` \>|brtrue.s `target`<br /><br /> brinst.s `target`|0 以外の場合は、指定したオフセットで、ターゲット命令に分岐 \(`true`\)、短縮形です。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` 前の操作によってスタックにプッシュされます。  
  
2.  `value` スタックからポップされます。場合 `value` は `true`, 、分岐する `target`です。  
  
 `brtrue.s` 命令が場合に、指定したターゲット命令に制御を転送 `value` \(型 `native int`\) がゼロ以外 \(`true`\)。 場合 `value` ゼロ \(`false`\)、次の命令実行が続けられます。  
  
 場合 `value` はオブジェクト参照です \(型 `O`\) し、 `brinst` \(エイリアスを `brtrue`\) オブジェクトのインスタンスを表す場合は、制御を転送 \(たとえば、ない場合は、null オブジェクト参照を参照してください <xref:System.Reflection.Emit.OpCodes.Ldnull>\)。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `brtrue.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>渡されたメソッド記述子によって示されているメソッドを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The following table lists the instruction's hexadecimal and Microsoft Intermediate Language \(MSIL\) assembly format, along with a brief reference summary:  
  
|Format|Assembly Format|Description|  
|------------|---------------------|-----------------|  
|28 \< **languageKeyword tag is not supported!!!!**<br /> \>|call **parameterReference tag is not supported!!!!**|Call the method described by **parameterReference tag is not supported!!!!**<br />.|  
  
 The stack transitional behavior, in sequential order, is:  
  
1.  Method arguments **parameterReference tag is not supported!!!!**  
     through **parameterReference tag is not supported!!!!**  
     are pushed onto the stack.  
  
2.  Method arguments **parameterReference tag is not supported!!!!**  
     through **parameterReference tag is not supported!!!!**  
     are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor. When complete, a return value is generated by the callee method and sent to the caller.  
  
3.  The return value is pushed onto the stack.  
  
 The **languageKeyword tag is not supported!!!!**  
 instruction calls the method indicated by the method descriptor passed with the instruction. The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used. The **languageKeyword tag is not supported!!!!**  
 instruction can be immediately preceded by a **languageKeyword tag is not supported!!!!**  
 \(<xref:System.Reflection.Emit.OpCodes.Tailcall>\) prefix instruction to specify that the current method state should be released before transferring control. If the call transfers control to a method of higher trust than the origin method, the stack frame is not released. Instead, the execution continues silently as if the **languageKeyword tag is not supported!!!!**  
 had not been supplied. The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function. In all of these cases the destination address is determined entirely from the method descriptor \(contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>\).  
  
 The arguments are placed on the stack in left\-to\-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. There are three important special cases:  
  
 1. Calls to an instance \(or virtual\) method must push that instance reference before any of the user\-visible arguments. The instance reference must not be a null reference. The signature carried in the metadata does not contain an entry in the parameter list for the **languageKeyword tag is not supported!!!!**  
 pointer; instead, it uses a bit to indicate whether the method requires passing the **languageKeyword tag is not supported!!!!**  
 pointer.  
  
 2. It is valid to call a virtual method using **languageKeyword tag is not supported!!!!**  
 \(rather than **languageKeyword tag is not supported!!!!**  
\); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.  
  
 3. Note that a delegate's **languageKeyword tag is not supported!!!!**  
 method can be called with either the **languageKeyword tag is not supported!!!!**  
 or **languageKeyword tag is not supported!!!!**  
 instruction.  
  
 <xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method. The security check may occur when the Microsoft Intermediate Language \(MSIL\) instructions are converted to native code rather than at run time.  
  
> [!NOTE]
>  When calling methods of System.Object on value types, consider using the **languageKeyword tag is not supported!!!!**  
>  prefix with the **languageKeyword tag is not supported!!!!**  
>  instruction instead of emitting a **languageKeyword tag is not supported!!!!**  
>  instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the **languageKeyword tag is not supported!!!!**  
>  prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a **languageKeyword tag is not supported!!!!**  
> . These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the **languageKeyword tag is not supported!!!!**  
 opcode:  
  
-   ILGenerator.Emit\(OpCode, MethodInfo\)  
  
-   ILGenerator.EmitCall\(OpCode, MethodInfo, Type\[\]\)  
  
> [!NOTE]
>  The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for **languageKeyword tag is not supported!!!!**  
>  calls. Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し規則によって記述されている引数を使用して、評価スタックで \(エントリ ポイントへのポインターとして\) 指定されているメソッドを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|29 \< `T` \>|calli `callSiteDescr`|呼び出し規約によって記述されている引数を指すメソッドを呼び出します。|  
  
 履歴の移行動作を順番には。  
  
1.  メソッドの引数 `arg1` を通じて `argN` スタックにプッシュします。  
  
2.  メソッドのエントリのポインターはスタックにプッシュされます。  
  
3.  メソッドの引数 `arg1` を通じて `argN` メソッド エントリのポインターはスタックからポップされます。 で、同じメソッドの呼び出しを実行します。 完了すると、戻り値が呼び出し先メソッドによって生成され、呼び出し元に送信します。  
  
4.  戻り値は、スタックにプッシュされます。  
  
 `calli` 命令は、引数を持つメソッドのエントリのポインターを呼び出します `arg1` を通じて `argN`します。 これらの引数の型は、特定の呼び出し規約によって記述されます \(`callSiteDesc`\)。`calli` 命令はすぐ後に、 `tail` プレフィックス \(<xref:System.Reflection.Emit.OpCodes.Tailcall>\) メソッドの現在の状態を制御を転送する前に解放することを指定します。 呼び出しが転送される場合、元のメソッドのスタック フレームより信頼性の高いメソッドに制御は解放されません。代わりに、実行が継続されますまるで、 `tail` が提供されなかった。  
  
 メソッドのエントリのポインターは呼び出し規約 \(スタンドアロン シグネチャのメタデータ トークン\) によって記述されている引数を正当に呼び出すことができる \(ターゲット コンピューターのネイティブ コードへの特定のポインターと見なされます。 使用してこのようなポインターを作成することができます、 <xref:System.Reflection.Emit.OpCodes.Ldftn> または <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> 手順については、ネイティブ コードから渡されたか。  
  
 呼び出し規約が動的にチェックされませんが、これを使用するコード、 `calli` 実際には、先に指定した呼び出し規約が使用していない場合、命令が正常に動作しません。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、すべての必要な引数が多い順にスタックの一番上がまで、スタックし、3 番目、2 番目の引数に配置します。 インスタンスまたは仮想メソッドの引数構築コード シーケンスでは、任意のユーザーに表示される引数の前に、\(null 参照することはできません\) をそのインスタンスの参照をプッシュする必要があります。  
  
 <xref:System.Security.SecurityException> システムのセキュリティが呼び出されたメソッドに呼び出し元のアクセスを許可していない場合にスローされる可能性ができます。 セキュリティ チェックは、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換された場合に発生することができます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> メソッドを実行するために使用できる、 `calli` スタック上の命令です。 注意 `calli` を呼び出す必要がありますを使用するのではなく、メソッドの下、 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 命令をスタック上に直接配置するクラス。  
  
-   ILGenerator.EmitCalli \(オペコード、CallingConventions、種類はであるマネージ呼び出し規約を使用した呼び出しの Type\[\]\) を入力します。  
  
-   ILGenerator.EmitCalli \(オペコード、アンマネージ呼び出し規約を使用した呼び出しの CallingConvention、種類、Type\[\]\) です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト上で遅延バインディング メソッドを呼び出し、戻り値を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The following table lists the instruction's hexadecimal and Microsoft Intermediate Language \(MSIL\) assembly format, along with a brief reference summary:  
  
|Format|Assembly Format|Description|  
|------------|---------------------|-----------------|  
|6F \< **languageKeyword tag is not supported!!!!**<br /> \>|callvirt **parameterReference tag is not supported!!!!**|Calls a specific method associated with **parameterReference tag is not supported!!!!**<br />.|  
  
 The stack transitional behavior, in sequential order, is:  
  
1.  An object reference **parameterReference tag is not supported!!!!**  
     is pushed onto the stack.  
  
2.  Method arguments **parameterReference tag is not supported!!!!**  
     through **parameterReference tag is not supported!!!!**  
     are pushed onto the stack.  
  
3.  Method arguments **parameterReference tag is not supported!!!!**  
     through **parameterReference tag is not supported!!!!**  
     and the object reference **parameterReference tag is not supported!!!!**  
     are popped from the stack; the method call is performed with these arguments and control is transferred to the method in **parameterReference tag is not supported!!!!**  
     referred to by the method metadata token. When complete, a return value is generated by the callee method and sent to the caller.  
  
4.  The return value is pushed onto the stack.  
  
 The **languageKeyword tag is not supported!!!!**  
 instruction calls a late\-bound method on an object. That is, the method is chosen based on the runtime type of **parameterReference tag is not supported!!!!**  
 rather than the compile\-time class visible in the method pointer. **languageKeyword tag is not supported!!!!**  
 can be used to call both virtual and instance methods. The **languageKeyword tag is not supported!!!!**  
 instruction may be immediately preceded by a **languageKeyword tag is not supported!!!!**  
 \(<xref:System.Reflection.Emit.OpCodes.Tailcall>\) prefix to specify that the current stack frame should be released before transferring control. If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.  
  
 The method metadata token provides the name, class and signature of the method to call. The class associated with **parameterReference tag is not supported!!!!**  
 is the class of which it is an instance. If the class defines a non\-static method that matches the indicated method name and signature, this method is called. Otherwise all classes in the base class chain of this class are checked in order. It is an error if no method is found.  
  
 `Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method. If the method has a return value, it is pushed on the stack upon method completion. On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.  
  
 The arguments are placed on the stack in left\-to\-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The instance reference **parameterReference tag is not supported!!!!**  
 \(always required for **languageKeyword tag is not supported!!!!**  
\) must be pushed before any of the user\-visible arguments. The signature \(carried in the metadata token\) need not contain an entry in the parameter list for the this pointer.  
  
 Note that a virtual method can also be called using the<xref:System.Reflection.Emit.OpCodes.Call> instruction.  
  
 <xref:System.MissingMethodException> is thrown if a non\-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes. This is typically detected when Microsoft Intermediate Language \(MSIL\) instructions are converted to native code, rather than at runtime.  
  
 <xref:System.NullReferenceException> is thrown if obj is null.  
  
 <xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method. The security check may occur when the CIL is converted to native code rather than at run time.  
  
> [!NOTE]
>  When calling methods of System.Object on value types, consider using the **languageKeyword tag is not supported!!!!**  
>  prefix with the **languageKeyword tag is not supported!!!!**  
>  instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the **languageKeyword tag is not supported!!!!**  
>  prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a **languageKeyword tag is not supported!!!!**  
> . These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the **languageKeyword tag is not supported!!!!**  
 opcode:  
  
-   ILGenerator.Emit\(OpCode, MethodInfo\)  
  
-   ILGenerator.EmitCall\(OpCode, MethodInfo, Type\[\]\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したクラスへの参照により渡されたオブジェクトをキャストしようとします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|74 \< `T` \>|castclass `class`|型の新しいオブジェクトをオブジェクトにキャスト `class`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされます。参照先のオブジェクトをキャスト指定した `class`します。  
  
3.  成功した場合、新しいオブジェクト参照がスタックにプッシュされます。  
  
 `castclass` 命令は、オブジェクト参照をキャストしようとしています \(型 `O`\) を指定したクラスにスタックの一番上です。 新しいクラスには、目的のクラスを示すメタデータ トークンを指定します。 スタックの上部にあるオブジェクトのクラス \(新しいクラスがインターフェイスにある場合\)、新しいクラスを実装していませんし、新しいクラスの派生クラスではない場合、 <xref:System.InvalidCastException> がスローされます。 オブジェクト参照が null 参照では、 `castclass` が成功し、null 参照と新しいオブジェクトを返します。  
  
 <xref:System.InvalidCastException> obj をクラスにキャストできない場合にスローされます。  
  
 <xref:System.TypeLoadException> クラスが見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `castclass` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 値が等しい場合、整数 1 <see langword="(int32" />\) が評価スタックにプッシュされますそれ以外の場合 0 \(<see langword="int32" />\) が評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 01|ceq|場合 1 をプッシュ `value1` equals `value2`有効でない、0 をプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value1` と比較する `value2`です。  
  
4.  場合 `value1` に等しい `value2`, 、1 がスタックにプッシュされます。 それ以外の場合 0 を、スタックにプッシュします。  
  
 `ceq` 命令を比較 `value1` と `value2`です。 場合 `value1` に等しい `value2`, し、1 \(型の `int32`\) がスタックにプッシュします。 それ以外の場合 0 \(型の `int32`\) がスタックにプッシュします。  
  
 浮動小数点数の `ceq` 番号は順序付けられていない場合は 0 が返されます \(いずれかまたは両方が NaN\)。 無限の値は、それ自体と同じです。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ceq` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 最初の値が 2 番目よりも大きい場合は、値 1 は、整数 <see langword="(int32" />\) が評価スタックにプッシュされますそれ以外の場合 0 \(<see langword="int32" />\) が評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 02|cgt|場合に 1 をプッシュ `value1` がより大きい `value2`有効でない、0 をプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `cgt` かどうか `value1` よりも大きい `value2`します。  
  
4.  場合 `value1` よりも大きい `value2`, 、1 がスタックにプッシュされます。 それ以外の場合 0 を、スタックにプッシュします。  
  
 `cgt` 命令を比較 `value1` と `value2`です。 場合 `value1` がより厳密に大きい `value2`, 、 `int32` 値 1 がスタックにプッシュします。 それ以外の場合、 `int32` 0 の値がスタックにプッシュします。  
  
-   浮動小数点数の `cgt` \(1 つまたは両方の引数が NaN\) の場合は、数値は順序付けられていない場合は 0 を返します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `cgt` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なしの値または順序なしの値を比較します。 最初の値が 2 番目よりも大きい場合は、値 1 は、整数 <see langword="(int32" />\) が評価スタックにプッシュされますそれ以外の場合 0 \(<see langword="int32" />\) が評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 03|cgt.un|場合に 1 をプッシュ `value1` よりも大きい `value2`有効でない、0 \(符号なしの値\) をプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `cgt.un` かどうか `value1` がより大きい `value2`します。  
  
4.  場合 `value1` よりも大きい `value2`, 、1 がスタックにプッシュされます。 それ以外の場合 0 を、スタックにプッシュします。  
  
 `int32` 場合は、次のいずれかが値 1 がスタックにプッシュされる `true` :  
  
 浮動小数点数の `value1` を順序付けされていない `value2`します。  
  
 整数値の `value1` がより厳密に大きい `value2` 符号なしの数値としてと見なされるとします。  
  
 それ以外の場合、 `int32` 0 の値がスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `cgt.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スロー <see cref="T:System.ArithmeticException" /> 値が有限数ではない場合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|C3|ckfinite|スロー <xref:System.ArithmeticException> 値が有限数ではない場合。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます.  
  
2.  `value` スタックからポップされ、 `ckfinite` に命令を実行します。  
  
3.  `value` プッシュ バック スタックに例外がスローされない場合。  
  
 `ckfinite instruction` スロー <xref:System.ArithmeticException> 場合 `value` \(浮動小数点数\) は、いずれか、"not a number"の値 \(NaN\) または `+-` 無限大の値。`Ckfinite` 例外がスローされない場合は、スタックに値を残します。 実行が指定されていない `value` 浮動小数点数ではありません。  
  
 <xref:System.ArithmeticException> 場合にスローされる `value` 'normal' の数値ではありません。  
  
 なお、特別な例外、または派生クラスの <xref:System.ArithmeticException> より適切な例外ハンドラーに正しくない値を渡すことがあります。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ckfinite` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 最初の値が小さい場合、秒を超える値は、整数 1 <see langword="(int32" />\) が評価スタックにプッシュされますそれ以外の場合 0 \(<see langword="int32" />\) が評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 04|clt|場合に 1 をプッシュ `value1` は未満 `value2`有効でない、0 をプッシュします。|  
  
 シーケンシャルな順序でスタックの遷移の動作: `value1` スタックにプッシュします。  
  
1.  `value2` スタックにプッシュされます。  
  
2.  `value2` `value1` スタックからポップされます。 `clt` かどうか `value1` がより小さい `value2`します。  
  
3.  場合 `value1` がより小さい `value2`, 、1 がスタックにプッシュされます。 それ以外の場合 0 を、スタックにプッシュします。  
  
 `clt` 命令を比較 `value1` と `value2`です。 場合 `value1` がより厳密に小さい `value2`, 、 `int32` 値 1 がスタックにプッシュします。 それ以外の場合、 `int32` 0 の値がスタックにプッシュします。  
  
-   浮動小数点数の `clt` \(1 つまたは両方の引数が NaN\) の場合は、数値は順序付けられていない場合は 0 を返します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `clt` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なしまたは順序なしの値を比較 <paramref name="value1" /> と <paramref name="value2" />です。 If <paramref name="value1" /> がより小さい <paramref name="value2" />, 、整数値 1、 <see langword="(int32" />\) 評価にプッシュされますスタック。 それ以外の場合、0 \(<see langword="int32" />\) が評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 05|clt.un|場合に 1 をプッシュ `value1` はより小さい `value2`有効でない、0 \(符号なしの値\) をプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `clt.un` かどうか `value1` がより小さい `value2`します。  
  
4.  場合 `value1` がより小さい `value2`, 、1 がスタックにプッシュされます。 それ以外の場合 0 を、スタックにプッシュします。  
  
 `clt.un` 命令を比較 `value1` と `value2`です。`int32` 、次のいずれかが当てはまる場合、値 1 が、スタックにプッシュします。  
  
-   `value1` より厳密に小さい `value2` \(用として `clt`\)。  
  
-   浮動小数点数の `value1` を順序付けされていない `value2`します。  
  
-   整数値の `value1` がより厳密に小さい `value2` 符号なしの数値としてと見なされるとします。  
  
 それ以外の場合、 `int32` 0 の値がスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `clt.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>仮想メソッド呼び出しをする対象の型を制約します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The following table lists the instruction's hexadecimal and Microsoft intermediate language \(MSIL\) assembly format, along with a brief reference summary:  
  
|Format|Assembly Format|Description|  
|------------|---------------------|-----------------|  
|FE 16 \< **languageKeyword tag is not supported!!!!**<br /> \>|constrained. **parameterReference tag is not supported!!!!**|Call a virtual method on a type constrained to be type **languageKeyword tag is not supported!!!!**<br />.|  
  
 The **languageKeyword tag is not supported!!!!**  
 prefix is permitted only on a **languageKeyword tag is not supported!!!!**  
 instruction.  
  
 The state of the MSIL stack at this point must be as follows:  
  
1.  A managed pointer, **parameterReference tag is not supported!!!!**  
    , is pushed onto the stack. The type of **parameterReference tag is not supported!!!!**  
     must be a managed pointer \(**languageKeyword tag is not supported!!!!**  
    \) to **parameterReference tag is not supported!!!!**  
    . Note that this is different from the case of an unprefixed **languageKeyword tag is not supported!!!!**  
     instruction, which expects a reference of **parameterReference tag is not supported!!!!**  
    .  
  
2.  Method arguments **parameterReference tag is not supported!!!!**  
     through **parameterReference tag is not supported!!!!**  
     are pushed onto the stack, just as with an unprefixed **languageKeyword tag is not supported!!!!**  
     instruction.  
  
 The **languageKeyword tag is not supported!!!!**  
 prefix is designed to allow **languageKeyword tag is not supported!!!!**  
 instructions to be made in a uniform way independent of whether **parameterReference tag is not supported!!!!**  
 is a value type or a reference type.  
  
 When a **languageKeyword tag is not supported!!!!**  
 **parameterReference tag is not supported!!!!**  
 instruction has been prefixed by **languageKeyword tag is not supported!!!!**  
 **parameterReference tag is not supported!!!!**  
, the instruction is executed as follows:  
  
-   If **parameterReference tag is not supported!!!!**  
     is a reference type \(as opposed to a value type\) then **parameterReference tag is not supported!!!!**  
     is dereferenced and passed as the 'this' pointer to the **languageKeyword tag is not supported!!!!**  
     of **parameterReference tag is not supported!!!!**  
    .  
  
-   If **parameterReference tag is not supported!!!!**  
     is a value type and **parameterReference tag is not supported!!!!**  
     implements **parameterReference tag is not supported!!!!**  
     then **parameterReference tag is not supported!!!!**  
     is passed unmodified as the 'this' pointer to a **languageKeyword tag is not supported!!!!**  
     **parameterReference tag is not supported!!!!**  
     instruction, for the implementation of **parameterReference tag is not supported!!!!**  
     by **parameterReference tag is not supported!!!!**  
    .  
  
-   If **parameterReference tag is not supported!!!!**  
     is a value type and **parameterReference tag is not supported!!!!**  
     does not implement **parameterReference tag is not supported!!!!**  
     then **parameterReference tag is not supported!!!!**  
     is dereferenced, boxed, and passed as the 'this' pointer to the **languageKeyword tag is not supported!!!!**  
     **parameterReference tag is not supported!!!!**  
     instruction.  
  
 This last case can occur only when **parameterReference tag is not supported!!!!**  
 was defined on <xref:System.Object>, <xref:System.ValueType>, or<xref:System.Enum> and not overridden by **parameterReference tag is not supported!!!!**  
. In this case, the boxing causes a copy of the original object to be made. However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.  
  
 The **languageKeyword tag is not supported!!!!**  
 prefix supports IL generators that create generic code. Normally the **languageKeyword tag is not supported!!!!**  
 instruction is not valid on value types. Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of **parameterReference tag is not supported!!!!**  
 and the method being called. However, when **parameterReference tag is not supported!!!!**  
 is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.  
  
 The **languageKeyword tag is not supported!!!!**  
opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether **parameterReference tag is not supported!!!!**  
 is a value type or a reference type. Although it is intended for the case where **parameterReference tag is not supported!!!!**  
 is a generic type variable, the **languageKeyword tag is not supported!!!!**  
 prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.  
  
 Using the **languageKeyword tag is not supported!!!!**  
 prefix also avoids potential versioning problems with value types. If the **languageKeyword tag is not supported!!!!**  
 prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object. For example, if a value type `V` overrides the Object.ToString\(\) method, a **languageKeyword tag is not supported!!!!**  
 `V.ToString()` instruction is emitted; if it does not, a **languageKeyword tag is not supported!!!!**  
 instruction and a **languageKeyword tag is not supported!!!!**  
 `Object.ToString()` instruction are emitted. A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.  
  
 The **languageKeyword tag is not supported!!!!**  
 prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a **languageKeyword tag is not supported!!!!**  
. If the **languageKeyword tag is not supported!!!!**  
prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time. Using the **languageKeyword tag is not supported!!!!**  
 prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.  
  
 The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the **languageKeyword tag is not supported!!!!**  
 opcode:  
  
-   ILGenerator.Emit\(OpCode, Type\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="native int" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|D3|conv.i|変換 `native int`, プッシュ、 `native int` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.i` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> と <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> 結果型は、結果の値を正しく表すことができない場合に例外をスローする手順については等価です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.i` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="int8" />, 、\(埋め込み\) を拡張して <see langword="int32" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|67|conv.i1|変換 `int8`, プッシュ、 `int32` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.i1` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> と <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> 結果型は、結果の値を正しく表すことができない場合に例外をスローする手順については等価です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.i1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="int16" />, 、\(埋め込み\) を拡張して <see langword="int32" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|68|conv.i2|変換 `int16`, プッシュ、 `int32` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.i2` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> と <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> 結果型は、結果の値を正しく表すことができない場合に例外をスローする手順については等価です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.i2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="int32" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|69|conv.i4|変換 `int32`, プッシュ、 `int32` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.i4` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> と <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> 結果型は、結果の値を正しく表すことができない場合に例外をスローする手順については等価です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.i4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="int64" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|6A|conv.i8 を使用|変換 `int64`, プッシュ、 `int64` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.i8` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> と <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> 結果型は、結果の値を正しく表すことができない場合に例外をスローする手順については等価です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.i8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上の符号付きの値に変換 <see langword="native int" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|D4|conv.ovf.i|変換、 `native int` \(スタック上でとして `native int`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.i` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.i` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上の符号なしの値に変換 <see langword="native int" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|8A|conv.ovf.i.un|符号なしの値に変換、 `native int` \(スタック上でとして `native int`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.i.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.i.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The following table lists the instruction's hexadecimal and Microsoft Intermediate Language \(MSIL\) assembly format, along with a brief reference summary:  
  
|Format|Assembly Format|Description|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Convert to an **languageKeyword tag is not supported!!!!**<br /> \(on the stack as **languageKeyword tag is not supported!!!!**<br />\) and throw an exception on overflow.|  
  
 The stack transitional behavior, in sequential order, is:  
  
1.  `value` is pushed onto the stack.  
  
2.  `value` is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.  
  
3.  If the conversion is successful, the resulting value is pushed onto the stack.  
  
 The **languageKeyword tag is not supported!!!!**  
 opcode converts the **parameterReference tag is not supported!!!!**  
 on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.  
  
 Conversions from floating\-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to **languageKeyword tag is not supported!!!!**  
 when they are loaded onto the evaluation stack \(unless **languageKeyword tag is not supported!!!!**  
 or **languageKeyword tag is not supported!!!!**  
 are used, in which case the result is also **languageKeyword tag is not supported!!!!**  
\).  
  
 <xref:System.OverflowException> is thrown if the result can not be represented in the result type.  
  
 The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the **languageKeyword tag is not supported!!!!**  
 opcode:  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上の符号なしの値に変換 <see langword="int8" /> にそれを拡張および <see langword="int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|82|conv.ovf.i1.un|符号なしの値に変換、 `int8` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.i1.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.i1.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上の符号付きの値に変換 <see langword="int16" /> 拡張するか、 <see langword="int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|B5|conv.ovf.i2|変換、 `int16` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.i2` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.i2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上の符号なしの値に変換 <see langword="int16" /> にそれを拡張および <see langword="int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|83|conv.ovf.i2.un|符号なしの値に変換、 `int16` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.i2.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.i2.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上の符号付きの値に変換 <see langword="int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|B7|conv.ovf.i4|変換、 `int32` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.i4` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.i4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上の符号なしの値に変換 <see langword="int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|84|conv.ovf.i4.un|符号なしの値に変換、 `int32` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.i4.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.i4.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上の符号付きの値に変換 <see langword="int64" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|B9|conv.ovf.i8|変換、 `int64` \(スタック上でとして `int64`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.i8` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.i8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上の符号なしの値に変換 <see langword="int64" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|85|conv.ovf.i8.un|符号なしの値に変換、 `int64` \(スタック上でとして `int64`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.i8.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.i8.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号付きの値を評価スタックの一番上に変換します <see langword="unsigned native int" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|D5|conv.ovf.u|変換、 `unsigned native int` \(スタック上でとして `native int`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.u` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.u` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なしの値を評価スタックの一番上に変換 <see langword="unsigned native int" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|8B|conv.ovf.u.un|値を符号、 `unsigned native int` \(スタック上でとして `native int`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.u.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.uvf.u.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号付きの値を評価スタックの一番上に変換 <see langword="unsigned int8" /> にそれを拡張および <see langword="int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|B4|conv.ovf.u1|変換、 `unsigned int8` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.u1` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.u1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なしの値を評価スタックの一番上に変換 <see langword="unsigned int8" /> にそれを拡張および <see langword="int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|86|conv.ovf.u1.un|符号なしの値に変換、 `unsigned int8` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.u1.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.u1.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号付きの値を評価スタックの一番上に変換 <see langword="unsigned int16" /> にそれを拡張および <see langword="int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|B6|conv.ovf.u2|変換、 `unsigned int16` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.u2` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.u2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なしの値を評価スタックの一番上に変換 <see langword="unsigned int16" /> にそれを拡張および <see langword="int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|87|conv.ovf.u2.un|符号なしの値に変換、 `unsigned int16` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.u2.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.u2.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号付きの値を評価スタックの一番上に変換します <see langword="unsigned int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|B8|conv.ovf.u4|変換、 `unsigned int32` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.u4` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u`を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.u4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なしの値を評価スタックの一番上に変換 <see langword="unsigned int32" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|88|conv.ovf.u4.un|符号なしの値に変換、 `unsigned int32` \(スタック上でとして `int32`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.u4.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.u4.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号付きの値を評価スタックの一番上に変換します <see langword="unsigned int64" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|BA|conv.ovf.u8|変換、 `unsigned int64` \(スタック上でとして `int64`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.u8` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.u8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なしの値を評価スタックの一番上に変換 <see langword="unsigned int64" />, スロー、 <see cref="T:System.OverflowException" /> オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|89|conv.ovf.u8.un|符号なしの値に変換、 `unsigned int64` \(スタック上でとして `int64`\)、オーバーフローについての例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.ovf.u8.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位の場所で指定された種類のスタックの一番上です。 値が大きすぎるか、対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.ovf.i` または `conv.ovf.u` を使用する場合は結果も `native int`\)。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.ovf.u8.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値を評価スタックの一番上に変換 <see langword="float32" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|76|conv.r.un|変換する符号なし整数、浮動小数点プッシュ `F` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.r.un` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 浮動小数点型を整数に変換するオーバーフローが発生した場合、 `result` が返されますが指定されていません。`conv.r.un` 操作は、整数をスタックからを取得し、、署名されていないと解釈します。 整数を表す浮動小数点数に置き換えられます。 いずれか、 `float32`, 精度の損失のない整数を表すの十分な場合、またはしない場合、 `float64`です。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.r.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="float32" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|6B|conv.r4|変換 `float32`, プッシュ、 `F` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.r4` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.r4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="float64" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|6C|conv.r8|変換 `float64`, プッシュ、 `F` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.r8` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.r8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="unsigned native int" />, にそれを拡張および <see langword="native int" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|E0|conv.u|変換 `unsigned native int`, プッシュ、 `native int` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.u` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> と <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> 結果型は、結果の値を正しく表すことができない場合に例外をスローする手順については等価です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.u` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="unsigned int8" />, にそれを拡張および <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|D2|conv.u1|変換 `int8`, プッシュ、 `int32` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.u1` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> と <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> 結果型は、結果の値を正しく表すことができない場合に例外をスローする手順については等価です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.u1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="unsigned int16" />, にそれを拡張および <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|D1|conv.u2|変換 `int16`, プッシュ、 `int32` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.u2` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> と <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> 結果型は、結果の値を正しく表すことができない場合に例外をスローする手順については等価です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.u2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="unsigned int32" />, にそれを拡張および <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|6 D|conv.u4|変換 `unsigned int32`, プッシュ、 `int32` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.u4` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> と <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> 結果型は、結果の値を正しく表すことができない場合に例外をスローする手順については等価です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.u4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値に変換 <see langword="unsigned int64" />, にそれを拡張および <see langword="int64" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|6E|conv.u8|変換 `int64`, プッシュ、 `int64` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックとの変換から操作を行おうとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュします。  
  
 `conv.u8` オペコードに変換、 `value` オペレーション コード、および変換した値をスタックの最上位のままにして指定された型にスタックの上にします。 4 バイト未満の整数値に拡張されます `int32` を評価スタックに読み込まれるとき \(しない限り、 `conv.i` または `conv.u` を使用する場合は結果も `native int`\)。 浮動小数点値に変換する、 `F` 型です。  
  
 浮動小数点数から整数値への変換では、数値 0 の方向に切り捨てられます。 変換するときに、 `float64` に、 `float32`, 、精度が失われることができます。 場合 `value` に収まるように大きすぎる、 `float32 (F)`, 、正の無限大 \(場合 `value` が正の値\) または負の無限大 \(場合 `value` が負の値\) が返されます。 変換中の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、 `int32`, 、値が符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> と <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> 結果型は、結果の値を正しく表すことができない場合に例外をスローする手順については等価です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `conv.u8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソース アドレスから指定した数のバイトを宛先アドレスにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 17|cpblk|データを別の 1 つのメモリ ブロックにコピーします。|  
  
 履歴の移行動作を順番には。  
  
1.  送信先アドレスは、スタックにプッシュされます。  
  
2.  送信元アドレスは、スタックにプッシュされます。  
  
3.  コピーするバイト数は、スタックにプッシュされます。  
  
4.  バイトの数、送信元アドレス、宛先アドレスがスタックからポップされます。指定したバイト数は、発信元アドレスから宛先アドレスにコピーされます。  
  
 `cpblk` 命令された数のコピー \(型 `unsigned int32`\) ソース アドレスからのバイトの \(型の `*`, 、`native int`, 、または `&`\) 送信先のアドレス \(型の `*`, 、`native int`, 、または `&`\)。 動作 `cpblk` 元とコピー先の領域が重なっている場合は指定されていません。  
  
 `cpblk` ソースと宛先アドレスの両方をマシンの元のサイズにアラインされることを想定しています。`cpblk` 命令のすぐ前に、 `unaligned.<prefix>` 命令がソースまたは転送先のいずれかに整列がないことを示します。  
  
 操作、 `cpblk` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされる可能性ができます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `cpblk` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトのアドレスにある値型のコピー \(型 <see langword="&amp;" />, 、<see langword="*" /> または <see langword="native int" />\) 対象オブジェクトのアドレス \(型 <see langword="&amp;" />, 、<see langword="*" /> または <see langword="native int" />\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|70 \< `T` \>|コピー `classTok`|値のコピーをソース オブジェクトからコピー先のオブジェクトに入力します。|  
  
 履歴の移行動作を順番には。  
  
1.  移行先のオブジェクト参照は、スタックにプッシュされます。  
  
2.  ソース オブジェクトの参照は、スタックにプッシュされます。  
  
3.  2 つのオブジェクト参照がスタックからポップされます。ソース オブジェクトのアドレスの値の型は、目的のオブジェクトのアドレスにコピーされます。  
  
 動作 `cpobj` 元とコピー先のオブジェクトの参照がクラス トークンによって表されるクラスのインスタンスへのポインターでない場合に指定されていない `classTok` \(、 `typeref` または `typedef`\)、または `classTok` 値の型は表しません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされる可能性ができます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `cpobj` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を除算し、結果として、浮動小数点のプッシュ \(型 <see langword="F" />\) または商 \(型 <see langword="int32" />\) を評価スタックにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|5B|div|商または浮動小数点の結果を返す 2 つの値を除算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value1` で割った値 `value2`です。  
  
4.  結果は、スタックにプッシュされます。  
  
 `result` \= `value1` div value2 が次の条件を満たします。  
  
 &#124; `result` &#124; \= &#124; `value1` &#124;\/ &#124; `value2` &#124; とします。  
  
 記号 \(`result`\) \= \+, に署名する場合 \(`value1`\) \= 記号 \(`value2`\)、または \- 場合は、記号 \(`value1`\) ~ \= 記号 \(`value2`\)  
  
 `div` 命令は、結果を計算し、スタックにプッシュします。  
  
 整数の除算はゼロに向かって切り捨てられます。  
  
 限られた数 0 による除算では、正しく署名付きの無限の値を生成します。  
  
 0 を 0 または無限の無限大 NaN \(Not A Number\) 値を除算します。 任意の数が無限で割った値ゼロの値が生成されます。  
  
 整数演算スロー <xref:System.ArithmeticException> 場合は、結果は、結果の型で表すことはできません。 これが起こる場合 `value1` が最大の負の値と `value2` \-1 です。  
  
 整数演算スロー <xref:System.DivideByZeroException> 場合 `value2` ゼロです。  
  
 Intel ベース プラットフォームに注意してください、 <xref:System.OverflowException> \(minint div\-1\) を計算するときにスローされます。 浮動小数点演算 \(生成される小数点代わりに\) 例外はスローされません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `div` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を除算し、結果をプッシュ \(<see langword="int32" />\) を評価スタックにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|5C|div.un 命令|2 つの値、署名なし、し、商を返すことを分割します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value1` で割った値 `value2`です。  
  
4.  結果は、スタックにプッシュされます。  
  
 `div.un` 命令計算 `value1` で割った値 `value2`, 、どちらも、符号なし整数とプッシュとして、 `result` スタックにします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `div.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にある値をコピーし、そのコピーを評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|25|dup|スタックの上部にある値を複製します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` 重複のスタックからポップされます。  
  
3.  `value` スタックにプッシュ バックします。  
  
4.  重複する値は、スタックにプッシュされます。  
  
 `dup` 命令がスタックの最上位の要素を複製し、2 つの同一の値を残します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `dup` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>制御を転送、 <see langword="filter" /> 共通言語基盤 \(CLI\) 例外ハンドラー、例外の句。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 11|endfilter|SEH 例外処理のフィルター句を終了します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` スタックからポップされます。 `endfilter` が実行されると、例外ハンドラーに制御が移ります。  
  
 `Value` \(型でなければならない `int32` は特定の値セットの 1 つ\) がフィルター句から返されます。 いずれかを指定する必要があります。  
  
-   `exception_continue_search` \(`value` \= 0\) 例外ハンドラーの検索を続行するには  
  
-   `exception_execute_handler` \(`value` \= 1\)、2 つ目を開始する finally ブロックが実行されるまで、このフィルター句を使用して、ハンドラーが関連付けられている例外処理の段階が配置されています。 探索時に、ハンドラーが実行されます。  
  
 その他の整数値を指定されていない結果となります。  
  
 フィルターのエントリ ポイント メソッドの例外の表に示すようにするとフィルターのコード ブロックの最初の命令がある必要があります。`endfilter` 命令はフィルターのコード ブロックの最後の命令である必要があります \(したがってが 1 つになります `endfilter` の任意の 1 つのフィルター ブロック\) します。 実行した後、 `endfilter` 命令の制御に論理的にフロー CLI 例外処理機構にします。  
  
 例外処理機構を通じて場合を除き、フィルター ブロックに制御を転送できません。 フィルター ブロックの以外を使用すると、制御を転送できません、 `throw` 命令または最後に実行することによって `endfilter` 命令します。 埋め込むことはできません、 `try` ブロック内で、 `filter` ブロックします。 内部例外がスローされた場合、 `filter` ブロック、途中で傍受されて、値 0 \(`exception_continue_search`\) が返されます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `endfilter` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>制御を転送、 <see langword="fault" /> または <see langword="finally" /> 共通言語基盤 \(CLI\) 例外ハンドラー例外ブロックの句。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|DC|endfinally<br /><br /> endfault|終了、 `finally` または `fault` 例外ブロックの句。|  
  
 スタックこの命令の遷移の動作はありません。  
  
 `Endfinally` `endfault` の終了を知らせる、 `finally` または `fault` 句のため、例外ハンドラーが呼び出されるまでそのスタック アンワインドを続行できます。`endfinally` または `endfault` 命令が CLI 例外処理機構に制御を転送します。 次が検索され、メカニズム `finally` のままにして命令で保護されたブロックが終了した場合、チェーン内の句。 CLI の検索は次の場合は、保護されたブロックは、例外によって終了された、 `finally` または `fault`, 、または例外処理の最初のパスで選択した例外ハンドラーを入力します。  
  
 `endfinally` 命令が構文的に内に表示されるのみ、 `finally` ブロックします。 異なり、 `endfilter` 命令で、ブロックが終了する必要はありません、 `endfinally` 命令、およびが多くあります `endfinally` 必要なブロック内の指示します。 これらの同じ制限があります、 `endfault` 命令と `fault` ブロックします。  
  
 制御を転送できません、 `finally` \(または `fault`\) を除く例外処理機構を通じてをブロックします。 制御を転送できません、 `finally` \(または `fault`\) 以外の使用によりブロック、 `throw` 命令またはを実行する、 `endfinally` \(または `endfault`\) 命令します。 具体的には、することはできません"out"から落下、 `finally` \(または `fault`\) ブロックまたは実行する、 <xref:System.Reflection.Emit.OpCodes.Ret> または <xref:System.Reflection.Emit.OpCodes.Leave> 内の命令、 `finally` \(または `fault`\) ブロックします。  
  
 注意してください、 `endfault` と `endfinally` 命令はエイリアスであるため同じオペコードに対応します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `endfinally` \(`endfault`\) オペコード、だけでなく、 `ILGenerator` メソッド <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>します。  
  
-   ILGenerator.Emit\(OpCode\)  
  
-   ILGenerator.EndExceptionBlock\(\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のアドレスの指定したメモリ ブロックを、指定のサイズと初期値に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 18|initblk|指定された値のメモリのブロックでは、それぞれの場所を設定します。|  
  
 履歴の移行動作を順番には。  
  
1.  開始アドレスは、スタックにプッシュされます。  
  
2.  初期値は、スタックにプッシュされます。  
  
3.  初期化するためにバイト数は、スタックにプッシュされます。  
  
4.  バイト、初期値、および開始アドレスの数が、スタックからポップされ、これらの値に従って初期化を実行します。  
  
 `initblk` 命令数を設定します \(`unsigned int32`\)、指定したアドレスで始まるバイト \(型の `native int`, 、`&`, 、または `*`\) 初期化値 \(型の `unsigned int8`\)。`initblk` 開始アドレスが、マシンの元のサイズに合わせて配置されると仮定します。  
  
 操作、 `initblk` 、すぐに前の手順を変更できます <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> 命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされる可能性ができます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `initblk` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したアドレスにある値型の各フィールドを null 参照または適切なプリミティブ型の 0 に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 15 \< `T` \>|`initobj` `typeTok`|値の型を初期化します。|  
  
 履歴の移行動作を順番には。  
  
1.  初期化するために、値型のアドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。種類として、指定したアドレスにある値型が初期化された `typeTok`します。  
  
 `initobj` 命令がプッシュされたアドレスで指定された値型の各フィールドを初期化します \(型の `native int`, 、`&`, 、または `*`\) null 参照または適切なプリミティブ型の 0 にします。 このメソッドが呼び出された後、インスタンスが呼び出されるコンス トラクター メソッドの準備ができています。 場合 `typeTok` 、参照型では、この命令と同じ効果 `ldnull` 続けて `stind.ref`します。  
  
 異なり <xref:System.Reflection.Emit.OpCodes.Newobj>, 、`initobj` コンス トラクター メソッドを呼び出しません。`Initobj` 一方の値の型の初期化を目的として `newobj` の割り当てし、オブジェクトの初期化に使用します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `initobj` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照するかどうかをテスト \(型 <see langword="O" />\)、特定のクラスのインスタンスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|75 \< `T` \>|isinst `class`|オブジェクト参照がのインスタンスであるかどうか `class`, null 参照またはそのクラスのインスタンスを返すこと、またはインターフェイスします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、参照で渡されたクラスのインスタンスであるかどうかに、テスト `class`します。  
  
3.  結果 \(オブジェクト参照または null 参照\) は、スタックにプッシュされます。  
  
 `Class` メタデータ トークンは、目的のクラスを示します。 スタックの上部にあるオブジェクトのクラスを実装するかどうかは `class` \(場合 `class` インターフェイス\) の派生クラスは、または `class` \(場合 `class` 通常のクラスは、\) 型にキャストし、 `class` し、結果は、スタックにプッシュを正確にかのよう <xref:System.Reflection.Emit.OpCodes.Castclass> が呼び出されています。 それ以外の場合、null 参照がスタックにプッシュされます。 オブジェクト参照自体が null 参照し、 `isinst` 同様に null 参照を返します。  
  
 <xref:System.TypeLoadException> クラスが見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換された場合に検出します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `isinst` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドを終了し、指定したメソッドにジャンプします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|27 \< `T` \>|jmp `method`|現在のメソッドを終了し、指定したメソッドにジャンプします。|  
  
 スタックこの命令の遷移の動作はありません。  
  
 `jmp` \(移動\) の命令は、によって指定されたメソッドに制御を転送 `method`, 、これはメソッド参照のメタデータ トークン。 現在の引数は、先のメソッドに転送されます。  
  
 この命令を実行すると、評価スタックに空にする必要があります。 呼び出し規約、数、および宛先アドレスにある引数の型は、現在のメソッドのと一致する必要があります。  
  
 `jmp` 命令は、転送の制御を使用することはできません、 `try`, 、`filter`, 、`catch`, 、または `finally` ブロックします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `jmp` オペコード。  
  
-   ILGenerator.Emit \(オペコード、MethodInfo\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したインデックス値によって参照される引数をスタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 09 \< `unsigned int16` \>|ldarg `index`|引数を読み込む `index` をスタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  引数値 `index` スタックにプッシュします。  
  
 `ldarg` 命令がインデックスの引数にプッシュ `index`, 、位置引数インデックスは 0 から、評価スタックにします。`ldarg` 命令は、受信引数からコピーすることで、値型またはプリミティブ値をスタックの読み込みに使用できます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 可変長の引数リストを取得する手順については、 `ldarg` 命令は、最初の可変部分の署名のでなく、その引数を固定にのみ使用できます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Arglist> 詳細については、命令\)。  
  
 4 バイト長より小さい整数値を保持している引数を入力に拡張されます `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldarg` オペコード。  
  
-   ILGenerator.Emit \(オペコード、short\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 0 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|02|ldarg.0|引数 0 をスタックに読み込みます|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 0 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.0` 命令は、インデックス 0 の引数の値を読み込むための効率的なエンコーディングします。  
  
 `ldarg.0` 命令は引数のインデックスが 0 を評価スタックにプッシュします。`ldarg.0` 命令は、受信引数からコピーすることで、値型またはプリミティブ値をスタックの読み込みに使用できます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を入力に拡張されます `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldarg.0` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 1 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|03|ldarg.1|引数に 1 をスタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 1 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.1` 命令は、インデックス 1 の引数の値を読み込むための効率的なエンコーディングします。  
  
 `ldarg.1` 命令は引数のインデックスが 1 を評価スタックにプッシュします。`ldarg.1` 命令は、受信引数からコピーすることで、値型またはプリミティブ値をスタックの読み込みに使用できます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を入力に拡張されます `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldarg.1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 2 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|04|ldarg.2|引数 2 をスタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 2 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.2` 命令は、インデックス 2 の引数の値を読み込むための効率的なエンコーディングします。  
  
 `ldarg.2` 命令は引数のインデックスが 2 を評価スタックにプッシュします。`ldarg.2` 命令は、受信引数からコピーすることで、値型またはプリミティブ値をスタックの読み込みに使用できます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を入力に拡張されます `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldarg.2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 3 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|05|ldarg.3|引数に 3 をスタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 3 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.3` 命令はインデックス 3 の引数の値を読み込むため、効率的なエンコーディングします。  
  
 `ldarg.3` 命令は引数のインデックスが 3 を評価スタックにプッシュします。`ldarg.3` 命令は、受信引数からコピーすることで、値型またはプリミティブ値をスタックの読み込みに使用できます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を入力に拡張されます `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldarg.3` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した短い形式のインデックスによって参照される引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|0 E \< `unsigned int8` \>|ldarg.s `index`|引数を読み込む `index` スタックに短縮形です。|  
  
 履歴の移行動作を順番には。  
  
1.  引数値 `index` スタックにプッシュします。  
  
 `ldarg.s` 命令はインデックスの引数を読み込む 4 ~ 255 の効率的なエンコーディングします。  
  
 `ldarg.s` 命令がインデックスの引数にプッシュ `index`, 、位置引数インデックスは 0 から、評価スタックにします。`ldarg.s` 命令は、受信引数からコピーすることで、値型またはプリミティブ値をスタックの読み込みに使用できます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 可変長の引数リストを取得する手順については、 `ldarg.s` 命令は、最初の可変部分の署名のでなく、その引数を固定にのみ使用できます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Arglist> 詳細については、命令\)。  
  
 4 バイト長より小さい整数値を保持している引数を入力に拡張されます `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldarg.s` オペコード。  
  
-   ILGenerator.Emit オペコード \(バイト\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引数アドレスを評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 0A \< `unsigned int16` \>|ldarga `index`|インデックスが引数のアドレスをフェッチ `index`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレス `addr` によってインデックス付けされた引数の `index` スタックにプッシュします。  
  
 `ldarga` 命令アドレスを取得する \(型の `*`\) によってインデックス付けされた引数の `index`, 引数が、インデックスは 0 以降から、します。 アドレス `addr` は常に、ターゲット コンピューター上の標準の境界に配置します。  
  
 可変長の引数リストを取得する手順については、 `ldarga` 命令は、最初の可変部分の署名のでなく、その引数を固定にのみ使用できます。  
  
 `ldarga` 参照渡しによるパラメーターの引き渡しに使用されます。 それ以外の場合の <xref:System.Reflection.Emit.OpCodes.Ldarg> と <xref:System.Reflection.Emit.OpCodes.Starg> 使用する必要があります。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldarga` オペコード。  
  
-   ILGenerator.Emit \(オペコード、short\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引数アドレス \(短い形式\) を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|0F \< `unsigned int8` \>|ldarga.s `index`|インデックスが引数のアドレスをフェッチ `index`, 、短縮形です。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレス `addr` によってインデックス付けされた引数の `index` スタックにプッシュします。  
  
 `ldarga.s` \(短い形式の `ldarga`\)引数番号 0 ~ 255 に使用する必要があり、効率的なエンコーディングがします。  
  
 `ldarga.s` 命令アドレスを取得する \(型の`*`\) によってインデックス付けされた引数の `index`, 引数が、インデックスは 0 以降から、します。 アドレス `addr` は常に、ターゲット コンピューター上の標準の境界に配置します。  
  
 可変長の引数リストを取得する手順については、 `ldarga.s` 命令は、最初の可変部分の署名のでなく、その引数を固定にのみ使用できます。  
  
 `ldarga.s` 参照渡しによるパラメーターの引き渡しに使用されます。 それ以外の場合の <xref:System.Reflection.Emit.OpCodes.Ldarg_S> と <xref:System.Reflection.Emit.OpCodes.Starg_S> 使用する必要があります。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldarga.s` オペコード。  
  
-   ILGenerator.Emit オペコード \(バイト\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の指定された値をプッシュ<see langword="int32" />として評価スタックに、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language \(MSIL\) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|20 \< `int32` \>|目 ldc.i4`num`|値をプッシュ`num`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値`num`スタックにプッシュされます。  
  
 整数\-128 ~ 127、エンコードと特に短いエンコードの\-1 ~ 8 についての特殊な短い \(とそのためより効率的な\) エンコーディングがあることに注意してください。 すべての短いエンコーディングは、4 バイト整数をスタックにプッシュします。 8 バイト整数 4、8 バイト浮動小数点数と短い形式に適合しない 4 バイト値の長いエンコーディングが使用されます。 8 バイト整数定数をスタックにプッシュする 3 つの方法します。  
  
 1.使用して、 <xref:System.Reflection.Emit.OpCodes.Ldc_I8> 32 ビット以上で表現する必要がある定数の命令。  
  
 2.使用して、<xref:System.Reflection.Emit.OpCodes.Ldc_I4>命令を実行して、 <xref:System.Reflection.Emit.OpCodes.Conv_I8> 9 を 32 ビットを必要とする定数をします。  
  
 3.続けて、短い形式の命令を使用して、 <xref:System.Reflection.Emit.OpCodes.Conv_I8> 8 個以下のビット単位で表すことができる定数。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4`オペコード。  
  
-   ILGenerator.Emit \(オペコード、int\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を 0 として評価スタックにプッシュする <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|16|ldc.i4.0|0 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 0 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.0` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 1 として評価スタックにプッシュする <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|17|ldc.i4.1|1 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 1 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 2 として評価スタックにプッシュする <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|18|ldc.i4.2|2 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 2 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 3 として評価スタックにプッシュする <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|19|ldc.i4.3|3 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 3 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.3` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに 4 プッシュ、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|1A|ldc.i4.4|4 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 4 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに 5 のプッシュ、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|1B|ldc.i4.5|5 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 5 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.5` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに 6 のプッシュ、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|1 C|ldc.i4.6|6 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 6 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.6` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに 7 プッシュ、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|1D|ldc.i4.7|7 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  7 という値は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.7` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに 8 のプッシュ、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|1E|ldc.i4.8|8 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  8 の値は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を\-1 として評価スタックにプッシュする <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|15|ldc.i4.m1|\-1 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値\-1 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.m1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたプッシュ <see langword="int8" /> 値として評価スタックに、 <see langword="int32" />, 、短縮形です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|1F \< `int8` \>|ldc.i4.s `num`|プッシュ `num` としてスタックに `int32`, 、短縮形です。|  
  
 履歴の移行動作を順番には。  
  
1.  値 `num` スタックにプッシュします。  
  
 `ldc.i4.s` \-128 127 の整数を評価スタックにプッシュをより効率的なエンコーディングです。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i4.s` オペコード。  
  
-   ILGenerator.Emit オペコード \(バイト\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定された型の値をプッシュ <see langword="int64" /> として評価スタックに、 <see langword="int64" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|21 \< `int64` \>|場合は、ldc.i8 `num`|プッシュ `num` としてスタックに `int64`します。|  
  
 履歴の移行動作を順番には。  
  
1.  値 `num` スタックにプッシュします。  
  
 このエンコーディング、 `int64` の値をスタックします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.i8` オペコード。  
  
-   ILGenerator.Emit \(オペコード、長い\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定された型の値をプッシュ <see langword="float32" /> 型として評価スタックに <see langword="F" /> \(float\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|22 \< `float32` \>|ldc.r4 `num`|プッシュ `num` としてスタックに `F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  値 `num` スタックにプッシュします。  
  
 このエンコーディング、 `float32` の値をスタックします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.r4` オペコード。  
  
-   ILGenerator.Emit \(オペコード、1 つ\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定された型の値をプッシュ <see langword="float64" /> 型として評価スタックに <see langword="F" /> \(float\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|23 \< `float64` \>|ldc.r8 `num`|プッシュ `num` としてスタックに `F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  値 `num` スタックにプッシュします。  
  
 このエンコーディング、 `float64` の値をスタックします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldc.r8` オペコード。  
  
-   ILGenerator.Emit \(オペコード、double\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの要素を命令で指定された型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|A3 \< `T` \>|ldelem `typeTok`|要素を読み込みます `index` 型としてのスタックの一番上に `typeTok`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクトで、型の値によって表されるので `O`します。  
  
 戻り値の型が、トークンで指定された `typeTok` 命令にします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはの上限を超える `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の要素を読み込みます <see langword="native int" /> として評価スタックの一番上に指定した配列インデックスにある、 <see langword="native int" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|97|ldelem.i|型の要素を読み込みます `native int` で `index` としてスタックの一番上に、 `native int`です。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.i` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.i` は `native int`です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.i` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の要素を読み込みます <see langword="int8" /> として評価スタックの一番上に指定した配列インデックスにある、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|90|ldelem.i1|型の要素を読み込みます `int8` で `index` としてスタックの一番上に、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.i1` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.i1` は `int8`です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.i1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の要素を読み込みます <see langword="int16" /> として評価スタックの一番上に指定した配列インデックスにある、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|92|ldelem.i2|型の要素を読み込みます `int16` で `index` としてスタックの一番上に、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.i2` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.i2` は `int16`です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.i2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の要素を読み込みます <see langword="int32" /> として評価スタックの一番上に指定した配列インデックスにある、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|94|ldelem.i4|型の要素を読み込みます `int32` で `index` としてスタックの一番上に、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.i4` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.i4` は `int32`です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.i4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の要素を読み込みます <see langword="int64" /> として評価スタックの一番上に指定した配列インデックスにある、 <see langword="int64" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|96|ldelem.i8|型の要素を読み込みます `int64` で `index` としてスタックの一番上に、 `int64`です。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.i8` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.i8` は `int64`です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.i8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の要素を読み込みます <see langword="float32" /> 型として評価スタックの一番上に指定した配列インデックスにある <see langword="F" /> \(float\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|98|ldelem.r4|型の要素を読み込みます `float32` で `index` 型としてのスタックの一番上に `F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.r4` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.r4` は `float32`です。  
  
 浮動小数点値が型に変換されます `F` を評価スタックに読み込まれるときにします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.r4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の要素を読み込みます <see langword="float64" /> 型として評価スタックの一番上に指定した配列インデックスにある <see langword="F" /> \(float\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|99|ldelem.r8|型の要素を読み込みます `float64` で `index` 型としてのスタックの一番上に `F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.r8` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.r8` は `float64`です。  
  
 浮動小数点値が型に変換されます `F` を評価スタックに読み込まれるときにします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.r8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックス型として評価スタックの一番上にオブジェクト参照を含む要素を読み込みます <see langword="O" /> \(オブジェクト参照\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|9A|ldelem.ref|オブジェクト参照を持つ要素を読み込む `index` 型としてのスタックの一番上に `O`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.ref` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.ref` 型は、 `O` \(オブジェクト参照\)。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.ref` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の要素を読み込みます <see langword="unsigned int8" /> として評価スタックの一番上に指定した配列インデックスにある、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|91|ldelem.u1|型の要素を読み込みます `unsigned int8` で `index` としてスタックの一番上に、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.u1` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.u1` は `int8`です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.u1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の要素を読み込みます <see langword="unsigned int16" /> として評価スタックの一番上に指定した配列インデックスにある、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|93|ldelem.u2|型の要素を読み込みます `unsigned int16` としてスタックの一番上にインデックスにある、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.u2` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.u2` は `int16`です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.u2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の要素を読み込みます <see langword="unsigned int32" /> として評価スタックの一番上に指定した配列インデックスにある、 <see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|95|ldelem.u4|型の要素を読み込みます `unsigned int32` としてスタックの一番上にインデックスにある、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされます。 位置に格納されている値 `index` で `array` を検索します。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.u4` 命令のインデックスを持つ要素の値を読み込む `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。  
  
 戻り値 `ldelem.u4` は `int32`です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 配列が必要な型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelem.u4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型として評価スタックの一番上に指定した配列インデックスにある配列要素のアドレスをロード <see langword="&amp;" /> \(マネージ ポインター\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|8 F \< `T` \>|ldelema `class`|位置にある配列要素のアドレスをロード `index` 型として評価スタックの一番上に `&` \(マネージ ポインター\)。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `array` スタックにプッシュします。  
  
2.  インデックス値 `index` スタックにプッシュします。  
  
3.  `index` `array` スタックからポップされた位置に格納されているアドレス `index` で `array` を検索するとします。  
  
4.  アドレスは、スタックにプッシュされます。  
  
 `ldelema` オブジェクトの配列内の特定のインデックスにあるオブジェクトのアドレスを取得するために使用 \(型の `class`\)。`ldelema` 命令は、インデックス位置にある値のアドレスをロード `index` \(型 `native int`\) 0 から始まる 1 次元配列で `array` され、スタックの一番上に配置します。 配列オブジェクト、型の値によって表されるので `O`します。 値型でなければなりません `class` の命令で渡されます。  
  
 戻り値 `ldelema` マネージ ポインター \(型 `&`\)。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldelema` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照が現在評価スタック上にあるオブジェクト内のフィールドの値を検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|7B \< `T` \>|ldfld `field`|指定したオブジェクトをスタック内のフィールドの値をプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 \(またはポインター\) は、スタックにプッシュされます。  
  
2.  オブジェクト参照 \(またはポインター\) がスタックからポップされます。オブジェクト内の指定したフィールドの値が存在するとします。  
  
3.  フィールドに格納されている値は、スタックにプッシュされます。  
  
 `ldfld` 命令がスタックにオブジェクトにあるフィールドの値にプッシュします。 オブジェクトがオブジェクト参照と、スタック上に存在する必要があります \(型 `O`\)、マネージ ポインター \(型 `&`\)、アンマネージ ポインター \(型 `native int`\)、一時的なポインター \(型 `*`\)、または値型のインスタンス。 検証可能なコードでは、アンマネージ ポインターは使用できません。 オブジェクトのフィールドは、必ずフィールド メンバーを参照しているメタデータ トークンを指定します。 戻り値の型は、フィールドに関連付けられているものと同じです。 インスタンス フィールド \(その場合、オブジェクトあってはいけません null 参照\) または静的フィールドのいずれかのフィールドがあります。  
  
 `ldfld` 命令の前に、いずれかまたは両方の <xref:System.Reflection.Emit.OpCodes.Unaligned> と <xref:System.Reflection.Emit.OpCodes.Volatile> プレフィックス。  
  
 <xref:System.NullReferenceException> オブジェクトが null とフィールドが静的でない場合にスローされます。  
  
 <xref:System.MissingFieldException> 指定したフィールドは、メタデータ内で見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換する場合にチェックします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldfld` オペコード。  
  
-   ILGenerator.Emit \(オペコード、最後に\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照が現在評価スタック上にあるオブジェクト内のフィールドのアドレスを検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|7C \< `T` \>|ldflda `field`|アドレス プッシュ `field` をスタックに指定されたオブジェクト。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 \(またはポインター\) は、スタックにプッシュされます。  
  
2.  オブジェクト参照 \(またはポインター\) がスタックからポップされます。オブジェクト内の指定したフィールドのアドレスを検出します。  
  
3.  指定したフィールドのアドレスは、スタックにプッシュされます。  
  
 `ldflda` 命令がスタックにオブジェクトにあるフィールドのアドレスにプッシュします。 オブジェクトがオブジェクト参照と、スタック上に存在する必要があります \(型 `O`\)、マネージ ポインター \(型 `&`\)、アンマネージ ポインター \(型 `native int`\)、一時的なポインター \(型 `*`\)、または値型のインスタンス。 検証可能なコードでは、アンマネージ ポインターは使用できません。 オブジェクトのフィールドは、必ずフィールド メンバーを参照しているメタデータ トークンを指定します。  
  
 によって返される値 `ldflda` マネージ ポインター \(型 `&`\) オブジェクトがアンマネージ ポインターとしてスタックにプッシュされた、しない限り、その場合のリターン アドレスもアンマネージ ポインター \(型 `native int`\)。  
  
 `ldflda` 命令の前に、いずれかまたは両方の <xref:System.Reflection.Emit.OpCodes.Unaligned> と <xref:System.Reflection.Emit.OpCodes.Volatile> プレフィックス。  
  
 <xref:System.InvalidOperationException> オブジェクトがアクセス元となるアプリケーション ドメイン内にない場合にスローされます。 アクセス中のアプリケーション ドメイン内にないフィールドのアドレスをロードできません。  
  
 <xref:System.NullReferenceException> オブジェクトが null とフィールドが静的でない場合にスローされます。  
  
 <xref:System.MissingFieldException> 指定したフィールドは、メタデータ内で見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換する場合にチェックします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldflda` オペコード。  
  
-   ILGenerator.Emit \(オペコード、最後に\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アンマネージ ポインター プッシュ \(型<see langword="native int" />\) を評価スタックに特定のメソッドを実装しているネイティブ コードにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表は、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language \(MSIL\) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 06 \<\>`T` \>|ldftn`method`|によって参照されるメソッドへのポインターをプッシュ`method`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  特定のメソッドへのアンマネージ ポインターは、スタックにプッシュされます。  
  
 特定のメソッド \(`method`\) を使用して呼び出すことができます、<xref:System.Reflection.Emit.OpCodes.Calli>命令マネージ メソッド \(またはアンマネージ コードにマネージ コードから遷移をスタブ\) を参照する場合。  
  
 値には、CLR 呼び出し規約を使用してネイティブ コードにポイントが返されます。 このメソッドのポインターは、コールバック ルーチンとしてアンマネージ ネイティブ コードに渡すことはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldftn`オペコード。  
  
-   ILGenerator.Emit \(オペコード、MethodInfo\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込む <see langword="native int" /> として、 <see langword="native int" /> スタック、評価に間接的にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|4 D|ldind.i|読み込み、 `native int` アドレスに `addr` としてスタックに、 `native int`です。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  取得した値は、スタックにプッシュされます。  
  
 `ldind.i` いない命令を直接読み込みます、 `native int` 、指定したアドレスからの値 \(型の `native int`, 、`&`, 、または \*\) としてスタックに、 `native int`です。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca> と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.i` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込む <see langword="int8" /> として、 <see langword="int32" /> スタック、評価に間接的にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|46|ldind.i1|読み込み、 `int8` アドレスに `addr` としてスタックに、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  取得した値は、スタックにプッシュされます.  
  
 `ldind.i1` いない命令を直接読み込みます、 `int8` 、指定したアドレスからの値 \(型の `native int`, 、`&`, 、または \*\) としてスタックに、 `int32`です。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca> と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.i1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込む <see langword="int16" /> として、 <see langword="int32" /> スタック、評価に間接的にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|48|ldind.i2|読み込み、 `int16` アドレスに `addr` としてスタックに、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  取得した値は、スタックにプッシュされます。  
  
 `ldind.i2` いない命令を直接読み込みます、 `int16` 、指定したアドレスからの値 \(型の `native int`, 、`&`, 、または \*\) としてスタックに、 `int32`です。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca>と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.i2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込む <see langword="int32" /> として、 <see langword="int32" /> スタック、評価に間接的にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|4A|ldind.i4|読み込み、 `int32` アドレスに `addr` としてスタックに、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  取得した値は、スタックにプッシュされます。  
  
 `ldind.i4` いない命令を直接読み込みます、 `int32` 、指定したアドレスからの値 \(型の `native int`, 、`&`, 、または \*\) としてスタックに、 `int32`です。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca> と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.i4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込む <see langword="int64" /> として、 <see langword="int64" /> スタック、評価に間接的にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|4 C|ldind.i8|読み込み、 `int64` アドレスに `addr` としてスタックに、 `int64`です。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  取得した値は、スタックにプッシュされます。  
  
 `ldind.i8` いない命令を直接読み込みます、 `int64` 、指定したアドレスからの値 \(型の `native int`, 、`&`, 、または \*\) としてスタックに、 `int64`です。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca> と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.i8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込む <see langword="float32" /> 型として <see langword="F" /> \(float\) を評価スタックに直接します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|4E|ldind.r4|読み込み、 `float32` アドレスに `addr` 型としてスタックに `F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  取得した値は、スタックにプッシュされます。  
  
 `ldind.r4` いない命令を直接読み込みます、 `float32` 、指定したアドレスからの値 \(型の `native int`, 、`&`, 、または \*\) を型としてスタックに `F`します。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca> と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.r4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込む <see langword="float64" /> 型として <see langword="F" /> \(float\) を評価スタックに直接します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|4F|ldind.r8|読み込み、 `float64` アドレスに `addr` 型としてスタックに `F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  取得した値は、スタックにプッシュされます。  
  
 `ldind.r8` いない命令を直接読み込みます、 `float64` 、指定したアドレスからの値 \(型の `native int`, 、`&`, 、または \*\) としてスタックに、 `float64`です。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca> と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.r8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型としてオブジェクト参照を読み込む <see langword="O" /> \(オブジェクト参照\)、評価スタックに直接します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|50|ldind.ref|アドレスでのオブジェクト参照を読み込む `addr` 型としてスタックに `O`|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにあるオブジェクトの参照を取得します。  
  
3.  フェッチされた参照は、スタックにプッシュされます。  
  
 `ldind.ref` 命令が、指定したアドレスのオブジェクト参照を直接読み込みます \(型の `native int`, 、`&`, 、または \*\) を型としてスタックに `O`します。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca> と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.ref` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込む <see langword="unsigned int8" /> として、 <see langword="int32" /> スタック、評価に間接的にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|47|ldind.u1|読み込み、 `unsigned int8` アドレスに `addr` としてスタックに、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  取得した値は、スタックにプッシュされます。  
  
 `ldind.u1` いない命令を直接読み込みます、 `unsigned int8` 、指定したアドレスからの値 \(型の`native int`, 、`&`, 、または \*\) としてスタックに、 `int32`です。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca> と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.u1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込む <see langword="unsigned int16" /> として、 <see langword="int32" /> スタック、評価に間接的にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|49|ldind.u2|読み込み、 `unsigned int16` アドレスに `addr` としてスタックに、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  取得した値は、スタックにプッシュされます。  
  
 `ldind.u2` いない命令を直接読み込みます、 `unsigned int16` 、指定したアドレスからの値 \(型の `native int`, 、`&`, 、または \*\) としてスタックに、 `int32`です。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca> と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.u2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込む <see langword="unsigned int32" /> として、 <see langword="int32" /> スタック、評価に間接的にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|4B|ldind.u4|読み込み、 `unsigned int32` アドレスに `addr` としてスタックに、 `int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  取得した値は、スタックにプッシュされます。  
  
 `ldind.u4` いない命令を直接読み込みます、 `unsigned int32` 、指定したアドレスからの値 \(型の `native int`, 、`&`, 、または \*\) としてスタックに、 `int32`です。  
  
 すべての `ldind` 手順については、ショートカット、 <xref:System.Reflection.Emit.OpCodes.Ldobj> 命令が対応する組み込みの値クラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください `int32` \(いない `native int`\) を評価スタックに読み込まれるとき。 浮動小数点値に変換する `F` を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft 中間言語 \(MSIL\) により、 `ldind` 命令は、ポインターの型と矛盾しない方法で使用します。  
  
 スタックに最初にプッシュされるアドレスは、コンピューター上のオブジェクトの元のサイズに合わせる必要がある、または <xref:System.NullReferenceException> 発生することができます \(を参照してください、 <xref:System.Reflection.Emit.OpCodes.Unaligned> 予防策の命令をプレフィックス\)。 アドレスを返すすべての MSIL 命令の結果 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloca> と <xref:System.Reflection.Emit.OpCodes.Ldarga>\) が、安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けは、\[ターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldind.u4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス番号が 0 から始まる 1 次元配列の要素数を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|8 E|ldlen|長さのプッシュ \(型の `natural unsigned int`\) スタック上、配列のです。|  
  
 履歴の移行動作を順番には。  
  
1.  配列へのオブジェクト参照は、スタックにプッシュされます。  
  
2.  配列の参照がスタックからポップされ、長さが計算されます。  
  
3.  長さは、スタックにプッシュされます。  
  
 配列オブジェクト、型の値によって表されるので `O`します。 長さとして返されて、 `natural unsigned int`です。  
  
 <xref:System.NullReferenceException> 配列の参照が null 参照である場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldlen` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 0C \< `unsigned int16` \>|ldloc `index`|インデックスのローカル変数を読み込む `index` をスタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  指定したインデックスのローカル変数の値がスタックにプッシュされます。  
  
 `ldloc` 命令はローカル変数が番号付き 0 以降の評価スタックに渡されたインデックス ローカル変数の数の内容をプッシュします。 ローカル変数は、メソッドの初期化フラグが true の場合にのみ、メソッドを入力する前に 0 に初期化されます。 65,535 がある \(2 ^16\-1\) 使用できるローカル変数 \(0 ~ 65,534\)。 可能性の高い実装は、特定のメソッドのローカル変数の合計数と共にのローカルの指標を追跡する 2 バイトの整数を使用するため、インデックス 65,535 は無効です。 65535 のインデックスが行われた有効な場合は、このようなメソッドのローカル変数の数を追跡する幅の整数を必要があります。  
  
 `ldloc.0`, 、`ldloc.1`, 、`ldloc.2`, 、および `ldloc.3` 手順については、最初の 4 つのローカル変数にアクセスするため、効率的なエンコーディングを提供します。  
  
 値の型は、メソッドのヘッダーに指定されているローカル変数の型と同じです。 4 バイト長が型に拡張されてよりも小さいパーティションつまりローカルの変数を参照してください `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldloc` オペコード。  
  
-   ILGenerator.Emit \(オペコード、LocalBuilder\)  
  
-   ILGenerator.Emit \(オペコード、short\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 0 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|06|ldloc.0|インデックス 0 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 0 のローカル変数の値がスタックにプッシュされます。  
  
 `ldloc.0` 特に効率的なエンコーディングの <xref:System.Reflection.Emit.OpCodes.Ldloc>, 、インデックス 0 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッドのヘッダーに指定されているローカル変数の型と同じです。 4 バイト長よりも小さくするローカル変数は、型に拡張されます `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldloc.0` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 1 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|07|ldloc.1|インデックス 1 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 1 のローカル変数の値がスタックにプッシュされます。  
  
 `ldloc.1` 特に効率的なエンコーディングの <xref:System.Reflection.Emit.OpCodes.Ldloc>, 、インデックス 1 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッドのヘッダーに指定されているローカル変数の型と同じです。 4 バイト長よりも小さくするローカル変数は、型に拡張されます `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldloc.1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 2 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|08|ldloc.2|インデックス 2 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 2 のローカル変数の値がスタックにプッシュされます。  
  
 `ldloc.2` 特に効率的なエンコーディングの <xref:System.Reflection.Emit.OpCodes.Ldloc>, 、インデックス 2 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッドのヘッダーに指定されているローカル変数の型と同じです。 4 バイト長よりも小さくするローカル変数は、型に拡張されます `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldloc.2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 3 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|09|ldloc.3|インデックス 3 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 3 のローカル変数の値がスタックにプッシュされます。  
  
 `ldloc.3` 特に効率的なエンコーディングの <xref:System.Reflection.Emit.OpCodes.Ldloc>, 、インデックス 3 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッドのヘッダーに指定されているローカル変数の型と同じです。 4 バイト長よりも小さくするローカル変数は、型に拡張されます `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldloc.3` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数を評価スタックに読み込みます \(短い形式\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|11 \< `unsigned int8` \>|ldloc.s `index`|インデックスのローカル変数を読み込む `index` スタックに短縮形です。|  
  
 履歴の移行動作を順番には。  
  
1.  指定したインデックスのローカル変数の値がスタックにプッシュされます。  
  
 `ldloc.s` 命令はローカル変数が番号付き 0 以降の評価スタックに渡されたインデックス ローカル変数の数の内容をプッシュします。 ローカル変数は、メソッドの初期化フラグが true の場合、メソッドを入力する前に 0 に初期化されます。 256 \(2 ^8\) ローカルで使用できる変数 \(0 ~ 255\) 省略形はより効率的なエンコーディング `ldloc`します。  
  
 値の型は、メソッドのヘッダーに指定されているローカル変数の型と同じです。 4 バイト長が型に拡張されてよりも小さいパーティションつまりローカルの変数を参照してください `int32` をスタックに読み込まれるとき。 浮動小数点値は、ネイティブのサイズに拡張されます \(型 `F`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldloc.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、LocalBuilder\)  
  
-   ILGenerator.Emit オペコード \(バイト\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE OD \< `unsigned int16` \>|ldloca `index`|ローカル変数のアドレスをロード `index` を評価スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  指定したインデックス位置のローカル変数に格納されているアドレスは、スタックにプッシュされます。  
  
 `ldloca` 命令は、ローカル変数は、番号 0 以降のスタックに渡されたインデックス ローカル変数の数のアドレスをプッシュします。 スタックにプッシュされた値が既に正しく整列して使用するなどの命令で <xref:System.Reflection.Emit.OpCodes.Ldind_I> と <xref:System.Reflection.Emit.OpCodes.Stind_I>です。 結果は、一時的なポインター \(型 `*`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldloca` オペコード。  
  
-   ILGenerator.Emit \(オペコード、short\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます \(短い形式\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|12 \< `unsigned int8` \>|ldloca.s `index`|ローカル変数のアドレスをロード `index` を評価スタックに短縮形です。|  
  
 履歴の移行動作を順番には。  
  
1.  指定したインデックス位置のローカル変数に格納されているアドレスは、スタックにプッシュされます。  
  
 `ldloca.s` 命令は、ローカル変数は、番号 0 以降のスタックに渡されたインデックス ローカル変数の数のアドレスをプッシュします。 スタックにプッシュされた値が既に正しく整列して使用するなどの命令で <xref:System.Reflection.Emit.OpCodes.Ldind_I> と <xref:System.Reflection.Emit.OpCodes.Stind_I>です。 結果は、一時的なポインター \(型 `*`\)。  
  
 `ldloca.s` 命令は、0 ~ 255 のローカル変数で使用するため、効率的なエンコーディングを提供します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldloca.s` オペコード。  
  
-   ILGenerator.Emit オペコード \(バイト\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Null 参照をプッシュします \(型 <see langword="O" />\) を評価スタックにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|14|ldnull|null 参照をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  Null オブジェクト参照は、スタックにプッシュされます。  
  
 `ldnull` null 参照をプッシュします \(型 `O`\) スタックにします。 これを使用するには、データが入力されている前に、または禁止になったときに場所を初期化します。  
  
 `ldnull` サイズに依存しない null 参照を提供します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldnull` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アドレスが指す値型オブジェクトを評価スタックの一番上にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|71 \< `T` \>|ldobj `class`|値型のインスタンスのコピー `class` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  値型のオブジェクトのアドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップしを検索すると、インスタンスの特定のアドレスにします。  
  
3.  そのアドレスに格納されているオブジェクトの値は、スタックにプッシュされます。  
  
 `ldobj` 命令をパラメーターとして値型を渡すために使用します。  
  
 `ldobj` 命令が指す値をコピー `addrOfValObj` \(型の `&`, 、`*`, 、または `native int`\)、スタックの一番上にします。 コピーされたバイト数は、クラスのサイズに依存します \(指定されたとおり、 `class` パラメーター\)。`class` パラメーターは、値型を表すメタデータ トークン。  
  
 操作、 `ldobj` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> 命令のプレフィックスします。  
  
 <xref:System.TypeLoadException> クラスが見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldobj` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドの値を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|7 E \< `T` \>|ldsfld `field`|値をプッシュ `field` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  特定のフィールドの値は、スタックにプッシュされます。  
  
 `ldsfld` 命令は、静的 \(クラスのすべてのインスタンスで共有\) の値をプッシュ、スタックのフィールドです。 戻り値の型は、渡されたメタデータ トークンに関連付けられた `field`します。  
  
 `ldsfld` 命令できますが、 <xref:System.Reflection.Emit.OpCodes.Volatile> プレフィックス。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldsfld` オペコード。  
  
-   ILGenerator.Emit \(オペコード、最後に\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドのアドレスを評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|7 F \< `T` \>|ldsflda `field`|アドレスをプッシュ `field` スタック|  
  
 履歴の移行動作を順番には。  
  
1.  特定のフィールドのアドレスは、スタックにプッシュされます。  
  
 `ldsflda` 命令は、静的 \(クラスのすべてのインスタンスで共有\) のアドレスをプッシュ、スタックのフィールドです。 アドレスは、一時的なポインターとして表すことができます \(型 `*`\) 場合、メタデータ トークン `field` はメモリがマネージ型を表します。 それ以外の場合、そのアンマネージ ポインターに対応しています \(型 `native int`\)。 注意 `field` 静的を割り当てたの相対仮想アドレス \(それを含む PE ファイルがメモリに読み込まれるベース アドレスからのフィールドのオフセット\) を使用したグローバルするメモリは管理されません。  
  
 `ldsflda` 命令できますが、 <xref:System.Reflection.Emit.OpCodes.Volatile> プレフィックス。  
  
 <xref:System.MissingFieldException> フィールドは、メタデータ内で見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなく、ネイティブ コードに変換されるときにチェックします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldsflda` オペコード。  
  
-   ILGenerator.Emit \(オペコード、最後に\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータに格納されているリテラル文字列への新しいオブジェクト参照をプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|72 \< `T` \>|ldstr `mdToken`|メタデータ文字列トークンの文字列オブジェクトをプッシュ `mdToken`します。|  
  
 履歴の移行動作を順番には。  
  
1.  文字列へのオブジェクト参照は、スタックにプッシュされます。  
  
 `ldstr` 命令のオブジェクト参照をプッシュする \(型 `O`\) メタデータに格納されている指定された文字列リテラルを表す新しいオブジェクトを文字列にします。`ldstr` 命令が必要なメモリを割り当てし、実行時に必要な文字列形式のファイルで使用される形式の文字列リテラルに変換するために必要な任意の形式変換を実行します。  
  
 共通言語基盤 \(CLI\) からの 2 つの結果を保証する `ldstr` を同じ文字のシーケンスを持つ 2 つのメタデータ トークンを参照しているオブジェクトを返す正確に同じ文字列 \(「文字列インターンの使用」と呼ばれるプロセス\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldstr` オペコード。  
  
-   ILGenerator.Emit \(オペレーション コード、文字列\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータ トークンをそのランタイム表現に変換し、評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|D0 \< `T` \>|ldtoken `token`|メタデータ トークンをそのランタイム表現に変換します。|  
  
 履歴の移行動作を順番には。  
  
1.  渡されたトークンを変換、 `RuntimeHandle` 、スタックにプッシュされます。  
  
 `ldtoken` 命令プッシュ、 `RuntimeHandle` の指定したメタデータ トークン。 A `RuntimeHandle` できる、 `fieldref/fielddef`, 、 `methodref/methoddef`, 、または `typeref/typedef`です。  
  
 呼び出しでスタックにプッシュされた値を使用できます `Reflection` システム クラス ライブラリのメソッドです。  
  
 ランタイム ハンドルのについては、次のクラスを参照してください: <xref:System.RuntimeFieldHandle>, 、<xref:System.RuntimeTypeHandle>, 、および <xref:System.RuntimeMethodHandle>です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldtoken` オペコード。  
  
-   ILGenerator.Emit \(オペコード、MethodInfo\)  
  
-   ILGenerator.Emit \(オペコード、最後に\)  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アンマネージ ポインター プッシュ \(型 <see langword="native int" />\) を評価スタックに指定したオブジェクトに関連付けられている特定の仮想メソッドを実装しているネイティブ コードにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 07 \< `T` \>|ldvirtftn `method`|オブジェクトの仮想メソッドへのポインターをプッシュ `method` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  メソッドにオブジェクト参照がスタックし、エントリ ポイントのアドレスからポップされます。 \(指定したメタデータ トークンによって `method`\) を検索します。  
  
3.  ポインター `method` スタックにプッシュします。  
  
 結果のアンマネージ ポインターが、スタックにプッシュ、 `ldvirtftn` を使用して命令を呼び出すことができる、 <xref:System.Reflection.Emit.OpCodes.Calli> 命令マネージ メソッド \(またはマネージ コード アンマネージ コードからから遷移するスタブ\) を参照する場合。  
  
 アンマネージ ポインターは、CLR の呼び出し規約を使用してネイティブ コードを指します。 コールバック ルーチンとして、このメソッドのポインターをアンマネージ ネイティブ コードに渡されなかった必要があります。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ldvirtftn` オペコード。  
  
-   ILGenerator.Emit \(オペコード、MethodInfo\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードの保護領域を終了し、制御を特定のターゲット命令に無条件で転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|DD \< `int32` \>|ままにして `target`|コードの保護領域を終了します。|  
  
 この命令に指定されている履歴の移行の動作はありません。  
  
 `leave` 命令を現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表され、特定のターゲット命令に制御を移します。  
  
 `leave` 命令がに似ていますが、 `br` 、命令が、それを使用して、終了、 `try`, 、`filter`, 、または `catch` ブロック内に制御を転送するこのようなブロックの通常の分岐命令が使用のみことができます。`leave` 命令を評価スタックを空にして、適切なを囲むことを確認 `finally` ブロックを実行します。  
  
 使用することはできません、 `leave` を終了する命令、 `finally` ブロックします。 使用する catch ブロック内から有効な例外ハンドラーのコード生成を容易にする、 `leave` 、関連付けられている任意の命令に制御を転送命令 `try` ブロックします。  
  
 最初に制御を転送できますのみ命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `leave` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードの保護領域を終了し、制御をターゲット命令に無条件で転送します \(短い形式\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|DE \< `int8` \>|leave.s `target`|短い形式のコードの保護領域を終了します。|  
  
 この命令に指定されている履歴の移行の動作はありません。  
  
 `leave.s` 命令を現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表され、渡されたターゲット命令に制御を移します。  
  
 `leave.s` 命令がに似ていますが、 `br` 、命令が、それを使用して、終了、 `try`, 、`filter`, 、または `catch` ブロック内に制御を転送するこのようなブロックの通常の分岐命令が使用のみことができます。`leave.s` 命令を評価スタックを空にして、適切なを囲むことを確認 `finally` ブロックを実行します。  
  
 使用することはできません、 `leave.s` を終了する命令、 `finally` ブロックします。 使用する catch ブロック内から有効な例外ハンドラーのコード生成を容易にする、 `leave.s` 、関連付けられている任意の命令に制御を転送命令 `try` ブロックします。  
  
 最初に制御を転送できますのみ命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `leave.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル動的メモリ プールからのバイト数を割り当てるし、アドレス プッシュ \(一時ポインター、型 <see langword="*" />\) を評価スタックに割り当てられている最初のバイトのです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 0F|localloc|ローカル ヒープの領域を割り当てます。|  
  
 履歴の移行動作を順番には。  
  
1.  割り当てるバイト数は、スタックにプッシュされます。  
  
2.  バイト数がスタックからポップされます。サイズに対応するメモリ容量は、ローカル ヒープから割り当てられます。  
  
3.  割り当てられたメモリの最初のバイトへのポインターはスタックにプッシュされます。  
  
 `localloc` 命令を割り当てます `size` \(型 `natural unsigned int`\) ローカル動的メモリをプールし、アドレスが返されます \(一時ポインター、型 `*`\) の最初の割り当てられたバイトです。 メモリ ブロックの場合にのみ、メソッドの初期化フラグは、0 に初期化が返される `true`です。 現在のメソッドを実行するとき、 <xref:System.Reflection.Emit.OpCodes.Ret>, 、ローカル メモリ プールは再利用するために使用可能になります。  
  
 結果として得られるアドレスが整列して任意のプリミティブ データ型そこに格納できるを使用できるように、 `stind` 指示 \(など <xref:System.Reflection.Emit.OpCodes.Stind_I4>\) を使用して読み込むと、 `ldind` 指示 \(など <xref:System.Reflection.Emit.OpCodes.Ldind_I4>\)。  
  
 `localloc` 命令内に出現できず、 `filter`, 、`catch`, 、`finally`, 、または `fault` ブロックします。  
  
 <xref:System.StackOverflowException> 要求の処理を十分なメモリがある場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `localloc` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の型のインスタンスへの型指定された参照を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|C6 \< `T` \>|mkrefany `class`|型の型指定された参照をプッシュ `class` をスタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  ポインターのデータがスタックにプッシュします。  
  
2.  マウス ポインターがポップされ、型の型指定された参照に変換 `class`します。  
  
3.  型指定された参照は、スタックにプッシュされます。  
  
 `mkrefany` 命令には、動的に型指定された参照を渡すことがサポートしています。 ポインター型でなければなりません `&`, 、`*`, 、または `native int`, 、およびデータの部分の有効なアドレスを保持します。`Class` マウス ポインターによって参照されるデータの種類を記述するクラスのトークン。`Mkrefany` 型指定された参照をポインター型の非透過の記述子を提供するスタックにプッシュ `class`します。  
  
 型指定された参照に許可されている唯一の有効な操作では、パラメーターとして型指定された参照を必要とするメソッドに渡すことです。 呼び出し先を使えば、 <xref:System.Reflection.Emit.OpCodes.Refanytype> と <xref:System.Reflection.Emit.OpCodes.Refanyval> 型 \(クラス\) とアドレスをそれぞれ取得する手順についてです。  
  
 <xref:System.TypeLoadException> 場合にスローされる `class` が見つかりません。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `mkrefany` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を乗算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|5A|mul|スタック上の 2 つの値を乗算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value1` が乗算 `value2`します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `mul` 命令を乗算 `value1` によって `value2` し、結果をスタックにプッシュします。 整数演算には、オーバーフローについては、上位のビットが暗黙に切り捨てられます。  
  
 参照してください <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> 整数固有のオーバーフロー処理で操作を乗算します。  
  
 浮動小数点型の場合は、0 \* 無限大 \= NaN です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `mul` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの整数値を乗算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|D8|mul.ovf|オーバーフロー チェックを使用してスタック上の 2 つの整数値を乗算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value1` が乗算 `value2`, 、オーバーフロー チェックを使用します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `mul.ovf` 命令は、整数を乗算 `value1` 整数 `value2` し、結果をスタックにプッシュします。 結果は結果の型に収まらない場合は、例外がスローされます。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `mul.ovf` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を乗算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|D9|mul.ovf.un|オーバーフロー チェックを使用してスタック上の 2 つの符号なしの値を乗算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value1` が乗算 `value2`, 、オーバーフロー チェックを使用します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `mul.ovf.un` 命令が符号なし整数を乗算 `value1` 符号なし整数で `value2` し、結果をスタックにプッシュします。 結果は結果の型に収まらない場合は、例外がスローされます。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `mul.ovf.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値を無効にし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|65|負|現在、スタックの一番上に値を否定します。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  値がスタックからポップされ、符号を反転します。  
  
3.  結果は、スタックにプッシュされます。  
  
 `neg` 命令の値を無効にし、結果をスタックにプッシュします。 戻り値の型は、オペランドの型と同じです。  
  
 整数値の否定は、標準的な 2 の補数の否定。 具体的には、否定 \(これに相当する正の値はありません\) を負の数には、負の数値が生成されます。 オーバーフローを使用するこのを検出するために、 <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> 命令代わりに \(つまり、0 から減算\)。  
  
 浮動小数点数を否定すると、オーバーフローが発生することはできません、および否定 NaN と NaN が返されます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `neg` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の型の要素を持つ、インデックス番号が 0 から始まる新しい 1 次元配列へのオブジェクト参照を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|8 D \< `T` \>|newarr `etype`|型の要素を持つ新しい配列を作成 `etype`します。|  
  
 履歴の移行動作を順番には。  
  
1.  配列内の要素の数は、スタックにプッシュされます。  
  
2.  要素の数が、スタックからポップされ、配列が作成されます。  
  
3.  新しい配列にオブジェクト参照は、スタックにプッシュされます。  
  
 `newarr` 命令のオブジェクト参照をプッシュする \(型 `O`\) の要素の型は、新しい、0 から始まる 1 次元配列に `etype` \(、型を記述するメタデータ トークン\)。 として新しい配列の要素の数を指定する必要があります、 `native int`です。 有効な配列インデックス範囲は 0 から 1 を引いた要素の最大数です。  
  
 配列の要素には、値型を含む、任意の型を指定できます。  
  
 適切な値の型を参照するメタデータ トークンを使用して数値の 0 から始まる 1 次元の配列が作成されます \(<xref:System.Int32>, など\)。 配列の要素は、適切な型の 0 に初期化されます。  
  
 始まる 1 次元配列と多次元配列を使用して作成 <xref:System.Reflection.Emit.OpCodes.Newobj> なく `newarr`です。 メソッドを使用してを作成より一般的に、 <xref:System.Array> .NET Framework クラスにします。  
  
 <xref:System.OutOfMemoryException> メモリ不足のため、要求を満たす場合にスローされます。  
  
 <xref:System.OverflowException> 場合にスローされる `numElems` が 0 未満です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `newarr` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しいオブジェクトまたはオブジェクト参照をプッシュ、値型の新しいインスタンスを作成 \(型 <see langword="O" />\) を評価スタックにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|73 \< `T` \>|newobj `ctor`|初期化されていないオブジェクトまたは値型を割り当て、コンス トラクター メソッドを呼び出して `ctor`します。|  
  
 履歴の移行動作を順番には。  
  
1.  引数 `arg1` を通じて `argn` 順序でスタックにプッシュされます。  
  
2.  引数 `argn` を通じて `arg1` スタックからポップされに渡される `ctor` オブジェクト作成のためです。  
  
3.  新しいオブジェクトへの参照は、スタックにプッシュされます。  
  
 `newobj` 命令は、新しいオブジェクトまたは値型の新しいインスタンスを作成します。`Ctor` メタデータ トークンは、\(、 `methodref` または `methoddef` コンス トラクターとしてマークする必要があります\) を示す名前とクラスを呼び出すコンス トラクターのシグネチャ。  
  
 `newobj` 命令に関連付けられているクラスの新しいインスタンスを割り当てる `ctor` し、すべてのフィールドが、適切な型の 0 または null 参照を適切には、新しいインスタンスを初期化します。 これは、後、コンス トラクターを呼び出して `ctor` 新しく作成されたインスタンスと指定された引数を使用します。 ここがオブジェクト参照を初期化するコンス トラクターが呼び出された後 \(型 `O`\) がスタックにプッシュします。  
  
 コンス トラクターの観点から、初期化されていないオブジェクトは引数 0 であり、次の順序での newobj に渡されるその他の引数。  
  
 使用してすべての 0 から始まる 1 次元配列が作成された <xref:System.Reflection.Emit.OpCodes.Newarr>, ではなく、 `newobj`です。 これに対し、他のすべての配列 \(1 つの次元数よりも、または 1 次元が 0 以上\) が使用してを作成するは `newobj`です。  
  
 値型は通常を使用しないで作成 `newobj`します。 引数またはを使用してローカル変数として割り当てられる通常 `newarr` \(の 0 から始まる 1 次元配列の場合\)、またはオブジェクトのフィールドとして。 使用して初期化される割り当てたら、 <xref:System.Reflection.Emit.OpCodes.Initobj>です。 ただし、 `newobj` ししたり、ローカルに格納されている、引数として渡すことができると、スタックに値型の新しいインスタンスを作成する命令を使用できます。  
  
 <xref:System.OutOfMemoryException> メモリ不足のため、要求を満たす場合にスローされます。  
  
 <xref:System.MissingMethodException> コンス トラクター メソッドの場合にスローされる `ctor` 指定された名前のクラスおよび署名で見つかりませんでした。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `newobj` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ConstructorInfo\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オペコードがパッチされている場合は、領域を補完します。 循環参照の処理を利用することはできますが、意味のある演算は実行されません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|00|nop|動作せず、操作を実行します。|  
  
 この命令に対して定義されている、スタックの遷移の動作はありません。  
  
 `nop` 操作は何も行われません。 オペコードがパッチされている場合に、スペースを入力するものです。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `nop` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある整数値のビットごとの補数を計算し、結果を同じ型として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|66|not|値のビットごとの補数を計算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックのビットごとの補数を計算します。  
  
3.  結果は、スタックにプッシュされます。  
  
 `not` 命令は整数値のビットごとの補数を計算し、結果をスタックにプッシュします。 戻り値の型は、オペランドの型と同じです。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `not` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある 2 つの整数値のビットごとの補数を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|60|または|演算を実行しますか、2 つの整数値の整数を返します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` 、ビットごとの OR、スタックからポップされます。 計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `or` 命令をし、結果をスタックにプッシュ、スタックの一番上の 2 つの値のビットごとの OR を計算します。  
  
 `Or` 整数固有操作です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `or` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にある値を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|26|pop|スタックから上位の値をポップします。|  
  
 履歴の移行動作を順番には。  
  
1.  上位の値は、スタックからポップされます。  
  
 `pop` 命令がスタックから先頭の要素を削除します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `pop` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以降の配列アドレス演算で、実行時に型チェックを実行しないこと、および変更可能性が制限されたマネージ ポインターを返すことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 1E|読み取り専用です。|以降の配列アドレス演算では、実行時に型チェックは実行しないと、制限付きの可変性を指すマネージ ポインターが返されることを指定します。|  
  
 このプレフィックスは直前のみ表示できます。、 `ldelema` 命令と呼び出しには、特別 `Address` アレイ上のメソッドです。 後続の操作には、その影響が生じます。  
  
1.  実行時に型チェックの演算は実行されません。 暗黙の型チェックは通常、 `ldelema` と `stelem` 参照で使用する入力配列。 ないため、値クラス、実行時型チェックので `readonly` はその例では何も行いません。  
  
2.  検証ツールでは変更可能性が制限することで、マネージ ポインターとしてアドレス演算の結果を取り扱います。  
  
 ポインターは、宣言型の値を変更できるかどうかを制御するため変更可能性が制限されていると呼ばれます。 ポインターは読み取り専用のパブリック フィールド、または場所に値を更新するメソッドを公開しない値クラス、\(したがってプレフィックスの名前\)。 具体的には、プリミティブ型 \(System.Int32 など\) を表すクラスは、ミューテーターを公開しないと、このため、読み取り専用です。  
  
 この方法で制限されたマネージ ポインターは、次の方法でのみ使用できます。  
  
-   として、 `object` のパラメーター、 `ldfld`, 、`ldflda`, 、`stfld`, 、`call`, 、または`constrained callvirt` 指示します。  
  
-   として、 `pointer` パラメーターを `ldobj` 命令またはのいずれかに、 `ldind` 指示します。  
  
-   として、 `source` パラメーターを `cpobj` 命令します。  
  
 その他のなどすべての操作が許可されていない、 `stobj`, 、`initobj`, 、または `mkrefany` 操作、またはのいずれか、 `stind` 指示します。  
  
 目的、 `readonly` プレフィックスは、ジェネリック コードの配列から要素をフェッチするときに、型チェックを避けることです。 たとえば、式 `arr[i].m()`, 配列の要素型であるという点 `arr` メソッドを使用してインターフェイスが存在するように制約されたジェネリック型は、 `m`, は次の MSIL にコンパイルします。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 なし、 `readonly` プレフィックス、 `ldelema` 命令は大文字と小文字で、型チェックを実行する場所です。 0 が参照型です。 だけでなく、効率的で、この種類のチェックはありませんは正しい意味合いを持つ。 型チェック `ldelema` 非常に強力なは、完全に一致します。 配列には、型のサブクラスが保持されている場合です。 0 で、上記のコードには、型チェックは失敗します。  
  
 配列の要素のアドレスがフェッチされると、要素自体ではなくへのハンドルを確保するため `arr[i]` 両方の動作が値型と参照型の場合と、そのために渡すことが、 `constrained callvirt` 命令します。  
  
 一般にできなくなる、配列には、参照型の要素が保持されている場合、ランタイム チェックをスキップしても安全です。 安全には、このポインターから配列への変更が行われていないことを確認する必要があります。 検証規則では、これを確認します。 制限されたマネージ ポインターは、にない厳密には読み取り専用値の型ですが、値型の型の安全性の問題はありませんので、インスタンス メソッドの呼び出しのオブジェクトとして渡すことができます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `readonly` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型指定された参照に埋め込まれている型トークンを取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 1D|refanytype|型指定された参照に格納されている型トークンをプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値型の参照は、スタックにプッシュされます。  
  
2.  型指定された参照がスタックからポップされ、その対応する型のトークンを取得します。  
  
3.  型のトークンは、スタックにプッシュされます。  
  
 型指定された参照には、型のトークンとオブジェクト インスタンスにアドレスが含まれています。  
  
 `refanytype` 命令は、型指定された参照に埋め込まれている型トークンを取得します。 参照してください、 <xref:System.Reflection.Emit.OpCodes.Mkrefany> の作成方法についての命令が参照を入力します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `refanytype` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アドレスを取得します \(型 <see langword="&amp;" />\) 型指定された参照に埋め込まれています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|C2 \< `T` \>|refanyval `type`|型指定された参照に格納されているアドレスにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値型の参照は、スタックにプッシュされます。  
  
2.  型指定された参照がスタックからポップし、対応するアドレスを取得します。  
  
3.  アドレスは、スタックにプッシュされます。  
  
 型指定された参照には、型のトークンとオブジェクト インスタンスにアドレスが含まれています。  
  
 `refanyval` 命令に埋め込まれたアドレスを取得する、型指定された参照です。 スタックで指定した型指定された参照に埋め込まれた型がで指定された型に一致する必要があります `type` \(いずれかのメタデータ トークン、 `typedef` または `typeref`\)。 参照してください、 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 関連するコンテンツに対する命令です。  
  
 <xref:System.InvalidCastException> 場合にスローされる `type` 型参照に格納されている型と同じではありません \(この場合、 `type` にクラスが提供されます、 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 構築命令が型指定された参照と呼ばれます\)。  
  
 <xref:System.TypeLoadException> 場合にスローされる `type` が見つかりません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `refanyval` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を除算し、剰余を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|5D|rem|除算の剰余プッシュ `value1` によって `value2` をスタックにします。|  
  
> [!NOTE]
>  ReplaceThisText  
  
 履歴の移行動作を順番には。  
  
1.  A `value1` スタックにプッシュします。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックとの残りの部分からポップされます。 `value1` `div` `value2` を計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `result` \= `value1` `rem` `value2` 次の条件を満たします。  
  
 `result` \= `value1` \- `value2` `×` \(`value1` `div` `value2`\), and:  
  
 0 \= &#124; `result` &#124; \< &#124; `value2` &#124;、記号 \(`result`\) \= 記号 \(`value1`\) ここで、 `div` はゼロに向かって切り捨て除算命令します。  
  
 場合 `value2` ゼロまたは `value1` 無限大 NaN になります。 場合 `value2` 無限大の場合は、結果は `value1` \(の否定 `-infinity`\)。  
  
 整数演算スロー <xref:System.DivideByZeroException> 場合 `value2` ゼロです。  
  
 Intel ベース プラットフォームに注意してください、 <xref:System.OverflowException> を計算するときにスローされます \(minint `rem` \-1\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `rem` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なしの値を除算し、剰余を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|5E|rem.un|除算の剰余の符号なしをプッシュ `value1` 符号なしで `value2` をスタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックとの残りの部分からポップされます。 `value1` `div` `value2` を計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `result` \= `value1` `rem.un` `value2` 次の条件を満たします。  
  
 `result` \= `value1` \- `value2` x\(`value1` `div.un` `value2`\), and:  
  
 0 \= `result` \< `value2`, ここで、 `div.un` は符号なしの除算命令します。  
  
 `rem.un` 命令計算 `result` し、スタックにプッシュします。`Rem.un` 引数を符号なし整数として扱われますながら <xref:System.Reflection.Emit.OpCodes.Rem> 、符号付き整数を扱います。  
  
 `Rem.un` 浮動小数点数に指定されていません。  
  
 整数演算スロー <xref:System.DivideByZeroException> 場合 `value2` ゼロです。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `rem.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドから戻り、呼び出し先の評価スタックから呼び出し元の評価スタックに戻り値 \(存在する場合\) をプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|2A|ret|値を返す可能性があるメソッドから返します。|  
  
 履歴の移行動作を順番には。  
  
1.  戻り値は、呼び出し先の評価スタックからポップされます。  
  
2.  手順 1. で得た戻り値は、呼び出し元の評価スタックにプッシュされます。  
  
 戻り値が呼び出し先の評価スタック上に存在しない場合は、値なしには \(ありませんスタック遷移の動作、呼び出し先または呼び出し元のいずれかのメソッド\) が返されます。  
  
 戻り値の型存在する場合、現在のメソッドが決まりますスタックの一番上と現在のメソッドを呼び出したメソッドのスタックにコピーしたからフェッチする値の型。 現在のメソッドの評価スタックは、返される値を除く空にする必要があります。  
  
 `ret` の制御を転送する命令を使用できない、`try`, 、`filter`, 、`catch`, 、または `finally` ブロックします。 内から、 `try` または `catch`, を使用して、 <xref:System.Reflection.Emit.OpCodes.Leave> 命令の出力先を `ret` 外側のすべての例外ブロックの外側にある命令します。`filter` と `finally` ブロックは、コードが埋め込まれているメソッドではなく、例外処理の一部で、論理的に、正しく生成された Microsoft 中間言語 \(MSIL\) 命令がメソッド内からの戻り値を実行しないで、 `filter` または `finally`です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `ret` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外を再スローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 1A|再スロー|現在の例外を再スローします。|  
  
 この命令の履歴の移行動作が定義されていません。  
  
 `rethrow` 命令は、本体内でのみ、 `catch` ハンドラー。 このハンドラーでキャッチされた例外と同じ例外がスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `rethrow` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を指定したビット数だけ、0 を使用して左にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|62|shl|整数が \(0 でシフト\) の左にシフトします。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  シフトするビットの量は、スタックにプッシュされます。  
  
3.  シフトするビット数と、値がスタックからポップされます。値は指定されたビット数だけ左にシフトします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `shl` 命令は、値をシフト \(型 `int32`, 、`int64` または `native int`\) 指定したビット数だけ左します。 ビットの数値型の値は、 `int32` または `native int`です。 シフトするビット数が \(bits\) の幅、指定された値以上である場合、戻り値は指定されません。  
  
 `Shl` 0 のビットをシフトごとの最下位の位置に挿入します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `shl` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を指定したビット数だけ、符号を付けて右にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|63|shr|整数を \(記号でシフト\) 右にシフトします。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  シフトするビットの量は、スタックにプッシュされます。  
  
3.  シフトするビット数と、値がスタックからポップされます。値は指定されたビット数だけ右にシフトします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `shr.un` 命令は、値をシフト \(型 `int32`, 、`int64` または `native int`\) 指定されたビット数だけ右です。 ビットの数値型の値は、 `int32` または `native int`です。 シフトするビット数が \(bits\) の幅、指定された値以上である場合、戻り値は指定されません。  
  
 `Shr` 上位の元の値の符号を維持し、シフトごとのビットを複製、 `result`です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `shr` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値を指定したビット数だけ、0 を使用して右にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|64|shr.un|整数を \(0 でシフト\) 右にシフトします。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  シフトするビットの量は、スタックにプッシュされます。  
  
3.  シフトするビット数と、値がスタックからポップされます。値は指定されたビット数だけ右にシフトします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `shr.un` 命令は、値をシフト \(型 `int32`, 、`int64` または `native int`\) 指定されたビット数だけ右です。 ビットの数値型の値は、 `int32`, 、`int64` または `native int`です。 シフトするビット数が \(bits\) の幅、指定された値以上である場合、戻り値は指定されません。  
  
 `Shr.un` 0 のビットをシフトごとに優先順位の高いに挿入します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `shr.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された値型のサイズ \(バイト単位\) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 1C \< `T` \>|sizeof `valType`|\(バイト単位\) として値型のサイズをプッシュ、 `unsigned int32`です。|  
  
 履歴の移行動作を順番には。  
  
1.  指定された値型のサイズをバイト単位で \(`valType`\) が、スタックにプッシュします。  
  
 `valType` メタデータ トークンである必要があります \(、 `typeref` または `typedef`\) 値の型、参照型またはジェネリック型パラメーターを指定します。  
  
 参照型では、返されるサイズは対応する参照値のサイズは、参照値によって参照されるオブジェクトに格納されたデータのサイズではなく \(32 ビット システムでは 4 バイト\) を入力します。 ジェネリック型パラメーターは、型またはこれを定義するメソッドの本体でのみ使用できます。 その型またはメソッドがインスタンス化する場合は、値型または参照型でジェネリック型パラメーターが置き換えられます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `sizeof` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 0B \< `unsigned int16` \>|starg `num`|スタックから上位の値をポップし、引数スロットに格納します。 `num`します。|  
  
 履歴の移行動作を順番には。  
  
1.  現在、スタックの一番上に値がポップされ、引数スロットに配置 `num`します。  
  
 `starg` 命令がスタックから値をポップし、引数スロットに配置 `num`します。 値の型は、現在のメソッドのシグネチャで指定された引数の型に一致する必要があります。  
  
 可変個引数リストを取得する手順については、 `starg` 命令は、最初の可変部分の署名のでなく、その引数を固定にのみ使用できます。  
  
 4 バイト長より小さい整数値を保持している引数に格納を実行すると、スタックから引数が移動すると、値が切り捨てられます。 浮動小数点値は、ネイティブのサイズから丸められます \(型 `F`\) を引数に関連付けられているサイズにします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `starg` オペコード。  
  
-   ILGenerator.Emit \(オペコード、short\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します \(短い形式\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|10 \< `unsigned int8` \>|starg.s `num`|スタックから上位の値をポップし、引数スロットに格納します。 `num`, 、短縮形です。|  
  
 履歴の移行動作を順番には。  
  
1.  現在、スタックの一番上に値がポップされ、引数スロットに配置 `num`します。  
  
 `starg.s` 命令がスタックから値をポップし、引数スロットに配置 `num`します。 値の型は、現在のメソッドのシグネチャで指定された引数の型に一致する必要があります。  
  
 `starg.s` 命令は、最初の 256 個の引数で使用するための効率的なエンコーディングを提供します。  
  
 可変個引数リストを取得する手順については、 `starg.s` 命令は、最初の可変部分の署名のでなく、その引数を固定にのみ使用できます。  
  
 4 バイト長より小さい整数値を保持している引数に格納を実行すると、スタックから引数が移動すると、値が切り捨てられます。 浮動小数点値は、ネイティブのサイズから丸められます \(型 `F`\) を引数に関連付けられているサイズにします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できます、 `starg.s` オペコード。  
  
-   ILGenerator.Emit オペコード \(バイト\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの、命令で指定された型の値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|A4 \< `T` \>|stelem `typeTok`|指定したインデックスにある配列要素を型の値に置き換えます `typeTok` スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に `array`, 、スタックにプッシュします。  
  
2.  インデックス値、 `index`, 、内の要素へ `array` スタックにプッシュします。  
  
3.  命令で指定された型の値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックスにある配列要素に格納されます。  
  
 `stelem` 命令は 1 次元配列で指定された 0 から始まるインデックス位置にある要素の値を置換 `array` 、値を使用します。 値が、トークンで指定された型 `typeTok` 命令にします。  
  
 配列オブジェクトで、型の値によって表されるので `O`します。 インデックスの種類は、 `native int`です。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stelem` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、 <see langword="native int" /> 評価スタックの値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|9B|stelem.i|指定したインデックス位置にある配列要素、 `native int` スタックの値にします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に `array`, 、スタックにプッシュします。  
  
2.  内の要素への有効なインデックス `array` スタックにプッシュします。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックスにある配列要素に格納されます。  
  
 `stelem.i` 命令は、要素の値を置換 `index` 1 次元配列で `array` で、 `native int` 値がスタックにプッシュします。  
  
 配列オブジェクト、型の値によって表されるので `O`します。 インデックスの種類は、 `native int`です。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stelem.i` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、 <see langword="int8" /> 評価スタックの値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|9C|stelem.i1|指定したインデックス位置にある配列要素、 `int8` スタックの値にします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に `array`, 、スタックにプッシュします。  
  
2.  内の要素への有効なインデックス `array` スタックにプッシュします。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックスにある配列要素に格納されます。  
  
 `stelem.i1` 命令は、要素の値を置換 `index` 1 次元配列で `array` で、 `int8` 値がスタックにプッシュします。  
  
 配列オブジェクト、型の値によって表されるので `O`します。 インデックスの種類は、 `native int`です。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stelem.i1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、 <see langword="int16" /> 評価スタックの値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|9D|stelem.i2|指定したインデックス位置にある配列要素、 `int16` スタックの値にします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に `array`, 、スタックにプッシュします。  
  
2.  内の要素への有効なインデックス `array` スタックにプッシュします。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックスにある配列要素に格納されます。  
  
 `stelem.i2` 命令は、要素の値を置換 `index` 1 次元配列で `array` で、 `int16` 値がスタックにプッシュします。  
  
 配列オブジェクト、型の値によって表されるので `O`します。 インデックスの種類は、 `native int`です。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stelem.i2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、 <see langword="int32" /> 評価スタックの値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|9E|stelem.i4|指定したインデックス位置にある配列要素、 `int32` スタックの値にします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に `array`, 、スタックにプッシュします。  
  
2.  内の要素への有効なインデックス `array` スタックにプッシュします。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックスにある配列要素に格納されます。  
  
 `stelem.i4` 命令は、要素の値を置換 `index` 1 次元配列で `array` で、 `int32` 値がスタックにプッシュします。  
  
 配列オブジェクト、型の値によって表されるので `O`します。 インデックスの種類は、 `native int`です。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stelem.i4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、 <see langword="int64" /> 評価スタックの値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|9F|stelem.i8|指定したインデックス位置にある配列要素、 `int64` スタックの値にします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に `array`, 、スタックにプッシュします。  
  
2.  内の要素への有効なインデックス `array` スタックにプッシュします。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックスにある配列要素に格納されます。  
  
 `stelem.i8` 命令は、要素の値を置換 `index` 1 次元配列で `array` で、 `int64` 値がスタックにプッシュします。  
  
 配列オブジェクト、型の値によって表されるので `O`します。 インデックスの種類は、 `native int`です。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stelem.i8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、 <see langword="float32" /> 評価スタックの値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|A0|stelem.r4|指定したインデックス位置にある配列要素、 `float32` スタックの値にします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に `array`, 、スタックにプッシュします。  
  
2.  内の要素への有効なインデックス `array` スタックにプッシュします。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックスにある配列要素に格納されます。  
  
 `stelem.r4` 命令は、要素の値を置換 `index` 1 次元配列で `array` で、 `float32` 値がスタックにプッシュします。  
  
 配列オブジェクト、型の値によって表されるので `O`します。 インデックスの種類は、 `native int`です。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stelem.r4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、 <see langword="float64" /> 評価スタックの値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|A1|stelem.r8|指定したインデックス位置にある配列要素、 `float64` スタックの値にします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に `array`, 、スタックにプッシュします。  
  
2.  内の要素への有効なインデックス `array` スタックにプッシュします。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックスにある配列要素に格納されます。  
  
 `stelem.r8` 命令は、要素の値を置換 `index` 1 次元配列で `array` で、 `float64` 値がスタックにプッシュします。  
  
 配列オブジェクト、型の値によって表されるので `O`します。 インデックスの種類は、 `native int`です。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stelem.r8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したインデックスにある配列要素をオブジェクト参照値に置き換えます \(型 <see langword="O" />\) 評価スタックにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|A2|stelem.ref|指定したインデックス位置にある配列要素、 `ref` 値 \(型 `O`\) スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に `array`, 、スタックにプッシュします。  
  
2.  内の要素への有効なインデックス `array` スタックにプッシュします。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックスにある配列要素に格納されます。  
  
 `stelem.ref` 命令は 1 次元配列で指定されたインデックス位置にある要素の値を置換 `array` で、 `ref` \(型 `O`\) 値がスタックにプッシュします。  
  
 配列オブジェクト、型の値によって表されるので `O`します。 インデックスの種類は、 `native int`です。  
  
 なお `stelem.ref` の要素の型に指定された値を暗黙的にキャスト `array` 配列の要素に値を割り当てる前にします。 検証済みのコードであっても、このキャストが失敗することができます。 したがって、 `stelem.ref` 命令がスローできる <xref:System.InvalidCastException>です。 以外で始まる 1 次元の配列、多次元配列の場合、 <xref:System.Array> クラスには、 <xref:System.Array.SetValue%2A> メソッドです。  
  
 <xref:System.NullReferenceException> 場合にスローされる `array` null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる `index` が負の場合、またはのバインドよりも大きい `array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる `array` 必要な型の要素を保持しません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stelem.ref` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照またはポインターのフィールドに格納された値を新しい値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|7D \< `T` \>|stfld `field`|値の置換 `field` の新しい値を持つオブジェクト。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照またはポインターは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値とオブジェクトの参照\/ポインターがスタックからポップされます。値 `field` オブジェクトには、指定された値に置き換えられます。  
  
 `stfld` 命令には、オブジェクトのフィールドの値が置き換えられます \(型 `O`\) またはポインター経由で \(種類 `native int`, 、`&`, 、または `*`\) に特定の値。`Field` フィールド メンバーの参照を表すメタデータ トークンです。`stfld` 命令は、のいずれかまたは両方のプレフィックスを持つことができます <xref:System.Reflection.Emit.OpCodes.Unaligned> と <xref:System.Reflection.Emit.OpCodes.Volatile>です。  
  
 <xref:System.NullReferenceException> オブジェクト参照またはポインターが null 参照と、フィールドが静的な場合にスローされます。  
  
 <xref:System.MissingFieldException> 場合にスローされる `field` メタデータに格納されていません。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなく、ネイティブ コードに変換されるときにチェックします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stfld` オペコード。  
  
-   ILGenerator.Emit \(オペコード、最後に\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納 <see langword="native int" /> 提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|DF|しない|店舗、 `native int` 指定のアドレスにします。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.i` 命令ストア、 `native int` 指定されたアドレスにある値 \(型 `native int`, 、`*`, 、または `&`\)。  
  
 タイプ セーフな演算を必要とする、 `stind.i` 命令ポインターの型と矛盾しない方法で使用します。 操作、 `stind.i` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> 命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `addr` 命令のサフィックスが含まれる引数の型用に自然にアラインされていません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stind.i` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納 <see langword="int8" /> 提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|52|stind.i1|店舗、 `int8` 指定のアドレスにします。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.i1` 命令ストア、 `int8` 指定されたアドレスにある値 \(型 `native int`, 、`*`, 、または `&`\)。  
  
 タイプ セーフな演算を必要とする、 `stind.i1` 命令ポインターの型と矛盾しない方法で使用します。 操作、 `stind.i1` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> 命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `addr` 命令のサフィックスが含まれる引数の型用に自然にアラインされていません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stind.i1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納 <see langword="int16" /> 提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|53|stind.i2|店舗、 `int16` 指定のアドレスにします。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.i2` 命令ストア、 `int16` 指定されたアドレスにある値 \(型 `native int`, 、`*`, 、または `&`\)。  
  
 タイプ セーフな演算を必要とする、 `stind.2i` 命令ポインターの型と矛盾しない方法で使用します。 操作、 `stind.i2` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `addr` 命令のサフィックスが含まれる引数の型用に自然にアラインされていません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stind.i2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納 <see langword="int32" /> 提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|54|stind.i4|店舗、 `int32` 指定のアドレスにします。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.i4` 命令ストア、 `int32` 指定されたアドレスにある値 \(型 `native int`, 、`*`, 、または `&`\)。  
  
 タイプ セーフな演算を必要とする、 `stind.i4` 命令ポインターの型と矛盾しない方法で使用します。 操作、 `stind.i4` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> 命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `addr` 命令のサフィックスが含まれる引数の型用に自然にアラインされていません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stind.i4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納 <see langword="int64" /> 提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|55|stind.i8|店舗、 `int64` 指定のアドレスにします。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.i8` 命令ストア、 `int64` 指定されたアドレスにある値 \(型 `native int`, 、`*`, 、または `&`\)。  
  
 タイプ セーフな演算を必要とする、 `stind.i8` 命令ポインターの型と矛盾しない方法で使用します。 操作、 `stind.i` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> 命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `addr` 命令のサフィックスが含まれる引数の型用に自然にアラインされていません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stind.i8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納 <see langword="float32" /> 提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|56|stind.r4|店舗、 `float32` 指定のアドレスにします。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.r4` 命令ストア、 `float32` 指定されたアドレスにある値 \(型 `native int`, 、`*`, 、または `&`\)。  
  
 タイプ セーフな演算を必要とする、 `stind.r4` 命令ポインターの型と矛盾しない方法で使用します。 操作、 `stind.r4` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> 命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `addr` 命令のサフィックスが含まれる引数の型用に自然にアラインされていません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stind.r4` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納 <see langword="float64" /> 提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|57|stind.r8|店舗、 `float64` 指定のアドレスにします。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.r8` 命令ストア、 `float64` 指定されたアドレスにある値 \(型 `native int`, 、`*`, 、または `&`\)。  
  
 タイプ セーフな演算を必要とする、 `stind.r8` 命令ポインターの型と矛盾しない方法で使用します。 操作、 `stind.r8` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> 命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `addr` 命令のサフィックスが含まれる引数の型用に自然にアラインされていません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stind.r8` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスにオブジェクト参照値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|51|しない|オブジェクト参照を格納 \(型 `O`\)、特定のアドレスにある値。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.ref` 命令は、指定されたアドレスにオブジェクト参照値を格納 \(型 `native int`, 、`*`, 、または `&`\)。  
  
 タイプ セーフな演算を必要とする、 `stind.ref` 命令ポインターの型と矛盾しない方法で使用します。 操作、 `stind.ref` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> 命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる `addr` 命令のサフィックスが含まれる引数の型用に自然にアラインされていません。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stind.ref` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、指定したインデックスのローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 0 E \< `unsigned int16` \>|stloc `index`|スタックから値をポップし、ローカル変数に格納 `index`します。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップされ、ローカル変数に格納 `index`します。  
  
 `stloc` 命令が評価スタックから上位の値をポップし、ローカル変数の数に移動 `index`, では、ローカル変数は番号 0 以降。 値の型は、ローカルの現在のメソッドのシグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、ローカル変数に、スタックから移動することと、値が切り捨てられます。 浮動小数点値は、ネイティブのサイズから丸められます \(型 `F`\) を引数に関連付けられているサイズにします。  
  
 正しい Microsoft 中間言語 \(MSIL\) 命令を必要とする `index` ローカルの有効なインデックスがあります。`stloc` 命令、 `index` 包括的な範囲 65534 に 0 である必要があります \(具体的には、65535 が正しくありません\)。 65535 を除くための実用的な: 可能性の高い実装は特定のメソッドのローカル変数の合計数だけでなく、ローカルのインデックスを追跡するために 2 バイトの整数を使用します。 65535 のインデックスが行われた有効な場合は、このようなメソッドのローカル変数の数を追跡する幅の整数を必要があります。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stloc` オペコード。  
  
-   ILGenerator.Emit \(オペコード、LocalBuilder\)  
  
-   ILGenerator.Emit \(オペコード、short\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 0 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|0A|stloc.0|0 のローカル変数には、スタックから値をポップします。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップされ、インデックスが 0 でローカル変数に格納されます。  
  
 `stloc.0` 命令は、評価スタックの一番上の値をポップし、インデックスが 0 であるローカル変数に移動します。 値の型は、ローカルの現在のメソッドのシグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 `stloc.0` 0 のローカル変数に値を格納するため特に効率的なエンコードです。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、ローカル変数に、スタックから移動することと、値が切り捨てられます。 浮動小数点値は、ネイティブのサイズから丸められます \(型 `F`\) を引数に関連付けられているサイズにします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stloc.0` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 1 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|0B|stloc.1|1 のローカル変数には、スタックから値をポップします。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップされ、インデックスが 1 でローカル変数に格納されます。  
  
 `stloc.1` 命令は、評価スタックの一番上の値をポップし、インデックスが 1 でローカル変数に移動します。 値の型は、ローカルの現在のメソッドのシグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 `stloc.1` 1 のローカル変数に値を格納するため特に効率的なエンコードです。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、ローカル変数に、スタックから移動することと、値が切り捨てられます。 浮動小数点値は、ネイティブのサイズから丸められます \(型 `F`\) を引数に関連付けられているサイズにします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stloc.1` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 2 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|0C|stloc.2|ローカル変数 2 に、スタックから値をポップします。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップされ、インデックスが 2 でローカル変数に格納されます。  
  
 `stloc.2` 命令は、評価スタックの一番上の値をポップし、インデックスが 2 でローカル変数に移動します。 値の型は、ローカルの現在のメソッドのシグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 `stloc.2` 2 のローカル変数に値を格納するため特に効率的なエンコードです。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、ローカル変数に、スタックから移動することと、値が切り捨てられます。 浮動小数点値は、ネイティブのサイズから丸められます \(型 `F`\) を引数に関連付けられているサイズにします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stloc.2` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 3 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|0 D|stloc.3|ローカル変数 3 に、スタックから値をポップします。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップされ、インデックスが 3 でローカル変数に格納されます。  
  
 `stloc.3` 命令が評価スタックから上位の値をポップし、インデックスが 3 でローカル変数に移動します。 値の型は、ローカルの現在のメソッドのシグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 `stloc.3` 3 のローカル変数に値を格納するため特に効率的なエンコードです。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、ローカル変数に、スタックから移動することと、値が切り捨てられます。 浮動小数点値は、ネイティブのサイズから丸められます \(型 `F`\) を引数に関連付けられているサイズにします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stloc.3` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップしに格納するローカル変数リスト <paramref name="index" /> \(短い形式\)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|13 \< `unsigned int8` \>|stloc.s `index`|スタックから値をポップし、ローカル変数に格納 `index`, 、短縮形です。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップされ、ローカル変数に格納 `index`します。  
  
 `stloc.s` 命令が評価スタックから上位の値をポップし、ローカル変数の数に移動 `index`, では、ローカル変数は番号 0 以降。 値の型は、ローカルの現在のメソッドのシグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 `stloc.s` 命令は、0 255 までからのローカル変数の効率的なエンコーディングを提供します。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、ローカル変数に、スタックから移動することと、値が切り捨てられます。 浮動小数点値は、ネイティブのサイズから丸められます \(型 `F`\) を引数に関連付けられているサイズにします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stloc.s` オペコード。  
  
-   ILGenerator.Emit \(オペコード、LocalBuilder\)  
  
-   ILGenerator.Emit オペコード \(バイト\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックから提供されたメモリ アドレスに、指定した型の値をコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|81 \< `T` \>|stobj `class`|型の値が格納 `class` をメモリにスタックからです。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  型の値型オブジェクト `class` スタックにプッシュします。  
  
3.  オブジェクトとアドレスがスタックからポップされます。値型オブジェクトは、アドレスに格納されます。  
  
 `stobj` 命令アドレスで指定されたアドレスに値型のオブジェクトをコピーする \(型のポインター `native int`, 、`*`, 、または `&`\)。 コピーされたバイト数で表されるクラスのサイズによって異なります `class`, 、値型を表すメタデータ トークン。  
  
 操作、 `stobj` 命令を変更する直前に <xref:System.Reflection.Emit.OpCodes.Volatile> または <xref:System.Reflection.Emit.OpCodes.Unaligned> 命令のプレフィックスします。  
  
 <xref:System.TypeLoadException> クラスが見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stobj` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドの値を評価スタックの値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|80 \< `T` \>|stsfld `field`|値を置き換えます `field` 提供の値にします。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  値がスタックからポップされに格納されている `field`します。  
  
 `stsfld` 命令がスタックから値を持つ静的フィールドの値を置換します。`field` 静的フィールドのメンバーを参照する必要があります、メタデータ トークン。  
  
 `stsfld` 命令を前に付けることがあります <xref:System.Reflection.Emit.OpCodes.Volatile>します。  
  
 <xref:System.MissingFieldException> フィールドは、メタデータ内で見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換する場合にチェックします。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `stsfld` オペコード。  
  
-   ILGenerator.Emit \(オペコード、最後に\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある値から別の値を減算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|59|sub|新しい数値を返す別の 1 つの値を減算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value2` から減算 `value1`します。  
  
4.  結果は、スタックにプッシュされます。  
  
 整数演算のオーバーフローが検出されない \(適切なオーバーフロー処理では、次を参照してください。 <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>\)。  
  
 整数の減算飽和するのではなく、ラップします。 例: 8 ビット整数場所 `value1` 0 に設定されていると `value2` 設定されている 1 に、「ラップされた」結果は 255 になります。  
  
 浮動小数点オーバーフロー `+inf` \(`PositiveInfinity`\) または `-inf` \(`NegativeInfinity`\)。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `sub` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある整数値を別の整数値から減算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|DA|sub.ovf|オーバーフロー チェックを別の 1 つの整数値を減算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value2` から減算 `value1` と、オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 この操作を実行して、符号付き整数。浮動小数点値を使用して <xref:System.Reflection.Emit.OpCodes.Sub>します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `sub.ovf` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある符号なし整数値を別の符号なし整数値から減算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|DB|sub.ovf.un|オーバーフロー チェックを別の 1 つの符号なし整数値を減算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` スタックからポップされます。 `value2` から減算 `value1` と、オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException> 結果が結果の型で表されていないことができる場合にスローされます。  
  
 この操作を実行して、符号付き整数。浮動小数点値を使用して <xref:System.Reflection.Emit.OpCodes.Sub>します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `sub.ovf.un` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ジャンプ テーブルを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|45 \< `unsigned int32` \> \< `int32` \>... \< `int32` \>|switch \(`N`, `t1`, `t2`... `tN`\)|いずれかにジャンプ `N` 値。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  値がスタックからポップされ、実行は値が、値によってインデックス付けされたオフセット位置にある命令に転送より小さい `N`します。  
  
 `switch` 命令がジャンプ テーブルを実装します。 命令の形式は、 `unsigned int32` ターゲットの数を表す `N`, と続く `N` int32 値を指定することは、ターゲットをジャンプします。 これらのターゲットは、これを次の命令の先頭からのオフセット \(正または負の値\) として表されます `switch` 命令します。  
  
 `switch` 命令がスタックから値をポップしを比較して、符号なし整数として `N`します。 値の場合より小さい `N`, 、ターゲットが、番号が 0 からインデックスの値をターゲットに転送される実行 \(値 0 は、最初のターゲットを受け取り、値 1 と 2 つ目のターゲットなど\)。 値がより大きいかに等しい場合 `N`, 、次の命令 \(フォール スルー\) で実行が続行されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 制御が移りますアウトや `try`, 、`catch`, 、`filter`, 、および `finally` ブロックがこの命令によって行うことはできません。 \(このような移動は厳しく制限されるは、ままにして命令を代わりに使用する必要があります。\)  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `switch` オペコード。`Label[]` 引数は、32 ビット オフセットを表すラベルの配列。  
  
-   \(オペコード、Label\[\]\) ILGenerator.Emit  
  
   
  
## 例  
 次のコード サンプルは、の使用法を示しています、 `Switch` の配列を使用してジャンプ テーブルを生成するオペコード <xref:System.Reflection.Emit.Label>します。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実際の呼び出し命令が実行される前に、現在のメソッドのスタック フレームが削除されるように、後置のメソッド呼び出し命令を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 14|末尾。|後続の呼び出しでは、現在のメソッドを終了します。|  
  
 この命令に対して定義されている履歴の移行の動作はありません。  
  
 `tail` プレフィックス命令が直前に指定する必要があります、 <xref:System.Reflection.Emit.OpCodes.Call>, 、<xref:System.Reflection.Emit.OpCodes.Calli>, 、または <xref:System.Reflection.Emit.OpCodes.Callvirt> 命令します。 これは、呼び出し命令が実行される前に、現在のメソッドのスタック フレームを削除するかを示します。 また、次の呼び出しから返される値も、現在のメソッドによって返される値と、メソッド間ジャンプに呼び出しを変換したがってできることを意味します。  
  
 スタックは、次の呼び出しによって転送される引数を除く空にする必要があります。 呼び出し命令を次の命令は ret である必要があります。 したがって、唯一の有効なコード シーケンスは `tail. call` \(または `calli` または `callvirt`\)。 Microsoft 中間言語 \(MSIL\) の正しい指示する必要がありますへ分岐できません、 `call` 、命令が、これらは、それに続くへ分岐可能性があります <xref:System.Reflection.Emit.OpCodes.Ret>します。  
  
 コントロールに転送されたは信頼できないコードから、信頼されるコードからコード id のセキュリティは、現在のフレームを破棄できません。 .NET Framework セキュリティ チェックの可能性がありますので、 `tail` は無視され、標準のまま <xref:System.Reflection.Emit.OpCodes.Call> 命令します。 同様にの呼び出しが戻った後に同期の領域を終了できるようにするために、 `tail` 同期済みとマークされたメソッドを終了するために使用する場合、プレフィックスは無視されます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `tail` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Opcode オブジェクトのインスタンス。</param>
        <summary>提供されたオペコードが 1 バイト引数をとる場合は、true または false を返します。</summary>
        <returns>
          <see langword="True" /> または <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、どの MSIL オペレーション コードでは、"short"、使用するフォームは最適化されたコード内を検索を使用できます。  
  
 `TakesSingleByteArgument` 返します `true` 場合、 <xref:System.Reflection.Emit.OpCode> インスタンスでは、1 バイト引数を受け取り、次の場合。  
  
-   オペコード サイズのバイトのアドレスにする分岐命令の実行 \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Br_S> と <xref:System.Reflection.Emit.OpCodes.Bgt_S>\)。  
  
-   オペコード バイトの値をスタックにプッシュ \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>\)。  
  
-   オペコード参照変数または引数のバイト サイズ「省略形」を使用して \(たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldloc_S> と <xref:System.Reflection.Emit.OpCodes.Stloc_S>\)。  
  
 それ以外を返します `false`します。  
  
 次の例では、使用 `TakesSingleByteArgument` に反映して、 `OpCodes` クラスとテストを行っているかどうか各 `OpCode` フィールドは 1 バイト引数を取ります。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックにある例外オブジェクトをスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|7A|throw|例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  \(例外\) へのオブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックし、スローされた例外からポップされます。  
  
 `throw` 命令は、例外オブジェクトをスロー \(型 `O`\) 現在のスタックにします。  
  
 <xref:System.NullReferenceException> オブジェクト参照が null 参照である場合にスローされます。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `throw` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にあるアドレスが、直後の自然なサイズに対応しない可能性がありますかを示す <see langword="ldind" />, 、<see langword="stind" />, 、<see langword="ldfld" />, 、<see langword="stfld" />, 、<see langword="ldobj" />, 、<see langword="stobj" />, 、<see langword="initblk" />, 、または <see langword="cpblk" /> 命令します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 12 \< `unsigned int8` \>|アライメントされていません。`alignment`|後続のポインターの命令が固定である可能性を示します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
 `Unaligned` 指定のアドレス \(アンマネージ ポインター、 `native int`\) スタックに適さないことがあります、直後の自然なサイズに `ldind`, 、`stind`, 、`ldfld`, 、`stfld`, 、`ldobj`, 、`stobj`, 、`initblk`, 、または `cpblk` 命令します。 つまり、に対して、 <xref:System.Reflection.Emit.OpCodes.Ldind_I4> 命令のアドレスのアラインメントは 4 バイト境界にできない可能性があります。`initblk` と `cpblk` 既定の配置が依存しているアーキテクチャ \(32 ビットの Cpu、64 ビット Cpu で 8 バイトでは 4 バイト\)。 32 ビット ワードのサイズには、出力を制限しないコード ジェネレーターを使用する必要があります `unaligned` 不明の場合、アラインメントは、コンパイル時に 8 バイトであります。  
  
 配置の値には、1、2、または 4 および生成されたコードでは、アドレスはバイト、2 バイト、またはクアッド バイトでアライン、それぞれを想定してください手段があります。 その一時的なものに注意してくださいポインター \(型 `*`\)、常に配置します。  
  
 配置中に、 `cpblk` 命令は 2 つの数値 \(ソースの 1 つ\) と、変換先の 1 つ、論理的にはありません影響のパフォーマンスに小さい数値が指定されている場合のみです。  
  
 `unaligned` と `volatile` プレフィックスは、任意の順序で組み合わせることができます。 必要があります直前にある、 `ldind`, 、`stind`, 、`ldfld`, 、`stfld`, 、`ldobj`, 、`stobj`, 、`initblk`, 、または `cpblk`命令します。 のみ、 <xref:System.Reflection.Emit.OpCodes.Volatile> のプレフィックスは許可されて、 <xref:System.Reflection.Emit.OpCodes.Ldsfld> と <xref:System.Reflection.Emit.OpCodes.Stsfld> 指示します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `unaligned` オペコード。  
  
-   ILGenerator.Emit \(オペコード、ラベル\)  
  
-   ILGenerator.Emit オペコード \(バイト\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値型のボックス化変換された形式をボックス化が解除された形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|79 \< `T` \>|ボックス化解除します。 `valType`|値型のデータを抽出する `obj`, 、その表現をボックス化します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、値型のポインターをボックス化解除。  
  
3.  値型のポインターはスタックにプッシュされます。  
  
 値型では、共通言語基盤 \(CLI\) 内に 2 つの別個の形式があります。  
  
-   値の型が別のオブジェクトに埋め込まれたときに使用される「生」のフォームです。  
  
-   ここで値型のデータは事前にラップ \(ボックス化\) オブジェクトに個別のエンティティとして存在する可能性が 'ボックス化' の形式です。  
  
 `unbox` 命令がオブジェクト参照に変換 \(型 `O`\)、値型のポインターに、値型の表現をボックス化 \(マネージ ポインター型 `&`\)、そのフォームをボックス化解除します。 提供された値型 \(`valType`\) がボックス化されたオブジェクト内に含まれる値の型の種類を示すメタデータ トークン。  
  
 異なり <xref:System.Reflection.Emit.OpCodes.Box>, 、オブジェクトで使用する値型のコピーを作成する必要となる `unbox` オブジェクトから値型をコピーする必要はありません。 通常、ボックス化されたオブジェクトの内部に存在する値の種類のアドレスを単純に算出します。  
  
 <xref:System.InvalidCastException> としてオブジェクトがボックス化されていない場合にスローされる `valType`します。  
  
 <xref:System.NullReferenceException> オブジェクト参照が null 参照である場合にスローされます。  
  
 <xref:System.TypeLoadException> 値を入力する場合にスローされる `valType` が見つかりません。 これは、通常、Microsoft 中間言語 \(MSIL\) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `unbox` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>命令で指定された型のボックス化変換された形式を、ボックス化が解除された形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|A5 \< `T` \>|unbox.any `typeTok`|データの抽出 `obj`, 、その表現をボックス化します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 `obj` スタックにプッシュします。  
  
2.  オブジェクト参照がスタックからポップされ、命令で指定された型にボックス化解除されます。  
  
3.  結果のオブジェクト参照または値の型は、スタックにプッシュされます。  
  
 値型のボックス化された形式に適用すると、 `unbox.any` 内に含まれる値を抽出する命令 `obj` \(型の `O`\) と同じであるため `unbox` 続けて `ldobj`します。  
  
 参照型に適用すると、 `unbox.any` 命令と同じ効果は、 `castclass` `typeTok`します。  
  
 場合は、オペランド `typeTok` がジェネリック型パラメーターでは、実行時の動作はそのジェネリック型パラメーターに対して指定されている型によって決まります。  
  
 <xref:System.InvalidCastException> 場合にスローされる `obj` ボックス化された型ではありません。  
  
 <xref:System.NullReferenceException> 場合にスローされる `obj` null 参照です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `unbox.any` オペコード。  
  
-   ILGenerator.Emit \(オペコード、型\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にあるアドレスが揮発性である可能性があるため、この位置の読み取り結果をキャッシュできないこと、またはこの位置への複数の格納を中止できないことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|FE 13|揮発性です。|後続のポインターの参照が揮発性であることを示します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
 `volatile`。 アドレスが揮発性のアドレスを指定します \(つまり、参照できる外部で実行の現在のスレッドに\) と場所をキャッシュできないことやその場所に複数の店舗を中止できないことの読み取りの結果。 あるアクセス `volatile` へのアクセスを 1 つを示すだけに影響が同じ場所にその他のアクセスを個別にマークする必要があります。 揮発性の場所へのアクセスをアトミックに実行する必要はありません。  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned> と `volatile` プレフィックスは、任意の順序で組み合わせることができます。 必要があります直前にある、 `ldind`, 、`stind`, 、`ldfld`, 、`stfld`, 、`ldobj`, 、`stobj`, 、`initblk`, 、または `cpblk` 命令します。 のみ、 `volatile` のプレフィックスは許可されて、 <xref:System.Reflection.Emit.OpCodes.Ldsfld> と <xref:System.Reflection.Emit.OpCodes.Stsfld> 指示します。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `volatile` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある 2 つの値のビットごとの XOR を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に、命令の 16 進数および簡単なリファレンスの概要と共に、Microsoft 中間言語 \(MSIL\) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|--------|--------------|--------|  
|61|xor|2 つの整数値のビットごとの XOR を計算し、整数を返します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1` がポップされます。 スタックとのビットごとの XOR を計算します。  
  
4.  ビットごとの XOR `value2` と `value1` スタックにプッシュします。  
  
 `xor` 命令は、上位 2 つのビットごとの XOR、スタックの値であり、結果をスタックに残しますを計算します。  
  
 `Xor` 整数固有操作です。  
  
 次 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> メソッドのオーバー ロードを使用して、 `xor` オペコード。  
  
-   ILGenerator.Emit\(OpCode\)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>