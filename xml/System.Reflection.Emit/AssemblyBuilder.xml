<Type Name="AssemblyBuilder" FullName="System.Reflection.Emit.AssemblyBuilder">
  <TypeSignature Language="C#" Value="public sealed class AssemblyBuilder : System.Reflection.Assembly, System.Runtime.InteropServices._AssemblyBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AssemblyBuilder extends System.Reflection.Assembly implements class System.Runtime.InteropServices._AssemblyBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.AssemblyBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.Assembly</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._AssemblyBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._AssemblyBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>動的アセンブリを定義し、表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 A dynamic assembly is an assembly that is created using the Reflection Emit APIs. The dynamic modules in the assembly are saved when the dynamic assembly is saved using the <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> method. To generate an executable, the <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> method must be called to identify the method that is the entry point to the assembly. Assemblies are saved as DLLs by default, unless the <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> method requests the generation of a console application or a Windows\-based application.  
  
 If a dynamic assembly contains more than one dynamic module, the assembly's manifest file name should match the module's name that is specified as the first argument to the <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> method.  
  
 Some methods on the base <xref:System.Reflection.Assembly> class, such as **languageKeyword tag is not supported!!!!**  
 and **languageKeyword tag is not supported!!!!**  
, will not work correctly when called from <xref:System.Reflection.Emit.AssemblyBuilder> objects. You can load the defined dynamic assembly and call the methods on the loaded assembly. For example, to ensure that resource modules are included in the returned module list, call **languageKeyword tag is not supported!!!!**  
 on the loaded <xref:System.Reflection.Assembly> object.  
  
 The signing of a dynamic assembly using <xref:System.Reflection.AssemblyName.KeyPair%2A> is not effective until the assembly is saved to disk. So, strong names will not work with transient dynamic assemblies.  
  
 To get an <xref:System.Reflection.Emit.AssemblyBuilder> object, use the <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=fullName> method.  
  
## Reflection emit dynamic assembly scenarios  
 The following are some things to consider when using the <xref:System.Reflection.Emit.AssemblyBuilder> class to create dynamic assemblies.  
  
### Dynamic modules  
 Reflection emit supports the creation of dynamic modules defined in dynamic assemblies. A dynamic module created in a dynamic assembly can be transient or persistable.  
  
### Restrictions on type references  
 Assemblies can reference types defined in another assembly. A transient dynamic assembly can safely reference types defined in another transient dynamic assembly, a persistable dynamic assembly, or a static assembly. However, the common language runtime does not allow a persistable dynamic module to reference a type defined in a transient dynamic module. This is because when the persisted dynamic module is loaded after being saved to disk, the runtime cannot resolve the references to types defined in the transient dynamic module.  
  
### Restrictions on emitting to remote application domains  
 Some scenarios require a dynamic assembly to be created and executed in a remote application domain. Reflection emit does not allow a dynamic assembly to be emitted directly to a remote application domain. The solution is to emit the dynamic assembly in the current application domain, save the emitted dynamic assembly to disk, and then load the dynamic assembly into the remote application domain.  
  
### Dynamic assembly access modes  
 Dynamic assemblies can be created using one of the following access modes:  
  
-   <xref:System.Reflection.Emit.AssemblyBuilderAccess.Run?displayProperty=fullName>  
  
     The dynamic assembly represented by an <xref:System.Reflection.Emit.AssemblyBuilder> object is transient. The dynamic assembly can only be used to execute the emitted code.  
  
-   <xref:System.Reflection.Emit.AssemblyBuilderAccess.Save?displayProperty=fullName>  
  
     The dynamic assembly represented by an <xref:System.Reflection.Emit.AssemblyBuilder> object is persistable but cannot be executed until the saved portable executable \(PE\) file has been loaded from disk.  
  
-   <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=fullName>  
  
     The dynamic assembly represented by an <xref:System.Reflection.Emit.AssemblyBuilder> object is persistable, but can also be executed before and\/or after the assembly is saved to disk.  
  
 The access mode must be specified by providing the appropriate <xref:System.Reflection.Emit.AssemblyBuilderAccess> value in the call to the <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly%2A?displayProperty=fullName> method when the dynamic assembly is defined and cannot be changed later. The runtime uses the access mode of a dynamic assembly to optimize the assembly's internal representation.  
  
   
  
## 例  
 The following code example shows how to define a dynamic assembly with one module. The module in the example assembly contains one type, `MyDynamicType`, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user\-supplied number by the private field value and returns the result.  
  
 <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=fullName> is specified when the assembly is created. The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with [MSIL Disassembler \(Ildasm.exe\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b) or used in another program.  
  
 [!code-cpp[AssemblyBuilderClass\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
    <altmember cref="Overload:System.AppDomain.DefineDynamicAssembly" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddResourceFile">
      <MemberSignature Language="C#" Value="public void AddResourceFile (string name, string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddResourceFile(string name, string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">リソースの論理名。</param>
        <param name="fileName">論理名のマップ先物理ファイル名 \(.resources ファイル\)。 これにパスが含まれていてはなりません。ファイルは、追加先アセンブリと同じディレクトリの中になければなりません。</param>
        <summary>このアセンブリに既存のリソース ファイルを追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `fileName` should not be the same as that of any other persistable module, standalone managed resource, or the standalone manifest file.  
  
 The managed resources in the file are assumed to be public.  
  
 The specified resource file must be in the directory where the assembly will be saved.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> flag. \(See [Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298).\) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
   
  
## 例  
 The following code sample demonstrates how to attach a resource file to a dynamically created assembly, using **languageKeyword tag is not supported!!!!**  
.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> は以前に定義されています。  
  
 \-または\-  
  
 アセンブリには、<paramref name="fileName" /> という名前の別のファイルがあります。  
  
 \-または\-  
  
 <paramref name="name" /> の長さが 0 です。  
  
 \-または\-  
  
 <paramref name="fileName" /> の長さが 0 か、または <paramref name="fileName" /> にパスが含まれる場合。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="fileName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">The FileIOPermissionAccess.Read permission is needed to access the resource file **parameterReference tag is not supported!!!!**  
.</permission>
      </Docs>
    </Member>
    <Member MemberName="AddResourceFile">
      <MemberSignature Language="C#" Value="public void AddResourceFile (string name, string fileName, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddResourceFile(string name, string fileName, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">リソースの論理名。</param>
        <param name="fileName">論理名のマップ先物理ファイル名 \(.resources ファイル\)。 これにパスが含まれていてはなりません。ファイルは、追加先アセンブリと同じディレクトリの中になければなりません。</param>
        <param name="attribute">リソースの属性。</param>
        <summary>このアセンブリに既存のリソース ファイルを追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `fileName` 持続可能な他のモジュール、スタンドアロン マネージ リソースまたはスタンドアロンのマニフェスト ファイルのと同じしないでください。  
  
 属性には、マネージ リソースを指定できます。  
  
 指定したリソース ファイルは、アセンブリが保存されるディレクトリにする必要があります。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 、このメンバーは必要なくなる <xref:System.Security.Permissions.ReflectionPermission> で、 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> フラグ。 \(「[Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298)」を参照\)。 この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## 例  
 次のコード サンプルを使用して、動的に作成されたアセンブリにリソース ファイルを添付する方法を示しています `AddResourceFile`します。  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> は以前に定義されています。  
  
 \-または\-  
  
 アセンブリには、<paramref name="fileName" /> という名前の別のファイルがあります。  
  
 \-または\-  
  
 <paramref name="name" /> の長さが 0 か、または <paramref name="fileName" /> の長さが 0 の場合。  
  
 \-または\-  
  
 <paramref name="fileName" /> にパスが含まれています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="fileName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つからない場合。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">The FileIOPermissionAccess.Read permission is needed to access the resource file **parameterReference tag is not supported!!!!**  
.</permission>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public override string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> オブジェクトの中など、初めに指定されたアセンブリの場所を取得します。</summary>
        <value>初めに指定されたとおりのアセンブリの場所。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 読み込み済みのマニフェストを含むファイルへの絶対パスを取得する、 <xref:System.Reflection.Assembly.Location%2A?displayProperty=fullName> プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドは現在サポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">アセンブリの名前。</param>
        <param name="access">アセンブリのアクセス権。</param>
        <summary>指定した名前とアクセス権がある動的アセンブリを定義します。</summary>
        <returns>新しいアセンブリを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">アセンブリの名前。</param>
        <param name="access">アセンブリのアクセス権。</param>
        <param name="assemblyAttributes">アセンブリの属性を含むコレクション。</param>
        <summary>指定した名前、アクセス権、および属性がある新しいアセンブリを定義します。</summary>
        <returns>新しいアセンブリを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">動的モジュールの名前。 長さは 260 文字未満でなければなりません。</param>
        <summary>このアセンブリの中に、指定された一時動的モジュールを定義します。</summary>
        <returns>定義された動的モジュールを表す <see cref="T:System.Reflection.Emit.ModuleBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 It is an error to define multiple dynamic modules with the same name in an assembly.  
  
 The defined dynamic module is transient. The dynamic module is not saved, even if the parent dynamic assembly was created with <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave>.  
  
> [!NOTE]
>  To suppress optimizations when debugging dynamic modules, apply the <xref:System.Diagnostics.DebuggableAttribute> attribute to the dynamic assembly before calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>. Create an instance of <xref:System.Diagnostics.DebuggableAttribute> with the <xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations> flag and apply it using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method. The attribute must be applied to the dynamic assembly. It has no effect if applied to the module.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> flag. \(See [Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298).\) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
   
  
## 例  
 \[Visual Basic, C\#\]  
  
 The code example below demonstrates how to create a transient dynamic module using **languageKeyword tag is not supported!!!!**  
.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空白文字から始まっています。  
  
 \-または\-  
  
 <paramref name="name" /> の長さが 0 です。  
  
 \-または\-  
  
 <paramref name="name" /> の長さが 260 文字以上です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.ExecutionEngineException">既定のシンボル ライターのアセンブリを読み込めません。  
  
 \-または\-  
  
 既定のシンボルのライター インターフェイスを実装する型が見つかりません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name, bool emitSymbolInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="emitSymbolInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動的モジュールの名前。 長さは 260 文字未満でなければなりません。</param>
        <param name="emitSymbolInfo">シンボル情報を生成する場合、<see langword="true" />。それ以外の場合、<see langword="false" />。</param>
        <summary>このアセンブリ内に名前付き一時動的モジュールを定義し、シンボル情報を生成する必要があるかどうかを指定します。</summary>
        <returns>定義された動的モジュールを表す <see cref="T:System.Reflection.Emit.ModuleBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 It is an error to define multiple dynamic modules with the same name in an assembly.  
  
 The dynamic module is not saved, even if the parent dynamic assembly was created with <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave>.  
  
> [!NOTE]
>  To suppress optimizations when debugging dynamic modules, apply the <xref:System.Diagnostics.DebuggableAttribute> attribute to the dynamic assembly before calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>. Create an instance of <xref:System.Diagnostics.DebuggableAttribute> with the <xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations> flag and apply it using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method. The attribute must be applied to the dynamic assembly. It has no effect if applied to the module.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> flag. \(See [Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298).\) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
   
  
## 例  
 \[Visual Basic, C\#\]  
  
 The code example below demonstrates how to create a transient dynamic module using **languageKeyword tag is not supported!!!!**  
, suppressing symbol information.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CPP/source.cpp#2)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CS/source.cs#2)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空白文字から始まっています。  
  
 \-または\-  
  
 <paramref name="name" /> の長さが 0 です。  
  
 \-または\-  
  
 <paramref name="name" /> の長さが 260 文字以上です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ExecutionEngineException">既定のシンボル ライターのアセンブリを読み込めません。  
  
 \-または\-  
  
 既定のシンボル ライターのインターフェイスを実装する型が見つかりません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name, string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの名前。 長さは 260 文字未満でなければなりません。</param>
        <param name="fileName">動的モジュールの保存先となるファイルの名前。</param>
        <summary>指定したファイルに保存される指定された名前を持つ、永続する動的モジュールを定義します。 シンボル情報は生成されません。</summary>
        <returns>定義された動的モジュールを表す <see cref="T:System.Reflection.Emit.ModuleBuilder" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 To define a persistable dynamic module, this assembly needs to be created with the <xref:System.Reflection.Emit.AssemblyBuilderAccess.Save> or the <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave> attribute.  
  
 If you want the module to contain the assembly manifest, **parameterReference tag is not supported!!!!**  
 should be the same as the name of the assembly \(that is, the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> property of the <xref:System.Reflection.AssemblyName> used to create the dynamic assembly\) and **parameterReference tag is not supported!!!!**  
 should be the same as the filename you specify when you save the assembly.  
  
 In an assembly with only one module, that module should contain the assembly manifest.  
  
> [!NOTE]
>  To suppress optimizations when debugging dynamic modules, apply the <xref:System.Diagnostics.DebuggableAttribute> attribute to the dynamic assembly before calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>. Create an instance of <xref:System.Diagnostics.DebuggableAttribute> with the <xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations> flag and apply it using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method. The attribute must be applied to the dynamic assembly. It has no effect if applied to the module.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> flag. \(See [Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298).\) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
   
  
## 例  
 \[Visual Basic, C\#\]  
  
 The code example below demonstrates how to create a persistent dynamic module using **languageKeyword tag is not supported!!!!**  
.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CPP/source.cpp#3)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CS/source.cs#3)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="fileName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> または <paramref name="fileName" /> の長さが 0 です。  
  
 または  
  
 <paramref name="name" /> の長さが 260 文字以上です。  
  
 または  
  
 <paramref name="fileName" /> にパス指定 \(ディレクトリ コンポーネントなど\) が含まれています。  
  
 または  
  
 このアセンブリに属する別のファイルの名前と競合しています。</exception>
        <exception cref="T:System.InvalidOperationException">このアセンブリは既に保存されています。</exception>
        <exception cref="T:System.NotSupportedException">このアセンブリは、<see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Run" /> 属性を持つ動的アセンブリで呼び出されました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.ExecutionEngineException">既定のシンボル ライターのアセンブリを読み込めません。  
  
 \-または\-  
  
 既定のシンボルのライター インターフェイスを実装する型が見つかりません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write\=true or Append\=true is needed to save the module</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name, string fileName, bool emitSymbolInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="emitSymbolInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの名前。 長さは 260 文字未満でなければなりません。</param>
        <param name="fileName">動的モジュールの保存先となるファイルの名前。</param>
        <param name="emitSymbolInfo">
          <see langword="true" /> の場合、既定のシンボル ライターを使用してシンボル情報が書き込まれます。</param>
        <summary>モジュール名、モジュールの保存先のファイル名、および既定のシンボルのライターを使用してシンボル情報を出力する必要があるかどうかを指定して、永続する動的モジュールを定義します。</summary>
        <returns>定義された動的モジュールを表す <see cref="T:System.Reflection.Emit.ModuleBuilder" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 To define a persistable dynamic module, this assembly needs to be created with the <xref:System.Reflection.Emit.AssemblyBuilderAccess.Save> or the <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave> attribute.  
  
 If you want the module to contain the assembly manifest, **parameterReference tag is not supported!!!!**  
 should be the same as the name of the assembly \(that is, the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> property of the <xref:System.Reflection.AssemblyName> used to create the dynamic assembly\) and **parameterReference tag is not supported!!!!**  
 should be the same as the filename you specify when you save the assembly.  
  
 In an assembly with only one module, that module should contain the assembly manifest.  
  
> [!NOTE]
>  To suppress optimizations when debugging dynamic modules, apply the <xref:System.Diagnostics.DebuggableAttribute> attribute to the dynamic assembly before calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>. Create an instance of <xref:System.Diagnostics.DebuggableAttribute> with the <xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations> flag and apply it using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method. The attribute must be applied to the dynamic assembly. It has no effect if applied to the module.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> flag. \(See [Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298).\) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
   
  
## 例  
 \[Visual Basic, C\#\]  
  
 The code example below demonstrates how to create a persistent dynamic module with symbol emission using **languageKeyword tag is not supported!!!!**  
.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CPP/source.cpp#4)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CS/source.cs#4)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="fileName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> または <paramref name="fileName" /> の長さが 0 です。  
  
 または  
  
 <paramref name="name" /> の長さが 260 文字以上です。  
  
 または  
  
 <paramref name="fileName" /> にパス指定 \(ディレクトリ コンポーネントなど\) が含まれています。  
  
 または  
  
 このアセンブリに属する別のファイルの名前と競合しています。</exception>
        <exception cref="T:System.InvalidOperationException">このアセンブリは既に保存されています。</exception>
        <exception cref="T:System.NotSupportedException">このアセンブリは、<see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Run" /> 属性を持つ動的アセンブリで呼び出されました。</exception>
        <exception cref="T:System.ExecutionEngineException">既定のシンボル ライターのアセンブリを読み込めません。  
  
 \-または\-  
  
 既定のシンボル ライターのインターフェイスを実装する型が見つかりません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write\=true or Append\=true is needed to save this module</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">リソースの論理名。</param>
        <param name="description">文章によるリソースの説明。</param>
        <param name="fileName">論理名をマップする物理ファイル名 \(.resources ファイル\)。 これにはパスを含めないでください。</param>
        <summary>既定のパブリック リソース属性で、このアセンブリのスタンドアロン マネージ リソースを定義します。</summary>
        <returns>指定されたリソースの <see cref="T:System.Resources.ResourceWriter" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Fine grain resources can be added with the returned <xref:System.Resources.ResourceWriter> by calling <xref:System.Resources.ResourceWriter.AddResource%2A>.  
  
 `fileName` should not be the same as that of any other persistable module, stand\-alone managed resource, or the stand\-alone manifest file.  
  
 The runtime calls the <xref:System.Resources.ResourceWriter.Close%2A> method when the dynamic assembly is saved.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> flag. \(See [Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298).\) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
   
  
## 例  
 The following example uses the <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> method to get a resource writer. The example uses the resource writer to add three resource strings.  
  
 [!code-cpp[AssemblyBuilder.DefineResource Example 2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder.DefineResource Example 2/CPP/assemblybuilder_defineresource.cpp#1)]
 [!code-csharp[AssemblyBuilder.DefineResource Example 2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder.DefineResource Example 2/CS/assemblybuilder_defineresource.cs#1)]
 [!code-vb[AssemblyBuilder.DefineResource Example 2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder.DefineResource Example 2/VB/assemblybuilder_defineresource.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> は以前に定義されています。  
  
 \-または\-  
  
 アセンブリには、<paramref name="fileName" /> という名前の別のファイルがあります。  
  
 \-または\-  
  
 <paramref name="name" /> の長さが 0 です。  
  
 または  
  
 <paramref name="fileName" /> の長さが 0 です。  
  
 または  
  
 <paramref name="fileName" /> にパスが含まれています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="fileName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write\=true or Append\=true</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, string fileName, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, string fileName, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">リソースの論理名。</param>
        <param name="description">文章によるリソースの説明。</param>
        <param name="fileName">論理名をマップする物理ファイル名 \(.resources ファイル\)。 これにはパスを含めないでください。</param>
        <param name="attribute">リソースの属性。</param>
        <summary>このアセンブリのスタンドアロン マネージ リソースを定義します。 属性には、マネージ リソースを指定できます。</summary>
        <returns>指定されたリソースの <see cref="T:System.Resources.ResourceWriter" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Fine\-grain resources can be added with the returned <xref:System.Resources.ResourceWriter> by calling <xref:System.Resources.ResourceWriter.AddResource%2A>.  
  
 `fileName` should not be the same as that of any other persistable module, standalone managed resource, or the standalone manifest file.  
  
 The runtime calls the <xref:System.Resources.ResourceWriter.Close%2A> method when the dynamic assembly is saved.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> flag. \(See [Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298).\) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> は既に定義済みか、<paramref name="fileName" /> という名前のアセンブリに別のファイルが存在する場合。  
  
 または  
  
 <paramref name="name" /> の長さが 0 です。  
  
 または  
  
 <paramref name="fileName" /> の長さが 0 です。  
  
 または  
  
 <paramref name="fileName" /> にパスが含まれています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="fileName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write\=true or Append\=true</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (byte[] resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(unsigned int8[] resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="resource">アンマネージ リソースを表すバイトの非透過 BLOB。</param>
        <summary>このアセンブリのアンマネージ リソースをバイトの非透過 BLOB として定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 An assembly can be associated with only one unmanaged resource. This means that calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A> or <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A> after either one of the methods was called previously will throw the System.ArgumentException being throw. Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility \(not supplied with the common language runtime\).  
  
   
  
## 例  
 The following code sample creates and attaches an array of bytes representing an unmanaged resource to a dynamic assembly, using **languageKeyword tag is not supported!!!!**  
.  
  
 [!code-cpp[AssemblyBuilder\_DefineUnmanagedResource2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource2/CPP/assemblybuilder_defineunmanagedresource2.cpp#1)]
 [!code-csharp[AssemblyBuilder\_DefineUnmanagedResource2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource2/CS/assemblybuilder_defineunmanagedresource2.cs#1)]
 [!code-vb[AssemblyBuilder\_DefineUnmanagedResource2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource2/VB/assemblybuilder_defineunmanagedresource2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">アンマネージ リソースは、以前に定義されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resource" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (string resourceFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(string resourceFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceFileName">リソース ファイルの名前。</param>
        <summary>リソース ファイルの名前が指定されたこのアセンブリのアンマネージ リソース ファイルを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 An assembly can be associated with only one unmanaged resource. This means that calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A> or <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A> after either one of the methods was called previously will throw the System.ArgumentException. Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility \(not supplied with the common language runtime\).  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> flag. \(See [Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298).\) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
   
  
## 例  
 The example below demonstrates a call to **languageKeyword tag is not supported!!!!**  
, passing an external resource file.  
  
 [!code-cpp[AssemblyBuilder\_DefineUnmanagedResource\#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource/CPP/assemblybuilder_defineunmanagedresource.cpp#3)]
 [!code-csharp[AssemblyBuilder\_DefineUnmanagedResource\#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource/CS/assemblybuilder_defineunmanagedresource.cs#3)]
 [!code-vb[AssemblyBuilder\_DefineUnmanagedResource\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource/VB/assemblybuilder_defineunmanagedresource.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">アンマネージ リソースは、以前に定義されました。  
  
 または  
  
 ファイル <paramref name="resourceFileName" /> を読み取ることができません。  
  
 または  
  
 <paramref name="resourceFileName" /> が空の文字列 \(""\) です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFileName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="resourceFileName" /> が見つかりません。  
  
 または  
  
 <paramref name="resourceFileName" /> はディレクトリです。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">The FileIOPermissionAccess.Read permission is needed to access the resource file **parameterReference tag is not supported!!!!**  
.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineVersionInfoResource">
      <MemberSignature Language="C#" Value="public void DefineVersionInfoResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineVersionInfoResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの AssemblyName オブジェクトと、アセンブリのカスタム属性に指定された情報を使用して、アンマネージ バージョンの情報リソースを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリは、アンマネージ リソースを 1 つだけに関連付けることができます。 つまり、その通話 <xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A> または <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A> のいずれかが呼び出された後、以前、System.ArgumentException がスローされます。 複数のアンマネージ リソースを \(共通言語ランタイム SDK に付属していません\)、Microsoft ResMerge ユーティリティなどのツールとマージする必要があります。  
  
 引数が空の文字列は単一の空白として書き込まれます。 スペースは、引数の文字列内の null 文字に置き換えられます。  
  
 情報を推測、 `AssemblyName` この動的アセンブリを定義するために使用します。 このアセンブリのカスタム属性で指定された情報を上書きする、 `AssemblyName` オブジェクトです。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 、このメンバーは必要なくなる <xref:System.Security.Permissions.ReflectionPermission> で、 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> フラグ。 \(「[Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298)」を参照\)。 この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## 例  
 次の例は、の使用方法を示しています。 `DefineVersionInfoResource`します。  
  
 [!code-cpp[AssemblyBuilder\_DefineVersionInfoResource\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/CPP/assemblybuilder_defineversioninforesource.cpp#1)]
 [!code-csharp[AssemblyBuilder\_DefineVersionInfoResource\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/CS/assemblybuilder_defineversioninforesource.cs#1)]
 [!code-vb[AssemblyBuilder\_DefineVersionInfoResource\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/VB/assemblybuilder_defineversioninforesource.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">アンマネージ バージョンの情報リソースが既に定義されています。  
  
 \-または\-  
  
 アンマネージ バージョン情報が大きすぎて、保持できません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineVersionInfoResource">
      <MemberSignature Language="C#" Value="public void DefineVersionInfoResource (string product, string productVersion, string company, string copyright, string trademark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="product" Type="System.String" />
        <Parameter Name="productVersion" Type="System.String" />
        <Parameter Name="company" Type="System.String" />
        <Parameter Name="copyright" Type="System.String" />
        <Parameter Name="trademark" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="product">このアセンブリが配布される製品の名前。</param>
        <param name="productVersion">このアセンブリが配布される製品のバージョン。</param>
        <param name="company">このアセンブリを作成した会社の名前。</param>
        <param name="copyright">このアセンブリに適用されるすべての著作権情報、商標、および登録商標を記述します。 これには、すべての通知の全文、法的な記号、著作権表示年、商標番号などが含まれます。 英語で、この文字列が"Copyright Microsoft Corp. の形式でなければなりません1990\-2001".</param>
        <param name="trademark">このアセンブリに適用されるすべての商標および登録商標を記述します。 これには、すべての通知の全文、法的な記号、商標番号などが含まれます。 英語では、この文字列は "Windows is a trademark of Microsoft Corporation" という書式になります。</param>
        <summary>指定された仕様で、このアセンブリのアンマネージ バージョン情報リソースを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリは、アンマネージ リソースを 1 つだけに関連付けることができます。 つまり、その通話 <xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A> または <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A> のいずれかが呼び出された後、以前、System.ArgumentException がスローされます。 複数のアンマネージ リソースを Microsoft などのツールとマージする必要がある `ResMerge` ユーティリティ \(共通言語ランタイム SDK に付属していません\)。  
  
 引数が空の文字列は単一の空白として書き込まれます。 スペースは、引数の文字列内の null 文字に置き換えられます。  
  
 バージョン リソースの構造には、バージョン、言語、およびファイルの配布を識別するデータが含まれています。 インストール プログラムは、ファイル インストール ライブラリ \(バージョンの関数を使用します。DLL\) ファイルから、バージョン情報リソースを取得し、リソースからバージョン情報ブロックを抽出します。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 、このメンバーは必要なくなる <xref:System.Security.Permissions.ReflectionPermission> で、 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> フラグ。 \(「[Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298)」を参照\)。 この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## 例  
 次の例は、の使用方法を示しています。 `DefineVersionInfoResource`します。  
  
 [!code-cpp[AssemblyBuilder\_DefineVersionInfoResource\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/CPP/assemblybuilder_defineversioninforesource.cpp#1)]
 [!code-csharp[AssemblyBuilder\_DefineVersionInfoResource\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/CS/assemblybuilder_defineversioninforesource.cs#1)]
 [!code-vb[AssemblyBuilder\_DefineVersionInfoResource\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/VB/assemblybuilder_defineversioninforesource.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">アンマネージ バージョン情報リソースが既に定義されています。  
  
 \-または\-  
  
 アンマネージ バージョン情報が大きすぎて、保持できません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリのエントリ ポイントを返します。</summary>
        <value>このアセンブリのエントリ ポイント。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">対象のインスタンスと比較する対象のオブジェクト、または <see langword="null" />。</param>
        <summary>対象のインスタンスが、指定したオブジェクトに等しいかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> がこのインスタンスの型および値に等しい場合は <paramref name="obj" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.Evidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリの証拠を取得します。</summary>
        <value>このアセンブリの証拠。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の動的アセンブリの表示名を取得します。</summary>
        <value>動的アセンブリの表示名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>現在の <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> に適用されたカスタム属性をすべて返します。</summary>
        <returns>カスタム属性を含む配列。属性がない場合、配列は空です。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">属性の派生元となる基本型。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>現在適用されているすべてのカスタム属性を返します <see cref="T:System.Reflection.Emit.AssemblyBuilder" />, 、指定した属性の型から派生したとします。</summary>
        <returns>
          <paramref name="attributeType" /> の任意のレベルから派生したカスタム属性を含む配列。そのような属性がない場合、配列は空です。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> は、ランタイムによって提供された <see cref="T:System.Type" /> オブジェクトではありません。 たとえば、<paramref name="attributeType" /> は <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトです。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> に適用されている属性に関する情報を含む <see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトを返します。</summary>
        <returns>現在のモジュールに適用されている属性に関するデータを表す <see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトのジェネリック リスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 カスタム属性自体のリフレクション専用コンテキストに読み込まれるコードが定義されている場合、リフレクションのみのコンテキスト内のコードのカスタム属性を調べるには、このメソッドを使用します。 などのメソッド <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=fullName> と <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=fullName> 属性のインスタンスを作成するため、このような場合では使用できません。 リフレクションのみのコンテキストでコードを実行できません。 詳細については、たとえばコードを参照してください、 <xref:System.Reflection.CustomAttributeData> クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder GetDynamicModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder GetDynamicModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求された動的モジュールの名前。</param>
        <summary>指定された名前の動的モジュールを返します。</summary>
        <returns>要求された動的モジュールを表す ModuleBuilder オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の長さが 0 です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリで定義されているエクスポートされた型を取得します。</summary>
        <returns>このアセンブリで定義されているエクスポートされた型を格納している <see cref="T:System.Type" /> の配列。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">このメソッドは実装されていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public override System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">指定されたファイルの名前。</param>
        <summary>このアセンブリのマニフェストのファイル テーブル内の指定されたファイルの <see cref="T:System.IO.FileStream" /> を取得します。</summary>
        <returns>指定されたファイルの <see cref="T:System.IO.FileStream" />。ファイルが見つからない場合は、<see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `name` ファイルへのパスを含めないでください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドは現在サポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public override System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース モジュールを含めるかどうかを指定して、アセンブリ マニフェストのファイル テーブルのファイルを取得します。</summary>
        <returns>
          <see cref="T:System.IO.FileStream" /> オブジェクトの配列。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">このメソッドは現在サポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>このアセンブリの一部であるすべての読み込み済みモジュールを返し、また必要に応じて、リソース モジュールを含めます。</summary>
        <returns>このアセンブリの一部である読み込み済みモジュール。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public override System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">リソースの名前。</param>
        <summary>指定されたリソースが永続化された方法に関する情報を返します。</summary>
        <returns>リソースのトポロジに関する情報が設定された <see cref="T:System.Reflection.ManifestResourceInfo" />。リソースが見つからない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">このメソッドは現在サポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public override string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリから指定されたマニフェスト リソースを読み込みます。</summary>
        <returns>すべてのリソースの名前を格納している <see langword="String" /> 型配列。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">このメソッドは動的アセンブリではサポートされていません。 マニフェスト リソース名を取得するには、<see cref="M:System.Reflection.Assembly.GetManifestResourceNames" /> を使用します。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求されているマニフェスト リソースの名前。</param>
        <summary>このアセンブリから、指定されたマニフェスト リソースを読み込みます。</summary>
        <returns>このマニフェスト リソースを表す <see cref="T:System.IO.Stream" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">このメソッドは現在サポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">マニフェスト リソース名のスコープを指定するために名前空間を使用する型。</param>
        <param name="name">要求されているマニフェスト リソースの名前。</param>
        <summary>このアセンブリから、指定された型の名前空間によってスコープが指定されている、指定されたマニフェスト リソースを読み込みます。</summary>
        <returns>このマニフェスト リソースを表す <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.IO.Stream> が、リソースの先頭に設定ファイルを指すポインター。  
  
   
  
## 例  
 場合の完全な名前 `type` "MyNameSpace.MyClasses"と `name` 「ドット」は、 `GetManifestResourceStream` MyNameSpace.Dot という名前のリソースが検索されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドは現在サポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求されたモジュールの名前。</param>
        <summary>このアセンブリから指定されたモジュールを取得します。</summary>
        <returns>要求されたモジュール。モジュールが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>このアセンブリの一部であるすべてのモジュールを取得し、また必要に応じて、リソース モジュールを含めます。</summary>
        <returns>このアセンブリの一部であるモジュール。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public override System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">シャドウ コピーの後でコード ベースをアセンブリの場所に設定する場合は <see langword="true" />。コード ベースを元の場所に設定する場合は <see langword="false" />。</param>
        <summary>現在の動的アセンブリが作成された時に指定した <see cref="T:System.Reflection.AssemblyName" /> を取得し、指定されたとおりにコード ベースを設定します。</summary>
        <returns>動的アセンブリの名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public override System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> で参照されるアセンブリの <see cref="T:System.Reflection.AssemblyName" /> オブジェクトの不完全なリストを取得します。</summary>
        <returns>参照アセンブリのアセンブリ名の配列。 この配列は完全な一覧ではありません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、参照先アセンブリの完全な一覧を返しません。 たとえば、カスタム属性を適用する、 <xref:System.Reflection.Emit.AssemblyBuilder>, 、属性が定義されているアセンブリは、このメソッドによって返される一覧に含まれています。 ただし、使用する場合、 <xref:System.Type> オブジェクトの種類が含まれていないこと、メソッドのパラメーターの種類を指定します。  
  
 参照先アセンブリの完全な一覧を取得するアセンブリを保存、別のアプリケーション ドメイン、および呼び出しに読み込むときに、 <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">指定されたカルチャ。</param>
        <summary>指定されたカルチャ設定のサテライト アセンブリを取得します。</summary>
        <returns>指定されたサテライト アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サテライト アセンブリには、ローカライズできない実行可能コードと、既定またはニュートラル カルチャとして機能する単一カルチャ用のリソースが含まれているアプリケーションのメイン アセンブリをローカライズされたリソースが含まれています。  
  
 現在のアセンブリ バージョンを使用するには、このメソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">アセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">ファイル名が一致するサテライト アセンブリが見つかりましたが、<see langword="CultureInfo" /> は指定されているファイル名とは一致しませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">サテライト アセンブリは、有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">指定されたカルチャ。</param>
        <param name="version">サテライト アセンブリのバージョン。</param>
        <summary>指定されたバージョンの、指定されたカルチャ設定のサテライト アセンブリを取得します。</summary>
        <returns>指定されたサテライト アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サテライト アセンブリには、ローカライズできない実行可能コードと、既定またはニュートラル カルチャとして機能する単一カルチャ用のリソースが含まれているアプリケーションのメイン アセンブリをローカライズされたリソースが含まれています。  
  
 呼び出す、 <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> の現在のアセンブリ バージョンを使用するオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileLoadException">ファイル名が一致するサテライト アセンブリが見つかりましたが、<see langword="CultureInfo" /> またはバージョンが指定されているファイルとは一致しませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">アセンブリが見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">サテライト アセンブリは、有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">検索の対象となる型の名前。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="ignoreCase">検索中に型名の大文字と小文字の違いを無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>現在の <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> で定義および作成された型から、指定された型を取得します。</summary>
        <returns>指定された型。型が見つからない場合、またはまだ作成されていない場合は、<see langword="null" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すことによって作成されるまで、型が見つかりません、 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public override bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリがグローバル アセンブリ キャッシュから読み込まれたかどうかを示す値を取得します。</summary>
        <value>常に <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.Emit.AssemblyBuilder> オブジェクトは、常に動的アセンブリを表すし、そのため決してから読み込まれて、グローバル アセンブリ キャッシュです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public override long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的アセンブリが作成されるホスト コンテキストを取得します。</summary>
        <value>動的アセンブリが作成されるホスト コンテキストを示す値。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public override string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マニフェストを格納しているファイルに保存される、共通言語ランタイムのバージョンを取得します。</summary>
        <value>共通言語ランタイムのバージョンを表す文字列。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">テストする属性の種類。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>このメンバーに指定された属性の型の 1 つまたは複数のインスタンスが適用されるかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="attributeType" /> の 1 つまたは複数のインスタンスがこの動的アセンブリに適用される場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public override bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリが動的なアセンブリであることを示す値を取得します。</summary>
        <value>常に <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 An <xref:System.Reflection.Emit.AssemblyBuilder> object always represents a dynamic assembly.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public override string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>シャドウ コピーされたファイルではない場合は、マニフェストを格納している読み込み済みファイルの位置をコードベース形式で取得します。</summary>
        <value>マニフェストを格納している読み込み済みファイルの場所。 読み込み済みファイルがシャドウ コピーされている場合、<see langword="Location" /> はシャドウ コピーされる前のファイルの場所です。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">このメソッドは現在サポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリのマニフェストを格納している現在の <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> のモジュールを取得します。</summary>
        <value>マニフェスト モジュール。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public override System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の動的アセンブリの許可セットを取得します。</summary>
        <value>現在の動的アセンブリの許可セット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Security.PermissionSet> オブジェクトは、パスなどの機密情報を含めることができます。 そのため、これらのオブジェクトにアクセスするには、完全な信頼が必要です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public override bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的アセンブリがリフレクションのみのコンテキストにあるかどうかを示す値を取得します。</summary>
        <value>動的アセンブリがリフレクションのみのコンテキストにある場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 リフレクションのみのコンテキストで動的アセンブリを作成するには、次のように指定します。 <xref:System.Reflection.Emit.AssemblyBuilderAccess.ReflectionOnly?displayProperty=fullName> を作成するとき、 <xref:System.Reflection.Emit.AssemblyBuilder>です。 動的アセンブリがリフレクションのみのコンテキストで発生した場合は、そのコードを実行できません。  
  
> [!NOTE]
>  使用することができます、動的アセンブリをディスクに保存した後、 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> リフレクション専用コンテキストに完了したアセンブリを読み込みます。 ただし、アセンブリは変更不要になったことができます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Reflection.Emit.AssemblyBuilderAccess.ReflectionOnly" />
        <altmember cref="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string assemblyFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string assemblyFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFileName">アセンブリのファイル名。</param>
        <summary>ディスクにこの動的アセンブリを保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、この動的アセンブリで定義されているすべての一時的でない動的モジュールを保存します。 一時動的モジュールは保存されません。 アセンブリ ファイル名は、モジュールのいずれかの名前と同じでもかまいません。 必要な場合は、アセンブリ マニフェストがそのモジュールに格納します。`assemblyFileName` すべてのアセンブリ内に含まれるモジュールの名前を異なっていてもかまいません。 必要な場合は、アセンブリ ファイルには、アセンブリ マニフェストだけが含まれています。  
  
 各 <xref:System.Resources.ResourceWriter> を使用して取得 <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, 、このメソッドは、.resources ファイルおよび呼び出しを書き込みます <xref:System.Resources.ResourceWriter.Close%2A> ストリームを閉じます。  
  
 `assemblyFileName` ドライブまたはディレクトリのコンポーネントがないと、単純なファイル名を指定する必要があります。 特定のディレクトリにアセンブリを作成するには、いずれかを使用、 <xref:System.AppDomain.DefineDynamicAssembly%2A> ターゲット ディレクトリの引数を受け取るメソッドです。  
  
 .NET Framework version 2.0 では、このオーバー ロードで、 <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> メソッドを呼び出すことは、 <xref:System.Reflection.Emit.AssemblyBuilder.Save%28System.String%2CSystem.Reflection.PortableExecutableKinds%2CSystem.Reflection.ImageFileMachine%29> メソッドのオーバー ロードで <xref:System.Reflection.PortableExecutableKinds.ILOnly> の `portableExecutableKind` パラメーターと <xref:System.Reflection.ImageFileMachine.I386> の `imageFileMachine` パラメーター。  
  
   
  
## 例  
 次のコード サンプルは、動的アセンブリを作成しを使用してローカル ディスクに永続化 `Save`します。  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.Save Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.Save Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.Save Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.Save Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.Save Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.Save Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFileName" /> の長さは 0 です。  
  
 \-または\-  
  
 アセンブリに同じ名前のモジュール リソース ファイルが 2 つ以上あります。  
  
 \-または\-  
  
 アセンブリのターゲット ディレクトリが正しくありません。  
  
 \-または\-  
  
 <paramref name="assemblyFileName" /> が単純なファイル名 \(たとえば、ディレクトリまたはドライブのコンポーネントを持つ\) でないか、複数のアンマネージ リソース \(バージョン情報のリソースを含む\) がこのアセンブリで定義されています。  
  
 \-または\-  
  
 <see cref="T:System.Reflection.AssemblyCultureAttribute" /> の <see langword="CultureInfo" /> 文字列が有効な文字列ではなく、かつ、このメソッドを呼び出す前に <see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)" /> が呼び出されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFileName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">このアセンブリは、既に保存されています。  
  
 \-または\-  
  
 このアセンブリのアクセスは <see langword="Run" /><see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /> です</exception>
        <exception cref="T:System.IO.IOException">保存中に出力エラーが発生します。</exception>
        <exception cref="T:System.NotSupportedException">ディスクに書き込まれるアセンブリのモジュール内のいずれの型についても <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> が呼び出されませんでした。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write \= true or Append \= true is needed to save this assembly to the specified file name.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string assemblyFileName, System.Reflection.PortableExecutableKinds portableExecutableKind, System.Reflection.ImageFileMachine imageFileMachine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string assemblyFileName, valuetype System.Reflection.PortableExecutableKinds portableExecutableKind, valuetype System.Reflection.ImageFileMachine imageFileMachine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFileName" Type="System.String" />
        <Parameter Name="portableExecutableKind" Type="System.Reflection.PortableExecutableKinds" />
        <Parameter Name="imageFileMachine" Type="System.Reflection.ImageFileMachine" />
      </Parameters>
      <Docs>
        <param name="assemblyFileName">アセンブリのファイル名。</param>
        <param name="portableExecutableKind">コードの性質を指定する <see cref="T:System.Reflection.PortableExecutableKinds" /> 値のビットごとの組み合わせ。</param>
        <param name="imageFileMachine">ターゲット プラットフォームを指定する <see cref="T:System.Reflection.ImageFileMachine" /> の値。</param>
        <summary>ディスクにこの動的アセンブリを保存します。その際、アセンブリの実行可能ファイルのコードの性質とターゲット プラットフォームを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `imageFileMachine` と `portableExecutableKind` 互換性がない `imageFileMachine` よりも優先 `portableExecutableKind`します。 例外をスローすることはありません。 たとえば、指定した <xref:System.Reflection.ImageFileMachine.I386?displayProperty=fullName> と <xref:System.Reflection.PortableExecutableKinds.PE32Plus?displayProperty=fullName>, 、<xref:System.Reflection.PortableExecutableKinds.PE32Plus?displayProperty=fullName> は無視されます。  
  
 このメソッドは、この動的アセンブリで定義されているすべての一時的でない動的モジュールを保存します。 一時動的モジュールは保存されません。 アセンブリ ファイル名は、モジュールのいずれかの名前と同じでもかまいません。 必要な場合は、アセンブリ マニフェストがそのモジュールに格納します。`assemblyFileName` すべてのアセンブリ内に含まれるモジュールの名前を異なっていてもかまいません。 必要な場合は、アセンブリ ファイルには、アセンブリ マニフェストだけが含まれています。  
  
 各 <xref:System.Resources.ResourceWriter> を使用して取得 <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, 、このメソッドは、.resources ファイルおよび呼び出しを書き込みます <xref:System.Resources.ResourceWriter.Close%2A> ストリームを閉じます。  
  
 `assemblyFileName` ドライブまたはディレクトリのコンポーネントがないと、単純なファイル名を指定する必要があります。 特定のディレクトリにアセンブリを作成するには、いずれかを使用、 <xref:System.AppDomain.DefineDynamicAssembly%2A> ターゲット ディレクトリの引数を受け取るメソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFileName" /> の長さは 0 です。  
  
 \-または\-  
  
 アセンブリに同じ名前のモジュール リソース ファイルが 2 つ以上あります。  
  
 \-または\-  
  
 アセンブリのターゲット ディレクトリが正しくありません。  
  
 \-または\-  
  
 <paramref name="assemblyFileName" /> が単純なファイル名 \(たとえば、ディレクトリまたはドライブのコンポーネントを持つ\) でないか、複数のアンマネージ リソース \(バージョン情報のリソースを含む\) がこのアセンブリで定義されています。  
  
 \-または\-  
  
 <see cref="T:System.Reflection.AssemblyCultureAttribute" /> の <see langword="CultureInfo" /> 文字列が有効な文字列ではなく、かつ、このメソッドを呼び出す前に <see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)" /> が呼び出されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFileName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">このアセンブリは、既に保存されています。  
  
 \-または\-  
  
 このアセンブリのアクセスは <see langword="Run" /><see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /> です</exception>
        <exception cref="T:System.IO.IOException">保存中に出力エラーが発生します。</exception>
        <exception cref="T:System.NotSupportedException">ディスクに書き込まれるアセンブリのモジュール内のいずれの型についても <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> が呼び出されませんでした。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write \= true or Append \= true is needed to save this assembly to the specified file name.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>共通言語ランタイム \(CLR: Common Language Runtime\) によってこのアセンブリに適用されるセキュリティ規則のセットを示す値を取得します。</summary>
        <value>CLR によってこの動的アセンブリに適用されるセキュリティ規則のセット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] レベル 2 の透過性を常に強制 \(<xref:System.Security.SecurityRuleSet.Level2?displayProperty=fullName>\) の動的アセンブリを生成します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">カスタム属性を定義するヘルパー クラスのインスタンス。</param>
        <summary>カスタム属性ビルダーを使用して、このアセンブリのカスタム属性を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> cannot be used to set declarative security attributes. Use one of the overloads of <xref:System.AppDomain.DefineDynamicAssembly%2A> that takes required, optional, and refused permissions.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> flag. \(See [Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298).\) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
   
  
## 例  
 The following code sample illustrates the use of **languageKeyword tag is not supported!!!!**  
 within <xref:System.Reflection.Emit.AssemblyBuilder>, using a <xref:System.Reflection.Emit.CustomAttributeBuilder>.  
  
 [!code-cpp[AssemblyBuilder\_SetCustomAttribute1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute1/CPP/assemblybuilder_setcustomattribute1.cpp#1)]
 [!code-csharp[AssemblyBuilder\_SetCustomAttribute1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute1/CS/assemblybuilder_setcustomattribute1.cs#1)]
 [!code-vb[AssemblyBuilder\_SetCustomAttribute1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute1/VB/assemblybuilder_setcustomattribute1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">カスタム属性のコンストラクター。</param>
        <param name="binaryAttribute">属性を表すバイト blob。</param>
        <summary>指定されたカスタム属性 blob を使用して、このアセンブリのカスタム属性を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 See the metadata specification in the ECMA Partition II documentation for details on how to format **parameterReference tag is not supported!!!!**  
. The documentation is available online; see [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.  
  
 `RuntimeConstructorInfo` is a special type generated by the system. It derives from the <xref:System.Reflection.ConstructorInfo> class, and any <xref:System.Reflection.ConstructorInfo> object you obtain through reflection is actually an instance of `RuntimeConstructorInfo`.  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> cannot be used to set declarative security attributes. Use one of the overloads of <xref:System.AppDomain.DefineDynamicAssembly%2A> that takes required, optional, and refused permissions.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> flag. \(See [Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298).\) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
   
  
## 例  
 The following code sample illustrates the use of **languageKeyword tag is not supported!!!!**  
 to attach a custom attribute to a dynamically generated assembly.  
  
 [!code-cpp[AssemblyBuilder\_SetCustomAttribute2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute2/CPP/assemblybuilder_setcustomattribute2.cpp#1)]
 [!code-csharp[AssemblyBuilder\_SetCustomAttribute2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute2/CS/assemblybuilder_setcustomattribute2.cs#1)]
 [!code-vb[AssemblyBuilder\_SetCustomAttribute2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute2/VB/assemblybuilder_setcustomattribute2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> または <paramref name="binaryAttribute" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="con" /> は <see langword="RuntimeConstructorInfo" /> オブジェクトではありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetEntryPoint">
      <MemberSignature Language="C#" Value="public void SetEntryPoint (System.Reflection.MethodInfo entryMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetEntryPoint(class System.Reflection.MethodInfo entryMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryMethod" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="entryMethod">この動的アセンブリのエントリ ポイントを表すメソッドへの参照。</param>
        <summary>コンソール アプリケーションを開発していると仮定した場合、この動的アセンブリのエントリ ポイントを設定します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryMethod" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entryMethod" /> は、このアセンブリ内に含まれません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetEntryPoint">
      <MemberSignature Language="C#" Value="public void SetEntryPoint (System.Reflection.MethodInfo entryMethod, System.Reflection.Emit.PEFileKinds fileKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetEntryPoint(class System.Reflection.MethodInfo entryMethod, valuetype System.Reflection.Emit.PEFileKinds fileKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="fileKind" Type="System.Reflection.Emit.PEFileKinds" />
      </Parameters>
      <Docs>
        <param name="entryMethod">この動的アセンブリのエントリ ポイントを表すメソッドへの参照。</param>
        <param name="fileKind">ビルド中のアセンブリの実行可能ファイルの型。</param>
        <summary>このアセンブリのエントリ ポイントを設定し、ビルド中の移植可能な実行可能 \(PE ファイル\) の型を定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 、このメンバーは必要なくなる <xref:System.Security.Permissions.ReflectionPermission> で、 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=fullName> フラグ。 \(「[Security Issues in Reflection Emit](http://msdn.microsoft.com/ja-jp/0f8bf8fa-b993-478f-87ab-1a1a7976d298)」を参照\)。 この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryMethod" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entryMethod" /> は、このアセンブリ内に含まれません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetIDsOfNames`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">メソッドは COM <c>IDispatch</c> インターフェイスを使用して遅延バインディングで呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfo`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">メソッドは COM <c>IDispatch</c> インターフェイスを使用して遅延バインディングで呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトによって提供される型情報インターフェイスの数を受け取る場所へのポインター。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 \(0 または 1\) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfoCount`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">メソッドは COM <c>IDispatch</c> インターフェイスを使用して遅延バインディングで呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::Invoke`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">メソッドは COM <c>IDispatch</c> インターフェイスを使用して遅延バインディングで呼び出されます。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリのスタンドアロン マネージ リソースを定義します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたサテライト アセンブリを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SetEntryPoint">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この動的アセンブリのエントリ ポイントを設定します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ディスクにこの動的アセンブリを保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="AddResourceFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリに既存のリソース ファイルを追加します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリから、指定されたマニフェスト リソースを読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="DefineVersionInfoResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリのアンマネージ バージョン情報リソースを定義します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="DefineUnmanagedResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリのアンマネージ リソースを定義します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> に適用されたカスタム属性を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリにカスタム属性を設定します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>動的アセンブリを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="DefineDynamicModule">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリ内部の動的モジュールを定義します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>