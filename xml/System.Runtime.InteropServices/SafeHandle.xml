<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>オペレーティング システム ハンドルのラッパー クラスを表します。 このクラスは継承する必要があります。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Runtime.InteropServices.SafeHandle> クラスには、ハンドル リソース、および処理の途中でガベージ コレクションによって解放されてから意図しないアンマネージ オブジェクトを参照する Windows では、リサイクルされているハンドルの防止のクリティカル ファイナライズが用意されています。  
  
 このトピックでは、次の内容について説明します。  
  
 [なぜ SafeHandle でしょうか。](#Why)   
 [SafeHandle の実行内容](#Does)   
 [SafeHandle から派生したクラス](#Derived)  
  
<a name="Why"></a>   
## なぜ SafeHandle でしょうか。  
 .NET Framework version 2.0 では、すべてのオペレーティング システムにハンドルをカプセル化でしただけ前に、 <xref:System.IntPtr> マネージ ラッパー オブジェクトです。 これには、ネイティブ コードと相互運用する便利な方法がでしたが、ハンドルが突然中止されたスレッドやスタック オーバーフローなどの非同期例外によってリーク可能性があります。 これらの非同期例外はオペレーティング システム リソースのクリーンアップに支障をきたす、アプリでほとんどどこにでも発生することができます。  
  
 上書きを <xref:System.Object.Finalize%2A?displayProperty=fullName> メソッドのアンマネージ リソースのクリーンアップを許可するときにオブジェクトがガベージ コレクション、状況によっては、ファイナライズ可能なオブジェクトを再要求できるガベージによってプラットフォーム内でメソッドの実行中にコレクションが呼び出しです。 ファイナライザーは、そのプラットフォームに渡されるハンドルを解放する場合は、呼び出しを呼び出し、ハンドルの破損につながる可能性があります。 プラットフォームの中に、メソッドがブロックされている間、ハンドルが解放もされるようにファイルを読み取り中に呼び出しを呼び出します。  
  
 ほど、積極的に、Windows には、ハンドルが再利用、ためのハンドルはリサイクルされ、機密データを含む可能性がある別のリソースを示すがします。 これはリサイクル攻撃と呼ばれ、ことができますデータが破損する可能性のあるセキュリティの脅威となります。  
  
<a name="Does"></a>   
## SafeHandle の実行内容  
 <xref:System.Runtime.InteropServices.SafeHandle> クラスは、これらオブジェクトの有効期間に関する問題のいくつかを簡素化し、プラットフォームと統合されたオペレーティング システムのリソースのリークを防止するように起動します。<xref:System.Runtime.InteropServices.SafeHandle> クラスは、割り当てと解放を妨げることがなくハンドルによってオブジェクトの有効期間に関する問題を解決します。 によって、ハンドルが閉じられ、予期しない時に実行することが保証されるクリティカル ファイナライザーが含まれている <xref:System.AppDomain> アンロードされると、プラットフォーム呼び出しの状況であってもが破損した状態であると見なされます。  
  
 <xref:System.Runtime.InteropServices.SafeHandle> から継承 <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, 、クリティカル ファイナライザーの前に、重要でないすべてのファイナライザーが呼び出されます。 同じガベージ コレクションの実行中にライブが不要になったオブジェクトには、ファイナライザーが呼び出されます。 たとえば、 <xref:System.IO.FileStream> オブジェクトは、ハンドル リークまたはリサイクルされることがなくバッファー内の既存のデータを洗い出すに通常のファイナライザーを実行できます。 一般的な用途は、重要な重要ではないファイナライザーの間でこの非常に弱い順序付けすることはありません。 使用するこれらのライブラリを許可することで既存のライブラリの移行を支援するには、主に存在する <xref:System.Runtime.InteropServices.SafeHandle> 、セマンティクスを変更することがなく。 また、クリティカル ファイナライザーと何も呼び出してなど、 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=fullName> メソッドが制約された実行領域である必要があります。 これには、ファイナライザーの呼び出し先内でどのようなコードを記述するの制約が設けられています。  
  
 プラットフォームが自動的に操作を呼び出しによってカプセル化されるハンドルの参照カウントをインクリメント、 <xref:System.Runtime.InteropServices.SafeHandle> と完了時にそれらをデクリメントします。 こうハンドル リサイクルまたはされず予期せず終了します。  
  
 構築する際に、基になるハンドルの所有権を指定できる <xref:System.Runtime.InteropServices.SafeHandle> オブジェクトに値を指定することによって、 `ownsHandle` の引数、 <xref:System.Runtime.InteropServices.SafeHandle> クラスのコンス トラクターです。 これを制御するかどうか、 <xref:System.Runtime.InteropServices.SafeHandle> オブジェクトが破棄された後に、オブジェクトは、ハンドルを解放します。  これは例外的な有効期間の要件を持つハンドル、または有効期限を持つが他のユーザーによって制御されるハンドルを使用するために役立ちます。  
  
<a name="Derived"></a>   
## SafeHandle から派生したクラス  
 <xref:System.Runtime.InteropServices.SafeHandle> オペレーティング システム ハンドルの抽象ラッパー クラスです。 このクラスからの派生は困難です。 代わりに、次のセーフ ハンドルを提供する <xref:Microsoft.Win32.SafeHandles> 名前空間の派生クラスを使用してください。  
  
-   ファイル \(、 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> クラス\)。  
  
-   メモリ マップ ファイル \(、 <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> クラス\)。  
  
-   パイプ \(、 <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> クラス\)。  
  
-   メモリ ビュー \(、 <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> クラス\)。  
  
-   暗号の構成要素 \(、 <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, 、<xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, 、<xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, 、および <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> クラス\)。  
  
-   プロセス \(、 <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> クラス\)。  
  
-   レジストリ キー \(、 <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> クラス\)。  
  
-   待機ハンドル \(、 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> クラス\)。  
  
   
  
## 例  
 次のコード例から派生する、オペレーティング システム ファイル ハンドル用のカスタムのセーフ ハンドルを作成 <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>します。 ファイルからバイトを読み取りし、16 進数値を表示します。 障害テスト ハーネスも含まれています。 中止するには、スレッドを原因となったが、ハンドル値を解放します。  使用する場合、 <xref:System.IntPtr> ハンドルを表現するには、ハンドルが非同期スレッドの中止のためリーク場合があります。  
  
 コンパイル済みのアプリケーションと同じフォルダー内のテキスト ファイルを必要があります。 "Hexviewer"だ、アプリケーションの名前を入力すると仮定するとコマンドラインの使用には。  
  
 `HexViewer <filename> -Fault`  
  
 必要に応じて指定 `-Fault` 意図的に特定のウィンドウでスレッドを中断することで、ハンドル リークが発生しようとします。 Windows Perform.exe ツールを使用すると、エラーを挿入するときにハンドル数を監視できます。  
  
 [!code-csharp[SafeHandle\#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">for full trust for inheritors. This member cannot be inherited by partially trusted code.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
    <block subset="none" type="overrides">
      <para>To create a class derived from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must know how to create and free an operating system handle. This process is different for different handle types because some use the [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) function, while others use more specific functions such as [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) or [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). For this reason, you must create a derived class of <see cref="T:System.Runtime.InteropServices.SafeHandle" /> for each operating system handle type that you want to wrap in a safe handle.  
  
 When you inherit from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must override the following members: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> and <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  
  
 You should also provide a default constructor that calls the base constructor with a value that represent an invalid handle value, and a <see cref="T:System.Boolean" /> value indicating whether the native handle is owned by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> and consequently should be freed when that <see cref="T:System.Runtime.InteropServices.SafeHandle" /> has been disposed.</para>
    </block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">無効なハンドルの値 \(通常は 0 または \-1\)。<see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> の実装では、この値に対して <see langword="true" /> を返す必要があります。</param>
        <param name="ownsHandle">終了処理中に <see langword="true" /> によってハンドルを確実に解放する場合は <see cref="T:System.Runtime.InteropServices.SafeHandle" />。それ以外の場合は <see langword="false" /> \(お勧めしません\)。</param>
        <summary>指定した無効なハンドル値を使用して、<see cref="T:System.Runtime.InteropServices.SafeHandle" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 `ownsHandle` パラメーターは `false`, 、<xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> は呼び出しません。 そのため、これは使用しないで、コードでリソースがリークが発生すると、このパラメーターの値を使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">派生クラスがアンマネージ コードのアクセス許可なしにアセンブリに存在しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">for full trust for inheritors. This member cannot be inherited by partially trusted code.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リソースを解放するためのハンドルをマークします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed. This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case. Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary \(for example, to flush out file buffers or to write some data back into memory\). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.  
  
 Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.  
  
> [!NOTE]
>  Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">参照カウンターが正常にインクリメントされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Runtime.InteropServices.SafeHandle" /> インスタンスの参照カウンターを手動でインクリメントします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> method prevents the common language runtime from reclaiming memory used by a handle \(which occurs when the runtime calls the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method\). You can use this method to manually increment the reference count on a <xref:System.Runtime.InteropServices.SafeHandle> instance. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> returns a Boolean value using a **languageKeyword tag is not supported!!!!**  
 parameter \(**parameterReference tag is not supported!!!!**  
\) that indicates whether the reference count was incremented successfully. This allows your program logic to back out in case of failure. You should set **parameterReference tag is not supported!!!!**  
 to **languageKeyword tag is not supported!!!!**  
 before calling <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. If **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, avoid resource leaks by matching the call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> with a corresponding call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  
  
> [!CAUTION]
>  This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region \(CER\), where a thread abort cannot interrupt processing.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> フィールドの値を戻します。</summary>
        <returns>
          <see langword="IntPtr" /> フィールドの値を表す <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />。 ハンドルが <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" /> で無効としてマークされている場合にも、このメソッドは元のハンドル値を返すため、返される値が古い値である可能性があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 You can use this method to retrieve the actual handle value from an instance of the <xref:System.Runtime.InteropServices.SafeHandle> derived class. This method is needed for backwards compatibility because many properties in the .NET Framework return **languageKeyword tag is not supported!!!!**  
 handle types. **languageKeyword tag is not supported!!!!**  
 handle types are platform\-specific types used to represent a pointer or a handle.  
  
> [!CAUTION]
>  Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value. The returned handle can also be recycled at any point. At best, this means the handle might suddenly stop working. At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle. For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource. See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Runtime.InteropServices.SafeHandle" /> インスタンスの参照カウンターを手動でデクリメントします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  
  
> [!CAUTION]
>  This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region \(CER\), where a thread abort cannot interrupt processing. In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads. Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Runtime.InteropServices.SafeHandle" /> クラスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed. This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case. Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary \(for example, to flush out file buffers or to write some data back into memory\). In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.  
  
 Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object. The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state.  
  
> [!NOTE]
>  Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">通常の破棄操作を実行する場合は <see langword="true" />。ハンドルを終了する場合は <see langword="false" />。</param>
        <summary>通常の破棄操作を実行するかどうかを指定して、<see cref="T:System.Runtime.InteropServices.SafeHandle" /> クラスによって使用されているアンマネージ リソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 You should never explicitly call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method with the **parameterReference tag is not supported!!!!**  
 parameter set to **languageKeyword tag is not supported!!!!**  
.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ハンドルに関連付けられたすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> メソッドは、デストラクター、 <xref:System.Runtime.InteropServices.SafeHandle> クラスです。 アプリケーション コードでは、このメソッドを直接呼び出さないでください。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ラップするハンドルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ハンドルをパブリックに公開しない \(つまり、派生クラスの外部で\)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ハンドルが閉じているかどうかを示す値を取得します。</summary>
        <value>ハンドルが閉じている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> メソッドを示す値を返すかどうか、 <xref:System.Runtime.InteropServices.SafeHandle> オブジェクトのハンドルは、ネイティブのリソースの関連付けがなくなってします。 定義とこれに対し、 <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> かどうか指定したハンドルは常に無効とみなさを計算するプロパティです。<xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> メソッドが返される、 `true` 値は、次の場合。  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> メソッドが呼び出されました。  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> メソッドまたは <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> メソッドが呼び出されへの参照がない、 <xref:System.Runtime.InteropServices.SafeHandle> 他のスレッド上のオブジェクト。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされると、ハンドル値が無効かどうかを示す値を取得します。</summary>
        <value>ハンドル値が無効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生クラスで実装する必要があります、 <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> プロパティ、共通言語ランタイムでは、重大な終了処理が必要かどうかを確認できるようにします。 派生クラスでサポートしているハンドルの一般的な型に合った実装を提供する必要があります \(0 または\-1 が正しくありません\)。 これらのクラスは、特定のセーフ ハンドルの種類のさらに派生します。  
  
 異なり、 <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> プロパティは、レポートをかどうか、 <xref:System.Runtime.InteropServices.SafeHandle> 基になるハンドルを使用してオブジェクトが完了した、 <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> プロパティがあるかどうか、指定したハンドルの値は常に無効とみなさを計算します。 したがって、 <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> プロパティは常に 1 つのハンドル値を同じ値を返します。  
  
   
  
## 例  
 次の例では、ファイルが正常に開かれたかどうかを確認します。 このコード例が示されている例の一部は、 <xref:System.Runtime.InteropServices.SafeHandle> クラスです。  
  
 [!code-csharp[SafeHandle\#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、ハンドルを解放するために必要なコードを実行します。</summary>
        <returns>ハンドルが正常に解放された場合は <see langword="true" />。深刻なエラーが発生した場合は <see langword=" false" />。 この場合、[ReleaseHandleFailed](http://msdn.microsoft.com/ja-jp/44cd98ba-95e5-40a1-874d-e8e163612c51) マネージ デバッグ アシスタントが生成されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> メソッドは、ハンドルがで定義されている有効な場合にのみとに 1 回だけ呼び出される保証は、 <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> プロパティです。 このメソッドの実装、 <xref:System.Runtime.InteropServices.SafeHandle> ハンドルを解放するために必要なコードを実行するクラスを派生します。 の機能の 1 つ <xref:System.Runtime.InteropServices.SafeHandle> は、コードの実装で、リソース リークの防止を保証する <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 失敗しない必要があります。 ガベージ コレクター <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>ガベージ コレクション、同時になったオブジェクトの通常のファイナライザーが実行された後です。 ガベージ コレクターがこのメソッドを呼び出すためのリソースを保証する、メソッドがその中に中断されていない、実行中です。 このメソッドは、\(静的に確定できる呼び出しグラフの中ですべてのメソッド\) およびインスタンスの構築時に制約された実行領域 \(CER\) として準備されます。 オーバーライドされた場合は、どのエラー パスを導入しないように注意する必要がありますが、これには、スレッドの中止の割り込みが防止されますが、 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> メソッドです。 具体的には、適用、 <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> から呼び出すメソッドが存在する属性 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>します。 ほとんどの場合、このコードがあります。  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 簡単なクリーンアップをさらに、\(たとえば、Win32 API を呼び出す `CloseHandle` ファイル ハンドルで\) 1 つのプラットフォーム呼び出しの戻り値をチェックすることができます。 複雑なクリーンアップのためには、多くのプログラム ロジックとその一部が失敗する多くのメソッド呼び出しがあります。 プログラム ロジックが、このような場合の各フォールバック コードを持つことを確認する必要があります。  
  
 場合 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 返します `false` 生成何らかの理由で、 [ReleaseHandleFailed](http://msdn.microsoft.com/ja-jp/44cd98ba-95e5-40a1-874d-e8e163612c51) マネージ デバッグ アシスタントです。  これにより、リソースを解放しようとすると、失敗した場合を検出できます。  
  
   
  
## 例  
 次のコード例は、ハンドルを解放し、示されている例の一部である、 <xref:System.Runtime.InteropServices.SafeHandle> クラスです。  
  
 [!code-csharp[SafeHandle\#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">使用する既存のハンドル。</param>
        <summary>ハンドルを指定した既存のハンドルに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> メソッドを .NET Framework の COM 相互運用機能のインフラストラクチャがマーシャ リングをサポートしていないために、\(構造体には、ハンドルが返されます\) の場合など、既存のハンドルをサポートする必要がある場合にのみ出力構造体のハンドル。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>今後は使用しないものとしてハンドルをマークします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す、 <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> メソッドがわかっているハンドルが不要になったリソースを参照している場合のみです。 これは、値を変更しない、 <xref:System.Runtime.InteropServices.SafeHandle.handle> フィールド; 終了としてのみのハンドルをマークしています。 ハンドルが古い値が含まれます。 この呼び出しの効果は、ことは行われませんリソースを解放します。  
  
 場合と同様、 <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> メソッドを使用して <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> を既存のハンドルをサポートする必要がある場合にのみです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Runtime.InteropServices.SafeHandle" /> クラスによって使用されているリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>