<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>属性付きメソッドがアンマネージ ダイナミックリンク ライブラリ \(DLL\) によって静的エントリ ポイントとして公開されることを示します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 You can apply this attribute to methods.  
  
 The <xref:System.Runtime.InteropServices.DllImportAttribute> attribute provides the information needed to call a function exported from an unmanaged DLL. As a minimum requirement, you must supply the name of the DLL containing the entry point.  
  
 You apply this attribute directly to C\# and C\+\+ method definitions; however, the Visual Basic compiler emits this attribute when you use the **languageKeyword tag is not supported!!!!**  
 statement. For complex method definitions that include <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, or <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields, you apply this attribute directly to Visual Basic method definitions.  
  
 **Note** JScript does not support this attribute. You can use C\# or Visual Basic wrapper classes to access unmanaged API methods from JScript programs.  
  
 For additional information about using the platform invoke service to access functions in unmanaged DLLs, see [&#91;\<topic:\/\/cpconconsumingunmanageddllfunctions\>&#93;](http://msdn.microsoft.com/ja-jp/eca7606e-ebfb-4f47-b8d9-289903fdc045).  
  
> [!NOTE]
>  The <xref:System.Runtime.InteropServices.DllImportAttribute> does not support marshaling of generic types.  
  
   
  
## 例  
 The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 **languageKeyword tag is not supported!!!!**  
 function.  The code example then calls the imported method.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">アンマネージ メソッドを含んでいる DLL の名前。 DLL がアセンブリに含まれている場合、アセンブリの表示名があります。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> をインポートするメソッドを含む DLL の名前を持つクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アンマネージ DLL ファイルが含まれているアセンブリでは、たとえば、リンカーを使用している場合、または `/linkresource` コンパイラ オプションの一部としてアセンブリの表示名を指定できる `dllName`です。 たとえば、名前付きアンマネージ DLL `unmanaged.dll` という名前のマネージ アセンブリに含まれる `MyAssembly`, 、次のコードに示すように、属性を指定することがあります。  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Runtime.InteropServices.DllImportAttribute> 属性、Win32 のインポートを `MessageBox` 関数です。  コード例は、インポートされたメソッドを呼び出します。  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有効または Unicode 文字を ANSI 文字に変換するときに、最適マッピングの動作を無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `true`, 、最適マッピング動作が有効になります。 それ以外の場合、最適マッピングが無効になっています。<xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> フィールドは `true` 既定です。 このフィールドの設定のどのレベルの設定を上書き、 <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=fullName> 属性です。  
  
 共通言語ランタイムは、Windows 98 または Windows me で実行中のアンマネージ メソッドに渡される Unicode 文字が管理している ANSI 文字に変換します。 最適マッピングを使用すると、完全一致が存在しない場合は、近い文字を提供する相互運用マーシャラーします。 など、マーシャラーは、ANSI 文字を使用するアンマネージ メソッドに対して 'c' の著作権文字を Unicode に変換します。 一部の文字がない最適形式です。これらの文字といいます。 既定値にマップできない文字が変換通常 '?'ANSI 文字です。  
  
> [!CAUTION]
>  特定の Unicode 文字は、円記号など、危険な文字に変換されます ' \\' 文字で、パスを誤って変更することができます。 設定して、 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> フィールドを `true`, 、例外をスローして、呼び出し元にマップできない文字の存在を通知することができます。  
  
> [!CAUTION]
>  によって提供される既定値を変更することはできません、 <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> と <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> フィールドのアンマネージのセーフ配列に ANSI 文字数\] または \[LPSTRs マネージ配列の要素を渡すことができます。 最適マッピングが常に有効になっているし、例外はスローされません。 この組み合わせに、セキュリティ モデルが損なわれる可能性があります。  
  
   
  
## 例  
 場合によっては、Visual Basic 開発者が使用して、 <xref:System.Runtime.InteropServices.DllImportAttribute>, の代わりに、 `Declare` ステートメントは、マネージ コードで DLL 関数を定義します。 設定、 <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> フィールドは、このような場合のいずれかです。 次の例は、最も厳密に適用する方法を示しています。 文字のマッピングのセキュリティをプラットフォーム呼び出しメソッドの定義を ANSI 文字セットを指定する、最適マッピングの動作を無効にすると、マップできない Unicode 文字に例外をスローしています。  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エントリ ポイントの呼び出し規約を示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このフィールドのいずれかに設定する、 <xref:System.Runtime.InteropServices.CallingConvention> 列挙型のメンバーです。 既定値、 <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> フィールドは <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, 、順番に既定で設定される <xref:System.Runtime.InteropServices.CallingConvention.StdCall> 規則です。  
  
 詳細については、MSDN ライブラリの呼び出し規約を参照してください。  
  
   
  
## 例  
 場合によっては、Visual Basic 開発者が使用して、 <xref:System.Runtime.InteropServices.DllImportAttribute>, の代わりに、 `Declare` ステートメントは、マネージ コードで DLL 関数を定義します。 設定、 <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> フィールドは、このような場合のいずれかです。  
  
 System.Runtime.InteropServices.DllImportAttribute\#1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メソッドとコントロールの名前を修飾する文字列パラメーターをマーシャ リングする方法を示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メンバーを持つこのフィールドを使用して、 <xref:System.Runtime.InteropServices.CharSet> 文字列パラメーターのマーシャ リング動作を指定して、指定された正確な名前 \("A"または"W"で終わる名前\) を起動するには、どのエントリ ポイント名を指定する列挙体です。 C\# および Visual Basic の既定の列挙体メンバー `CharSet.Ansi` C\+\+ の既定の列挙体メンバーおよび `CharSet.None`, と同じに `CharSet.Ansi`します。 Visual Basic では使用して、 `Declare` ステートメントを指定する、 `CharSet` フィールドです。  
  
 <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> フィールドの動作に影響、 `CharSet` フィールドを呼び出すには、どのエントリ ポイント名を決定します。 詳細な説明と、文字列のマーシャ リングとに関連付けられている動作と一致する名前の例については、 `CharSet` フィールドを参照してください [Specifying a Character Set](http://msdn.microsoft.com/ja-jp/a8347eb1-295f-46b9-8a78-63331f9ecc50)します。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Runtime.InteropServices.DllImportAttribute> 属性、Win32 のインポートを `MessageBox` 関数です。  コード例は、インポートされたメソッドを呼び出します。  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前または呼び出される DLL エントリ ポイントの序数を示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 エントリ ポイントを含む DLL の名前を示す文字列を指定することによって、エントリ ポイント名を指定するか、エントリ ポイントを特定するには、その序数をします。 たとえば、1、\# 記号では、序数が付きます。 共通言語ランタイムでマークされたの.net メソッドの名前を使用してこのフィールドを省略した場合、 <xref:System.Runtime.InteropServices.DllImportAttribute>です。  
  
 詳細については、「[&#91;\<topic:\/\/cpconidentifyingfunctionsindlls\>&#93;](http://msdn.microsoft.com/ja-jp/3e3f6780-6d90-4413-bad7-ba641220364d)」を参照してください。 使用する方法を示す例については、 <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> フィールドを参照してください [Specifying an Entry Point](http://msdn.microsoft.com/ja-jp/d1247f08-0965-416a-b978-e0b50652dfe3)します。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Runtime.InteropServices.DllImportAttribute> 属性、Win32 のインポートを `MessageBox` 関数です。  コード例では、 <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> プロパティをインポートする関数を指定して、名前に変更 `MyNewMessageBoxMethod`します。  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールかどうか、 <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> フィールドは共通言語ランタイムによってエントリ ポイント名を指定した以外の場合に、アンマネージ DLL を検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `false`, 、文字 A で追加されたエントリ ポイント名が呼び出されるときに、 <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=fullName> フィールドに設定されている `CharSet.Ansi`, 、文字 W が付いたエントリ ポイント名が呼び出されるとときに、 <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=fullName> フィールドに設定されて、 `CharSet.Unicode`です。 通常、マネージ コンパイラは、このフィールドを設定します。  
  
 次の表に、間のリレーションシップ、 <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> と <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> プログラミング言語によって課される既定値に基づくフィールドです。 既定の設定をオーバーライドできますが、注意が必要でこれを行います。  
  
|言語|ANSI|Unicode|自動|  
|--------|----------|-------------|--------|  
|Visual Basic|ExactSpelling: \= True|ExactSpelling: \= True|ExactSpelling: false|  
|C\#|ExactSpelling \= false|ExactSpelling \= false|ExactSpelling \= false|  
|C\+\+|ExactSpelling \= false|ExactSpelling \= false|ExactSpelling \= false|  
  
   
  
## 例  
 場合によっては、Visual Basic 開発者が使用して、 <xref:System.Runtime.InteropServices.DllImportAttribute>, 、使用する代わりに、 `Declare` ステートメントは、マネージ コードで DLL 関数を定義します。 設定、 <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> フィールドは、このような場合のいずれかです。  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>かどうかアンマネージ メソッドがあることを示します <see langword="HRESULT" /> または <see langword="retval" /> の値は直接変換を返すかどうか <see langword="HRESULT" /> または <see langword="retval" /> 返す値は自動的に例外に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定、 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> フィールドを `true` を含むアンマネージ シグネチャを直接変換 `HRESULT` または `retval` 値; に設定 `false` に自動的に変換する `HRESULT` または `retval` 例外の値。 既定では、 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> フィールドは `true`です。  
  
 ときに `true`, 、結果として得られるメソッドのシグネチャを表す整数値を返す、 `HRESULT` 値。  ここでは、手動で戻り値を検査してそれに従って応答アプリケーションにします。  
  
 設定すると、 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> フィールドを `false`, 、結果として得られるメソッドのシグネチャには、整数ではなく void 戻り値の型が含まれています \(`HRESULT`\) 型を返します。  アンマネージ メソッドが作成するとき、 `HRESULT`, 、戻り値のランタイムは自動的に無視 `S_OK` \(または 0\)、例外をスローしません。`HRESULT`以外の s `S_OK`, 、ランタイムが自動的に対応する例外をスロー、 `HRESULT`です。  なお、 <xref:System.Runtime.InteropServices.DllImportAttribute> 属性のみを返すメソッドをこの変換を実行する、 `HRESULT`です。  
  
 既定のエラー報告動作を変更することもできます `HRESULT`場合は、例外に合わせてレポート アプリケーションの構造エラー例外にします。  
  
 このフィールドはのような <xref:System.Runtime.InteropServices.PreserveSigAttribute>。 ただし、対照的に、 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> フィールドの場合は、属性の既定値 `false`です。  
  
 場合によっては、Visual Basic 開発者が使用して、 <xref:System.Runtime.InteropServices.DllImportAttribute>, 、使用する代わりに、 `Declare` ステートメントは、マネージ コードで DLL 関数を定義します。 設定、 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> フィールドは、このような場合のいずれかです。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Runtime.InteropServices.DllImportAttribute> アンマネージをインポートする `SHAutoComplete` 関数を 1 回、 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> フィールドに設定 `true` ときのこの <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> フィールドに設定 `false`します。  このコード例では、 `SHAutoComplete` 、例外の 1 つの時間に発生したエラーを生成する関数と `HRESULT` 次です。  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し先が呼び出すかどうかを示す、 <see langword="SetLastError" /> 属性付きメソッドから戻る前に Win32 API 関数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `true` 呼び出し先が呼び出すことを示すために `SetLastError`。 そうしないと、 `false`です。 既定値は、`false` です。  
  
 ランタイム マーシャラー `GetLastError` およびその他の API 呼び出しによって上書きされないようにするのに返される値をキャッシュします。 エラー コードを取得するにを呼び出して <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>します。  
  
   
  
## 例  
 場合によっては、Visual Basic 開発者が使用して、 <xref:System.Runtime.InteropServices.DllImportAttribute>, 、使用する代わりに、 `Declare` ステートメントは、マネージ コードで DLL 関数を定義します。 設定、 <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> フィールドは、このような場合のいずれかです。  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有効または ANSI に変換されるマップできない Unicode 文字で例外のスローを無効に"?"文字です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `true` 例外が毎回ことを示すために、相互運用マーシャラーがマップできない文字です。 `false` ことを示すために、 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> フィールドが無効になります。 このフィールドは `false` 既定です。  
  
 共通言語ランタイムは、Windows 98 または Windows me で実行中のアンマネージ メソッドに渡される Unicode 文字が管理している ANSI 文字に変換します。 最適マッピングを使用すると、完全一致が存在しない場合は、近い文字を提供する相互運用マーシャラーします。 など、マーシャラーは、ANSI 文字を使用するアンマネージ メソッドに対して 'c' の著作権文字を Unicode に変換します。 一部の文字がない最適形式です。これらの文字といいます。 既定値にマップできない文字が変換通常 '?'ANSI 文字です。  
  
> [!CAUTION]
>  特定の Unicode 文字は、円記号など、危険な文字に変換されます ' \\' 文字で、パスを誤って変更することができます。 設定して、 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> フィールドを `true`, 、例外をスローして、呼び出し元にマップできない文字の存在を通知することができます。  
  
> [!CAUTION]
>  によって提供される既定値を変更することはできません、 <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> と <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> フィールドのアンマネージのセーフ配列に ANSI 文字数\] または \[LPSTRs マネージ配列の要素を渡すことができます。 最適マッピングが常に有効になっているし、例外はスローされません。 この組み合わせに、セキュリティ モデルが損なわれる可能性があります。  
  
   
  
## 例  
 場合によっては、Visual Basic 開発者が使用して、 <xref:System.Runtime.InteropServices.DllImportAttribute> を使用する代わりに、マネージ コードで DLL 関数を定義する、 `Declare` ステートメントです。 設定、 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> フィールドは、このような場合のいずれかです。 次の例は、最も厳密に適用する方法を示しています。 文字のマッピングのセキュリティをプラットフォーム呼び出しメソッドの定義を ANSI 文字セットを指定する、最適マッピングの動作を無効にすると、マップできない Unicode 文字に例外をスローしています。  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エントリ ポイントを含む DLL ファイルの名前を取得します。</summary>
        <value>エントリ ポイントを含む DLL ファイルの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 完全パスまたは相対パスを指定することができます。 パスを指定しない場合、DLL で他のいくつかの方法で、DLL が読み込まれていない場合、実行時にでも現在のパスにする必要があります。 注意してください、ただし、完全修飾パスを使用していることができます問題が生じる可能性、DLL が移動された場合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>