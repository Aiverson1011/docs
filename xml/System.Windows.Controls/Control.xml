<Type Name="Control" FullName="System.Windows.Controls.Control">
  <TypeSignature Language="C#" Value="public class Control : System.Windows.FrameworkElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.Windows.FrameworkElement" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Control" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>基本クラスを表す ユーザー インターフェイス (UI) を使用する要素、 <see cref="T:System.Windows.Controls.ControlTemplate" /> の外観を定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Controls.Control> クラスは、アプリケーションに追加するコントロールの多くの基本クラスです。<xref:System.Windows.Controls.Control> クラスはごくわずかな動作を行います。 定義を追加することはできますが、 <xref:System.Windows.Controls.Control> そのため、アプリケーションはより一般的に、継承されたコントロールを追加 <xref:System.Windows.Controls.Control>, 、など、 <xref:System.Windows.Controls.Button> または <xref:System.Windows.Controls.ListBox>です。  
  
 <xref:System.Windows.Controls.Control.Template%2A> プロパティとは、 <xref:System.Windows.Controls.ControlTemplate>, 、表示するように指定、 <xref:System.Windows.Controls.Control>です。 コントロールの外観の変更が、その機能を保持する場合は、新しいを作成するを考慮する必要があります <xref:System.Windows.Controls.ControlTemplate> 新しいクラスを作成する代わりにします。 詳細については、「[スタイルとテンプレート](http://msdn.microsoft.com/ja-jp/481765e5-5467-4a75-9f7b-e10e2ac410d9)」を参照してください。  
  
 コントロールを継承できますをカスタム動作でコントロールを作成できるだけでなく、その外観をカスタマイズできるようにする場合、 <xref:System.Windows.Controls.Control> クラスを定義、 <xref:System.Windows.Controls.ControlTemplate>です。  既存のコントロールの動作を拡張する場合から継承するクラスから継承することができます <xref:System.Windows.Controls.Control>します。  
  
 A <xref:System.Windows.Controls.Control> がない、 <xref:System.Windows.Controls.ControlTemplate> 、アプリケーションと、次のプロパティも何も起こりませんしない限り、設定に表示されていない、 <xref:System.Windows.Controls.ControlTemplate> それらを明示的に参照します。  
  
-   <xref:System.Windows.Controls.Control.Background%2A>  
  
-   <xref:System.Windows.Controls.Control.BorderBrush%2A>  
  
-   <xref:System.Windows.Controls.Control.BorderThickness%2A>  
  
-   <xref:System.Windows.Controls.Control.FontFamily%2A>  
  
-   <xref:System.Windows.Controls.Control.FontSize%2A>  
  
-   <xref:System.Windows.Controls.Control.FontStretch%2A>  
  
-   <xref:System.Windows.Controls.Control.FontWeight%2A>  
  
-   <xref:System.Windows.Controls.Control.Foreground%2A>  
  
-   <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A>  
  
-   <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A>  
  
 これらのプロパティを使用する一般的な方法は、内の要素をバインドする、 <xref:System.Windows.Controls.ControlTemplate> プロパティにします。  値に基づいて色を変更する、制御したい場合など、 <xref:System.Windows.Controls.Control.Background%2A> プロパティ内の要素の一部のプロパティをバインドすることができます、 <xref:System.Windows.Controls.ControlTemplate> に、 <xref:System.Windows.Controls.Control.Background%2A>です。 使用して、 [TemplateBinding マークアップ拡張](http://msdn.microsoft.com/ja-jp/1d25bbfc-dbc2-499d-9f12-419d23d4ac6a) 内の要素へのコントロールのプロパティをバインドする、 <xref:System.Windows.Controls.ControlTemplate>です。  
  
 <xref:System.Windows.Controls.Control> メタデータをオーバーライド、 <xref:System.Windows.UIElement.Focusable%2A> プロパティの既定の設定と `true`です。 詳細については、次を参照してください [依存関係プロパティの概要](http://msdn.microsoft.com/ja-jp/d119d00c-3afb-48d6-87a0-c4da4f83dee5)。  
  
   
  
## 例  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Controls.Control" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">コンテンツの配置に使用される計算されたサイズ。</param>
        <summary>配置とのコンテンツのサイズと呼ばれる、 <see cref="T:System.Windows.Controls.Control" /> オブジェクトです。</summary>
        <returns>コントロールのサイズです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のコントロールの配置では、最初のビジュアルの子のみを配置します。 変換は適用されません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロールの背景を説明するブラシを設定します。</summary>
        <value>コントロールの背景の塗りつぶしに使用するブラシ。 既定値は、<see cref="P:System.Windows.Media.Brushes.Transparent" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Controls.Control.Background%2A> プロパティ コントロールの静止状態にのみ適用されます。  コントロールの既定のスタイルは、コントロールの状態が変更されたときに、その外観を指定します。 設定する場合など、 <xref:System.Windows.Controls.Control.Background%2A> プロパティを <xref:System.Windows.Controls.Button>, にこのボタンはその値が押されたまたは無効になっていないときのみです。 コントロールがバック グラウンドの高度なカスタマイズを作成する場合は、コントロールのスタイルを定義する必要があります。  
  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.Background%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。  
  
<a name="dependencyPropertyInfo_Background"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.BackgroundProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
   
  
## 例  
 次の例では、コントロールの background プロパティを設定する方法を示します。  
  
 [!code-xml[ControlProps\#11](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#11)]  
  
 [!code-csharp[ControlProps\#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#1)]
 [!code-vb[ControlProps\#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#1)]  
  
 次の例が押されると、ボタンの背景を変更するトリガーを使用するテンプレートを示します。  
  
 [!code-xml[BackgroundProp\_snip\#ButtonTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/BackgroundProp_snip/CS/page1.xaml#buttontemplate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.Background" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush BorderBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush BorderBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.BorderBrush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロールの境界線の背景を説明するブラシを設定します。</summary>
        <value>コントロールの境界線の塗りつぶしに使用されるブラシ既定値は <see cref="P:System.Windows.Media.Brushes.Transparent" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.BorderBrush%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。  
  
<a name="dependencyPropertyInfo_BorderBrush"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.BorderBrushProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
   
  
## 例  
 次の例では、コントロールの枠線のブラシ プロパティを設定する方法を示します。  
  
 [!code-xml[ControlProps\#17](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#17)]  
  
 [!code-csharp[ControlProps\#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#7)]
 [!code-vb[ControlProps\#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.BorderBrushProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.BorderBrush" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderThickness">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness BorderThickness { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness BorderThickness" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.BorderThickness" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロールの境界線の太さを設定します。</summary>
        <value>太さの値。既定では 4 つの側の 0 の太さです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.BorderThickness%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。  
  
<a name="dependencyPropertyInfo_BorderThickness"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.BorderThicknessProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## 例  
 次の例では、コントロールの境界線の太さのプロパティを設定する方法を示します。  
  
 [!code-xml[ControlProps\_snip\#AdditionalControlProps11](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops11)]  
  
 [!code-csharp[ControlProps\_snip\#AdditionalControlProps1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops1)]
 [!code-vb[ControlProps\_snip\#AdditionalControlProps1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderThicknessProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderThicknessProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderThicknessProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.BorderThicknessProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.BorderThickness" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロールのフォント ファミリを設定します。</summary>
        <value>フォント ファミリ。 既定値は、システム ダイアログのフォントです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.FontFamily%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。  
  
<a name="dependencyPropertyInfo_FontFamily"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.FontFamilyProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 次の例では、コントロールのフォント ファミリのプロパティを設定する方法を示します。  
  
 [!code-xml[ControlProps\#13](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#13)]  
  
 [!code-csharp[ControlProps\#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#3)]
 [!code-vb[ControlProps\#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.FontFamily" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはフォント サイズを設定します。</summary>
        <value>内のテキストのサイズ、 <see cref="T:System.Windows.Controls.Control" />です。 既定値は、<see cref="P:System.Windows.SystemFonts.MessageFontSize" /> です。 フォント サイズでは、正の数値を指定する必要があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.FontSize%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。  
  
<a name="dependencyPropertyInfo_FontSize"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.FontSizeProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
<a name="xamlAttributeUsage_FontSize"></a>   
## XAML 属性の使用方法  
  
```  
<object FontSize="double"/>  
- or –  
<object FontSize ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_FontSize"></a>   
## XAML 値  
 *double*  
 <xref:System.Double>  
  
 文字列表現、 <xref:System.Double> 値。 これは、 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 測定します。 文字列が必要な小数点を明示的に含まれません。 値など `1` は許容されます。  
  
 同じ <xref:System.Double> プロパティの値\] セクションに記載されている範囲の制限がここに適用します。  
  
 *qualifiedDouble*  
 A *二重* は既に説明したように値がこれら単位の宣言文字列のいずれかが続きます。 `px`, 、`in`, 、`cm`, 、`pt`です。  
  
 `px` \(既定値\) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px \= \=  
  
 `cm` センチメートルを表します。1cm\=\=\(96\/2.54\) px  
  
 `pt` ポイントです。1pt\=\=\(96\/72\) px  
  
 **注** 多くの場合を double 型の値を「自動」に設定することがありますが、 <xref:System.Windows.Controls.Control.FontSize%2A?displayProperty=fullName> 場合の表示がない"Auto"に設定します。  
  
   
  
## 例  
 次の例では、コントロールのフォント サイズ プロパティを設定する方法を示します。  
  
 [!code-xml[ControlProps\#14](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#14)]  
  
 [!code-csharp[ControlProps\#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#4)]
 [!code-vb[ControlProps\#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.FontSize" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretch">
      <MemberSignature Language="C#" Value="public System.Windows.FontStretch FontStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStretch FontStretch" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontStretch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはフォントを縮小または画面上で展開する度合いを設定します。</summary>
        <value>
          <see cref="T:System.Windows.FontStretch" /> 値。 既定値は、<see cref="P:System.Windows.FontStretches.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.FontStretch%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。  
  
<a name="dependencyPropertyInfo_FontStretch"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.FontStretchProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 次の例では、コントロールのフォントの伸縮プロパティを設定する方法を示します。 ストレッチの可能な値を参照してください。 <xref:System.Windows.FontStretches>します。  
  
 [!code-xml[ControlProps\_snip\#AdditionalControlProps12](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops12)]  
  
 [!code-csharp[ControlProps\_snip\#AdditionalControlProps2](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops2)]
 [!code-vb[ControlProps\_snip\#AdditionalControlProps2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretchProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStretchProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStretchProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontStretchProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.FontStretch" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyle">
      <MemberSignature Language="C#" Value="public System.Windows.FontStyle FontStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStyle FontStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはフォントのスタイルを設定します。</summary>
        <value>
          <see cref="T:System.Windows.FontStyle" /> 値。 既定値は、<see cref="P:System.Windows.FontStyles.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.FontStyle%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。  
  
<a name="dependencyPropertyInfo_FontStyle"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.FontStyleProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 次の例では、コントロールのフォントのスタイル プロパティを設定する方法を示します。  
  
 [!code-xml[ControlProps\#15](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#15)]  
  
 [!code-csharp[ControlProps\#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#5)]
 [!code-vb[ControlProps\#5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.FontStyle" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeight">
      <MemberSignature Language="C#" Value="public System.Windows.FontWeight FontWeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontWeight FontWeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontWeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または指定したフォントの太さを設定します。</summary>
        <value>
          <see cref="T:System.Windows.FontWeight" /> 値。 既定値は、<see cref="P:System.Windows.FontWeights.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.FontWeight%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。 一覧については定義済み <xref:System.Windows.FontWeight> の値を参照してください、 <xref:System.Windows.FontWeights> クラスです。  
  
<a name="dependencyPropertyInfo_FontWeight"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.FontWeightProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 次の例では、設定する方法、 <xref:System.Windows.Controls.Control.FontWeight%2A> コントロールのプロパティです。  
  
 [!code-xml[ControlProps\#16](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#16)]  
  
 [!code-csharp[ControlProps\#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#6)]
 [!code-vb[ControlProps\#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontWeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontWeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontWeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.FontWeight" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または前景色を表すブラシを設定します。</summary>
        <value>コントロールの前景の描画するブラシ。 既定値は、システム ダイアログのフォントの色です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.Foreground%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。  
  
<a name="dependencyPropertyInfo_Foreground"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.ForegroundProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## 例  
 次の例では、コントロールのフォントのスタイル プロパティを設定する方法を示します。  
  
 [!code-xml[ControlProps\#12](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#12)]  
  
 [!code-csharp[ControlProps\#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#2)]
 [!code-vb[ControlProps\#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.Foreground" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HandlesScrolling">
      <MemberSignature Language="C#" Value="protected virtual bool HandlesScrolling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HandlesScrolling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.HandlesScrolling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サポートするコントロールにスクロールするかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> コントロールがある場合、 <see cref="T:System.Windows.Controls.ScrollViewer" /> スタイルにはカスタムのキーボード スクロール動作とそれ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalContentAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalContentAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalContentAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.HorizontalContentAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロールの内容の水平方向の配置を設定します。</summary>
        <value>
          <see cref="T:System.Windows.HorizontalAlignment" /> 値のいずれか。 既定値は、<see cref="F:System.Windows.HorizontalAlignment.Left" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 他に、 <xref:System.Windows.HorizontalAlignment.Left>, 、<xref:System.Windows.HorizontalAlignment.Right>, 、および <xref:System.Windows.HorizontalAlignment.Center>, 、設定することができます、 <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> プロパティを <xref:System.Windows.HorizontalAlignment.Stretch>, 、子要素の親要素の割り当てられた領域を拡大します。 詳細については、次を参照してください。 [の配置、余白、パディングの概要](http://msdn.microsoft.com/ja-jp/9c6a2009-9b86-4e40-8605-0a2664dc3973)します。  
  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。  
  
<a name="dependencyPropertyInfo_HorizontalContentAlignment"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.HorizontalContentAlignmentProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、コントロールの水平方向のコンテンツの配置プロパティを設定する方法を示します。  
  
 [!code-xml[ControlProps\#18](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#18)]  
  
 [!code-csharp[ControlProps\#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#8)]
 [!code-vb[ControlProps\#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalContentAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalContentAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalContentAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.HorizontalContentAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.HorizontalContentAlignment" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTabStop">
      <MemberSignature Language="C#" Value="public bool IsTabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.IsTabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはタブ ナビゲーションにコントロールが含まれるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> コントロールがタブ ナビゲーションに含まれている場合それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 <xref:System.Windows.Controls.Control.IsTabStop%2A> は `false`, 、タブ ナビゲーションから、コントロールは除外されます。  
  
<a name="dependencyPropertyInfo_IsTabStop"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.IsTabStopProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、設定する方法、 <xref:System.Windows.Controls.Control.IsTabStop%2A> タブ ナビゲーションのプロパティとコントロールが記載されているかどうかをテストする方法です。  
  
 [!code-xml[ControlProps\_snip\#AdditionalControlProps15](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops15)]  
  
 [!code-csharp[ControlProps\_snip\#AdditionalControlProps4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops4)]
 [!code-vb[ControlProps\_snip\#AdditionalControlProps4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTabStopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTabStopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTabStopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.IsTabStopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.IsTabStop" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.MeasureOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">メソッドが返すことができる最大サイズ。</param>
        <summary>コントロールを再測定するために呼び出されます。</summary>
        <returns>指定された最大値までのコントロールのサイズ <paramref name="constraint" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロールの既定値は、最初のビジュアルの子のみを測定します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Control.MouseDoubleClick" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ボタンが複数回クリックされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このルーティング イベントでは、次の要素ツリーを通じてバブル ルートようとして、実際には直接ルーティングされたイベントごとに、要素ツリーに沿って発生する <xref:System.Windows.UIElement>です。 設定した場合、 <xref:System.Windows.RoutedEventArgs.Handled%2A> プロパティを `true` で、 <xref:System.Windows.Controls.Control.MouseDoubleClick> イベント ハンドラー、その後 <xref:System.Windows.Controls.Control.MouseDoubleClick> でルート上のイベントが発生する <xref:System.Windows.RoutedEventArgs.Handled%2A> に設定 `false`します。 これは、希望するユーザー コントロールをダブルクリックしたときに通知して、アプリケーションでイベントを処理するコントロールのコンシューマー向けの高レベルのイベントです。  
  
 マウスのダブルクリックを処理するコントロールの作成者が使用する必要があります、 <xref:System.Windows.UIElement.MouseLeftButtonDown> イベントと <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> が 2 です。  これはの状態になります <xref:System.Windows.RoutedEventArgs.Handled%2A> 要素ツリーの別の要素がイベントを処理する場合に適切に反映されます。  
  
 <xref:System.Windows.Controls.Control> クラスを定義、 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> と <xref:System.Windows.Controls.Control.MouseDoubleClick> イベントが 1 回のクリックにいない対応するイベントです。  かどうか、ユーザーがクリックしたコントロール 1 回を表示するには、次のように処理します。、 <xref:System.Windows.UIElement.MouseDown> イベント \(または、対応する\) を確認するかどうか、 <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> プロパティの値は 1 です。  
  
<a name="routedEventInfo_MouseDoubleClick"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.MouseDoubleClickEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
   
  
## 例  
 次の例では、イベント ハンドラーをアタッチする方法、 <xref:System.Windows.Controls.Control.MouseDoubleClick> イベントです。  
  
 [!code-xml[ControlProps\_snip\#ControlEvents11](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#controlevents11)]  
  
 次の例では、イベント ハンドラーの <xref:System.Windows.Controls.Control.MouseDoubleClick> イベントです。  
  
 [!code-csharp[ControlProps\_snip\#ControlEvents1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#controlevents1)]
 [!code-vb[ControlProps\_snip\#ControlEvents1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#controlevents1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDoubleClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDoubleClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.MouseDoubleClickEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.Controls.Control.MouseDoubleClick" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary>発生させる、 <see cref="E:System.Windows.Controls.Control.MouseDoubleClick" /> ルーティングされたイベント。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロールで発生し、 <xref:System.Windows.Controls.Control.MouseDoubleClick> イベントを呼び出して、 <xref:System.Windows.UIElement.RaiseEvent%2A> メソッドです。 詳細については、次を参照してください。 [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> in a derived class, be sure to call the base class’s <see cref="M:System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDoubleClick (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseDoubleClick(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary>発生させる、 <see cref="E:System.Windows.Controls.Control.PreviewMouseDoubleClick" /> ルーティングされたイベント。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロールで発生し、 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> イベントを呼び出して、 <xref:System.Windows.UIElement.RaiseEvent%2A> メソッドです。  詳細については、次を参照してください。 [ルーティング イベントの概要](http://msdn.microsoft.com/ja-jp/1a2189ae-13b4-45b0-b12c-8de2e49c29d2)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> in a derived class, be sure to call the base class’s <see cref="M:System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">古いテンプレート。</param>
        <param name="newTemplate">新しいテンプレート。</param>
        <summary>コントロールのテンプレートが変更されるたびに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 テンプレートの変更のタイミングは、次のとおりです。  
  
1.  テンプレートは変更、 <xref:System.Windows.DependencyObject.SetValue%2A> メソッドの呼び出し、スタイルのトリガー、またはその他の手段です。  
  
2.  プロパティ値の変更プロパティ変更コールバックが呼び出されます。  
  
3.  古いのビジュアル ツリーが削除されます。  
  
4.  内部メソッドが最終的に呼び出すと呼ばれる、 <xref:System.Windows.Controls.Control.OnTemplateChanged%2A> メソッドです。  
  
5.  メジャーを中に、後で <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> と呼ばれる新しいビジュアル ツリーが接続されているとします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロール内のスペースを設定します。</summary>
        <value>コンテンツの間の間隔、 <see cref="T:System.Windows.Controls.Control" /> とその <see cref="P:System.Windows.FrameworkElement.Margin" /> または <see cref="T:System.Windows.Controls.Border" />です。  既定では 4 つの側の 0 の太さです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 余白は、左の順序、一番上、右、および下で指定されます。 詳細については、次を参照してください。 <xref:System.Windows.Thickness> と [の配置、余白、パディングの概要](http://msdn.microsoft.com/ja-jp/9c6a2009-9b86-4e40-8605-0a2664dc3973)します。  
  
 このプロパティでは、そのテンプレートを使用してコントロールのみに影響、 <xref:System.Windows.Controls.Control.Padding%2A> プロパティをパラメーターとして。 その他のコントロールでは、このプロパティは影響しません。  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.PaddingProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>|  
  
   
  
## 例  
 次の例では、コントロールの padding プロパティを設定する方法を示します。  
  
 [!code-xml[ControlProps\_snip\#AdditionalControlProps13](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops13)]  
  
 [!code-csharp[ControlProps\_snip\#AdditionalControlProps3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops3)]
 [!code-vb[ControlProps\_snip\#AdditionalControlProps3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.PaddingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.Padding" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Control.PreviewMouseDoubleClick" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがマウス ボタンを 2 回以上クリックしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素ツリーに沿った各によって発行される直接ルーティングされたイベントを実際には、このルーティングされたイベントは、次の要素ツリーを通じてトンネリングのルートに思える、 <xref:System.Windows.UIElement>です。 設定した場合、 <xref:System.Windows.RoutedEventArgs.Handled%2A> プロパティを `true` で、 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> イベント ハンドラー、その後 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> でルート上のイベントが発生する <xref:System.Windows.RoutedEventArgs.Handled%2A> に設定 `false`, が、 <xref:System.Windows.Controls.Control.MouseDoubleClick> でイベントが発生する <xref:System.Windows.RoutedEventArgs.Handled%2A> に設定 `true`します。 これは、希望するユーザー コントロールをダブルクリックしたときに通知して、アプリケーションでイベントを処理するコントロールのコンシューマー向けの高レベルのイベントです。  
  
 マウスのダブルクリックを処理するコントロールの作成者が使用する必要があります、 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> イベントと <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> が 2 です。  これはの状態になります <xref:System.Windows.RoutedEventArgs.Handled%2A> 要素ツリーの別の要素がイベントを処理する場合に適切に反映されます。  
  
 <xref:System.Windows.Controls.Control> クラスを定義、 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> と <xref:System.Windows.Controls.Control.MouseDoubleClick> イベントが 1 回のクリックにいない対応するイベントです。  かどうか、ユーザーがクリックしたコントロール 1 回を表示するには、次のように処理します。、 <xref:System.Windows.UIElement.MouseDown> イベント \(または、対応する\) を確認するかどうか、 <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> プロパティの値は 1 です。  
  
<a name="routedEventInfo_PreviewMouseDoubleClick"></a>   
## ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.PreviewMouseDoubleClickEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
   
  
## 例  
 次の例では、イベント ハンドラーをアタッチする方法、 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> イベントです。  
  
 [!code-xml[ControlProps\_snip\#ControlEvents12](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#controlevents12)]  
  
 次の例では、イベント ハンドラーの <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> イベントです。  
  
 [!code-csharp[ControlProps\_snip\#ControlEvents2](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#controlevents2)]
 [!code-vb[ControlProps\_snip\#ControlEvents2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#controlevents2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDoubleClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDoubleClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDoubleClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.PreviewMouseDoubleClickEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.Controls.Control.PreviewMouseDoubleClick" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはユーザーが TAB キーを使用してコントロールを移動するときに、要素フォーカスを受け取る順序を決定する値を設定します。</summary>
        <value>デバイスの論理ナビゲーションの順序を決定する値。 既定値は <see cref="F:System.Int32.MaxValue" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 下のタブ インデックスを持つコントロールより高いインデックスを持つコントロールにフォーカスを受け取ります。  
  
<a name="dependencyPropertyInfo_TabIndex"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.TabIndexProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## 例  
 次の例では、3 つのボタンのタブ インデックスを設定します。  
  
 [!code-xml[ControlProps\_snip\#AdditionalControlProps17](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TabIndexProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TabIndexProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.TabIndexProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.TabIndex" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Template" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール テンプレートを取得または設定します。</summary>
        <value>
          <see cref="T:System.Windows.Controls.Control" /> の外観を定義するテンプレート。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Controls.ControlTemplate> の外観を指定、 <xref:System.Windows.Controls.Control>いる場合、 <xref:System.Windows.Controls.Control> が、 <xref:System.Windows.Controls.ControlTemplate>, 、 <xref:System.Windows.Controls.Control> 、アプリケーションでは表示されません。 コントロールの作成者は、既定のコントロール テンプレートを定義し、アプリケーションの作成者が上書きできる、 <xref:System.Windows.Controls.ControlTemplate> をコントロールのビジュアル ツリーを再定義します。 参照してください [コントロールのスタイルとテンプレート](http://msdn.microsoft.com/ja-jp/c19049bb-5ceb-492d-afd2-751dca0ed8e3) と既存のコントロールのビジュアル ツリーを変更する方法の例についてです。  
  
 A <xref:System.Windows.Controls.ControlTemplate> がユーザーとなどのオブジェクトの外側に表示されていない実装の細部の自己完結型装置を使用するものでは <xref:System.Windows.Style> オブジェクトです。 同じコントロール テンプレート内では、コントロール テンプレートの内容を操作する唯一の方法です。  
  
<a name="dependencyPropertyInfo_Template"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.TemplateProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Windows.Controls.ControlTemplate> の <xref:System.Windows.Controls.Button>です。  これをリソースとしてアプリケーションに追加すると、アプリケーション内のすべてのボタンは省略記号として表示されますがボタンとして機能。  
  
 [!code-xml[StylingIntroSample\_snip\#ButtonCT](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snip/CSharp/Window1.xaml#buttonct)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.TemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.Template" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>文字列表現を返します、 <see cref="T:System.Windows.Controls.Control" /> オブジェクトです。</summary>
        <returns>コントロールを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロールの作成者は、コントロールのコンシューマーを対象になる情報を格納する文字列を返すには、このメソッドをオーバーライドする必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalContentAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalContentAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalContentAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.VerticalContentAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロールの内容の垂直方向の配置を設定します。</summary>
        <value>
          <see cref="T:System.Windows.VerticalAlignment" /> 値のいずれか。 既定値は、<see cref="F:System.Windows.VerticalAlignment.Top" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 加え<xref:System.Windows.VerticalAlignment.Top>、 <xref:System.Windows.VerticalAlignment.Bottom>、および<xref:System.Windows.VerticalAlignment.Center>、設定することができます、<xref:System.Windows.Controls.Control.VerticalContentAlignment%2A>プロパティを<xref:System.Windows.VerticalAlignment.Stretch>、子要素の親要素の割り当てられているレイアウト領域の塗りつぶしを拡大します。 詳細については、次を参照してください。[アラインメント、余白、および概要のパディング](http://msdn.microsoft.com/ja-jp/9c6a2009-9b86-4e40-8605-0a2664dc3973)です。  
  
 このプロパティにのみ影響がテンプレートを使用して、コントロール、<xref:System.Windows.Controls.Control.VerticalContentAlignment%2A>プロパティをパラメーターとします。 その他のコントロールは、このプロパティには影響はありません。  
  
<a name="dependencyPropertyInfo_VerticalContentAlignment"></a>   
## 依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.Control.VerticalContentAlignmentProperty>|  
|メタデータ プロパティに設定します。`true`|なし|  
  
   
  
## 例  
 次の例では、コントロールのコンテンツの縦方向の配置プロパティを設定する方法を示します。  
  
 [!code-xml[ControlProps\#19](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#19)]  
  
 [!code-csharp[ControlProps\#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#9)]
 [!code-vb[ControlProps\#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalContentAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalContentAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalContentAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.VerticalContentAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.VerticalContentAlignment" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>