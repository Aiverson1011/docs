<Type Name="Enum" FullName="System.Enum">
  <TypeSignature Language="C#" Value="public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Enum extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Enum" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>列挙体の基底クラスを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 An enumeration is a set of named constants whose underlying type is any integral type. If no underlying type is explicitly declared, <xref:System.Int32> is used. <xref:System.Enum> is the base class for all enumerations in the .NET Framework. Enumeration types are defined by the **languageKeyword tag is not supported!!!!**  
 keyword in C\# and the **languageKeyword tag is not supported!!!!**  
...**languageKeyword tag is not supported!!!!**  
 construct in Visual Basic.  
  
 <xref:System.Enum> provides methods for comparing instances of this class, converting the value of an instance to its string representation, converting the string representation of a number to an instance of this class, and creating an instance of a specified enumeration and value.  
  
 You can also treat an enumeration as a bit field. For more information, see the [Non\-Exclusive Members and the Flags Attribute](#Flags) section and the <xref:System.FlagsAttribute> topic.  
  
 In this topic:  
  
 [Creating an enumeration type](#Creating)   
 [Instantiating an enumeration type](#Instantiating)   
 [Enumeration best practices](#BestPractices)   
 [Performing operations with enumerations](#Operations)   
 [Performing conversions](#conversions)  
 [Parsing enumeration values](#parsing)  
 [Formatting enumeration values](#formatting)  
[Iterating enumeration members](#iterating)  
[Non-exclusive members and the Flags attribute](#Flags)  
[Adding enumeration methods](#methods)  
  
<a name="Creating"></a>   
## Creating an enumeration type  
 Programming languages typically provide syntax to declare an enumeration that consists of a set of named constants and their values. The following example illustrates the syntax used by C\# and Visual Basic to define an enumeration. It creates an enumeration named `ArrivalStatus` that has three members: `ArrivalStatus.Early`, `ArrivalStatus.OnTime`, and `ArrivalStatus.Late`. Note that in both cases, the enumeration does not explicitly inherit from <xref:System.Enum>; the inheritance relationship is handled implicitly by the compiler.  
  
 [!code-csharp[System.Enum.Class\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class1.cs#1)]
 [!code-vb[System.Enum.Class\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class1.vb#1)]  
  
> [!WARNING]
>  You should never create an enumeration type whose underlying type is non\-integral or <xref:System.Char>. Although you can create such an enumeration type by using reflection, method calls that use the resulting type are unreliable and may also throw additional exceptions.  
  
<a name="Instantiating"></a>   
## Instantiating an enumeration type  
 You can instantiate an enumeration type just as you instantiate any other value type: by declaring a variable and assigning one of the enumeration's constants to it. The following example instantiates an `ArrivalStatus` whose value is `ArrivalStatus.OnTime`.  
  
 [!code-csharp[System.Enum.Class\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class1.cs#2)]
 [!code-vb[System.Enum.Class\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class1.vb#2)]  
  
 You can also instantiate an enumeration value in the following ways:  
  
-   By using a particular programming language's features to cast \(as in C\#\) or convert \(as in Visual Basic\) an integer value to an enumeration value. The following example creates an `ArrivalStatus` object whose value is `ArrivalStatus.Early` in this way.  
  
     [!code-csharp[System.Enum.Class\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#4)]
     [!code-vb[System.Enum.Class\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#4)]  
  
-   By calling its implicit default constructor. As the following example shows, in this case the underlying value of the enumeration instance is 0. However, this is not necessarily the value of a valid constant in the enumeration.  
  
     [!code-csharp[System.Enum.Class\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#3)]
     [!code-vb[System.Enum.Class\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#3)]  
  
-   By calling the <xref:System.Enum.Parse%2A> or <xref:System.Enum.TryParse%2A> method to parse a string that contains the name of a constant in the enumeration. For more information, see the [Parsing Enumeration Values](#parsing) section.  
  
-   By calling the <xref:System.Enum.ToObject%2A> method to convert an integral value to an enumeration type. For more information, see the [Performing Conversions](#conversions) section.  
  
<a name="BestPractices"></a>   
## Enumeration best practices  
 We recommend that you use the following best practices when you define enumeration types:  
  
-   If you have not defined an enumeration member whose value is 0, consider creating a `None` enumerated constant. By default, the memory used for the enumeration is initialized to zero by the common language runtime. Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.  
  
-   If there is an obvious default case that your application has to represent, consider using an enumerated constant whose value is zero to represent it. If there is no default case, consider using an enumerated constant whose value is zero to specify the case that is not represented by any of the other enumerated constants.  
  
-   Do not specify enumerated constants that are reserved for future use.  
  
-   When you define a method or property that takes an enumerated constant as a value, consider validating the value. The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.  
  
 Additional best practices for enumeration types whose constants are bit fields are listed in the [Non\-Exclusive Members and the Flags Attribute](#Flags) section.  
  
<a name="Operations"></a>   
## Performing operations with enumerations  
 You cannot define new methods when you are creating an enumeration. However, an enumeration type inherits a complete set of static and instance methods from the <xref:System.Enum> class. The following sections survey most of these methods, in addition to several other methods that are commonly used when working with enumeration values.  
  
<a name="conversions"></a>   
### Performing conversions  
 You can convert between an enumeration member and its underlying type by using a casting \(in C\#\) or conversion \(in Visual Basic\) operator. The following example uses casting or conversion operators to perform conversions both from an integer to an enumeration value and from an enumeration value to an integer.  
  
 [!code-csharp[System.Enum.Class\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#5)]
 [!code-vb[System.Enum.Class\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#5)]  
  
 The <xref:System.Enum> class also includes a <xref:System.Enum.ToObject%2A> method that converts a value of any integral type to an enumeration value. The following example uses the <xref:System.Enum.ToObject%28System.Type%2CSystem.Int32%29> method to convert an <xref:System.Int32> to an `ArrivalStatus` value. Note that, because the <xref:System.Enum.ToObject%2A> returns a value of type <xref:System.Object>, the use of a casting or conversion operator may still be necessary to cast the object to the enumeration type.  
  
 [!code-csharp[System.Enum.Class\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#6)]
 [!code-vb[System.Enum.Class\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#6)]  
  
 When converting an integer to an enumeration value, it is possible to assign a value that is not actually a member of the enumeration. To prevent this, you can pass the integer to the <xref:System.Enum.IsDefined%2A> method before performing the conversion. The following example uses this method to determine whether the elements in an array of integer values can be converted to `ArrivalStatus` values.  
  
 [!code-csharp[System.Enum.Class\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classconversion1.cs#7)]
 [!code-vb[System.Enum.Class\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classconversion1.vb#7)]  
  
 Although the <xref:System.Enum> class provides explicit interface implementations of the <xref:System.IConvertible> interface for converting from an enumeration value to an integral type, you should use the methods of the <xref:System.Convert> class, such as <xref:System.Convert.ToInt32%2A>, to perform these conversions. The following example illustrates how you can use the <xref:System.Enum.GetUnderlyingType%2A> method along with the <xref:System.Convert.ChangeType%2A?displayProperty=fullName> method to convert an enumeration value to its underlying type. Note that this example does not require the underlying type of the enumeration to be known at compile time.  
  
 [!code-csharp[System.Enum.Class\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classconversion2.cs#8)]
 [!code-vb[System.Enum.Class\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classconversion2.vb#8)]  
  
<a name="parsing"></a>   
### Parsing enumeration values  
 The <xref:System.Enum.Parse%2A> and <xref:System.Enum.TryParse%2A> methods allow you to convert the string representation of an enumeration value to that value. The string representation can be either the name or the underlying value of an enumeration constant. Note that the parsing methods will successfully convert string representations of numbers that are not members of a particular enumeration if the strings can be converted to a value of the enumeration's underlying type. To prevent this, the <xref:System.Enum.IsDefined%2A> method can be called to ensure that the result of the parsing method is a valid enumeration value. The example illustrates this approach and demonstrates calls to both the <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> and <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29?displayProperty=fullName> methods. Note that the non\-generic parsing method returns an object that you may have to cast \(in C\#\) or convert \(in Visual Basic\) to the appropriate enumeration type.  
  
 [!code-csharp[System.Enum.Class\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classparse1.cs#9)]
 [!code-vb[System.Enum.Class\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classparse1.vb#9)]  
  
<a name="formatting"></a>   
### Formatting enumeration values  
 You can convert enumeration values to their string representations by calling the static <xref:System.Enum.Format%2A> method, as well as the overloads of the instance <xref:System.Enum.ToString%2A> method. You can use a format string to control the precise way in which an enumeration value is represented as a string. For more information, see [Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1). The following example uses each of the supported enumeration format strings \("G" or "g", "D" or "d", "X" or "x", and "F" or "f" \) to convert a member of the `ArrivalStatus` enumeration to its string representations.  
  
 [!code-csharp[System.Enum.Class\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classformat1.cs#10)]
 [!code-vb[System.Enum.Class\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classformat1.vb#10)]  
  
<a name="iterating"></a>   
### Iterating enumeration members  
 The <xref:System.Enum> type does not implement the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interface, which would enable you to iterate members of a collection by using a **languageKeyword tag is not supported!!!!**  
 \(in C\#\) or **languageKeyword tag is not supported!!!!**  
 \(in Visual Basic\) construct. However, you can enumerate members in either of two ways.  
  
-   You can call the <xref:System.Enum.GetNames%2A> method to retrieve a string array containing the names of the enumeration members. Next, for each element of the string array, you can call the <xref:System.Enum.Parse%2A> method to convert the string to its equivalent enumeration value. The following example illustrates this approach.  
  
     [!code-csharp[System.Enum.Class\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classiterate.cs#11)]
     [!code-vb[System.Enum.Class\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classiterate.vb#11)]  
  
-   You can call the <xref:System.Enum.GetValues%2A> method to retrieve an array that contains the underlying values in the enumeration. Next, for each element of the array, you can call the <xref:System.Enum.ToObject%2A> method to convert the integer to its equivalent enumeration value. The following example illustrates this approach.  
  
     [!code-csharp[System.Enum.Class\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classiterate.cs#12)]
     [!code-vb[System.Enum.Class\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classiterate.vb#12)]  
  
<a name="Flags"></a>   
## Non\-exclusive members and the Flags attribute  
 One common use of an enumeration is to represent a set of mutually exclusive values. For example, an `ArrivalStatus` instance can have a value of `Early`, `OnTime`, or `Late`. It makes no sense for the value of an `ArrivalStatus` instance to reflect more than one enumeration constant.  
  
 In other cases, however, the value of an enumeration object can include multiple enumeration members, and each member represents a bit field in the enumeration value. The <xref:System.FlagsAttribute> attribute can be used to indicate that the enumeration consists of bit fields. For example, an enumeration named `Pets` might be used to indicate the kinds of pets in a household. It can be defined as follows.  
  
 [!code-csharp[System.Enum.Class\#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#13)]
 [!code-vb[System.Enum.Class\#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#13)]  
  
 The `Pets` enumeration can then be used as shown in the following example.  
  
 [!code-csharp[System.Enum.Class\#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#14)]
 [!code-vb[System.Enum.Class\#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#14)]  
  
 The following best practices should be used when defining a bitwise enumeration and applying the <xref:System.FlagsAttribute> attribute.  
  
-   Use the <xref:System.FlagsAttribute> custom attribute for an enumeration only if a bitwise operation \(AND, OR, EXCLUSIVE OR\) is to be performed on a numeric value.  
  
-   Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on. This means the individual flags in combined enumeration constants do not overlap.  
  
-   Consider creating an enumerated constant for commonly used flag combinations. For example, if you have an enumeration used for file I\/O operations that contains the enumerated constants `Read = 1` and `Write = 2`, consider creating the enumerated constant `ReadWrite = Read OR Write`, which combines the `Read` and `Write` flags. In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.  
  
-   Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.  
  
-   A convenient way to test whether a flag is set in a numeric value is to call the instance <xref:System.Enum.HasFlag%2A> method, as shown in the following example.  
  
     [!code-csharp[System.Enum.Class\#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#15)]
     [!code-vb[System.Enum.Class\#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#15)]  
  
     It is equivalent to performing a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, and then testing whether the result of that operation is equal to the flag enumerated constant. This is illustrated in the following example.  
  
     [!code-csharp[System.Enum.Class\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#16)]
     [!code-vb[System.Enum.Class\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#16)]  
  
-   Use `None` as the name of the flag enumerated constant whose value is zero. You cannot use the `None` enumerated constant in a bitwise AND operation to test for a flag because the result is always zero. However, you can perform a logical, not a bitwise, comparison between the numeric value and the `None` enumerated constant to determine whether any bits in the numeric value are set. This is illustrated in the following example.  
  
     [!code-csharp[System.Enum.Class\#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#17)]
     [!code-vb[System.Enum.Class\#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#17)]  
  
-   Do not define an enumeration value solely to mirror the state of the enumeration itself. For example, do not define an enumerated constant that merely marks the end of the enumeration. If you need to determine the last value of the enumeration, check for that value explicitly. In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.  
  
<a name="methods"></a>   
## Adding enumeration methods  
 Because enumeration types are defined by language structures, such as **languageKeyword tag is not supported!!!!**  
 \(C\#\) and **languageKeyword tag is not supported!!!!**  
 \(Visual Basic\), you cannot define custom methods for an enumeration type other than those methods inherited from the <xref:System.Enum> class.  However, you can use extension methods to add functionality to a particular enumeration type.  
  
 In the following example, the `Grades` enumeration represents the possible letter grades that a student may receive in a class. An extension method named `Passing` is added to the `Grades` type so that each instance of that type now "knows" whether it represents a passing grade or not.       The `Extensions` class also contains a static read\-write variable that defines the minimum passing grade. The return value of the `Passing` extension method reflects the current value of that variable.  
  
 [!code-csharp[System.Enum.Class\#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/Extensions.cs#18)]
 [!code-vb[System.Enum.Class\#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/Extensions.vb#18)]  
  
   
  
## 例  
 The following example demonstrates using an enumeration to represent named values and another enumeration to represent named bit fields.  
  
 [!code-cpp[enummain\#1](~/samples/snippets/cpp/VS_Snippets_CLR/enummain/CPP/EnumMain.cpp#1)]
 [!code-csharp[enummain\#1](~/samples/snippets/csharp/VS_Snippets_CLR/enummain/CS/EnumMain.cs#1)]
 [!code-vb[enummain\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enummain/VB/EnumMain.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
    <altmember cref="T:System.ValueType" />
    <altmember cref="T:System.FlagsAttribute" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Enum ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Enum" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="target">比較対象のオブジェクト、または <see langword="null" />。</param>
        <summary>指定したオブジェクトとこのインスタンスを比較し、これらの相対値を示す値を返します。</summary>
        <returns>このインスタンスと <paramref name="target" /> の相対値を示す符号付き数値。  
  
 <list type="table">  
<listheader>  
<term> 値  
  
 </term>  
<description> 説明  
  
 </description>  
</listheader>  
<item>  
<term> 0 より小さい値  
  
 </term>  
<description> このインスタンスの値がの値より小さい<paramref name="target" />です。  
  
 </description>  
</item>  
<item>  
<term> 0  
  
 </term>  
<description> このインスタンスの値がの値と等しい<paramref name="target" />です。  
  
 </description>  
</item>  
<item>  
<term> 0 より大きい値  
  
 </term>  
<description> このインスタンスの値がの値より大きい<paramref name="target" />です。  
  
 または  
  
 <paramref name="target" /> は <see langword="null" /> です。  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例は、の使用を示しています。`CompareTo`のコンテキストで`Enum`です。  
  
 [!code-cpp[enumcompareto\#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumcompareto/CPP/EnumCompareTo.cpp#1)]
 [!code-csharp[enumcompareto\#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumcompareto/CS/EnumCompareTo.cs#1)]
 [!code-vb[enumcompareto\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumcompareto/VB/EnumCompareTo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> とこのインスタンスは同じ型ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">このインスタンスの型は <see cref="T:System.SByte" />、<see cref="T:System.Int16" />、<see cref="T:System.Int32" />、<see cref="T:System.Int64" />、<see cref="T:System.Byte" />、<see cref="T:System.UInt16" />、<see cref="T:System.UInt32" />、<see cref="T:System.UInt64" /> のいずれでもありません。</exception>
        <altmember cref="M:System.Enum.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">対象のインスタンスと比較する対象のオブジェクト、または <see langword="null" />。</param>
        <summary>このインスタンスが指定されたオブジェクトに等しいかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="obj" /> が同じ型の列挙体値で、基になる値がこのインスタンスと同じである場合は <see langword="true" />、それ以外の場合は <see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Enum.Equals%28System.Object%29?displayProperty=fullName> method overrides <xref:System.ValueType.Equals%28System.Object%29?displayProperty=fullName> to define how enumeration members are evaluated for equality.  
  
   
  
## 例  
 The following example illustrates the use of the <xref:System.Enum.Equals%2A> method.  
  
 [!code-cpp[enumequals\#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumequals/CPP/EnumEquals.cpp#1)]
 [!code-csharp[enumequals\#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumequals/CS/EnumEquals.cs#1)]
 [!code-vb[enumequals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumequals/VB/EnumEquals.vb#1)]  
  
 The following example defines two enumeration types, `SledDog` and `WorkDog`. The `SledDog` enumeration has two members, `SledDog.AlaskanMalamute` and `SledDog.Malamute`, that have the same underlying value. The call to the <xref:System.Enum.Equals%2A> method indicates that these values are equal because their underlying values are the same. The `SledDog.Malamute` and `WorkDog.Newfoundland` members have the same underlying value, although they represent different enumeration types. A call to the <xref:System.Enum.Equals%2A> method indicates that these values are not equal.  
  
 [!code-csharp[System.Enum.Equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.equals/cs/enumequals.cs#1)]
 [!code-vb[System.Enum.Equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.equals/vb/enumequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Enum.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (Type enumType, object value, string format);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.Type enumType, object value, string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Format(System.Type,System.Object,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="enumType">変換する値の列挙型。</param>
        <param name="value">変換する値。</param>
        <param name="format">使用する出力形式。</param>
        <summary>指定した形式に従って、指定した列挙型の指定した値をそれと等価の文字列形式に変換します。</summary>
        <returns>
          <paramref name="value" /> の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表に有効な値を示しています、`format`パラメーター。  
  
|形式|説明|  
|--------|--------|  
|"G" または "g"|場合`value`は名前付きの列挙型定数に等しく、その定数の名前を返します。 それ以外の場合、10 進数表`value`が返されます。<br /><br /> たとえば、唯一の列挙定数が赤をという名前し、その値は 1 です。 場合`value`は 1 で指定、この形式は"Red"を返します。 ただし場合、 `value` 2 として指定されて、この形式は「2」を返します。<br /><br /> または<br /><br /> 場合、<xref:System.FlagsAttribute>カスタム属性が、列挙型に適用される`value`は 1 つ以上のビットで構成される 1 つまたは複数のフラグが含まれているビット フィールドとして扱われます。<br /><br /> 場合`value`列挙定数の名前の組み合わせと等しいかどうかが、これらの定数の名前のコンマ区切りのリストが返されます。`value`最大値を含むフラグから最小値へと向かうフラグが検索されます。 内のビット フィールドに対応する各フラグの`value`、コンマ区切りの一覧に、定数の名前を連結します。 そのフラグの値は、さらに考慮対象から除外し、次のフラグから検索を続行します。<br /><br /> 場合`value`は等しくありませんの組み合わせと等価の 10 進の等価の列挙定数をという名前`value`が返されます。|  
|"X" または "x"|表す`value`先頭に"0 x"16 進形式でします。|  
|"D" または "d"|表す`value`10 進数。|  
|"F" または "f"|"G"または"g"、同じように動作する点を除いて、<xref:System.FlagsAttribute>に存在している必要はありません、<xref:System.Enum>宣言します。|  
  
   
  
## 例  
 次の例は、の使用を示しています。`Format`のコンテキストで`Enum`です。  
  
 [!code-cpp[enumformat\#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumformat/CPP/EnumFormat.cpp#1)]
 [!code-csharp[enumformat\#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumformat/CS/EnumFormat.cs#1)]
 [!code-vb[enumformat\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumformat/VB/EnumFormat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" />、<paramref name="value" />、または <paramref name="format" /> パラメーターが <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> パラメーターが <see cref="T:System.Enum" /> 型ではありません。  
  
 または  
  
 <paramref name="value" /> は、型が <paramref name="enumType" /> とは異なる列挙体からのものです。  
  
 または  
  
 <paramref name="value" /> の型は、<paramref name="enumType" /> の基となる型ではありません。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> パラメーターに正しくない値が含まれています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> は "X" と等しいですが、列挙型が不明です。</exception>
        <altmember cref="M:System.Enum.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの値のハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetName(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetName(System.Type,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">列挙型。</param>
        <param name="value">基になる型に関連する特定の列挙型定数の値。</param>
        <summary>指定した値を持つ指定した列挙体にある定数の名前を取得します。</summary>
        <returns>値が <paramref name="value" /> である <paramref name="enumType" /> 内にある列挙型定数の名前が含まれた文字列。そのような定数が見つからない場合は、<see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 複数の列挙メンバー値がある場合、同じ基になる、<xref:System.Enum.GetName%2A>メソッドは、その列挙体メンバーのいずれかの名前が返されることを保証します。 ただし、これは保証されないことが常に返される同じ列挙型メンバーの名前。 結果として、複数の列挙体メンバーの値が同じ場合は、アプリケーション コード必要がありますしないによって異なります特定メンバーの名前を返すメソッド。  
  
   
  
## 例  
 次の例は、の使用を示しています。`GetName`です。  
  
 [!code-cpp[enumgetname\#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetname/CPP/EnumGetName.cpp#1)]
 [!code-csharp[enumgetname\#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetname/CS/EnumGetName.cs#1)]
 [!code-vb[enumgetname\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetname/VB/EnumGetName.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> または <paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。  
  
 \-または\-  
  
 <paramref name="value" /> は型が <paramref name="enumType" /> ではなく、基となる型が <paramref name="enumType" /> と同じでもありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNames">
      <MemberSignature Language="C#" Value="public static string[] GetNames (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetNames(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetNames(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">列挙型。</param>
        <summary>指定した列挙体に含まれている定数の名前の配列を取得します。</summary>
        <returns>
          <paramref name="enumType" /> に含まれている定数の名前の文字列配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 戻り値の配列の要素は、列挙型定数のバイナリ値で並べ替えられます \(つまり、その符号なしの大きさによって\)。 次の例は、配列によって返される情報を表示、<xref:System.Enum.GetNames%2A>負の値、0、正の値を含む列挙体のメソッドです。  
  
 [!code-csharp[System.Enum.GetNames\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getnames/cs/getnames1.cs#1)]
 [!code-vb[System.Enum.GetNames\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getnames/vb/getnames1.vb#1)]  
  
 同じ値を持つ列挙定数がある場合は、対応する名前の順序は指定されません。  
  
   
  
## 例  
 <xref:System.Enum.GetNames%2A> メソッドの使用例を次に示します。  
  
 [!code-cpp[enumgetnames\#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetnames/CPP/EnumGetNames.cpp#1)]
 [!code-csharp[enumgetnames\#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetnames/CS/EnumGetNames.cs#1)]
 [!code-vb[enumgetnames\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetnames/VB/EnumGetNames.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> パラメーターが <see cref="T:System.Enum" /> ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この列挙メンバーの基になる型の型コードを返します。</summary>
        <returns>このインスタンスの基になる型の型コードを返します。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">列挙型が不明です。</exception>
        <altmember cref="M:System.Enum.GetUnderlyingType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetUnderlyingType">
      <MemberSignature Language="C#" Value="public static Type GetUnderlyingType (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetUnderlyingType(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetUnderlyingType(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">基になる型が取得される列挙。</param>
        <summary>指定した列挙体の基になる型を返します。</summary>
        <returns>
          <paramref name="enumType" /> の基になる型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum>構造により、名前付き定数として表現されている値。 列挙型の値のデータ型は、基になる型と呼ばれます。 たとえば、基になる型の<xref:System.DayOfWeek>列挙体は、各曜日を表す定数で構成されます \(<xref:System.DayOfWeek.Monday?displayProperty=fullName>、<xref:System.DayOfWeek.Tuesday?displayProperty=fullName>など\) は<xref:System.Int32>します。  
  
   
  
## 例  
 次の例では、<xref:System.Enum.GetUnderlyingType%2A>メソッドをいくつかの列挙メンバーの基になる型を表示します。  
  
 [!code-csharp[System.Enum.GetUnderlyingType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getunderlyingtype/cs/getunderlyingtype1.cs#1)]
 [!code-vb[System.Enum.GetUnderlyingType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getunderlyingtype/vb/getunderlyingtype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。</exception>
        <altmember cref="M:System.Enum.GetTypeCode" />
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public static Array GetValues (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array GetValues(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetValues(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">列挙型。</param>
        <summary>指定した列挙体に含まれている定数の値の配列を取得します。</summary>
        <returns>
          <paramref name="enumType" /> に含まれている定数の値を格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 配列の要素は列挙定数のバイナリ値に基づいて並べ替えられます \(つまり、その符号なしの大きさによって\)。 次の例は、によって返される配列に関する情報を表示、<xref:System.Enum.GetValues%2A>負の値や 0、正の値を含む列挙体のメソッドです。  
  
 [!code-csharp[System.Enum.GetValues\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues1.cs#1)]
 [!code-vb[System.Enum.GetValues\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues1.vb#1)]  
  
 <xref:System.Enum.GetValues%2A>メソッドの各メンバーの値を含む配列を返します、`enumType`列挙します。 複数のメンバーの値が同じ場合は、返される配列には、重複する値が含まれています。 この場合、呼び出し、<xref:System.Enum.GetName%2A>返される配列内の各値を持つメソッドが重複する値を持つメンバーに割り当てられた一意の名前を復元できません。 すべての列挙体メンバーの名前を正常に取得する、<xref:System.Enum.GetNames%2A>メソッドです。  
  
 <xref:System.Enum.GetValues%2A>リフレクションのみのコンテキストでリフレクションを使用してメソッドを呼び出すことができません。 使用してすべての列挙体メンバーの値を取得する代わりに、<xref:System.Type.GetFields%2A?displayProperty=fullName>の配列を取得するメソッド<xref:System.Reflection.FieldInfo>列挙型のメンバーを表すオブジェクトを呼び出す、<xref:System.Reflection.FieldInfo.GetRawConstantValue%2A?displayProperty=fullName>配列の各要素に対してメソッドです。 次の例では、この方法を示します。 これは、Enumerations.dll という名前のアセンブリでは、次の列挙型を定義することが必要です。  
  
 [!code-csharp[System.Enum.GetValues\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues_reflectiononly.cs#2)]
 [!code-vb[System.Enum.GetValues\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues_reflectiononly.vb#2)]  
  
 アセンブリがリフレクションのみのコンテキストに読み込まれている、<xref:System.Type>を表すオブジェクト、`Pets`列挙型がインスタンス化の配列<xref:System.Reflection.FieldInfo>オブジェクトを取得し、フィールドの値がコンソールに表示されます。  
  
 [!code-csharp[System.Enum.GetValues\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues_reflectiononly.cs#3)]
 [!code-vb[System.Enum.GetValues\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues_reflectiononly.vb#3)]  
  
   
  
## 例  
 次の例は、の使用を示しています。<xref:System.Enum.GetValues%2A>です。  
  
 [!code-cpp[enumgetvalues\#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetvalues/CPP/EnumGetValues.cpp#1)]
 [!code-csharp[enumgetvalues\#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetvalues/CS/EnumGetValues.cs#1)]
 [!code-vb[enumgetvalues\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetvalues/VB/EnumGetValues.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">リフレクションのみのコンテキストでのリフレクションによって、メソッドが呼び出されます  
  
 \-または\-  
  
 <paramref name="enumType" /> は、リフレクションのみのコンテキストで読み込まれたアセンブリに基づく型です。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasFlag">
      <MemberSignature Language="C#" Value="public bool HasFlag (Enum flag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasFlag(class System.Enum flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.HasFlag(System.Enum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Enum" />
      </Parameters>
      <Docs>
        <param name="flag">列挙値。</param>
        <summary>現在のインスタンスで 1 つ以上のビット フィールドが設定されているかどうかを判断します。</summary>
        <returns>
          <paramref name="flag" /> に設定されているビット フィールドが現在のインスタンスでも設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.HasFlag%2A>メソッドには、次のブール式の結果が返されます。  
  
```  
thisInstance And flag = flag   
```  
  
 場合の基になる値`flag`0 の場合は、メソッドが返される`true`です。 この動作が望ましくない場合を使用できます、 <xref:System.Enum.Equals%2A> 0 や呼び出しとの等価性をテストするメソッド<xref:System.Enum.HasFlag%2A>場合にのみの基になる値`flag`0 以外の場合は、次の例に示すようにします。  
  
 [!code-csharp[System.Enum.HasFlag\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.hasflag/cs/hasflag0.cs#1)]
 [!code-vb[System.Enum.HasFlag\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.hasflag/vb/hasflag0.vb#1)]  
  
 <xref:System.Enum.HasFlag%2A>でマークされた列挙型で使用するメソッドが設計されています、<xref:System.FlagsAttribute>属性し、複数のビット フィールドが設定されているかどうかを確認するために使用できます。 マークされていない列挙型の<xref:System.FlagsAttribute>属性、いずれかを呼び出す、<xref:System.Enum.Equals%2A>メソッドまたは<xref:System.Enum.CompareTo%2A>メソッドです。  
  
   
  
## 例  
 次の例では定義、`ItemsOrdered`顧客がレストランで注文できます項目のカテゴリを表す列挙。 この例では、前菜と飲み物の両方の顧客が注文があるかどうかをテストします。  
  
 [!code-csharp[System.Enum.HasFlag\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.hasflag/cs/hasflag1.cs#2)]
 [!code-vb[System.Enum.HasFlag\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.hasflag/vb/hasflag1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="flag" /> は現在のインスタンスとは異なる型です。</exception>
        <altmember cref="T:System.FlagsAttribute" />
        <altmember cref="M:System.Enum.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public static bool IsDefined (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefined(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.IsDefined(System.Type,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">列挙型。</param>
        <param name="value">
          <c>enumType</c> 内の定数の値または名前。</param>
        <summary>指定した値を持つ定数が指定した列挙体に存在するかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="enumType" /> 内の定数の値が <paramref name="value" /> と等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `value`パラメーターには、次のいずれかを指定できます。  
  
-   型のメンバーはすべて`enumType`です。  
  
-   値が型の列挙体のメンバーである変数`enumType`です。  
  
-   列挙体のメンバーの名前の文字列形式。 文字列の文字には、列挙メンバー名として同じ大文字と小文字が必要です。  
  
-   基になる型の値`enumType`です。  
  
 場合の定数は、`enumType`ビット フィールドのセットを定義および`value`値、名、または複数のビット フィールドの基になる値が含まれています、<xref:System.Enum.IsDefined%2A>メソッドを返します。`false`です。 つまり、列挙型ビット フィールドのセットを定義するを判断するメソッドのみ 1 ビット フィールドが列挙体に属しているかどうか。 タグ付けされた列挙型で複数のビット フィールドが設定されているかどうかを決定する、<xref:System.FlagsAttribute>呼び出すことができます、属性、<xref:System.Enum.HasFlag%2A>メソッドです。  
  
   
  
## 例  
 次の例は、という名前の列挙を定義`PetType`個別のフィールドで構成されます。 呼び出して、<xref:System.Enum.IsDefined%2A>列挙値、文字列名、および複数のビット フィールドの設定に起因する複合型の値を基になる、できる限りメソッドです。  
  
 [!code-csharp[System.Enum.IsDefined\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.IsDefined/cs/isdefined1.cs#1)]
 [!code-vb[System.Enum.IsDefined\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.IsDefined/vb/IsDefined1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> または <paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see langword="Enum" /> ではありません。  
  
 \-または\-  
  
 <paramref name="value" /> の型は列挙体ですが、型 <paramref name="enumType" /> の列挙体ではありません。  
  
 \-または\-  
  
 <paramref name="value" /> の型は、<paramref name="enumType" /> の基となる型ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> の型が <see cref="T:System.SByte" />、<see cref="T:System.Int16" />、<see cref="T:System.Int32" />、<see cref="T:System.Int64" />、<see cref="T:System.Byte" />、<see cref="T:System.UInt16" />、<see cref="T:System.UInt32" />、<see cref="T:System.UInt64" />、<see cref="T:System.String" /> のどれでもありません。</exception>
        <block subset="none" type="usage">
          <para>If <paramref name="enumType" /> is an enumeration that is defined by using the <see cref="T:System.FlagsAttribute" /> attribute, the method returns <see langword="false" /> if multiple bit fields in <paramref name="value" /> are set but <paramref name="value" /> does not correspond to a composite enumeration value, or if <paramref name="value" /> is a string concatenation of the names of multiple bit flags. In the following example, a <c>Pets</c> enumeration is defined with the <see cref="T:System.FlagsAttribute" /> attribute. The <see cref="M:System.Enum.IsDefined(System.Type,System.Object)" /> method returns <see langword="false" /> when you pass it an enumeration value that has two bit fields (<c>Pets.Dog</c> and <c>Pets.Cat</c>) set, and when you pass it the string representation of that enumeration value ("Dog, Cat").  
  
 [!code-csharp[System.Enum.IsDefined#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.IsDefined/cs/isdefined2.cs#2)]
 [!code-vb[System.Enum.IsDefined#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.IsDefined/vb/isdefined2.vb#2)]  
  
 You can determine whether multiple bit fields are set by calling the <see cref="M:System.Enum.HasFlag(System.Enum)" /> method.</para>
        </block>
        <altmember cref="M:System.Enum.GetName(System.Type,System.Object)" />
        <altmember cref="M:System.Enum.GetNames(System.Type)" />
        <altmember cref="M:System.Enum.GetValues(System.Type)" />
        <altmember cref="M:System.Enum.HasFlag(System.Enum)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (Type enumType, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(class System.Type enumType, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="enumType">列挙型。</param>
        <param name="value">変換する名前または値が含まれている文字列。</param>
        <summary>文字列形式での 1 つ以上の列挙定数の名前または数値を、等価の列挙オブジェクトに変換します。</summary>
        <returns>値が <paramref name="value" /> により表される <paramref name="enumType" /> 型のオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `value`パラメーターには、列挙体のメンバーの基になる値や名前付き定数の文字列表現が含まれているかの一覧がコンマ \(,\) で区切られた定数をという名前です。 1 つ以上の空白文字が前または次の各値、名前、またはコンマで`value`です。 場合`value`リストで、戻り値は、ビットごとと組み合わせて、指定した名前の値`OR`操作します。  
  
 場合`value`の名前付き定数に対応していない名前は、`enumType`がスローされます、<xref:System.ArgumentException>です。 場合`value`の基になる値を表していないを整数の文字列表現です、`enumType`列挙型、メソッドは、基になる値が列挙体のメンバーを返します`value`整数型に変換します。 この動作が望ましくない場合は、呼び出し、<xref:System.Enum.IsDefined%2A>整数の特定の文字列表現が実際のメンバーであることを確認するメソッド`enumType`です。 次の例では定義、`Colors`列挙型、呼び出し、 <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> 、対応する列挙値、および呼び出し文字列に変換するメソッド、<xref:System.Enum.IsDefined%2A>の値が特定の整数値が基になることを確認するメソッド、`Colors`列挙します。  
  
 [!code-csharp[System.Enum.Parse\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample1.cs#1)]
 [!code-vb[System.Enum.Parse\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample1.vb#1)]  
  
 この操作は、大文字小文字を区別します。  
  
   
  
## 例  
 次の例では、<xref:System.Enum.Parse%28System.Type%2CSystem.String%29>メソッドを呼び出すことによって作成される文字列の配列を解析、<xref:System.Enum.GetNames%2A>メソッドです。 また、使用、<xref:System.Enum.Parse%28System.Type%2CSystem.String%29>ビット フィールドで構成される列挙値を解析します。  
  
 [!code-cpp[enumparse\#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumparse/CPP/EnumParse.cpp#1)]
 [!code-csharp[enumparse\#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumparse/CS/EnumParse.cs#1)]
 [!code-vb[enumparse\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumparse/VB/EnumParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> または <paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。  
  
 または  
  
 <paramref name="value" /> が空の文字列であるか、または空白しか含まれていません。  
  
 または  
  
 <paramref name="value" /> は名前ですが、列挙に対して定義されている名前付き定数の名前ではありません。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> は <paramref name="enumType" /> の基になる型の範囲外です。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (Type enumType, string value, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(class System.Type enumType, string value, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse(System.Type,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enumType">列挙型。</param>
        <param name="value">変換する名前または値が含まれている文字列。</param>
        <param name="ignoreCase">大文字と小文字を区別しない場合は <see langword="true" />。大文字と小文字を区別する場合は <see langword="false" />。</param>
        <summary>文字列形式での 1 つ以上の列挙定数の名前または数値を、等価の列挙オブジェクトに変換します。 演算で大文字と小文字を区別しないかどうかをパラメーターで指定します。</summary>
        <returns>
          <paramref name="value" /> によって表される値を持つ <paramref name="enumType" /> 型のオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `value`パラメーターには、列挙体のメンバーの基になる値や名前付き定数の文字列表現が含まれているかの一覧がコンマ \(,\) で区切られた定数をという名前です。 1 つ以上の空白文字が前または次の各値、名前、またはコンマで`value`です。 場合`value`リストで、戻り値は、ビットごとと組み合わせて、指定した名前の値`OR`操作します。  
  
 場合`value`の名前付き定数に対応していない名前は、`enumType`がスローされます、<xref:System.ArgumentException>です。 場合`value`の基になる値を表していないを整数の文字列表現です、`enumType`列挙型、メソッドは、基になる値が列挙体のメンバーを返します`value`整数型に変換します。 この動作が望ましくない場合は、呼び出し、<xref:System.Enum.IsDefined%2A>整数の特定の文字列表現が実際のメンバーであることを確認するメソッド`enumType`です。 次の例では定義、`Colors`列挙型、呼び出し、 <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> 、対応する列挙値、および呼び出し文字列に変換するメソッド、<xref:System.Enum.IsDefined%2A>で値を特定の整数値が基になることを確認する方法、`Colors`列挙します。  
  
 [!code-csharp[System.Enum.Parse\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample2.cs#2)]
 [!code-vb[System.Enum.Parse\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample2.vb#2)]  
  
 `ignoreCase`パラメーターは、この操作は、大文字小文字を区別するかどうかを指定します。  
  
   
  
## 例  
 次の例では、<xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29>メソッドを呼び出すことによって作成される文字列の配列を解析、<xref:System.Enum.GetNames%2A>メソッドです。 また、使用、<xref:System.Enum.Parse%28System.Type%2CSystem.String%29>ビット フィールドで構成される列挙値を解析します。  
  
 [!code-csharp[System.Enum.Parse\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample2.cs#2)]
 [!code-vb[System.Enum.Parse\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> または <paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。  
  
 または  
  
 <paramref name="value" /> が空の文字列 \(""\) であるか、または空白しか含まれていません。  
  
 または  
  
 <paramref name="value" /> は名前ですが、列挙に対して定義されている名前付き定数の名前ではありません。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> は <paramref name="enumType" /> の基になる型の範囲外です。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Parse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum Parse&lt;TEnum&gt; (string value) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum Parse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse``1(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">To be added.</typeparam>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum Parse&lt;TEnum&gt; (string value, bool ignoreCase) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum Parse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse``1(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値をブール値に変換します。</summary>
        <returns>このメンバーは常に例外をスローします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在、実装されていません。 常に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を 8 ビット符号なし整数に変換します。</summary>
        <returns>変換された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して <xref:System.Convert> 変換を実行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を Unicode 文字に変換します。</summary>
        <returns>このメンバーは常に例外をスローします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在、実装されていません。 常に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を <see cref="T:System.DateTime" /> に変換します。</summary>
        <returns>このメンバーは常に例外をスローします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在、実装されていません。 常に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を <see cref="T:System.Decimal" /> に変換します。</summary>
        <returns>このメンバーは常に例外をスローします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在、実装されていません。 常に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を倍精度浮動小数点数に変換します。</summary>
        <returns>このメンバーは常に例外をスローします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在、実装されていません。 常に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を 16 ビット符号付き整数に変換します。</summary>
        <returns>変換された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して <xref:System.Convert> 変換を実行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を 32 ビット符号付き整数に変換します。</summary>
        <returns>変換された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して<xref:System.Convert>変換を実行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を 64 ビット符号付き整数に変換します。</summary>
        <returns>変換された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して <xref:System.Convert> 変換を実行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を 8 ビット符号付き整数に変換します。</summary>
        <returns>変換された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して <xref:System.Convert> 変換を実行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を単精度浮動小数点数に変換します。</summary>
        <returns>このメンバーは常に例外をスローします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在、実装されていません。 常に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString().")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">変換後の型。</param>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を指定した型に変換します。</summary>
        <returns>変換された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して <xref:System.Convert> 変換を実行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を 16 ビット符号なし整数に変換します。</summary>
        <returns>変換された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して <xref:System.Convert> 変換を実行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を 32 ビット符号なし整数に変換します。</summary>
        <returns>変換された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して <xref:System.Convert> 変換を実行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>基になる型に基づいて、現在の値を 64 ビット符号なし整数に変換します。</summary>
        <returns>変換された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して <xref:System.Convert> 変換を実行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString(String).")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="enumType">返される列挙型。</param>
        <param name="value">列挙メンバーへと変換する値。</param>
        <summary>指定した 8 ビット符号なし整数を列挙メンバーに変換します。</summary>
        <returns>
          <paramref name="value" /> に設定される列挙体のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.Byte%29>メソッドに変換`value`基になる値が列挙体のメンバーを`value`です。 値がの境界の外側にある場合でも、変換が成功したことに注意してください`enumType`メンバー。 いることを確認する`value`の有効な基になる値は、`enumType`列挙体に渡すこと、<xref:System.Enum.IsDefined%2A>メソッドです。  
  
 この変換メソッドが型の値を返します<xref:System.Object>です。 キャスト、型のオブジェクトに変換したり`enumType`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="enumType">返される列挙型。</param>
        <param name="value">列挙メンバーへと変換する値。</param>
        <summary>指定した 16 ビット符号付き整数を列挙メンバーに変換します。</summary>
        <returns>
          <paramref name="value" /> に設定される列挙体のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.Int16%29>メソッドに変換`value`を基になる値を列挙メンバー`value`です。 値がの境界の外側にある場合でも、変換が成功したことに注意してください`enumType`メンバー。 いることを確認する`value`の有効な基になる値は、`enumType`列挙体に渡すこと、<xref:System.Enum.IsDefined%2A>メソッドです。  
  
 この変換メソッドが型の値を返します<xref:System.Object>です。 キャスト、型のオブジェクトに変換したり`enumType`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="enumType">返される列挙型。</param>
        <param name="value">列挙メンバーへと変換する値。</param>
        <summary>指定した 32 ビット符号付き整数を列挙メンバーに変換します。</summary>
        <returns>
          <paramref name="value" /> に設定される列挙体のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.Int32%29>メソッドに変換`value`を基になる値を列挙メンバー`value`です。 値がの境界の外側にある場合でも、変換が成功したことに注意してください`enumType`メンバー。 いることを確認する`value`の有効な基になる値は、`enumType`列挙体に渡すこと、<xref:System.Enum.IsDefined%2A>メソッドです。  
  
 この変換メソッドが型の値を返します<xref:System.Object>です。 キャスト、型のオブジェクトに変換したり`enumType`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="enumType">返される列挙型。</param>
        <param name="value">列挙メンバーへと変換する値。</param>
        <summary>指定した 64 ビット符号付き整数を列挙メンバーに変換します。</summary>
        <returns>
          <paramref name="value" /> に設定される列挙体のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.Int64%29> メソッドに変換 `value` を基になる値が列挙メンバー `value`します。 値がの境界の外側にある場合でも、変換が成功した注 `enumType` メンバーです。 いることを確認する `value` の有効な基になる値は、 `enumType` 列挙体に渡す、 <xref:System.Enum.IsDefined%2A> メソッドです。  
  
 この変換メソッドが型の値を返す <xref:System.Object>します。 キャストまたは型のオブジェクトに変換することができますし、 `enumType`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">返される列挙型。</param>
        <param name="value">列挙メンバーへと変換する値。</param>
        <summary>整数値を持つ指定したオブジェクトを列挙メンバーに変換します。</summary>
        <returns>値が <paramref name="value" /> である列挙オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.Object%29>メソッドは、整数値を変換します。`value`を基になる値を列挙メンバー`value`です。 値がの境界の外側にある場合でも、変換が成功したことに注意してください`enumType`メンバー。 いることを確認する`value`の有効な基になる値は、`enumType`列挙体に渡すこと、<xref:System.Enum.IsDefined%2A>メソッドです。  
  
 この変換メソッドが型の値を返します<xref:System.Object>です。 キャスト、型のオブジェクトに変換したり`enumType`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> または <paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。  
  
 または  
  
 <paramref name="value" /> の型が <see cref="T:System.SByte" />、<see cref="T:System.Int16" />、<see cref="T:System.Int32" />、<see cref="T:System.Int64" />、<see cref="T:System.Byte" />、<see cref="T:System.UInt16" />、<see cref="T:System.UInt32" />、または <see cref="T:System.UInt64" /> ではありません。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="enumType">返される列挙型。</param>
        <param name="value">列挙メンバーへと変換する値。</param>
        <summary>指定した 8 ビット符号付き整数値を列挙メンバーに変換します。</summary>
        <returns>
          <paramref name="value" /> に設定される列挙体のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.SByte%29> メソッドに変換 `value` を基になる値が列挙メンバー `value`します。 値がの境界の外側にある場合でも、変換が成功した注 `enumType` メンバーです。 いることを確認する `value` の有効な基になる値は、 `enumType` 列挙体に渡す、 <xref:System.Enum.IsDefined%2A> メソッドです。  
  
 この変換メソッドが型の値を返す <xref:System.Object>します。 キャストまたは型のオブジェクトに変換することができますし、 `enumType`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="enumType">返される列挙型。</param>
        <param name="value">列挙メンバーへと変換する値。</param>
        <summary>指定した 16 ビット符号なし整数値を列挙メンバーに変換します。</summary>
        <returns>
          <paramref name="value" /> に設定される列挙体のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt16%29> メソッドに変換 `value` を基になる値が列挙メンバー `value`します。 値がの境界の外側にある場合でも、変換が成功した注 `enumType` メンバーです。 いることを確認する `value` の有効な基になる値は、 `enumType` 列挙体に渡す、 <xref:System.Enum.IsDefined%2A> メソッドです。  
  
 この変換メソッドが型の値を返す <xref:System.Object>します。 キャストまたは型のオブジェクトに変換することができますし、 `enumType`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="enumType">返される列挙型。</param>
        <param name="value">列挙メンバーへと変換する値。</param>
        <summary>指定した 32 ビット符号なし整数値を列挙メンバーに変換します。</summary>
        <returns>
          <paramref name="value" /> に設定される列挙体のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt32%29> メソッドに変換 `value` を基になる値が列挙メンバー `value`します。 値がの境界の外側にある場合でも、変換が成功した注 `enumType` メンバーです。 いることを確認する `value` の有効な基になる値は、 `enumType` 列挙体に渡す、 <xref:System.Enum.IsDefined%2A> メソッドです。  
  
 この変換メソッドが型の値を返す <xref:System.Object>します。 キャストまたは型のオブジェクトに変換することができますし、 `enumType`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="enumType">返される列挙型。</param>
        <param name="value">列挙メンバーへと変換する値。</param>
        <summary>指定した 64 ビット符号なし整数値を列挙メンバーに変換します。</summary>
        <returns>
          <paramref name="value" /> に設定される列挙体のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt64%29> メソッドに変換 `value` を基になる値が列挙メンバー `value`します。 値がの境界の外側にある場合でも、変換が成功した注 `enumType` メンバーです。 いることを確認する `value` の有効な基になる値は、 `enumType` 列挙体に渡す、 <xref:System.Enum.IsDefined%2A> メソッドです。  
  
 この変換メソッドが型の値を返す <xref:System.Object>します。 キャストまたは型のオブジェクトに変換することができますし、 `enumType`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> が <see cref="T:System.Enum" /> ではありません。</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの値を、それと等価の文字列形式に変換します。</summary>
        <returns>このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 戻り値には、一般書式指定子 \("G"\) が表示されます。 つまり場合、<xref:System.FlagsAttribute>には適用されませんこの列挙型、名前付き定数と等しい、このインスタンスの値があるし、戻り値は、定数の名前を含む文字列。 場合、<xref:System.FlagsAttribute>が適用される 1 つまたは複数の名前付き定数の組み合わせがある、このインスタンスの値と同じにし、戻り値は、定数の名前のコンマ区切りのリストを含む文字列。 それ以外の場合、戻り値は、このインスタンスの数値の文字列形式です。 列挙値の書式設定の詳細については、次を参照してください。[Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)です。 一般に書式設定に関する詳細については、次を参照してください。[Formatting Types in the .NET Framework](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)です。  
  
   
  
## 例  
 次の例では、列挙型の値を文字列に変換するを示しています。  
  
 [!code-cpp[Classic Enum.ToString2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Enum.ToString2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/CS/source.cs#1)]
 [!code-vb[Classic Enum.ToString2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>If multiple enumeration members have the same underlying value and you attempt to retrieve the string representation of an enumeration member's name based on its underlying value, your code should not make any assumptions about which name the method will return. For example, the following enumeration defines two members, <c>Shade.Gray</c> and <c>Shade.Grey</c>, that have the same underlying value.  
  
 [!code-csharp[System.Enum.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#1)]
 [!code-vb[System.Enum.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#1)]  
  
 The following method call attempts to retrieve the name of a member of the <c>Shade</c> enumeration whose underlying value is 1. The method can return either "Gray" or "Grey", and your code should not make any assumptions about which string will be returned.  
  
 [!code-csharp[System.Enum.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#2)]
 [!code-vb[System.Enum.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#2)]</para>
        </block>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString().")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">\(互換性のために残されています\)</param>
        <summary>このメソッドのオーバーロードは今後使用しません。代わりに <see cref="M:System.Enum.ToString" /> を使用します。</summary>
        <returns>このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">書式指定文字列。</param>
        <summary>指定した書式を使用して、このインスタンスの値をそれと等価な文字列形式に変換します。</summary>
        <returns>
          <paramref name="format" /> で指定された、このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `format`パラメーターは、"G"または"g"、"D"または"d"、"X"または"x"と"F"または"f"書式指定文字列 \(書式指定文字列は区別されません\) を含めることができます。 場合`format`は`null`または空の文字列 \(""\)、一般書式指定子 \("G"\) を使用します。 列挙型書式指定文字列と書式設定の列挙値の詳細については、次を参照してください。[Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)です。 一般に書式設定に関する詳細については、次を参照してください。[Formatting Types in the .NET Framework](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)です。  
  
   
  
## 例  
 次の例では、列挙型の値を文字列に変換する方法を示します。  
  
 [!code-cpp[enum.tostring\#1](~/samples/snippets/cpp/VS_Snippets_CLR/enum.tostring/CPP/tostr.cpp#1)]
 [!code-csharp[enum.tostring\#1](~/samples/snippets/csharp/VS_Snippets_CLR/enum.tostring/CS/tostr.cs#1)]
 [!code-vb[enum.tostring\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enum.tostring/VB/tostr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> に正しくない仕様が含まれています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> は "X" と等しいですが、列挙型が不明です。</exception>
        <block subset="none" type="usage">
          <para>If multiple enumeration members have the same underlying value and you attempt to retrieve the string representation of an enumeration member's name based on its underlying value, your code should not make any assumptions about which name the method will return. For example, the following enumeration defines two members, <c>Shade.Gray</c> and <c>Shade.Grey</c>, that have the same underlying value.  
  
 [!code-csharp[System.Enum.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#1)]
 [!code-vb[System.Enum.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#1)]  
  
 The following method call attempts to retrieve the name of a member of the <c>Shade</c> enumeration whose underlying value is 1. The method can return either "Gray" or "Grey", and your code should not make any assumptions about which string will be returned.  
  
 [!code-csharp[System.Enum.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#3)]
 [!code-vb[System.Enum.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#3)]</para>
        </block>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
        <altmember cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString(String).")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">書式指定。</param>
        <param name="provider">\(現在不使用。\)</param>
        <summary>このメソッドのオーバーロードは現在使用しません。代わりに <see cref="M:System.Enum.ToString(System.String)" /> を使用します。</summary>
        <returns>
          <paramref name="format" /> で指定された、このインスタンスの値の文字列表記。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `format`パラメーターは、"G"または"g"、"D"または"d"、"X"または"x"と"F"または"f"書式指定文字列 \(書式指定文字列は区別されません\) を含めることができます。 場合`format`は`null`または空の文字列 \(""\)、一般書式指定子 \("G"\) を使用します。 列挙型書式指定文字列と書式設定の列挙値の詳細については、次を参照してください。[Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)です。 一般に書式設定に関する詳細については、次を参照してください。[Formatting Types in the .NET Framework](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)です。  
  
 のみを指定`format`;`provider`パラメーターは今後使用しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> は有効な書式指定を含みません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> は "X" と等しいですが、列挙型が不明です。</exception>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (Type enumType, string value, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(class System.Type enumType, string value, object result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse(System.Type,System.String,System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enumType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (Type enumType, string value, bool ignoreCase, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(class System.Type enumType, string value, bool ignoreCase, object result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse(System.Type,System.String,System.Boolean,System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enumType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static bool TryParse&lt;TEnum&gt; (string value, out TEnum result) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, !!TEnum result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse``1(System.String,``0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="TEnum&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">
          <c>value</c> の変換先の列挙型。</typeparam>
        <param name="value">変換する列挙定数の名前または基になる値の文字列形式。</param>
        <param name="result">このメソッドから制御が戻るときに、<c>result</c> には、解析操作が成功したときに値が <c>value</c> で表される <c>TEnum</c> 型のオブジェクトが格納されます。 解析操作が失敗した場合、<c>result</c> には <c>TEnum</c> の基になる型の既定値が格納されます。 この値が <c>TEnum</c> 列挙型のメンバーである必要がないことに注意してください。 このパラメーターは初期化せずに渡されます。</param>
        <summary>文字列形式での 1 つ以上の列挙定数の名前または数値を、等価の列挙オブジェクトに変換します。 戻り値は、変換が成功したかどうかを示します。</summary>
        <returns>
          <see langword="true" /> パラメーターが正常に変換された場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29>同じですが、<xref:System.Enum.Parse%28System.Type%2CSystem.String%29>以外を返しますが、例外をスローする代わりに、メソッド`false`変換に失敗する場合。 これにより、例外処理の列挙値の文字列形式を解析するときの必要があります。  
  
 `value`パラメーターには、列挙体のメンバーの基になる値や名前付き定数の文字列表現が含まれているか、名前付き定数または基になる値の一覧がコンマ \(,\) で区切られます。 場合`value`が複数には含まれていますという名前の定数または値 1 つ以上の空白文字の前にしたり、以下の各値、名前、またはコンマで`value`です。 場合`value`一覧、 `result` 、指定した名前の値を反映または値のビットごとの組み合わせを基になる`OR`操作します。 場合`value`列挙値を比較した結果の名前の文字列表現です`value`列挙型名は大文字小文字を区別します。  
  
 場合`value`名前を指定の名前付き定数に対応していない`TEnum`、メソッドを返します`false`です。 場合`value`の基になる値を表していないを整数の文字列表現です、`TEnum`列挙型、メソッドは、基になる値が列挙体のメンバーを返します`value`整数型に変換します。 この動作が望ましくない場合は、呼び出し、<xref:System.Enum.IsDefined%2A>整数の特定の文字列表現が実際のメンバーであることを確認するメソッド`TEnum`です。  
  
   
  
## 例  
 次の例では定義、`Colors`列挙型、呼び出し、 <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29> 、対応する列挙値、および呼び出し文字列に変換するメソッド、<xref:System.Enum.IsDefined%2A>で値を特定の整数値が基になることを確認する方法、`Colors`列挙します。  
  
 [!code-csharp[System.Enum.TryParse\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Enum.TryParse\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TEnum" /> は列挙型ではありません。</exception>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static bool TryParse&lt;TEnum&gt; (string value, bool ignoreCase, out TEnum result) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, bool ignoreCase, !!TEnum result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse``1(System.String,System.Boolean,``0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="result" Type="TEnum&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">
          <c>value</c> の変換先の列挙型。</typeparam>
        <param name="value">変換する列挙定数の名前または基になる値の文字列形式。</param>
        <param name="ignoreCase">大文字と小文字を区別しない場合は <see langword="true" />。大文字と小文字を区別する場合は <see langword="false" />。</param>
        <param name="result">このメソッドから制御が戻るときに、<c>result</c> には、解析操作が成功したときに値が <c>value</c> で表される <c>TEnum</c> 型のオブジェクトが格納されます。 解析操作が失敗した場合、<c>result</c> には <c>TEnum</c> の基になる型の既定値が格納されます。 この値が <c>TEnum</c> 列挙型のメンバーである必要がないことに注意してください。 このパラメーターは初期化せずに渡されます。</param>
        <summary>文字列形式での 1 つ以上の列挙定数の名前または数値を、等価の列挙オブジェクトに変換します。 演算で大文字と小文字を区別するかどうかをパラメーターで指定します。 戻り値は、変換が成功したかどうかを示します。</summary>
        <returns>
          <see langword="true" /> パラメーターが正常に変換された場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29>同じですが、<xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29>以外を返しますが、例外をスローする代わりに、メソッド`false`変換に失敗する場合。 これにより、例外処理の列挙値の文字列形式を解析するときの必要があります。  
  
 `value`パラメーターには、列挙体のメンバーの基になる値や名前付き定数の文字列表現が含まれているか、名前付き定数または基になる値の一覧がコンマ \(,\) で区切られます。 場合`value`が複数には含まれていますという名前の定数または値 1 つ以上の空白文字の前にしたり、以下の各値、名前、またはコンマで`value`です。 場合`value`一覧、 `result` 、指定した名前の値を反映または値のビットごとの組み合わせを基になる`OR`操作します。 場合`value`列挙値を比較した結果の名前の文字列形式を`value`列挙型名によって異なります、`ignoreCase`のパラメーターです。 場合`true`、比較では、大文字と小文字以外の場合は`false`は大文字小文字を区別します。  
  
 場合`value`の名前付き定数に対応していない名前は、 `TEnum`、メソッドを返します`false`です。 場合`value`の基になる値を表していないを整数の文字列表現です、`TEnum`列挙型、メソッドは、基になる値が列挙体のメンバーを返します`value`整数型に変換します。 この動作が望ましくない場合は、呼び出し、<xref:System.Enum.IsDefined%2A>整数の特定の文字列表現が実際のメンバーであることを確認するメソッド`TEnum`です。  
  
   
  
## 例  
 次の例では定義、`Colors`列挙型、呼び出し、 <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> 、対応する列挙値、および呼び出し文字列に変換するメソッド、<xref:System.Enum.IsDefined%2A>の値が特定の整数値が基になることを確認する方法、`Colors`列挙します。<xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29>定数を等価の列挙値には、名前付きの文字列形式に変換しようとしています。 メソッドは大文字と小文字を使用します。  
  
 [!code-csharp[System.Enum.TryParse\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tryparse/cs/tryparse2.cs#2)]
 [!code-vb[System.Enum.TryParse\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tryparse/vb/tryparse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TEnum" /> は列挙型ではありません。</exception>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した整数値を列挙メンバーに変換します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの値を、それと等価の文字列形式に変換します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>文字列形式での 1 つ以上の列挙定数の名前または数値を、等価の列挙オブジェクトに変換します。</summary>
        <altmember cref="M:System.Enum.TryParse``1(System.String,``0@)" />
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>文字列形式での 1 つ以上の列挙定数の名前または数値を、等価の列挙オブジェクトに変換します。 戻り値は、変換が成功したかどうかを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </MemberGroup>
  </Members>
</Type>