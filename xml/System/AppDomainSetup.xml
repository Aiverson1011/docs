<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.AppDomain" /> のインスタンスに追加できるアセンブリ バインディング情報を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティの変更、<xref:System.AppDomainSetup>インスタンスには影響しません、既存の<xref:System.AppDomain>します。 新しいの作成のみを与えることが<xref:System.AppDomain>、ときに、<xref:System.AppDomain.CreateDomain%2A>メソッドが呼び出された、<xref:System.AppDomainSetup>をパラメーターとしてのインスタンス。  
  
 このクラスは、<xref:System.IAppDomainSetup> インターフェイスを実装します。  
  
> [!CAUTION]
>  既定値、<xref:System.AppDomainSetup.DisallowCodeDownload%2A>プロパティは false。 この設定は、サービスの安全ではありません。 サービスが部分的に信頼されたコードをダウンロードするを防ぐためには、このプロパティを true に設定します。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.AppDomainSetup" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">アプリケーション ドメインに使用されるアクティベーション コンテキスト。</param>
        <summary>アプリケーション ドメイン用に指定されたアクティベーション コンテキスト \(マニフェストに基づくアクティベーションに使用される\) で、<see cref="T:System.AppDomainSetup" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.ActivationContext>に指定されたオブジェクト`activationContext`生成に使用される、<xref:System.Runtime.Hosting.ActivationArguments>新しいアプリケーション ドメインをアクティブ化するために必要な情報を含むオブジェクト。 これは、<xref:System.Runtime.Hosting.ActivationArguments>オブジェクトを使用してアクセスできる、<xref:System.AppDomainSetup.ActivationArguments%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationContext" /> は <see langword="null" /> です。</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">新しいアプリケーション ドメインの、マニフェストに基づくアクティベーションに必要な情報を指定するオブジェクト。</param>
        <summary>アプリケーション ドメインのマニフェストに基づくアクティベーション用に必要な、指定されたアクティベーション引数で、<see cref="T:System.AppDomainSetup" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定されたオブジェクト`activationArguments`を使用してアクセスできる、<xref:System.AppDomainSetup.ActivationArguments%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationArguments" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインのアクティベーションに関するデータを取得または設定します。</summary>
        <value>アプリケーション ドメインのアクティベーションに関するデータを格納するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティ設定されている場合に例外がスローされません`null`です。  
  
 によって提供される情報、<xref:System.Runtime.Hosting.ActivationArguments>オブジェクトは、マニフェストに基づくアクティベーションをサポートしています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロパティは、<see cref="P:System.AppDomainSetup.ApplicationTrust" /> プロパティから返される <see cref="T:System.Security.Policy.ApplicationTrust" /> オブジェクトのアプリケーション ID とは一致しないアプリケーション ID の <see cref="T:System.Runtime.Hosting.ActivationArguments" /> オブジェクトに設定されています。<see cref="P:System.AppDomainSetup.ApplicationTrust" /> プロパティが <see langword="null" /> の場合、例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインの初期化時に呼び出されるコールバック メソッドを表す <see cref="T:System.AppDomainInitializer" /> デリゲートを取得または設定します。</summary>
        <value>アプリケーション ドメインの初期化時に呼び出されるコールバック メソッドを表すデリゲート。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 情報をコールバック メソッドに渡すために文字列の配列を割り当てる、<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>プロパティです。 配列が毎回、コールバック メソッドに渡される、<xref:System.AppDomain>が初期化されています。  
  
 コールバック メソッドは、新しく作成されたアプリケーション ドメインのコンテキストで実行されます。  
  
   
  
## 例  
 次の例は、という名前の子アプリケーション ドメインを作成`ChildDomain`を使用して、<xref:System.AppDomainSetup>オブジェクトおよび既定のアプリケーション ドメインからの証拠。<xref:System.AppDomainSetup.AppDomainInitializer%2A>コールバック メソッドにプロパティが設定されている`AppDomainInit`、子ドメインの初期化時にこれが呼び出されます。 割り当てられた文字列の配列で、コールバック メソッドの引数を配置している、<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>プロパティです。 子ドメインが作成されると、コールバック メソッドの文字列が出力されます。  
  
 [!code-cpp[AppDomainInitializer\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.AppDomainInitializer" /> デリゲートが表すコールバック メソッドへの引数を取得または設定します。 コールバック メソッドは、アプリケーション ドメインの初期化時に呼び出されます。</summary>
        <value>
          <see cref="T:System.AppDomain" /> の初期化中、<see cref="T:System.AppDomainInitializer" /> デリゲートが表すコールバック メソッドが呼び出されたとき、このコールバック メソッドに渡される文字列の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、<xref:System.AppDomainSetup.AppDomainInitializer%2A>中に呼び出されるコールバック メソッドを指定するプロパティ<xref:System.AppDomain>初期化します。 場合、<xref:System.AppDomainSetup.AppDomainInitializer%2A>プロパティが設定されていない場合、このプロパティに割り当てられている配列は使用されません。  
  
 コールバック メソッドは、新しく作成されたアプリケーション ドメインのコンテキストで実行されます。  
  
   
  
## 例  
 次のコード例は、という名前の子アプリケーション ドメインを作成`ChildDomain`を使用して、<xref:System.AppDomainSetup>オブジェクトおよび既定のアプリケーション ドメインからの証拠。<xref:System.AppDomainSetup.AppDomainInitializer%2A>コールバック メソッドにプロパティが設定されている`AppDomainInit`、子ドメインの初期化時にこれが呼び出されます。 割り当てられた文字列の配列で、コールバック メソッドの引数を配置している、<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>プロパティです。 子ドメインが作成されると、コールバック メソッドの文字列が出力されます。  
  
 [!code-cpp[AppDomainInitializer\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.AppDomainSetup" /> オブジェクトを使用して作成されたアプリケーション ドメインのアプリケーション ドメイン マネージャーの型を提供するアセンブリの表示名を取得または設定します。</summary>
        <value>アプリケーション ドメイン マネージャーの <see cref="T:System.Type" /> を提供するアセンブリの表示名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーション ドメイン マネージャーの種類を指定するには、この両方のプロパティを設定し、<xref:System.AppDomainSetup.AppDomainManagerType%2A>プロパティです。 これらのプロパティのいずれかが設定されていない場合、その他は無視されます。  
  
 アプリケーション ドメイン マネージャーが、親のアプリケーション ドメインと同じ型から作成された型が指定されていない場合 \(元のアプリケーション ドメインは、<xref:System.AppDomain.CreateDomain%2A?displayProperty=fullName>メソッドが呼び出されます\)。  
  
 アプリケーション ドメインが読み込まれるときに<xref:System.TypeLoadException>アセンブリが存在しない場合、またはアセンブリに指定された型が含まれていない場合にスローされますが、<xref:System.AppDomainSetup.AppDomainManagerType%2A>プロパティです。<xref:System.IO.FileLoadException>アセンブリが見つかりましたが、バージョン情報が一致しない場合にスローされます。  
  
 既定のアプリケーション ドメインのアプリケーション ドメイン マネージャーを設定するには、使用、 [\<appDomainManagerAssembly\>](http://msdn.microsoft.com/ja-jp/c7c56e39-a700-44f5-b94e-411bfce339d9)と[\<appDomainManagerType\>](http://msdn.microsoft.com/ja-jp/ae8d5a7e-e7f7-47f7-98d9-455cc243a322)内の要素、 [\<runtime\>](http://msdn.microsoft.com/ja-jp/1eb2fae3-de4b-45b6-852f-517c39b751bd)アプリケーション構成ファイル、または環境変数に記載されている使用のセクション<xref:System.AppDomainManager>\<\/runtime\>\<\/appDomainManagerType\>。\<\/appDomainManagerAssembly\>  
  
 この機能では、アプリケーションに完全信頼が必要です。 \(たとえば、デスクトップで実行されているアプリケーションは完全な信頼。\) アプリケーションには、完全な信頼がない場合、<xref:System.TypeLoadException>がスローされます。  
  
 アセンブリの表示名の形式である、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.AppDomainSetup" /> オブジェクトを使用して作成されたアプリケーション ドメインのアプリケーション ドメイン マネージャーを提供する型の完全名を取得または設定します。</summary>
        <value>名前空間を含む、型の完全名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーション ドメイン マネージャーの種類を指定するには、この両方のプロパティを設定し、<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>プロパティです。 これらのプロパティのいずれかが設定されていない場合、その他は無視されます。  
  
 アプリケーション ドメイン マネージャーが、親のアプリケーション ドメインと同じ型から作成された型が指定されていない場合 \(元のアプリケーション ドメインは、<xref:System.AppDomain.CreateDomain%2A?displayProperty=fullName>メソッドが呼び出されます\)。  
  
 アプリケーション ドメインが読み込まれるときに<xref:System.TypeLoadException>によってアセンブリが指定されている場合にスローされますが、<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>プロパティにこのプロパティによって指定された型が含まれていません。  
  
 既定のアプリケーション ドメインのアプリケーション ドメイン マネージャーを設定するには、使用、 [\<appDomainManagerAssembly\>](http://msdn.microsoft.com/ja-jp/c7c56e39-a700-44f5-b94e-411bfce339d9)と[\<appDomainManagerType\>](http://msdn.microsoft.com/ja-jp/ae8d5a7e-e7f7-47f7-98d9-455cc243a322)内の要素、 [\<runtime\>](http://msdn.microsoft.com/ja-jp/1eb2fae3-de4b-45b6-852f-517c39b751bd)アプリケーション構成ファイル、または環境変数に記載されている使用のセクション<xref:System.AppDomainManager>\<\/runtime\>\<\/appDomainManagerType\>。\<\/appDomainManagerAssembly\>  
  
 この機能では、アプリケーションに完全信頼が必要です。 \(たとえば、デスクトップで実行されているアプリケーションが完全な信頼。\) アプリケーションには、完全な信頼がない場合、<xref:System.TypeLoadException>がスローされます。  
  
 型の完全名の形式である、<xref:System.Type.FullName%2A?displayProperty=fullName>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが格納されているディレクトリの名前を取得または設定します。</summary>
        <value>アプリケーションのベース ディレクトリの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーションの基本ディレクトリは、アセンブリ マネージャーがアセンブリのプローブを開始します。  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A>プロパティをアプリケーション ドメインにアクセス許可が付与されますに影響を与えることができます。 たとえば、通常、ローカル コンピューターから送信されたアプリケーション ドメインは、元の場所に基づいて完全に信頼を受け取ります。 ただし場合、<xref:System.AppDomainSetup.ApplicationBase%2A>プロパティの<xref:System.AppDomain>、イントラネットのディレクトリの完全な名前に設定されている、<xref:System.AppDomainSetup.ApplicationBase%2A>設定する場合でも、アプリケーション ドメインは、ローカル コンピューターから実際にあなた LocalIntranet grant をアプリケーション ドメインに許可する権限が制限されます。  
  
   
  
## 例  
 次の例で使用する方法、<xref:System.AppDomainSetup.ApplicationBase%2A>アセンブリ ローダーが、新しいアプリケーション ドメインに読み込むアセンブリをプローブを開始位置を設定するプロパティです。  
  
> [!NOTE]
>  指定したフォルダーが存在することを確認する必要があります。  
  
 [!code-cpp[ADApplicationBase\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path information. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの名前を取得または設定します。</summary>
        <value>アプリケーションの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例は、設定する方法を示します、<xref:System.AppDomainSetup.ApplicationName%2A>プロパティ、新しいアプリケーション ドメインを作成するときにします。  
  
 例では、新しいアプリケーション ドメインを作成してから、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=fullName>新しいアプリケーション ドメインにアセンブリを読み込んでのインスタンスを作成する方法、`Worker`クラスです。`Worker`クラスは継承<xref:System.MarshalByRefObject>例では、によって返されるプロキシを使用できるように、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>を呼び出して、`TestLoad`メソッドです。  
  
 `TestLoad`メソッドは、指定したアセンブリを読み込みます。 必要があるため、有効な完全修飾アセンブリ名を指定するか、コメント アウト、<xref:System.Reflection.Assembly.Load%28System.String%29>メソッドです。`TestLoad`メソッドには、指定したアセンブリとアセンブリが読み込まれることを示す、新しいアプリケーション ドメインに読み込まれるアセンブリが一覧表示されます。  
  
 この例では、<xref:System.LoaderOptimizationAttribute>属性へのアプリケーションがアプリケーション ドメイン間でコードを共有する方法をアセンブリ ローダーに通知します。  
  
 [!code-cpp[ADMultiDomain\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>セキュリティ情報や信頼情報を格納するオブジェクトを取得または設定します。</summary>
        <value>セキュリティ情報や信頼情報を格納するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは`null`ときに、<xref:System.AppDomainSetup>を作成します。 変更されると、null 参照をリセットできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロパティは、<see cref="P:System.AppDomainSetup.ActivationArguments" /> プロパティから返される <see cref="T:System.Runtime.Hosting.ActivationArguments" /> オブジェクトのアプリケーション ID とは一致しないアプリケーション ID の <see cref="T:System.Security.Policy.ApplicationTrust" /> オブジェクトに設定されています。<see cref="P:System.AppDomainSetup.ActivationArguments" /> プロパティが <see langword="null" /> の場合、例外はスローされません。</exception>
        <exception cref="T:System.ArgumentNullException">プロパティが <see langword="null" /> に設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ファイルがシャドウ コピーされる、そのアプリケーションに固有の領域の名前を取得または設定します。</summary>
        <value>ファイルのシャドウ コピー先のディレクトリ パスとファイル名から成る完全修飾名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを影響を与えるために、<xref:System.AppDomainSetup.ApplicationName%2A>プロパティも設定する必要があります。 場合、<xref:System.AppDomainSetup.ApplicationName%2A>プロパティが設定されていない、<xref:System.AppDomainSetup.CachePath%2A>プロパティは無視され、シャドウ コピーのキャッシュの場所の既定値は、ダウンロード キャッシュします。  
  
 シャドウ コピーの詳細については、次を参照してください。[Shadow Copying Assemblies](http://msdn.microsoft.com/ja-jp/de8b8759-fca7-4260-896b-5a4973157672)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path information. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインの構成ファイルの名前を取得または設定します。</summary>
        <value>構成ファイルの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 構成ファイルは、アプリケーション ドメインの構成データと検索の規則について説明します。 アプリケーション ドメインを作成するホストは、意味のある値が状況によって異なるために、このデータを提供します。  
  
 たとえば、各アプリケーション、ユーザー、およびコンピューターで実行可能ファイルの構成データが格納されている各アプリケーション、サイト、およびコンピューターの ASP.NET アプリケーションの構成データが格納されます。 ホストだけでは、構成データの特定の状況の詳細を認識します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path information. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み込むアセンブリを検索する際に、アプリケーションのベース パスおよびプライベート バイナリ パスを調査対象から除外するかどうかを指定します。</summary>
        <value>調査対象としない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> property is **languageKeyword tag is not supported!!!!**  
, the value of the <xref:System.AppDomainSetup.ApplicationBase%2A> property is ignored. That is, no assemblies are probed for in the directories specified by the <xref:System.AppDomainSetup.ApplicationBase%2A> property. In addition, the values of the <xref:System.AppDomainSetup.PrivateBinPath%2A> property and the <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> property are ignored. No assemblies are probed for in the directories specified by the <xref:System.AppDomainSetup.PrivateBinPath%2A> property.  
  
 The <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> property provides an additional layer of control over the loading process. In the normal assembly loading sequence, the application base is probed before the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event is raised. However, some applications might need to load assemblies from an OLE compound file within a document, or from a unique known location that is neither in the global assembly cache nor in the directories specified by the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> properties. Such applications can use the <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> property to avoid the delay caused by normal probing, and to avoid loading copies of the necessary assembly that might be located in the normal probing paths.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインでアセンブリ バインディング リダイレクトを使用できるかどうかを示す値を取得または設定します。</summary>
        <value>アセンブリのリダイレクトを使用できない場合は <see langword="true" />、使用できる場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> property is designed to be used by services and server applications where assembly binding redirection is not part of the application scenario.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインでアセンブリの HTTP ダウンロードを使用できるかどうかを示す値を取得または設定します。</summary>
        <value>アセンブリの HTTP ダウンロードを使用できない場合は <see langword="true" />。使用できる場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.AppDomainSetup.DisallowCodeDownload%2A> property is designed to be used by services and server applications where downloading code from an intranet or the Internet is not part of the application scenario.  
  
> [!CAUTION]
>  The default value for the <xref:System.AppDomainSetup.DisallowCodeDownload%2A> property is **languageKeyword tag is not supported!!!!**  
> . This setting is unsafe for services. To help prevent services from downloading partially trusted code, set this property to **languageKeyword tag is not supported!!!!**  
> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>構成ファイルの [&lt;publisherPolicy&gt;](http://msdn.microsoft.com/ja-jp/4613407e-d0a8-4ef2-9f81-a6acb9fdc7d4) セクションをアプリケーション ドメインに適用するかどうかを示す値を取得または設定します。</summary>
        <value>アプリケーション ドメインの構成ファイルの <see langword="&lt;publisherPolicy&gt;" /> セクションを無視する場合は <see langword="true" />。宣言された発行元ポリシーを有効とする場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> property specifically applies to a Web application that is loaded locally. Use this property to help prevent a malicious attempt to execute an unsafe Web application in safe mode.  
  
 For more information about bypassing publisher policy, see the [Redirecting Assembly Versions](http://msdn.microsoft.com/ja-jp/88fb1a17-6ac9-4b57-8028-193aec1f727c) topic. For more information about safe mode, see the "Examining the Configuration Files" section of the [How the Runtime Locates Assemblies](http://msdn.microsoft.com/ja-jp/772ac6f4-64d2-4cfb-92fd-58096dcd6c34) topic.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的に生成されたファイルが格納されるディレクトリのベース ディレクトリを取得または設定します。</summary>
        <value>
          <see cref="P:System.AppDomain.DynamicDirectory" /> が置かれているディレクトリ。  
  
 <block subset="none" type="note">  
<para>  
 このプロパティの戻り値は、割り当てられた値とは異なります。 「解説」を参照してください。  
  
</para>  
</block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this property to set the base directory where the dynamic directory for the new application domain will be located. When code in the new application domain loads an assembly, assembly resolution looks first in the normal probing paths. If it does not find the assembly, it looks in the dynamic directory, which is returned by the <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=fullName> property. Dynamic assemblies that will be loaded and executed by the new application domain can be placed there.  
  
 When you assign a path to the <xref:System.AppDomainSetup.DynamicBase%2A> property, an additional subdirectory is added; the name of this subdirectory is the hash code of the value assigned to the <xref:System.AppDomainSetup.ApplicationName%2A> property. Thus, the base directory subsequently returned by this property is always different from the value assigned.  
  
> [!IMPORTANT]
>  Assigning a value to this property does not create any directories. The directories must be created or verified by the code that uses them.  
  
 The dynamic directory is a subdirectory of <xref:System.AppDomainSetup.DynamicBase%2A>. Its simple name is the value returned by the <xref:System.AppDomainSetup.ApplicationName%2A> property, so its format is **placeholder tag is not supported!!!!**  
\\**placeholder tag is not supported!!!!**  
\\**placeholder tag is not supported!!!!**  
.  
  
   
  
## 例  
 The following example demonstrates how to use the <xref:System.AppDomainSetup.DynamicBase%2A> property to set the path an application domain probes when loading dynamic assemblies.  
  
 The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to "Example" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to "C:\\DynamicAssemblyDir". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  
  
> [!NOTE]
>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  
  
 The example creates a new application domain using the <xref:System.AppDomainSetup> object. The example then creates the dynamic directory if it does not already exist. Although the example uses the application domain's <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=fullName> property to get the name of the dynamic directory, it could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.  
  
 The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method \(**languageKeyword tag is not supported!!!!**  
 method in Visual Basic\) named `HelloFromAD`. Calling this method displays the name of the application domain.  
  
 The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  
  
 You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  
  
 [!code-cpp[ADDynamicBase\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">アプリケーション ドメインのアプリケーション名が <see langword="null" /> であるため、このプロパティを設定できません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path information. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> メソッドによって設定されたXML 構成情報を返します。これにより、アプリケーションの XML 構成情報はオーバーライドされます。</summary>
        <returns>
          <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> メソッドによって設定された XML 構成情報を格納する配列。<see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> メソッドが呼び出されなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> メソッドは、新しいアプリケーション ドメインを作成するアプリケーションの構成情報をオーバーライドする方法を提供します。 構成ファイルの情報で `value` アプリケーションの構成ファイルの情報をオーバーライドします。 たとえば、Example.exe アプリケーションでは、新しいアプリケーション ドメインを作成するときは、Example.exe.config ファイルから最初に取得された構成情報をオーバーライドできます。  
  
> [!IMPORTANT]
>  構成ファイルの情報のいくつかのコンシューマーが保管している情報を使用しないでください、 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> メソッドです。 ランタイムは、これにも強制しません。 すべての構成ファイルの情報が、新しいアプリケーション ドメインでオーバーライドされることを確認するには使用、 <xref:System.AppDomainSetup.ConfigurationFile%2A> プロパティを構成ファイルを指定します。<xref:System.AppDomainSetup.SetConfigurationBytes%2A> メソッドはアセンブリのバインディングに影響します。  
  
 内の XML `value` として格納される点を除いては、標準的な構成ファイル内の XML と同じ、 <xref:System.Byte> 配列。  
  
 アプリケーション ドメインの構成のバイト数にアクセスするには、使用、 <xref:System.AppDomain.SetupInformation%2A?displayProperty=fullName> を取得するプロパティ、 <xref:System.AppDomainSetup> アプリケーション ドメインのオブジェクトを使用して、 <xref:System.AppDomainSetup.GetConfigurationBytes%2A> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このドメインに関連付けられたライセンス ファイルの場所を取得または設定します。</summary>
        <value>ライセンス ファイルの場所と名前。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path information. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実行可能ファイルを読み込むために使用する最適化ポリシーを指定します。</summary>
        <value>
          <see cref="T:System.LoaderOptimizationAttribute" /> で使用される列挙型定数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例は、動的アセンブリを作成し、ディスク、および、使用に保存、<xref:System.AppDomainSetup.LoaderOptimization%2A>プロパティをアプリケーション ドメインにアセンブリを読み込むために使用する最適化ポリシーを設定します。  
  
 [!code-cpp[ADDyno\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サンドボックス化されたアプリケーション ドメインで実行されている部分信頼コードから参照できる、<see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> フラグでマークされたアセンブリのリストを取得または設定します。</summary>
        <value>部分アセンブリ名の配列。各部分名は単純なアセンブリ名と公開キーで構成されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、 <xref:System.Security.AllowPartiallyTrustedCallersAttribute> \(APTCA\) 属性が適用できる条件を設定してその<xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A>プロパティを<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>です。 マークされている APTCA アセンブリ<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>ホスト アプリケーションで許可されている場合を除き、部分的に信頼されたコードで使用することはできません。  
  
 サンド ボックス アプリケーション ドメインのホストは、単純な名前と、各アセンブリの公開キーを含む配列を作成し、このプロパティに、配列を割り当てることによって、条件付きの APTCA 属性を持つアセンブリを使用するアプリケーション ドメインでコードを許可します。 For example, an element of the array might look like the following: "MyAssembly, PublicKey\=0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9".  
  
> [!IMPORTANT]
>  サブクラスを使用している場合<xref:System.AppDomainManager>、およびそれを定義するアセンブリが、条件付きの APTCA 属性でマークされたアセンブリに依存して、渡されたリストでそれらのアセンブリを含める必要があります、<xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A>のプロパティ、<xref:System.AppDomainSetup>を使用するアプリケーション ドメインを作成します。 それ以外の場合、条件付きの APTCA 属性でマークされたアセンブリが無効になります。  
  
> [!NOTE]
>  サンド ボックス アプリケーション ドメインで実行されているアプリケーションをデバッグしているときにいくつか<xref:System.Security.SecurityException>メッセージは誤解を招くことがあります。 たとえば、メッセージを完全に信頼されたアセンブリのいずれかが限られるアクセス許可、本当の問題の原因がサンド ボックス アプリケーション ドメインの許可セットの値を超えているセキュリティの要求がサンド ボックス アプリケーション ドメインの境界に伝達する場合に状態があり、失敗しました。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プライベート アセンブリが調査されるアプリケーション ベース ディレクトリ下に存在するディレクトリのリストを取得または設定します。</summary>
        <value>セミコロンで区切られたディレクトリ名のリスト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プライベート アセンブリは、アプリケーションと同じディレクトリ構造で展開されます。 ディレクトリが指定されている場合<xref:System.AppDomainSetup.PrivateBinPath%2A>されない<xref:System.AppDomainSetup.ApplicationBase%2A>、それらは無視されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.AppDomainSetup.ApplicationBase" /> をアプリケーションの検索パスに含めたり、検索パスから除外して <see cref="P:System.AppDomainSetup.PrivateBinPath" /> だけを検索するようにしたりするための文字列値を取得または設定します。</summary>
        <value>アセンブリを検索するときにアプリケーションのベース パスを含める場合は、null 参照 \(Visual Basic では <see langword="Nothing" />\)。パスを除外する場合は、null 以外の文字列値。 既定値は <see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 任意の null 以外の文字列値にこのプロパティを設定を含む<xref:System.String.Empty?displayProperty=fullName>\(""\)、アプリケーションのディレクトリ パスを除外する: つまり、 <xref:System.AppDomainSetup.ApplicationBase%2A> — アプリケーション、およびアセンブリを検索する検索パスからでのみ<xref:System.AppDomainSetup.PrivateBinPath%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出しのたびに <c>QueryInterface</c> が実行できるように、アプリケーション ドメインの相互運用呼び出しに対するインターフェイス キャッシュが無効かどうかを示す値を取得または設定します。</summary>
        <value>現在の <see cref="T:System.AppDomainSetup" /> オブジェクトを使用して作成された、アプリケーション ドメインの相互運用呼び出しに対するインターフェイス キャッシュが無効の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 相互運用呼び出しのパフォーマンスに大きな影響を及ぼしますインターフェイスのキャッシュを無効にします。  
  
 このメンバーがで導入された、 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">互換性スイッチを指定する文字列値の列挙可能なセット。既存の互換性スイッチを消去する場合は <see langword="null" />。</param>
        <summary>指定されたスイッチを設定し、指定された問題のためにアプリケーション ドメインと以前のバージョンの .NET Framework の互換性を確保します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Major versions of the .NET Framework sometimes introduce breaking changes from the previous version. For example, the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] introduces a small number of breaking changes from the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]. Use the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> method to specify that one or more of these breaking changes should be rolled back for the application domain, to make the behavior compatible with the previous version of the .NET Framework.  
  
 Each time you call this method, it replaces the existing switch settings. To erase the settings, specify **languageKeyword tag is not supported!!!!**  
 for the **parameterReference tag is not supported!!!!**  
 parameter.  
  
 The set of string values you provide for **parameterReference tag is not supported!!!!**  
 can be a simple string array, because arrays implement the <xref:System.Collections.IEnumerable> interface.  
  
 The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  
  
|Switch|Meaning|  
|------------|-------------|  
|"NetFx40\_LegacySecurityPolicy"|Code access security \(CAS\) for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain. See [\<NetFx40\_LegacySecurityPolicy\> Element](http://msdn.microsoft.com/ja-jp/07132b9c-4a72-4710-99d7-e702405e02d4).|  
|"NetFx40\_Legacy20SortingBehavior"|String sorting defaults for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] are enabled in this application domain. Successfully restoring legacy sorting behavior also requires the sort00001000.dll dynamic link library to be available on the local system. See [\<CompatSortNLSVersion\> Element](http://msdn.microsoft.com/ja-jp/782cc82e-83f7-404a-80b7-6d3061a8b6e3).|  
|"NetFx40\_Legacy40SortingBehavior"|String sorting defaults for the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and Unicode 5.0 are enabled in this application domain. Successfully restoring legacy sorting behavior also requires the sort00060101.dll dynamic link library to be available on the local system.|  
|"NetFx40\_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain. See [\<TimeSpan\_LegacyFormatMode\> Element](http://msdn.microsoft.com/ja-jp/865e7207-d050-4442-b574-57ea29d5e2d6) and the "Restoring Legacy TimeSpan Formatting" section of the <xref:System.TimeSpan> topic.|  
|"UseRandomizedStringHashAlgorithm"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\<UseRandomizedStringHashAlgorithm\> Element](http://msdn.microsoft.com/ja-jp/c08125d6-56cc-4b23-b482-813ff85dc630).|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">アプリケーション ドメイン用に使用される XML 構成情報が格納された配列。</param>
        <summary>アプリケーションの XML 構成情報を置換し、アプリケーション ドメインの XML 構成情報を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> メソッドは、新しいアプリケーション ドメインを作成するアプリケーションの構成情報を交換する方法を提供します。 構成ファイルの情報で `value`、アプリケーションの構成ファイルの情報が置き換えられます。 たとえば、Example.exe アプリケーションでは、新しいアプリケーション ドメインを作成するときは、Example.exe.config ファイルから最初に取得された構成情報を置き換えることができます。  
  
> [!IMPORTANT]
>  構成ファイルの情報のいくつかのコンシューマーが保管している情報を使用しないでください、 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> メソッドです。 ランタイムは、これにも強制しません。 新しいアプリケーション ドメインですべての構成ファイルの情報を交換するためを使用して、 <xref:System.AppDomainSetup.ConfigurationFile%2A> プロパティを構成ファイルを指定します。<xref:System.AppDomainSetup.SetConfigurationBytes%2A> メソッドはアセンブリのバインディングに影響します。  
  
 内の XML `value` として格納される点を除いては、標準的な構成ファイル内の XML と同じ、 <xref:System.Byte> 配列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">オーバーライドする文字列比較関数の名前。</param>
        <param name="functionVersion">関数のバージョン。.NET Framework 4.5 では、その値は 1 以上である必要があります。</param>
        <param name="functionPointer">
          <c>functionName</c> をオーバーライドする関数へのポインター。</param>
        <summary>文字列比較関数の代替実装を持つ共通言語ランタイムを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の文字列の比較および並べ替え方法によって上書きできる、 <xref:System.AppDomainSetup.SetNativeFunction%2A> メソッド。  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 これらの関数については、次を参照してください。 [National Language Support Functions](http://go.microsoft.com/fwlink/?LinkId=228134)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionVersion" /> は 1 以上ではありません。  
  
 または  
  
 <paramref name="functionPointer" /> は <see cref="F:System.IntPtr.Zero" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>シャドウ コピー対象のアセンブリが格納されているディレクトリの名前を取得または設定します。</summary>
        <value>セミコロンで区切られたディレクトリ名のリスト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定ではシャドウ コピーが調査; で見つかったすべてのアセンブリがシャドウ コピーを有効にすると、つまり、ディレクトリ内で指定された、<xref:System.AppDomainSetup.PrivateBinPath%2A>と<xref:System.AppDomainSetup.ApplicationBase%2A>プロパティです。<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>プロパティで指定したディレクトリ内のアセンブリにシャドウ コピーを制限します。<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>です。  
  
 文字列を <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> プロパティに割り当てない場合、またはこのプロパティを `null` に設定した場合は、<xref:System.AppDomainSetup.ApplicationBase%2A> と <xref:System.AppDomainSetup.PrivateBinPath%2A> プロパティで指定したディレクトリ内のすべてのアセンブリがシャドウ コピーされます。  
  
> [!IMPORTANT]
>  セミコロンは区切り文字なので、ディレクトリ パスにはセミコロンを含めないでください。 セミコロンのためのエスケープ文字はありません。  
  
 シャドウ コピーが有効な場合は、アセンブリが読み込まれる前に別の場所にアセンブリ ファイルがコピーされます。 元のアセンブリ ファイルはロックされず、更新できるようにします。 シャドウ コピーの詳細については、次を参照してください。[Shadow Copying Assemblies](http://msdn.microsoft.com/ja-jp/de8b8759-fca7-4260-896b-5a4973157672)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path information. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>シャドウ コピーが有効であるか無効であるかを示す文字列を取得または設定します。</summary>
        <value>シャドウ コピーが有効な場合は文字列値 "true"。シャドウ コピーが無効な場合は "false"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シャドウ コピーの詳細については、次を参照してください。[Shadow Copying Assemblies](http://msdn.microsoft.com/ja-jp/de8b8759-fca7-4260-896b-5a4973157672)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> コンストラクターによって解析できる形式で、アプリケーション ドメインの .NET Framework のターゲット バージョンおよびプロファイルを指定する文字列を取得または設定します。</summary>
        <value>対象となる .NET Framework のバージョンとプロファイル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティへの読み込みと実行対象のバージョンまたはプロファイルにコンパイルされたアセンブリ、アプリケーション ドメインが使用されることを現在実行中の .NET Framework のバージョンに通知を設定します。 現在実行されている、.NET Framework のバージョンに対象のバージョンでコンパイルされたコードとの互換性に影響する省略可能な動作がある場合は、有効または互換性を向上させるために、必要に応じて、これらの動作を無効にすることできます。 これは、アプリケーションは、個別のアプリケーション ドメインで実行することにより、.NET Framework の複数のバージョンでコンパイルされたアドインをサポートしている場合に役立ちます。  
  
 クライアント アプリケーションの場合の値、<xref:System.AppDomainSetup.TargetFrameworkName%2A>から推論されるプロパティ、<xref:System.Runtime.Versioning.TargetFrameworkAttribute>属性。[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]後で、この属性が追加のプロジェクトの設定に基づいて自動的に、アセンブリと**ターゲット フレームワーク**プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.AppDomainSetup" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>