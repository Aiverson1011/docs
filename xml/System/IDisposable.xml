<Type Name="IDisposable" FullName="System.IDisposable">
  <TypeSignature Language="C#" Value="public interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>アンマネージ リソースを解放するためのメカニズムを提供します。  
  
 この型の .NET Framework ソース コードを参照するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d)です。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを表示するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース \(パッチや更新を含む\) をステップsee [instructions](http://referencesource.microsoft.com/).  
  
 このインターフェイスの主な用途は、アンマネージ リソースを解放します。 ガベージ コレクターは、自動的にそのオブジェクトを使用できなくする場合は、マネージ オブジェクトに割り当てられたメモリを解放します。 ただし、ガベージ コレクションが行われるタイミングを予想することはできません。 さらに、ガベージ コレクターは、ウィンドウ ハンドルなどのアンマネージ リソースの知識がないか、ファイルおよびストリームを開きます。  
  
 使用して、<xref:System.IDisposable.Dispose%2A>明示的に、ガベージ コレクターで組み合わせてのアンマネージ リソースを解放するには、このインターフェイスのメソッドです。 オブジェクトのコンシューマーは、オブジェクトが不要になったとき、このメソッドを呼び出すことができます。  
  
> [!WARNING]
>  重大な変更を追加するのには、<xref:System.IDisposable>既存のクラスへのインターフェイスです。 型の既存のコンシューマーが呼び出すことはできませんので<xref:System.IDisposable.Dispose%2A>、特定の種類によって保持されているアンマネージ リソースを解放することをすることはできません。  
  
 <xref:System.IDisposable.Dispose%2A?displayProperty=fullName>インスタンスによって所有されているリソースは不要になったときに、型のコンシューマーによって実装が呼び出されるで管理されているオブジェクトをラップする必要がありますか、 <xref:System.Runtime.InteropServices.SafeHandle> \(、推奨される代替手段\)、またはオーバーライドする必要があります<xref:System.Object.Finalize%2A?displayProperty=fullName>イベントで呼び出しを忘れた場合は、コンシューマーは、アンマネージ リソースを解放する<xref:System.IDisposable.Dispose%2A>です。  
  
> [!IMPORTANT]
>  .NET Framework で、C\+\+ コンパイラ リソースの確定的な破棄をサポートしているし、の直接の実装はできません、<xref:System.IDisposable.Dispose%2A>メソッドです。  
  
 方法の詳細についてはこのインターフェイスと<xref:System.Object.Finalize%2A?displayProperty=fullName>メソッドを使用するを参照してください、[Garbage Collection](http://msdn.microsoft.com/ja-jp/22b6cb97-0c80-4eeb-a2cf-5ed7655e37f9)と[Implementing a Dispose Method](http://msdn.microsoft.com/ja-jp/eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9)トピックです。  
  
## IDisposable を実装するオブジェクトを使用します。  
 実装<xref:System.IDisposable>アンマネージ リソースを直接使用している場合にのみです。 アプリは単に実装するオブジェクトを使用する場合<xref:System.IDisposable>が提供されない、<xref:System.IDisposable>実装します。 代わりに、オブジェクトを呼び出す必要があります<xref:System.IDisposable.Dispose%2A?displayProperty=fullName>その使用が終了した場合に実装します。 プログラミング言語によっては、これには 2 つの方法のいずれかの操作を行います。  
  
-   言語を使用して構築など、 `using` c\# および Visual Basic でのステートメント。  
  
-   呼び出しをラップすることによって、<xref:System.IDisposable.Dispose%2A?displayProperty=fullName>での実装、 `try`\/`catch`ブロックします。  
  
> [!NOTE]
>  ドキュメント型を実装する<xref:System.IDisposable>そのことに注意してくださいし、アラームを呼び出してその<xref:System.IDisposable.Dispose%2A>実装します。  
  
<a name="Using"></a>   
### C\# および Visual Basic を使用してステートメント  
 など、言語にコンストラクトがサポートしている場合、[を使用して](http://msdn.microsoft.com/ja-jp/124e1a63-2a4b-4132-b269-3b6d8d3ef72d)\(C\#\) ステートメントと[Using](http://msdn.microsoft.com/ja-jp/665d1580-dd54-4e96-a9a9-6be2a68948f1) Visual Basic でのステートメントを使用する明示的に呼び出す代わりに<xref:System.IDisposable.Dispose%2A?displayProperty=fullName>自分でします。 次の例で定義するには、このアプローチは`WordCount`ファイルとその中の単語の数に関する情報を保持するクラス。  
  
 [!code-csharp[System.IDisposable\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]
 [!code-vb[System.IDisposable\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]  
  
 `using`ステートメントは構文上の便利な実際にします。 コンパイル時に、言語コンパイラを実装する中間言語 \(IL\) の`try`\/`catch`ブロックします。  
  
 詳細については、`using`ステートメントを参照してください、[Using Statement \(Visual Basic\)](http://msdn.microsoft.com/ja-jp/665d1580-dd54-4e96-a9a9-6be2a68948f1)または[using Statement \(C\# Reference\)](http://msdn.microsoft.com/ja-jp/afc355e6-f0b9-4240-94dd-0d93f17d9fc3)トピックです。  
  
### Try\/catch ブロック  
 使用するプログラミング言語がのようなコンストラクトをサポートしないかどうか、 `using` c\# または Visual Basic では、ステートメントで呼び出すか、またはそれを使用しないようにする場合、<xref:System.IDisposable.Dispose%2A?displayProperty=fullName>実装から、`finally`のブロック、 `try`\/`catch`ステートメントです。 次の例が置き換えられます、`using`ブロックの前の例で、 `try`\/`catch`\/`finally`ブロックします。  
  
 [!code-csharp[System.IDisposable\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]
 [!code-vb[System.IDisposable\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]  
  
 詳細については、 `try`\/`finally`パターンは、「 [Try...Catch...Finally Statement \(Visual Basic\)](http://msdn.microsoft.com/ja-jp/d6488026-ccb3-42b8-a810-0d97b9d6472b)、 [try\-finally \(C\# Reference\)](http://msdn.microsoft.com/ja-jp/c27623fb-7261-4464-862c-7a369d3c8f0a)、または[try\-finally Statement \(C\)](http://msdn.microsoft.com/ja-jp/514400c1-c322-4bf3-9e48-3047240b8a82)です。  
  
## IDisposable の実装  
 実装する必要があります<xref:System.IDisposable>の種類のアンマネージ リソースを直接使用する場合にのみです。 型のコンシューマーが呼び出すことができます、<xref:System.IDisposable.Dispose%2A?displayProperty=fullName>実装のインスタンスが不要になったときにリソースを解放します。 呼び出しに失敗した場合を処理するために<xref:System.IDisposable.Dispose%2A>、いずれかから派生したクラスを使用する必要があります<xref:System.Runtime.InteropServices.SafeHandle>するか、アンマネージ リソースをラップする必要がありますオーバーライド、<xref:System.Object.Finalize%2A?displayProperty=fullName>参照型のメソッドです。 どちらの場合に使用する、<xref:System.IDisposable.Dispose%2A>クリーンアップ処理をすべてが、必要な解放、リリース、またはアンマネージ リソースをリセットするなど、アンマネージ リソースを使用して実行するメソッド。  
  
> [!IMPORTANT]
>  基本クラスを定義する場合はアンマネージ リソースを使用する、またはのいずれかが傾向があります、サブクラスは破棄されなければなりません、実装する必要があります、<xref:System.IDisposable.Dispose%2A?displayProperty=fullName>メソッドの 2 番目のオーバー ロードを提供および`Dispose`、次のセクションで説明したようにします。  
  
<a name="BaseClasses"></a>   
## IDisposable および継承階層  
 破棄可能にする必要のあるサブクラスを持つ基本クラスを実装する必要があります<xref:System.IDisposable>次のようにします。 実装するときに、このパターンを使用する必要があります<xref:System.IDisposable>任意の型にはない`sealed`\(`NotInheritable` Visual Basic で\)。  
  
-   これは、1 つの <xref:System.IDisposable.Dispose> パブリック非仮想メソッドと 1 つの `Dispose(Boolean` `disposing``)` プロテクト仮想メソッドを提供します。  
  
-   <xref:System.IDisposable.Dispose>メソッドを呼び出す必要があります`Dispose(true)`とパフォーマンスの最終処理を抑制する必要があります。  
  
-   基本型はファイナライザーを含めることはできません。  
  
 次のコード フラグメントでは、基本クラスで dispose パターンを反映しています。 種類をオーバーライドしないことを想定しています、<xref:System.Object.Finalize%2A?displayProperty=fullName>メソッドです。  
  
 [!code-csharp[System.IDisposable\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
 [!code-vb[System.IDisposable\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
 オーバーライドする場合、<xref:System.Object.Finalize%2A?displayProperty=fullName>メソッド、クラスは、次のパターンを実装する必要があります。  
  
 [!code-csharp[System.IDisposable\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
 [!code-vb[System.IDisposable\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
 サブクラスは破棄可能なパターンを次のように実装する必要があります。  
  
-   これらは `Dispose(Boolean)` をオーバーライドし、基底クラスの `Dispose(Boolean)` の実装を呼び出す必要があります。  
  
-   必要な場合にはファイナライザーを提供します。 ファイナライザーは `Dispose(false)` を呼び出す必要があります。  
  
 派生クラスは実装しないこと自体に注意してください、<xref:System.IDisposable>インターフェイスし、パラメーターなしを含めないでください<xref:System.IDisposable.Dispose%2A>メソッドです。 のみ、基本クラスをオーバーライドする`Dispose(Boolean)`メソッドです。  
  
 次のコード フラグメントでは、派生クラスで dispose パターンを反映しています。 種類をオーバーライドしないことを想定しています、<xref:System.Object.Finalize%2A?displayProperty=fullName>メソッドです。  
  
 [!code-csharp[System.IDisposable\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
 [!code-vb[System.IDisposable\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
   
  
## 例  
 次の例は、リソースを実装するクラスを作成する方法を示します、<xref:System.IDisposable>インターフェイスです。  
  
 [!code-cpp[System.IDisposable.Dispose Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IDisposable.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アンマネージ リソースの解放またはリセットに関連付けられているアプリケーション定義のタスクを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this method to close or release unmanaged resources such as files, streams, and handles held by an instance of the class that implements this interface. By convention, this method is used for all tasks associated with freeing resources held by an object, or preparing an object for reuse.  
  
> [!WARNING]
>  If you are using a class that implements the <xref:System.IDisposable> interface, you should call its <xref:System.IDisposable.Dispose%2A> implementation when you are finished using the class. For more information, see the "Using an object that implements IDisposable" section in the <xref:System.IDisposable> topic.  
  
 When implementing this method, ensure that all held resources are freed by propagating the call through the containment hierarchy. For example, if an object A allocates an object B, and object B allocates an object C, then A's <xref:System.IDisposable.Dispose%2A> implementation must call <xref:System.IDisposable.Dispose%2A> on B, which must in turn call <xref:System.IDisposable.Dispose%2A> on C.  
  
> [!IMPORTANT]
>  The C\+\+ compiler supports deterministic disposal of resources and does not allow direct implementation of the <xref:System.IDisposable.Dispose%2A> method.  
  
 An object must also call the <xref:System.IDisposable.Dispose%2A> method of its base class if the base class implements <xref:System.IDisposable>. For more information about implementing <xref:System.IDisposable> on a base class and its subclasses, see the "IDisposable and the inheritance hierarchy" section in the <xref:System.IDisposable> topic.  
  
 If an object's <xref:System.IDisposable.Dispose%2A> method is called more than once, the object must ignore all calls after the first one. The object must not throw an exception if its <xref:System.IDisposable.Dispose%2A> method is called multiple times. Instance methods other than <xref:System.IDisposable.Dispose%2A> can throw an <xref:System.ObjectDisposedException> when resources are already disposed.  
  
 Users might expect a resource type to use a particular convention to denote an allocated state versus a freed state. An example of this is stream classes, which are traditionally thought of as open or closed. The implementer of a class that has such a convention might choose to implement a public method with a customized name, such as `Close`, that calls the <xref:System.IDisposable.Dispose%2A> method.  
  
 Because the <xref:System.IDisposable.Dispose%2A> method must be called explicitly, there is always a danger that the unmanaged resources will not be released, because the consumer of an object fails to call its <xref:System.IDisposable.Dispose%2A> method. There are two ways to avoid this:  
  
-   Wrap the managed resource in an object derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>. Your <xref:System.IDisposable.Dispose%2A> implementation then calls the <xref:System.IDisposable.Dispose%2A> method of the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> instances. For more information, see "The SafeHandle alternative" section in the <xref:System.Object.Finalize%2A?displayProperty=fullName> topic.  
  
-   Implement a finalizer to free resources when <xref:System.IDisposable.Dispose%2A> is not called. By default, the garbage collector automatically calls an object's finalizer before reclaiming its memory. However, if the <xref:System.IDisposable.Dispose%2A> method has been called, it is typically unnecessary for the garbage collector to call the disposed object's finalizer. To prevent automatic finalization, <xref:System.IDisposable.Dispose%2A> implementations can call the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.  
  
 When you use an object that accesses unmanaged resources, such as a <xref:System.IO.StreamWriter>, a good practice is to create the instance with a **languageKeyword tag is not supported!!!!**  
 statement. The **languageKeyword tag is not supported!!!!**  
 statement automatically closes the stream and calls <xref:System.IDisposable.Dispose%2A> on the object when the code that is using it has completed. For an example, see the <xref:System.IO.StreamWriter> class.  
  
   
  
## 例  
 The following example shows how you can implement the <xref:System.IDisposable.Dispose%2A> method.  
  
 [!code-cpp[System.IDisposable.Dispose Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>