<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">遅延初期化されているオブジェクトの型。</typeparam>
    <summary>遅延初期化のサポートを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 特に、このような作成または実行が、プログラムの有効期間中に実行されない場合に、大規模またはリソースを消費するオブジェクトの作成またはリソースを消費するタスクの実行を延期するのに限定的な初期化を使用します。  
  
 インスタンスを作成する限定的な初期化の準備として、 <xref:System.Lazy%601>です。 型引数、 <xref:System.Lazy%601> を作成するオブジェクトは、遅延初期化するオブジェクトの種類を指定します。 作成するために使用するコンス トラクター、 <xref:System.Lazy%601> オブジェクトが初期化の特性を決定します。 限定的な初期化が初めて発生した、 <xref:System.Lazy%601.Value%2A?displayProperty=fullName> プロパティにアクセスします。  
  
 ほとんどの場合は、2 つの質問に対する回答に依存コンス トラクターを選択します。  
  
-   遅れて初期化されるオブジェクトは、複数のスレッドからアクセスされるでしょうか。 その場合、 <xref:System.Lazy%601> オブジェクトを使用するとすべてのスレッドに作成できます。 既定の動作は、スレッド セーフを作成する簡単なコンス トラクターのいずれかを使用する <xref:System.Lazy%601> オブジェクトのため、アクセスしようとしているスレッドの数に関係なく、遅延インスタンス化されたオブジェクトの 1 つのインスタンスを作成します。 作成する、 <xref:System.Lazy%601> スレッド セーフではないオブジェクトの場合は、スレッド セーフ no を指定することができますコンス トラクターを使用する必要があります。  
  
    > [!CAUTION]
    >  作成、 <xref:System.Lazy%601> スレッド セーフでオブジェクトが、遅れて初期化されるオブジェクトを保護しません。 複数のスレッドが、遅れて初期化されるオブジェクトにアクセスできる場合が必要プロパティとメソッド マルチ スレッド アクセスについて安全です。  
  
-   限定的な初期化が不要多くのコードに遅れて初期化されるオブジェクトがすべて必要があるし、例外をスローせず、既定のコンス トラクターか。 初期化コードを記述する必要がある場合、または例外を処理する必要がある場合は、ファクトリ メソッドを受け取るコンス トラクターのいずれかを使用します。 ファクトリ メソッドには、初期化コードを記述します。  
  
 これら 2 つの要因に基づいて選択するにはどのコンス トラクターを次の表に示します。  
  
|アクセスされるオブジェクト|初期化コードが必要ない場合 \(既定のコンス トラクター\) を使用して|初期化コードが必要な場合は、使用します。|  
|-------------------|------------------------------------------|--------------------------|  
|複数のスレッド|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|1 つのスレッド|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> `isThreadSafe` 設定 `false`します。|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> `isThreadSafe` 設定 `false`します。|  
  
 ラムダ式を使用すると、ファクトリ メソッドを指定します。 これにより、すべての初期化コードが 1 か所に保持されます。 ラムダ式では、遅れて初期化されるオブジェクトのコンス トラクターに渡す引数も含めて、コンテキストをキャプチャします。  
  
 **例外キャッシュ** ファクトリ メソッドを使用する場合、例外がキャッシュされます。 つまり、ファクトリ メソッドが例外の最初の時間をスローした場合、スレッドにアクセスしよう、 <xref:System.Lazy%601.Value%2A> のプロパティ、 <xref:System.Lazy%601> オブジェクト、後続するたびに、同じ例外がスローされます。 これにより、すべての呼び出しに、 <xref:System.Lazy%601.Value%2A> プロパティは、同じ結果を生成して、別のスレッドが異なる結果を得る場合に生じる可能性のある微妙なエラーを回避できます。<xref:System.Lazy%601> 、実際の代わりに `T` をそれ以外の場合は初期化されているある以前の時点での起動中に通常です。 その以前の時点でのエラーでは、通常致命的です。 回復可能な障害発生する可能性がある場合は、限定的な初期化を使用していなかった場合と同様、\(ここでは、ファクトリ メソッド\)、初期化ルーチンに再試行ロジックを構築することをお勧めします。  
  
 **をロックする代わりに** 特定の状況でのオーバーヘッドを回避することがあります、 <xref:System.Lazy%601> オブジェクトの既定のロック動作します。 まれな状況でデッドロックの可能性があります。 このような場合に使用することができます、 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> または <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンス トラクターを指定して <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=fullName>します。 これにより、 <xref:System.Lazy%601> 、スレッドを呼び出す場合、複数のスレッドの各遅れて初期化されるオブジェクトのコピーを作成するオブジェクト、 <xref:System.Lazy%601.Value%2A> プロパティ同時にします。<xref:System.Lazy%601> オブジェクトにより、すべてのスレッドが、遅れて初期化されるオブジェクトの同じインスタンスを使用し、使用されていないインスタンスを破棄します。 したがって、ロックのオーバーヘッドを軽減するのにかかるコストは、プログラムの作成し、負荷の高いオブジェクトの余分なコピーを破棄することがある場合もありますです。 ほとんどの場合、これはほとんどありません。 例として、 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> と <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンス トラクターは、この動作をについて説明します。  
  
> [!IMPORTANT]
>  指定すると <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, 、ファクトリ メソッドを指定した場合でも、例外はキャッシュしないでされます。  
  
 **相当するコンス トラクター** の使用を有効にするだけでなく <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, 、 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> と <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンス トラクターは、他のコンス トラクターの機能を複製することができます。 次の表は、同等の動作を生成するパラメーター値を示します。  
  
|作成する、 <xref:System.Lazy%601> オブジェクトを|コンス トラクターを持つ、 `LazyThreadSafetyMode` `mode` パラメーターを設定する `mode` に|ブール値を持つコンス トラクターの `isThreadSafe` パラメーターを設定する `isThreadSafe` に|スレッド セーフのパラメーターなしのコンス トラクター|  
|------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|-------------------------------------------------------------------|---------------------------------|  
|スレッド セーフでは完全に使用して、その 1 つのスレッドをロックでは、値を初期化します。|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|このようなすべてのコンス トラクターは、スレッド セーフでは完全にします。|  
|いないスレッド セーフであります。|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|該当しない。|  
|スレッド セーフでは完全に値を初期化するためにスレッド競合します。|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|該当しない。|該当なし。|  
  
 **その他の機能** の使用については <xref:System.Lazy%601> スレッド内静的フィールドを持つ、またはプロパティのバッキング ストアとして [Lazy Initialization](http://msdn.microsoft.com/ja-jp/56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b)します。  
  
   
  
## 例  
 次の例では、使用、 <xref:System.Lazy%601> クラスを複数のスレッドからのアクセスを限定的な初期化を提供します。  
  
> [!NOTE]
>  例では、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> コンス トラクターです。 使用についても示します、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> コンス トラクター \(を指定する `true` の `isThreadSafe`\) および <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンス トラクター \(を指定する <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=fullName> の `mode`\)。 別のコンス トラクターに切り替えると、同じどのコンス トラクターをコメント アウトを変更します。  
>   
>  例外を示す例については、同じコンス トラクターを使用して、キャッシュを参照してください、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> コンス トラクターです。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 コードの 4 つの主要セクションが、初期化子、ファクトリ メソッド、実際の初期化およびのコンス トラクターの作成を示す、 `LargeObject` クラスは、オブジェクトの作成時にメッセージが表示されます。`Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1\#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1\#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 ファクトリ メソッドより詳細な初期化のプレース ホルダーで、オブジェクトの作成を示しています。  
  
 [!code-csharp[System.Lazy\`1\#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1\#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 次に示すように、最初の 2 つのコードのセクションでは、でしたラムダ関数を使用してによって組み合わせて指定することに注意してください。  
  
 [!code-csharp[System.Lazy\`1\#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1\#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 例では、限定的な初期化が行われる前に、不確定な期間が切れることがありますを示すために一時停止します。 押すと、 **Enter** キー、例を作成して 3 つのスレッドを開始します。`ThreadProc` 3 つのスレッドのすべての呼び出しで使用されるメソッド、 <xref:System.Lazy%601.Value%2A> プロパティです。 このシナリオは、最初に、 `LargeObject` インスタンスを作成します。  
  
 [!code-csharp[System.Lazy\`1\#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1\#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 コンス トラクター、 `LargeObject` クラスは、コードの最後の主要セクションが含まれているメッセージが表示され、初期化中のスレッドの id を記録します。 完全なコード リストの最後に、プログラムからの出力が表示されます。  
  
 [!code-csharp[System.Lazy\`1\#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1\#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` \(Visual Basic の `Shared`\) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1\#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1\#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>既定では、すべてのパブリック、プロテクト メンバーの <see cref="T:System.Lazy`1" /> クラスはスレッド セーフであると、複数のスレッドから同時に使用される場合があります。 これらのスレッド セーフの保証は、必要に応じて、型のコンス トラクターにパラメーターを使用して、インスタンスごとに削除できます。</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生した場合は、ターゲット型の既定のコンストラクターが使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターで作成されたインスタンスは、複数のスレッドから同時に使用可能性があります。  
  
 スレッドの安全性モード、 <xref:System.Lazy%601> このコンス トラクターで初期化されたインスタンスが <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=fullName>です。 初期化しようとしている複数のスレッドとスレッドの安全性モードが動作を記述、 <xref:System.Lazy%601> インスタンス。  
  
 A <xref:System.Lazy%601> このコンス トラクターで作成されたインスタンスには、例外をキャッシュしません。 詳細については、次を参照してください。、 <xref:System.Lazy%601>クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> 列挙します。  
  
   
  
## 例  
 次の例では、このコンス トラクターの使用を示します。 使用についても説明して、 <xref:System.Lazy%601.%23ctor%28System.Boolean%29> コンス トラクター \(を指定する `true` の `isThreadSafe`\) および <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> コンス トラクター \(を指定する <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=fullName> の `mode`\)。 別のコンス トラクターに切り替えると、同じどのコンス トラクターをコメント アウトを変更します。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 この例のコードの 2 つのキーの行は、初期化子と実際の初期化の作成です。`Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctor\#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor\#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 例では、作成し、ブロックの 3 つのスレッドを開始、 <xref:System.Threading.ManualResetEvent> オブジェクトの例では、スレッドをすべて一度に解放できるようにします。`ThreadProc` 3 つのスレッドのすべての呼び出しで使用されるメソッド、 <xref:System.Lazy%601.Value%2A> を取得するプロパティ、 `LargeObject` インスタンス。  
  
 [!code-csharp[System.Lazy\`1.ctor\#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor\#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 <xref:System.Lazy%601> クラスのロックを作成する 1 つのスレッドが許可されるようには、 `LargeObject` インスタンス。 この例では、他のスレッドはすべてが同じインスタンスを取得することを示します。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` \(Visual Basic の `Shared`\) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctor\#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor\#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">同時に複数のスレッドでこのインスタンスを使用できるようにする場合には <see langword="true" />、このインスタンスを一度に 1 つのスレッドのみで使用できるようにする場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生すると、ターゲット型の既定のコンストラクターおよび指定した初期化モードが使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッドの安全性モード、<xref:System.Lazy%601>このコンス トラクターで初期化されているインスタンスが<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=fullName>場合`isThreadSafe`は`true`、それ以外のモードは<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=fullName>します。 複数のスレッドを初期化しようとするときにスレッド セーフ モードは動作について説明します、<xref:System.Lazy%601>インスタンス。 指定する、<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=fullName>モードを使用して、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>または<xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>コンス トラクターです。  
  
 A<xref:System.Lazy%601>このコンス トラクターで作成されるインスタンスでは、例外はキャッシュされません。 詳細については、次を参照してください。、<xref:System.Lazy%601>クラスまたは<xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName>列挙します。  
  
   
  
## 例  
 次の例では、スレッド セーフである、遅れて初期化されるオブジェクトに対するすべてのアクセスのと同じスレッドで発生しているシナリオではない、遅延初期化子を作成するこのコンス トラクターの使用を示します。 使用についても示します、<xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>コンス トラクター \(を指定する<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=fullName>の`mode`します。 別のコンス トラクターに切り替えると、どのコンス トラクターをコメント アウト オプションだけ変更します。  
  
> [!NOTE]
>  マルチ スレッド シナリオでこのコンス トラクターを使用する方法を示すコードについて \(を指定する`true`の`isThreadSafe`\)、例を参照してください、<xref:System.Lazy%601.%23ctor>コンス トラクターです。  
  
 例では、定義、`LargeObject`遅れて初期化されるクラスです。`Main`メソッドは、例では、作成、<xref:System.Lazy%601>インスタンスし、一時停止します。 キーを押したときに、**入力**キー、例では、アクセス、<xref:System.Lazy%601.Value%2A>のプロパティ、<xref:System.Lazy%601>これにより、初期化が発生するインスタンス。 コンス トラクター、`LargeObject`クラスには、コンソール メッセージが表示されます。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` \(Visual Basic の `Shared`\) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorBool\#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool\#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">必要に応じて、遅延初期化の値を生成するために呼び出されるデリゲート。</param>
        <summary>
          <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生すると、指定された初期化関数が使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターで作成されるインスタンスは、複数のスレッドから同時に使用可能性があります。  
  
 スレッドの安全性モード、<xref:System.Lazy%601>このコンス トラクターで初期化されているインスタンスが<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=fullName>です。 複数のスレッドを初期化しようとするときにスレッド セーフ モードは動作について説明します、<xref:System.Lazy%601>インスタンス。  
  
 によってスローされる例外`valueFactory`キャッシュされます。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> 列挙体の解説を参照してください。  
  
   
  
## 例  
 次の例では、キャッシュが例外の限定的な初期化を提供するこのコンス トラクターの使用を示します。 使用についても示します、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>コンス トラクター \(を指定する`true`の`isThreadSafe`\) および<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>コンス トラクター \(を指定する<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=fullName>の`mode`\)。 別のコンス トラクターに切り替えると、変更どのコンス トラクターをコメント アウトします。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 コードの 3 つの主要セクションが、実際の初期化とのコンス トラクターの初期化子の作成を示しています、`LargeObject`クラスは、例外のキャッシュを示しています。`Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc\#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc\#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 この例では、作成し、3 つのスレッドを開始します。`ThreadProc` 3 つのスレッドのすべての呼び出しによって使用されるメソッド、<xref:System.Lazy%601.Value%2A>取得するプロパティ、`LargeObject`インスタンス。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc\#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc\#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 コンス トラクターで、 `LargeObject` 、クラス コードの 3 番目の主要セクションが最初に例外をスローする、`LargeObject`インスタンスは作成されますが、これ以降発生するインスタンスの作成を許可。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc\#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc\#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 例では、実行時のインスタンスを作成しようとしています。 最初のスレッド`LargeObject`は失敗し、例外をキャッチします。 次のスレッドは、インスタンスの作成が正常にする予定であるが、<xref:System.Lazy%601>オブジェクトが例外をキャッシュします。 このためは、次の 3 つのすべてのスレッドは、例外をスローします。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` \(Visual Basic の `Shared`\) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc\#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc\#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">スレッド セーフ モードを指定する列挙値の 1 つ。</param>
        <summary>
          <paramref name="T" /> の既定のコンストラクターと指定されたスレッド セーフ モードを使用する <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッドの安全性モード、<xref:System.Lazy%601>とき、複数のスレッドを初期化するために、インスタンスが動作を説明します、<xref:System.Lazy%601>インスタンス。  
  
 A<xref:System.Lazy%601>このコンス トラクターで作成されるインスタンスでは、例外はキャッシュされません。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> 列挙体の解説を参照してください。  
  
   
  
## 例  
 次の例では、遅延オブジェクトの作成に競合する複数のスレッドをできるようにする遅延初期化子を作成するこのコンス トラクターの使用を示します。 複数のスレッドが、インスタンスの作成に成功する可能性がありますが、すべてのスレッドが最初に作成されたインスタンスを使用します。  
  
> [!NOTE]
>  シングル スレッドのシナリオでこのコンス トラクターを使用する方法を示す例については \(を指定する<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=fullName>の`mode`\) を参照してください、<xref:System.Lazy%601.%23ctor%28System.Boolean%29>コンス トラクターです。 このコンス トラクターを使用して、マルチ スレッド シナリオでの競合状態の代わりにロックを提供する方法を示す例については \(を指定する<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=fullName>の`mode`\) を参照してください、<xref:System.Lazy%601.%23ctor>コンス トラクターです。  
  
 例では、定義、`LargeObject`複数のスレッドのいずれかによって遅れて初期化されるクラスです。 コードの 3 つの主要セクションは、初期化子、実際の初期化とコンス トラクターの作成とのファイナライザーを示しています、`LargeObject`クラスです。 先頭に、`Main`メソッドは、例では、作成、<xref:System.Lazy%601>の限定的な初期化を実行するオブジェクト、 `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM\#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM\#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 この例は、作成し、ブロックを 3 つのスレッドを開始、<xref:System.Threading.ManualResetEvent>オブジェクトの例が、スレッドをすべて同時に解放できるようにします。`ThreadProc`メソッドを呼び出す、3 つすべてのスレッドによって使用される、<xref:System.Lazy%601.Value%2A>プロパティを作成、`LargeObject`インスタンス。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM\#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM\#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 のコンス トラクター、<xref:System.Lazy%601>指定されたインスタンス<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=fullName>、3 つすべてのスレッドを作成することが`LargeObject`インスタンス。 例では、このコンス トラクターおよびのファイナライザーでは、コンソール メッセージを表示することによって、`LargeObject`クラス。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM\#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM\#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 ただし、<xref:System.Lazy%601>オブジェクトにより 1 つのインスタンスは、すべてのスレッドによって使用されます。 出力例を使用を示しています 3 つすべてのスレッド、同じインスタンス、およびも他の 2 つのインスタンスがガベージ コレクションによって再要求できることを示しています。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` \(Visual Basic の `Shared`\) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM\#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM\#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> に無効な値が含まれています。</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">必要に応じて、遅延初期化の値を生成するために呼び出されるデリゲート。</param>
        <param name="isThreadSafe">同時に複数のスレッドでこのインスタンスを使用できるようにする場合には <see langword="true" />、このインスタンスを一度に 1 つのスレッドのみで使用できるようにする場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生すると、指定された初期化関数と初期化モードが使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッドの安全性モード、 <xref:System.Lazy%601> このコンス トラクターで初期化されたインスタンスが <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=fullName> 場合 `isThreadSafe` は `true`。 そうしないと、モードは <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=fullName>です。 初期化しようとしている複数のスレッドとスレッドの安全性モードが動作を記述、 <xref:System.Lazy%601> インスタンス。  
  
 指定する、 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=fullName> モードでは、使用、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> または <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> コンス トラクターです。  
  
 によってスローされる例外 `valueFactory` キャッシュされます。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> 列挙体の解説を参照してください。  
  
   
  
## 例  
 次の例では、キャッシュには、1 つのスレッドがあるシナリオで例外を限定的な初期化を提供するこのコンス トラクターの使用を示します。 使用についても示します、  <xref:System.Lazy%601.%23ctor%2A>コンス トラクター \(を指定する <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=fullName> の `mode`\)。 そのコンス トラクターに切り替えると、同じコンス トラクターをコメント アウトを変更します。  
  
> [!NOTE]
>  マルチ スレッドのシナリオでこのコンス トラクターを使用する方法を示すコードについて \(を指定する `true` の `isThreadSafe`\) の例を参照してください、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> コンス トラクターです。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 コードの 3 つの主要セクションが、実際の初期化とのコンス トラクターの初期化子の作成を示す、 `LargeObject` クラスは、例外のキャッシュを示しています。`Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool\#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool\#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 コンス トラクターの呼び出しで、 `isThreadSafe` パラメーターは `false`, ので、 <xref:System.Lazy%601> はスレッド セーフです。 スレッド セーフではないため、例では、 <xref:System.Lazy%601.Value%2A> 同じスレッドで 3 回のプロパティ。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool\#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool\#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 コンス トラクターで、 `LargeObject` クラス コードの 3 番目の主要セクションが最初に例外をスローする、 `LargeObject` インスタンスは作成しますが、発生するインスタンスの作成は、その後。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool\#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool\#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 この例を実行するのインスタンスを作成する最初の試み `LargeObject` は失敗し、例外がキャッチされました。 次の試行が成功すると思うかもしれませんが、 <xref:System.Lazy%601> オブジェクトが例外をキャッシュします。 このためは、次の 3 つのすべての試行は、例外をスローします。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` \(Visual Basic の `Shared`\) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool\#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool\#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">必要に応じて、遅延初期化の値を生成するために呼び出されるデリゲート。</param>
        <param name="mode">スレッド セーフ モードを指定する列挙値の 1 つ。</param>
        <summary>指定された初期化関数とスレッド セーフ モードを使用する <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッドの安全性モード、<xref:System.Lazy%601>インスタンスを初期化するときに複数のスレッドの動作をについて説明します、<xref:System.Lazy%601>インスタンス。  
  
 によってスローされる例外`valueFactory`はキャッシュされる場合を除き、`mode`は<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>します。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=fullName> 列挙体の解説を参照してください。  
  
   
  
## 例  
 次の例では、遅延オブジェクトの作成に競合する複数のスレッドをできるようにする遅延初期化子を作成するこのコンス トラクターの使用を示します。 複数のスレッドが、インスタンスの作成に成功する可能性がありますが、すべてのスレッドが最初に作成されたインスタンスを使用します。 さらに、この例を指定する場合の例外はキャッシュ決して<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>遅れて作成された型の既定のコンス トラクターによって初期化が実行の代わりに、関数であっても、します。  
  
> [!NOTE]
>  シングル スレッドのシナリオでこのコンス トラクターを使用する方法を示す例については \(を指定する<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=fullName>用`mode`\) を参照してください、<xref:System.Lazy%601.%23ctor%28System.Boolean%29>コンス トラクターです。 このコンス トラクターを使用して、マルチ スレッド シナリオでの競合状態の代わりにロックを提供する方法を示す例については \(を指定する<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=fullName>用`mode`\) を参照してください、<xref:System.Lazy%601.%23ctor>コンス トラクターです。  
  
 例では、定義、`LargeObject`複数のスレッドのいずれかによって遅れて初期化されるクラスです。 コードの 4 つの主要なセクションは、初期化子、実際の初期化、初期化関数と、コンス トラクターの作成とのファイナライザーを示しています、`LargeObject`クラスです。 先頭に、`Main`メソッドは、例では、作成、<xref:System.Lazy%601>の限定的な初期化を実行するオブジェクト、 `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM\#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM\#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 遅延初期化子では、関数を使用して、初期化を実行します。 この場合、関数が必要既定のコンス トラクターがないため、`LargeObject`クラスです。  
  
 この例は、作成しをブロックする 3 つのスレッドを開始、<xref:System.Threading.ManualResetEvent>オブジェクトの例が、スレッドをすべて同時に解放できるようにします。`ThreadProc`メソッドの呼び出し、3 つすべてのスレッドによって使用される、<xref:System.Lazy%601.Value%2A>プロパティを作成、`LargeObject`インスタンス。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM\#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM\#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 コードの 3 番目の主要セクションで、遅延初期化関数を作成する、`LargeObject`インスタンス。 関数が呼び出される最初の例外にスローされます。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM\#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM\#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 その他の<xref:System.Threading.LazyThreadSafetyMode>設定すると、初期化関数の未処理の例外はキャッシュされます。 ただし、<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>例外のキャッシュを抑制します。 例の出力は、オブジェクトを初期化後の試行が成功したことを示します。  
  
> [!NOTE]
>  例外メッセージは、通常、他のスレッドでオブジェクトが正常に初期化したことを示すメッセージの後に表示されます。 これは、スローして、例外をキャッチによって導入された、遅延が原因です。  
  
 のコンス トラクター、<xref:System.Lazy%601>指定されたインスタンス<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=fullName>、3 つすべてのスレッドを作成することが`LargeObject`インスタンス。 例では、このコンス トラクターおよびのファイナライザーでは、コンソール メッセージを表示することによって、`LargeObject`クラス。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM\#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM\#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 <xref:System.Lazy%601>オブジェクトにより 1 つのインスタンスが \(初期化関数が例外をスローするスレッド\) を除くすべてのスレッドによって使用されます。 この例からの出力に示します。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` \(Visual Basic の `Shared`\) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM\#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM\#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Lazy`1" /> インスタンスに対して値が作成されているかどうかを示す値を取得します。</summary>
        <value>この <see cref="T:System.Lazy`1" /> インスタンスに対して値が作成されている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 限定的な初期化が発生したとき、<xref:System.Lazy%601>インスタンス、する可能性があります、値を作成中または例外がスローされます。 例外がスローされると、後の動作の場合、<xref:System.Lazy%601>インスタンスは、有効では例外キャッシュするかどうかによって異なります。 場合、<xref:System.Lazy%601>インスタンスの初期化関数を指定しないコンス トラクターを使用して作成し、例外のキャッシュは無効です。 初期化するために、後続の試行、<xref:System.Lazy%601>成功可能性がありますと初期化が成功した後、<xref:System.Lazy%601.IsValueCreated%2A>プロパティから返される`true`です。 場合、<xref:System.Lazy%601>初期化関数のインスタンスが作成された \(によって指定された、`valueFactory`のパラメーター、<xref:System.Lazy%601>コンス トラクター\)、例外のキャッシュは、スレッドの安全性モードによって制御されます。  
  
-   モードの場合<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=fullName>または<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=fullName>、初期化するために 2 つ目の可能性はありません、<xref:System.Lazy%601>インスタンス。 場合は、例外が発生し、初期化関数でハンドルされていない、その例外はキャッシュされ、以降のアクセスの再スローされます、<xref:System.Lazy%601.Value%2A?displayProperty=fullName>プロパティです。 例外がスローされた場合、それには、このような場合の値は作成されません<xref:System.Lazy%601.IsValueCreated%2A>返します`false`です。  
  
-   モードの場合<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=fullName>を正常に初期化関数 \(または既定のコンス トラクター\) を実行している最初のスレッドの値を作成する、<xref:System.Lazy%601>インスタンス。 増やせる場合は、初期化関数は、1 つのスレッドで例外をスロー、他のスレッドも初期化するために、<xref:System.Lazy%601>インスタンス。 値が作成されるまで、<xref:System.Lazy%601.IsValueCreated%2A>プロパティから返される`false`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの <see cref="P:System.Lazy`1.Value" /> プロパティの文字列形式を作成して返します。</summary>
        <returns>このインスタンスの <see cref="P:System.Lazy`1.Value" /> プロパティについて <see cref="M:System.Object.ToString" />メソッド を呼び出した結果 \(値が作成されている場合。つまり、<see cref="P:System.Lazy`1.IsValueCreated" /> プロパティが <see langword="true" /> を返した場合\)。 それ以外の場合は、値が作成されていないことを示す文字列です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出すことも、初期化は失敗しません。  
  
 <xref:System.Lazy%601.Value%2A?displayProperty=fullName> プロパティを指定できます `null` ファクトリ メソッドの場合は、限定的な初期化後に指定された、 `valueFactory` のパラメーター、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, 、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, 、または <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> コンス トラクターを戻します `null`します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <see cref="P:System.Lazy`1.Value" /> プロパティが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Lazy`1" /> インスタンスの遅れて初期化される値を取得します。</summary>
        <value>現在の <see cref="T:System.Lazy`1" /> インスタンスの遅れて初期化される値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=fullName> プロパティは、 `false`, へのアクセス、 <xref:System.Lazy%601.Value%2A> プロパティ初期化が強制されます。  
  
 記載されている例外だけでなく、 <xref:System.Lazy%601.Value%2A> プロパティは、ファクトリ メソッドに渡されたによってスローされた未処理の例外をスローできる、 `valueFactory` のパラメーター、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, 、<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, 、または <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> コンス トラクターです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <see cref="T:System.Lazy`1" /> インスタンスは遅れて初期化される型の既定のコンストラクターを使用するために初期化され、コンストラクターにアクセスする権限がありません。</exception>
        <exception cref="T:System.MissingMemberException">
          <see cref="T:System.Lazy`1" /> インスタンスは遅れて初期化される型の既定のコンストラクターを使用するために初期化され、その型はパブリックのパラメーターのないコンストラクターを持ちません。</exception>
        <exception cref="T:System.InvalidOperationException">初期化関数はこのインスタンスの <see cref="P:System.Lazy`1.Value" /> にアクセスしようとします。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>