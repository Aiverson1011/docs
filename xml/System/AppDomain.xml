<Type Name="AppDomain" FullName="System.AppDomain">
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>アプリケーション ドメインを表します。アプリケーション ドメインとは、アプリケーションが実行される分離された環境です。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーション ドメインは、によって表される<xref:System.AppDomain>オブジェクト、ヘルプのマネージ コードを実行するための分離、アンロード、およびセキュリティの境界を提供します。  
  
-   アプリケーション ドメインを使用すると、プロセスを引き起こす可能性のあるタスクを分離できます。 場合の状態、<xref:System.AppDomain>タスクを実行している、不安定になった、<xref:System.AppDomain>プロセスの影響を与えずにアンロードできます。 これは、機能を再起動しなくても、プロセスが長時間にわたって実行する必要があるときに重要です。 また、データを共有する必要がありますしないタスクを分離アプリケーション ドメインを使用することができます。  
  
-   アセンブリが既定のアプリケーション ドメインに読み込まれている場合は、ことはできませんメモリからアンロードされたプロセスの実行中です。 ただし、開く場合は、アセンブリを実行する 2 番目のアプリケーション ドメイン、アセンブリはそのアプリケーション ドメインを読み込むときに読み込まれます。 場合によっては大きな Dll を使用する実行時間の長いプロセスのワーキング セットを最小限に抑えるには、この手法を使用します。  
  
 複数のアプリケーション ドメインが 1 つのプロセスで実行できます。ただし、アプリケーション ドメインとスレッド間の一対一の相関関係はありません。 複数のスレッドが 1 つのアプリケーション ドメインに属することができ、スレッドが 1 つのアプリケーション ドメインで実行中に、特定のスレッドがどの時点でも、1 つのアプリケーション ドメインに限定されていません。  
  
 使用してアプリケーション ドメインが作成された、<xref:System.AppDomain.CreateDomain%2A>メソッドです。<xref:System.AppDomain>インスタンスが読み込まれ、アセンブリを実行するために使用 \(<xref:System.Reflection.Assembly>\)。 ときに、<xref:System.AppDomain>が不要になった使用中でない場合が読み込まれています。  
  
 <xref:System.AppDomain>クラスは、アプリケーション ドメインは、読み込まれますときに、アセンブリが読み込まれるときに、または未処理の例外がスローされたときに応答するアプリケーションを有効にするイベントのセットを実装します。  
  
 アプリケーション ドメインの使用の詳細については、次を参照してください。[Application Domains](http://msdn.microsoft.com/ja-jp/113a8bbf-6875-4a72-a49d-ca2d92e19cc8)です。  
  
 このクラスは、実装、 <xref:System.MarshalByRefObject>、 <xref:System._AppDomain>、および<xref:System.Security.IEvidenceFactory>インターフェイスです。  
  
 リモート処理可能なラッパーは作成しないで、<xref:System.AppDomain>オブジェクト。 リモート参照を公開そうでした<xref:System.AppDomain>などのメソッドを公開する<xref:System.AppDomain.CreateInstance%2A>リモート アクセスと効率的にそのコード アクセス セキュリティを破棄する<xref:System.AppDomain>です。 悪意のあるクライアントが、リモートに接続する<xref:System.AppDomain>任意のリソースへのアクセスを取得する可能性があります、<xref:System.AppDomain>自体へのアクセスを持ちます。 拡張する型のリモート処理可能なラッパーを作成しない<xref:System.MarshalByRefObject>悪意のあるクライアントがセキュリティ システムをバイパスするために使用するメソッドを実装するとします。  
  
> [!CAUTION]
>  既定値、<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>プロパティは`false`します。 この設定は、サービスの安全ではありません。 サービスが部分的に信頼されたコードをダウンロードすることを防ぐためにこのプロパティを設定`true`です。  
  
   
  
## 例  
 この例は、新しいを作成する方法を示しています。 <xref:System.AppDomain>、を内の型の新しいインスタンスを作成<xref:System.AppDomain>を、その型のオブジェクトと通信します。 さらに、この例ではアンロード、<xref:System.AppDomain>原因でガベージ コレクションを実行するオブジェクト。  
  
 [!code-cpp[AppDomainX\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーション ドメインのアクティベーション コンテキストを取得します。</summary>
        <value>現在のアプリケーション ドメインのアクティベーション コンテキストを表すオブジェクト。ドメインにアクティベーション コンテキストが存在しない場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">プライベート パスに追加するディレクトリ名。</param>
        <summary>指定されたディレクトリ名をプライベート パス リストに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの使用は推奨されません、それらが既に読み込まれた後はアセンブリのプローブ パスが変わる可能性があります。 代わりに、<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName> プロパティを使用してください。  
  
 相対検索パス、または複数のプライベート パスは、アセンブリ リゾルバーがプライベート アセンブリをプローブ ベースのディレクトリに対する相対パスです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメイン内のアプリケーションの ID を取得します。</summary>
        <value>アプリケーション ドメイン内のアプリケーションを識別するオブジェクト。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションに付与されているアクセス許可の情報を取得し、実行に必要な信頼レベルがそのアプリケーションにあるかどうかを調べます。</summary>
        <value>アプリケーション ドメインにおけるアプリケーションのアクセス許可および信頼情報をカプセル化するオブジェクト。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。<see cref="P:System.Reflection.Assembly.FullName" /> プロパティによって返される表示名と同じ形式で指定します。</param>
        <summary>ポリシーが適用された後のアセンブリの表示名を返します。</summary>
        <returns>ポリシーが適用された後のアセンブリの表示名を保持する文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomain.ApplyPolicy%2A>メソッドはアセンブリ名と表示ポリシー後の表示名を返します。 これは、リフレクションのみのコンテキストでポリシーが適用されないため、ポリシーを使用してアセンブリを読み込む必要がある場合に便利です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリが読み込まれたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AssemblyLoadEventHandler>委任するため、このイベントは、どのようなアセンブリが読み込まれたことを示します。  
  
 このイベントのイベント ハンドラーを登録するには、必要なアクセス許可が必要、または<xref:System.Security.SecurityException>がスローされます。  
  
 イベント処理の詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
   
  
## 例  
 次の例は、<xref:System.AppDomain.AssemblyLoad>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 アセンブリの完全修飾名を取得する方法については、次を参照してください。[Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e)です。  
  
 [!code-cpp[AppDomain\_AssemblyLoad\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain\_AssemblyLoad\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain\_AssemblyLoad\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの解決が失敗したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 役割です、<xref:System.ResolveEventHandler>で指定されているアセンブリを返すには、このイベントの<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>プロパティ、またはアセンブリが認識されない場合は null を返します。 アセンブリが実行コンテキストに読み込まれている必要があります。リフレクション専用コンテキストに読み込まれる、このイベントが発生する原因となった、負荷が失敗します。  
  
 このイベントの使用に関するガイダンスについては、次を参照してください。[Resolving Assembly Loads](http://msdn.microsoft.com/ja-jp/5099e549-f4fd-49fb-a290-549edd456c6a)です。  
  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>プロパティは、アセンブリを解決できないアセンブリの読み込みを要求したを返します。 たとえば、ローダーは調査パスで要求元のアセンブリとその依存関係がないため、要求元のアセンブリの依存関係を読み込めませんでない可能性があります。 依存関係の 1 つ以上のバージョンが利用可能な場合は、要求元のアセンブリの id を知ることが、依存関係を検出するか、正しいバージョンを特定するに便利です。 可能性があります。 詳細については、「<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>」を参照してください。  
  
> [!IMPORTANT]
>  以降で、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、<xref:System.ResolveEventHandler>リソース アセンブリを含め、すべてのアセンブリに対してイベントが生成されます。 リソース アセンブリが、以前のバージョンで、イベントを発生しません。 オペレーティング システムがローカライズされている場合、ハンドラーが複数回呼び出す: フォールバック チェーン内のカルチャごとに 1 回です。  
  
 このイベントで、<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>プロパティは、ポリシーが適用される前に、アセンブリ名を返します。  
  
> [!IMPORTANT]
>  1 つ以上のイベント ハンドラーがこのイベントの登録されている場合、イベント ハンドラーが値を返すまでの順序でイベント handlersarecalled ではない`null`です。 後続のイベント ハンドラーは無視されます。  
  
 イベント処理の詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
   
  
## 例  
 次の例は、<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 アセンブリの完全修飾名を取得する方法については、次を参照してください。[Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e)です。  
  
 [!code-cpp[AssemblyResolve\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリを探すためにアセンブリ リゾルバーが使用したベース ディレクトリを取得します。</summary>
        <value>アセンブリを探すためにアセンブリ リゾルバーが使用するベース ディレクトリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティに対応、<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>プロパティです。 これも取得できますを使用して、<xref:System.AppDomain.GetData%2A>文字列"APPBASE"を持つメソッドです。  
  
   
  
## 例  
 次のコード例では、ドメインに読み込むアセンブリの検索に使用するベース ディレクトリを指定する、新しいアプリケーション ドメインを作成します。 使用して、<xref:System.AppDomain.BaseDirectory%2A>プロパティをコンソールに表示するため、ベース ディレクトリ パスを取得します。  
  
 [!code-cpp[ADSetup\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the information in the path itself, including if the path is in the form "file:\/\/" or \\\\UNC\\dir or "c:\\". Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プライベート アセンブリの場所を指定するパスを空の文字列 \(""\) にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プライベート パスは、プライベート アセンブリを検索する共通言語ランタイムが検索するベース ディレクトリの相対パスです。  
  
 詳細については、「<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>」を参照してください。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、<xref:System.AppDomain.ClearPrivatePath%2A>アセンブリが読み込まれるときに検索するプライベート パスの一覧からすべてのエントリを削除する方法です。  
  
 このメソッドは、現在使用されていません、し、新規の開発は使用できません。  
  
 [!code-cpp[ADClearPrivatePath\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シャドウ コピーされたアセンブリが含まれているディレクトリのリストを空の文字列 \(""\) にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シャドウ コピーのパスは、シャドウ コピーされたアセンブリのディレクトリの一覧が格納されています。  
  
 詳細については、次を参照してください。<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>と[Shadow Copying Assemblies](http://msdn.microsoft.com/ja-jp/de8b8759-fca7-4260-896b-5a4973157672)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要求された型を定義するアセンブリが格納されているファイルの名前。</param>
        <param name="typeName">要求された型の名前。</param>
        <summary>指定した COM 型の新しいインスタンスを作成します。 型を含んでいるアセンブリのファイルの名前と、型の名前をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、ローカルでの型を読み込むことがなく、リモート オブジェクトを作成します。  
  
 戻り値は、実際のオブジェクトにアクセスするラップ解除する必要があります。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>属性の値`true`適用する必要が明示的にまたは既定では、COM の型にこのメソッドをその型のインスタンスを作成するそれ以外の場合、<xref:System.TypeLoadException>がスローされます。  
  
   
  
## 例  
 次の例を示します  
  
 [!code-cpp[AppDomain\_CreateComInstanceFrom\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain\_CreateComInstanceFrom\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain\_CreateComInstanceFrom\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.TypeLoadException">型を読み込めません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.MissingMethodException">パブリック パラメーターなしのコンス トラクターは見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりません。</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> は抽象クラスです。  
  
 または  
  
 このメンバーは、遅延バインディング メカニズムで呼び出されました。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> が空の文字列 \(""\) です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">参照される COM オブジェクトは<see langword="null" />します。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求された型を定義するアセンブリが格納されているファイルの名前。</param>
        <param name="typeName">要求された型の名前。</param>
        <param name="hashValue">計算されたハッシュ コードの値を表します。</param>
        <param name="hashAlgorithm">アセンブリ マニフェストが使用するハッシュ アルゴリズムを表します。</param>
        <summary>指定した COM 型の新しいインスタンスを作成します。 型を含んでいるアセンブリのファイルの名前と、型の名前をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、ローカルでの型を読み込むことがなく、リモート オブジェクトを作成します。  
  
 戻り値は、実際のオブジェクトにアクセスするラップ解除する必要があります。  
  
 A[CreateComInstanceFrom メソッド \(String, String, Byte\<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>属性の値`true`適用する必要が明示的にまたは既定では、COM の型にこのメソッドの型のインスタンスを作成する場合は、[CreateComInstanceFrom メソッド \(String, String, Byte\<xref:System.TypeLoadException>がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.TypeLoadException">型を読み込めません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.MissingMethodException">パブリック パラメーターなしのコンス トラクターは見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> は抽象クラスです。  
  
 または  
  
 このメンバーは、遅延バインディング メカニズムで呼び出されました。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> が空の文字列 \(""\) です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">参照される COM オブジェクトは<see langword="null" />します。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。</param>
        <summary>名前を指定して新しいアプリケーション ドメインを作成します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `friendlyName`パラメーターは、人間にわかりやすい方法でドメインを識別するためのものです。 この文字列は、ユーザー インターフェイスでの表示に適したにする必要があります。  
  
 このメソッドのオーバー ロードを使用して、<xref:System.AppDomainSetup>既定のアプリケーション ドメインからの情報です。  
  
   
  
## 例  
 次の例を示しています、一般のいずれかを使用して、ドメインを作成する方法、<xref:System.AppDomain.CreateDomain%2A>オーバー ロードします。  
  
 [!code-cpp[AppDomain\_Setup\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain\_Setup\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain\_Setup\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。 この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。 詳細については、「<see cref="P:System.AppDomain.FriendlyName" />」を参照してください。</param>
        <param name="securityInfo">アプリケーション ドメインで実行されるコードの ID を確立する証拠。 現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</param>
        <summary>名前および証拠を指定して新しいアプリケーション ドメインを作成します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドのオーバー ロードを使用して、<xref:System.AppDomainSetup>既定のアプリケーション ドメインからの情報です。  
  
 場合`securityInfo`が指定されていない、現在のアプリケーション ドメインから証拠を使用します。  
  
> [!IMPORTANT]
>  サンド ボックス アプリケーション ドメインを作成するのには、このメソッドのオーバー ロードを使わないでください。 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、指定されている証拠`securityInfo`不要になったアプリケーション ドメインの許可セットに影響します。 使用して、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>サンド ボックス アプリケーション ドメインを作成するメソッドのオーバー ロードします。  
  
   
  
## 例  
 次の例を示しています、一般のいずれかを使用して、ドメインを作成する方法、<xref:System.AppDomain.CreateDomain%2A>オーバー ロードします。  
  
 [!code-cpp[AppDomain\_Setup\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain\_Setup\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain\_Setup\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。 この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。 詳細については、「<see cref="P:System.AppDomain.FriendlyName" />」を参照してください。</param>
        <param name="securityInfo">アプリケーション ドメインで実行されるコードの ID を確立する証拠。 現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</param>
        <param name="info">アプリケーション ドメインの初期化情報を格納しているオブジェクト。</param>
        <summary>名前、証拠、およびアプリケーション ドメイン設定情報を指定して、新しいアプリケーション ドメインを作成します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合`info`が指定されていない場合、このメソッドのオーバー ロードを使用して、<xref:System.AppDomainSetup>既定のアプリケーション ドメインからの情報です。  
  
 場合`securityInfo`が指定されていない、現在のアプリケーション ドメインから証拠を使用します。  
  
> [!IMPORTANT]
>  サンド ボックス アプリケーション ドメインを作成するのには、このメソッドのオーバー ロードを使わないでください。 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、指定されている証拠`securityInfo`不要になったアプリケーション ドメインの許可セットに影響します。 使用して、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>サンド ボックス アプリケーション ドメインを作成するメソッドのオーバー ロードします。  
  
   
  
## 例  
 次の例を示しています、一般のいずれかを使用して、ドメインを作成する方法、<xref:System.AppDomain.CreateDomain%2A>オーバー ロードします。  
  
 [!code-cpp[AppDomain\_Setup\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain\_Setup\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain\_Setup\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。 この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。 詳細については、<see cref="P:System.AppDomain.FriendlyName" /> の説明を参照してください。</param>
        <param name="securityInfo">アプリケーション ドメインで実行されるコードの ID を確立する証拠。 現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</param>
        <param name="info">アプリケーション ドメインの初期化情報を格納しているオブジェクト。</param>
        <param name="grantSet">新しいアプリケーション ドメインに読み込まれた、特定のアクセス許可を持たないすべてのアセンブリに付与される既定のアクセス許可セット。</param>
        <param name="fullTrustAssemblies">新しいアプリケーション ドメインで、完全に信頼されていると見なされるアセンブリを表す厳密名の配列。</param>
        <summary>指定された名前、証拠、アプリケーション ドメインの設定情報、既定のアクセス許可セット、および完全信頼されたアセンブリの配列を使用して、新しいアプリケーション ドメインを作成します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定する必要があります、<xref:System.AppDomainSetup.ApplicationBase%2A>のプロパティ、<xref:System.AppDomainSetup>オブジェクトに対して指定する`info`です。 それ以外の場合は、例外がスローされます。  
  
 場合`securityInfo`が指定されていない、現在のアプリケーション ドメインから証拠を使用します。  
  
 提供情報`grantSet`と`fullTrustAssemblies`作成に使用される、<xref:System.Security.Policy.ApplicationTrust>新しいアプリケーション ドメインのオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">アプリケーション ドメインで<see langword="null" />です。  
  
 または  
  
 <see cref="P:System.AppDomainSetup.ApplicationBase" />プロパティに設定されていない、<see cref="T:System.AppDomainSetup" />指定されているオブジェクト<paramref name="info" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to create and manipulate an application domain. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。 この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。 詳細については、「<see cref="P:System.AppDomain.FriendlyName" />」を参照してください。</param>
        <param name="securityInfo">アプリケーション ドメインで実行されるコードの ID を確立する証拠。 現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</param>
        <param name="appBasePath">アセンブリを探すためにアセンブリ リゾルバーが使用するベース ディレクトリ。 詳細については、「<see cref="P:System.AppDomain.BaseDirectory" />」を参照してください。</param>
        <param name="appRelativeSearchPath">アセンブリ リゾルバーがプライベート アセンブリを調べる場所を示す、ベース ディレクトリを基準とした相対パス。 詳細については、「<see cref="P:System.AppDomain.RelativeSearchPath" />」を参照してください。</param>
        <param name="shadowCopyFiles">
          <see langword="true" /> の場合、アセンブリのシャドウ コピーはこのアプリケーション ドメインに読み込まれます。</param>
        <summary>名前、証拠、アプリケーション ベース パス、相対検索パス、およびアセンブリのシャドウ コピーをアプリケーション ドメインに読み込むかどうかを示すパラメーターを指定して、新しいアプリケーション ドメインを作成します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合`securityInfo`が指定されていない、現在のアプリケーション ドメインから証拠を使用します。  
  
 シャドウ コピーの詳細については、次を参照してください。<xref:System.AppDomain.ShadowCopyFiles%2A>と[Shadow Copying Assemblies](http://msdn.microsoft.com/ja-jp/de8b8759-fca7-4260-896b-5a4973157672)です。  
  
> [!IMPORTANT]
>  サンド ボックス アプリケーション ドメインを作成するのには、このメソッドのオーバー ロードを使わないでください。 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、指定されている証拠`securityInfo`不要になったアプリケーション ドメインの許可セットに影響します。 使用して、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>サンド ボックス アプリケーション ドメインを作成するメソッドのオーバー ロードします。  
  
   
  
## 例  
 次の例を示しています、一般のいずれかを使用して、ドメインを作成する方法、<xref:System.AppDomain.CreateDomain%2A>オーバー ロードします。  
  
 [!code-cpp[AppDomain\_Setup\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain\_Setup\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain\_Setup\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。 この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。 詳細については、「<see cref="P:System.AppDomain.FriendlyName" />」を参照してください。</param>
        <param name="securityInfo">アプリケーション ドメインで実行されるコードの ID を確立する証拠。 現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</param>
        <param name="appBasePath">アセンブリを探すためにアセンブリ リゾルバーが使用するベース ディレクトリ。 詳細については、「<see cref="P:System.AppDomain.BaseDirectory" />」を参照してください。</param>
        <param name="appRelativeSearchPath">アセンブリ リゾルバーがプライベート アセンブリを調べる場所を示す、ベース ディレクトリを基準とした相対パス。 詳細については、「<see cref="P:System.AppDomain.RelativeSearchPath" />」を参照してください。</param>
        <param name="shadowCopyFiles">アプリケーション ドメインにアセンブリのシャドウ コピーを読み込む場合は <see langword="true" />。</param>
        <param name="adInit">新しい <see cref="T:System.AppDomain" /> オブジェクトの初期化時に呼び出されるコールバック メソッドを表す <see cref="T:System.AppDomainInitializer" /> デリゲート。</param>
        <param name="adInitArgs">新しい <see cref="T:System.AppDomain" /> オブジェクトの初期化時に <c>adInit</c> によって表されるコールバックに渡される文字列型引数の配列。</param>
        <summary>名前、証拠、アプリケーション ベース パス、相対検索パス、およびアセンブリのシャドウ コピーをアプリケーション ドメインに読み込むかどうかを示すパラメーターを指定して、新しいアプリケーション ドメインを作成します。 アプリケーション ドメインを初期化したときに呼び出されるコールバック メソッドと、そのコールバック メソッドに渡す文字列型引数の配列を指定します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 によって表されるメソッド`adInit`新しく作成されたアプリケーション ドメインのコンテキストで実行されます。  
  
 場合`securityInfo`が指定されていない、現在のアプリケーション ドメインから証拠を使用します。  
  
 シャドウ コピーの詳細については、次を参照してください。<xref:System.AppDomain.ShadowCopyFiles%2A>と[Shadow Copying Assemblies](http://msdn.microsoft.com/ja-jp/de8b8759-fca7-4260-896b-5a4973157672)です。  
  
> [!IMPORTANT]
>  サンド ボックス アプリケーション ドメインを作成するのには、このメソッドのオーバー ロードを使わないでください。 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、指定されている証拠`securityInfo`不要になったアプリケーション ドメインの許可セットに影響します。 使用して、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>サンド ボックス アプリケーション ドメインを作成するメソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、既定のコンス トラクターを呼び出します`typeName`です。  
  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`です。  
  
 呼び出そうとした<xref:System.AppDomain.CreateInstance%2A>ターゲットに現在のアプリケーション ドメインではないアプリケーション ドメインと、対象のアプリケーション ドメイン内のアセンブリが正常に読み込まです。<xref:System.Reflection.Assembly>は<xref:System.MarshalByRefObject>、このメソッドが返すしようとしたとき、 <xref:System.Reflection.Assembly> 、現在のアプリケーション ドメインに読み込まれたアセンブリの共通言語ランタイムはしようと現在のアプリケーション ドメインにアセンブリを読み込むの負荷が失敗する可能性があります。 現在のアプリケーション ドメインに読み込まれるアセンブリは、2 つのアプリケーション ドメインのパスの設定が異なる場合、最初に読み込まれたアセンブリとは異なる可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスは <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to call unmanaged code when creating an instance of a delegate. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアントでアクティブ化されるオブジェクトに関連します。クライアントのアクティブ化は、旧バージョンとの互換性のために保持されますが、新規の開発がないことをお勧めするレガシ テクノロジです。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。 アクティベーション属性の配列をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、既定のコンス トラクターを呼び出します`typeName`です。  
  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`です。  
  
 呼び出そうとした<xref:System.AppDomain.CreateInstance%2A>ターゲットに現在のアプリケーション ドメインではないアプリケーション ドメインと、対象のアプリケーション ドメイン内のアセンブリが正常に読み込まです。<xref:System.Reflection.Assembly>は<xref:System.MarshalByRefObject>、このメソッドが返すしようとしたとき、 <xref:System.Reflection.Assembly> 、現在のアプリケーション ドメインに読み込まれたアセンブリの共通言語ランタイムはしようと現在のアプリケーション ドメインにアセンブリを読み込むの負荷が失敗する可能性があります。 現在のアプリケーション ドメインに読み込まれるアセンブリは、2 つのアプリケーション ドメインのパスの設定が異なる場合、最初に読み込まれたアセンブリとは異なる可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスは <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to call unmanaged code when creating an instance of a delegate. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for the ability to invoke operations on all type members. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <c>typeName</c> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。<c>bindingAttr</c> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。<c>binder</c> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<c>args</c> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <c>args</c> から <c>typeName</c> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。 バインダー、バインディング フラグ、コンストラクター引数、引数を解釈するために使用するカルチャ固有の情報、および省略可能なアクティベーション属性をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照してください[CreateInstance メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`です。  
  
 呼び出そうとした[CreateInstance メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.AppDomain.CreateInstance%2A>ターゲットに現在のアプリケーション ドメインではないアプリケーション ドメインと、対象のアプリケーション ドメイン内のアセンブリが正常に読み込まです。[CreateInstance メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.Reflection.Assembly>は[CreateInstance メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.MarshalByRefObject>、このメソッドが返すしようとしたとき、 [CreateInstance メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.Reflection.Assembly> 、現在のアプリケーション ドメインに読み込まれたアセンブリの共通言語ランタイムはしようと現在のアプリケーション ドメインにアセンブリを読み込むの負荷が失敗する可能性があります。 現在のアプリケーション ドメインに読み込まれるアセンブリは、2 つのアプリケーション ドメインのパスの設定が異なる場合、最初に読み込まれたアセンブリとは異なる可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスは <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to call unmanaged code when creating an instance of a delegate. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for the ability to invoke operations on all type members. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <c>typeName</c> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。<c>bindingAttr</c> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。<c>binder</c> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<c>args</c> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <c>args</c> から <c>typeName</c> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアントでアクティブ化されるオブジェクトに関連します。クライアントのアクティブ化は、旧バージョンとの互換性のために保持されますが、新規の開発がないことをお勧めするレガシ テクノロジです。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <param name="securityAttributes">
          <c>typeName</c> の作成を承認するために使用される情報。</param>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。 バインダー、バインディング フラグ、コンストラクター引数、引数を解釈するために使用するカルチャ固有の情報、アクティベーション属性、型を作成するために必要な承認情報をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照してください[CreateInstance メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.Reflection.AssemblyName>形式の`assemblyName`します。  
  
 呼び出そうとした[CreateInstance メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.AppDomain.CreateInstance%2A>ターゲットに現在のアプリケーション ドメインではないアプリケーション ドメインと、対象のアプリケーション ドメイン内のアセンブリが正常に読み込まです。[CreateInstance メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.Reflection.Assembly>は[CreateInstance メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.MarshalByRefObject>、このメソッドが返すしようとしたとき、 [CreateInstance メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.Reflection.Assembly> 、現在のアプリケーション ドメインに読み込まれたアセンブリの共通言語ランタイムはしようと現在のアプリケーション ドメインにアセンブリを読み込むの負荷が失敗する可能性があります。 現在のアプリケーション ドメインに読み込まれるアセンブリは、2 つのアプリケーション ドメインのパスの設定が異なる場合、最初に読み込まれたアセンブリとは異なる可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。  
  
 または  
  
 <paramref name="securityAttributes" /> が <see langword="null" /> ではありません。 従来の CAS ポリシーが有効でない場合に<paramref name="securityAttributes" />する必要があります<see langword="null." /></exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスは <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for the ability to invoke operations on all type members. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <summary>指定した型の新しいインスタンスを作成します。 型が定義されているアセンブリの名前と、型の名前をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定したオブジェクトのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは便利なメソッドを結合する<xref:System.AppDomain.CreateInstance%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>です。 このメソッドは、既定のコンス トラクターを呼び出します`typeName`です。  
  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`です。 参照してください、<xref:System.Type.FullName%2A?displayProperty=fullName>プロパティの形式の`typeName`します。  
  
> [!NOTE]
>  メソッドへの事前バインディングされた呼び出しを行う場合`M`型のオブジェクトの`T1`によって返された<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>、メソッドが型のオブジェクトのメソッドへの事前バインディングされた呼び出しを行うことと`T2`アセンブリで`C`、現在のアセンブリまたはアセンブリを含む以外`T1`、アセンブリ`C`は現在のアプリケーション ドメインに読み込まれます。 事前バインディングされた呼び出しに場合でも、この読み込みが行われます`T1.M()`の本体で作成された、 <xref:System.Reflection.Emit.DynamicMethod>、またはその他の動的に生成されたコード。 現在のドメインが既定のドメイン、アセンブリがかどうか`C`プロセスが終了するまでアンロードすることはできません。 後で、現在のドメインがアセンブリの読み込みを試みると`C`負荷が失敗する可能性があります。  
  
   
  
## 例  
 次のコード例では、別のアプリケーション ドメインでコードを実行する最も簡単な方法を示します。 例では、という名前のクラスを定義する`Worker`から継承する<xref:System.MarshalByRefObject>です。`Worker`クラスを実行しているアプリケーション ドメインの名前を表示するメソッドを定義します。 インスタンスを作成、`Worker`および既定のアプリケーション ドメインで、新しいアプリケーション ドメイン。  
  
> [!NOTE]
>  含むアセンブリ`Worker`両方のアプリケーション ドメインに読み込まれている必要がありますが、新しいアプリケーション ドメイン内にのみ存在する他のアセンブリを読み込むことができます。  
  
 [!code-cpp[CreateInstanceAndUnwrap2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> が <paramref name="assemblyName" /> で見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアントでアクティブ化されるオブジェクトに関連します。クライアントのアクティブ化は、旧バージョンとの互換性のために保持されますが、新規の開発は使用しないでいるレガシ テクノロジです。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <summary>指定した型の新しいインスタンスを作成します。 型が定義されているアセンブリの名前、型の名前、およびアクティベーション属性の配列をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定したオブジェクトのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、便利な方法を組み合わせた<xref:System.AppDomain.CreateInstance%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>です。 このメソッドは、既定のコンス トラクターを呼び出します`typeName`です。  
  
 参照してください<xref:System.Reflection.AssemblyName>形式の`assemblyName`します。 参照してください、<xref:System.Type.FullName%2A?displayProperty=fullName>プロパティの形式を`typeName`です。  
  
> [!NOTE]
>  メソッドへの事前バインディングされた呼び出しを行う場合`M`型のオブジェクトの`T1`によって返された<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>、メソッドが型のオブジェクトのメソッドへの事前バインディングされた呼び出しを行うことと`T2`アセンブリで`C`、現在のアセンブリまたはアセンブリを含む以外`T1`、アセンブリ`C`は現在のアプリケーション ドメインに読み込まれます。 事前バインディングされた呼び出しに場合でも、この読み込みが行われます`T1.M()`の本体で作成された、 <xref:System.Reflection.Emit.DynamicMethod>、またはその他の動的に生成されたコード。 現在のドメインが既定のドメイン、アセンブリがかどうか`C`プロセスが終了するまでアンロードすることはできません。 後で、現在のドメインがアセンブリを読み込もうとしている場合`C`負荷が失敗する可能性があります。  
  
   
  
## 例  
 [!code-cpp[ADDyno\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> が <paramref name="assemblyName" /> で見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to call unmanaged code when creating an instance of a delegate. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for the ability to invoke operations on all type members. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <c>typeName</c> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。<c>bindingAttr</c> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。<c>binder</c> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<c>args</c> を空の配列または null にする必要があります。</param>
        <param name="culture">型の強制変換を制御するために使用するカルチャ固有のオブジェクト。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see langword="CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 一般的に、1 つの配列に 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトが含まれます。 リモート オブジェクトのアクティブ化に必要な URL を指定します。  
  
 このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。型名の大文字と小文字の区別を無視するかどうか、作成する型を選択するために使用されるバインディング属性とバインダー、コンストラクターの引数、カルチャ、およびアクティベーション属性を指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定したオブジェクトのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは便利なメソッドを結合する[CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.AppDomain.CreateInstance%2A>と[CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>です。  
  
 参照してください[CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`です。 参照してください、[CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.Type.FullName%2A?displayProperty=fullName>プロパティの形式に関する`typeName`です。  
  
> [!NOTE]
>  メソッドへの事前バインディングされた呼び出しを行う場合`M`型のオブジェクトの`T1`によって返された[CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>、メソッドが型のオブジェクトのメソッドへの事前バインディングされた呼び出しを行うことと`T2`アセンブリで`C`、現在のアセンブリまたはアセンブリを含む以外`T1`、アセンブリ`C`は現在のアプリケーション ドメインに読み込まれます。 事前バインディングされた呼び出しに場合でも、この読み込みが行われます`T1.M()`の本体で作成された、 [CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.Reflection.Emit.DynamicMethod>、またはその他の動的に生成されたコード。 現在のドメインが既定のドメイン、アセンブリがかどうか`C`プロセスが終了するまでアンロードすることはできません。 現在のドメインの後でしようとするとアセンブリの読み込み`C`負荷が失敗する可能性があります。  
  
   
  
## 例  
 次の例では、使用、`ignoreCase`パラメーター。  
  
 [!code-cpp[AppDomain\_CreateInstance\_IgnoreCase\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain\_CreateInstance\_IgnoreCase\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain\_CreateInstance\_IgnoreCase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to call unmanaged code when creating an instance of a delegate. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for the ability to invoke operations on all type members. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <c>typeName</c> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。<c>bindingAttr</c> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。<c>binder</c> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<c>args</c> を空の配列または null にする必要があります。</param>
        <param name="culture">型の強制変換を制御するために使用するカルチャ固有のオブジェクト。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see langword="CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <param name="securityAttributes">
          <c>typeName</c> の作成を承認するために使用される情報。</param>
        <summary>指定した型の新しいインスタンスを作成します。 型の名前、およびその検索方法と作成方法をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定したオブジェクトのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは便利なメソッドを結合する[CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.AppDomain.CreateInstance%2A>および[CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>です。  
  
 参照してください[CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`です。 参照してください、[CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.Type.FullName%2A?displayProperty=fullName>プロパティの形式を`typeName`です。  
  
> [!NOTE]
>  メソッドへの事前バインディングされた呼び出しを行う場合`M`型のオブジェクトの`T1`によって返された[CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>、メソッドが型のオブジェクトのメソッドへの事前バインディングされた呼び出しを行うことと`T2`アセンブリで`C`、現在のアセンブリまたはアセンブリを含む以外`T1`、アセンブリ`C`は現在のアプリケーション ドメインに読み込まれます。 事前バインディングされた呼び出しに場合でも、この読み込みが行われます`T1.M()`の本体で作成された、 [CreateInstanceAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.Reflection.Emit.DynamicMethod>、またはその他の動的に生成されたコード。 現在のドメインが既定のドメイン、アセンブリがかどうか`C`プロセスが終了するまでアンロードすることはできません。 後で、現在のドメインはアセンブリをロードしよう場合`C`負荷が失敗します。  
  
   
  
## 例  
 次の例では、使用、`ignoreCase`パラメーター。  
  
 [!code-cpp[AppDomain\_CreateInstance\_IgnoreCase\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain\_CreateInstance\_IgnoreCase\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain\_CreateInstance\_IgnoreCase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for the ability to invoke operations on all type members. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求する型を定義しているアセンブリが格納されているファイルの名前 \(パスを含む\)。 アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>新しいインスタンスのラッパーであるオブジェクト。<paramref name="typeName" /> が見つからない場合は <see langword="null" />。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のコンス トラクター`typeName`が呼び出されます。  
  
 詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName> メソッドを参照してください。  
  
 ときに、<xref:System.AppDomain.CreateInstanceFrom%2A>メソッドの使用を呼び出しが行われたアプリケーション ドメイン以外のターゲット アプリケーション ドメインでインスタンスを作成、アセンブリは対象のアプリケーション ドメインに読み込まれます。 ただし場合は、インスタンスがラップされた呼び出し元のアプリケーション ドメインで、特定の方法でラップされていないインスタンスを使用する可能性があります、呼び出し元のアプリケーション ドメインに読み込まれるアセンブリ。 たとえば、インスタンスは、ラップされたが後の型情報が要求される、そのメソッドを呼び出すために遅延バインディング。 アセンブリが呼び出し元のアプリケーション ドメインに読み込まれている場合、例外が発生することができます。  
  
-   同じアセンブリの別のバージョンが呼び出し元のアプリケーション ドメインに読み込まれた場合、または呼び出し元のアプリケーション ドメインの読み込みパスは、対象のアプリケーション ドメインを例外の異なるなど<xref:System.MissingMethodException>発生することができます。  
  
-   呼び出し元のアプリケーション ドメインが、インスタンスの型を事前バインディングされた呼び出しを行う場合<xref:System.InvalidCastException>インスタンスにキャストしようとしましたがときにスローされることができます。  
  
   
  
## 例  
 次の例を使用する方法を示しています、<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>対象のアプリケーション ドメインで、オブジェクトのインスタンスを作成し、そのメソッドを呼び出すメソッドのオーバー ロードします。  
  
 例では、定義、`MarshallableExample`クラスは、アプリケーション ドメインの境界を越えてマーシャ リングすることができます。 例では、現在実行中のアセンブリのパスを作成、対象のアプリケーション ドメインを作成および使用して、<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>対象のアプリケーション ドメインにアセンブリを読み込んでのインスタンスを作成するメソッドのオーバー ロード`MarshallableExample`です。  
  
> [!NOTE]
>  このパスはこの例では、絶対パスが相対パスのように動作ため、<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName>メソッドは、アセンブリの読み込みに使用します。  
  
 オブジェクト ハンドルをラップ解除後に、対象のアプリケーション ドメインでオブジェクトを使用する 3 つの方法を示します。  
  
-   遅延バインディングでリフレクションを使用して、メソッドを呼び出します。 これには、これにより、呼び出し元のアプリケーション ドメインに読み込まれるアセンブリ、型情報が必要です。 \(この例では既に読み込まれている。\)  
  
-   オブジェクトを呼び出し元と呼び出し先の両方に既知のインターフェイスにキャストします。 インターフェイスは、呼び出し元のアセンブリまたは呼び出し元と呼び出し先の両方によって参照される 3 つ目のアセンブリで定義されて、呼び出されたアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれているしません。  
  
-   その型が呼び出し元に認識されているときに直接オブジェクトを使用します。 アセンブリは、呼び出し元のアプリケーション ドメインに読み込まれている必要があります。  
  
 呼び出し元のアプリケーション ドメインに呼び出されるアセンブリが読み込まれないようにすることも、呼び出し元から派生するため、<xref:System.MarshalByRefObject>クラスとターゲットのアプリケーション ドメインで実行できるメソッドを定義します。 そのメソッドは、ターゲット アセンブリが既に対象のアプリケーション ドメインに読み込まれているために、ターゲット アセンブリを検査するのにリフレクションを使用できます。 例を参照して、<xref:System.AppDomain.DynamicDirectory%2A>プロパティです。  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom\_StringString\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom\_StringString\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom\_StringString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyFile" /> に見つかりませんでした。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.MissingMethodException">パラメーターなしのパブリック コンス トラクターは見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスは <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求する型を定義しているアセンブリが格納されているファイルの名前 \(パスを含む\)。 アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアントでアクティブ化されるオブジェクトに関連します。クライアントのアクティブ化は、旧バージョンとの互換性のために保持されますが、新規の開発がないことをお勧めするレガシ テクノロジです。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>新しいインスタンスのラッパーであるオブジェクト。<paramref name="typeName" /> が見つからない場合は <see langword="null" />。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のコンス トラクター`typeName`が呼び出されます。  
  
 この方法の詳細については、次を参照してください。、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>メソッドです。  
  
 ときに、<xref:System.AppDomain.CreateInstanceFrom%2A>メソッドの使用を呼び出しが行われたアプリケーション ドメイン以外のターゲット アプリケーション ドメインでインスタンスを作成、アセンブリは対象のアプリケーション ドメインに読み込まれます。 ただし場合は、インスタンスがラップされた呼び出し元のアプリケーション ドメインで、特定の方法でラップされていないインスタンスを使用する可能性があります、呼び出し元のアプリケーション ドメインに読み込まれるアセンブリ。 たとえば、インスタンスは、ラップされたが後の型情報が要求される、そのメソッドを呼び出すために遅延バインディング。 アセンブリが呼び出し元のアプリケーション ドメインに読み込まれている場合、例外が発生することができます。  
  
-   同じアセンブリの別のバージョンが呼び出し元のアプリケーション ドメインに読み込まれた場合、または呼び出し元のアプリケーション ドメインの読み込みパスはなど、対象のアプリケーション ドメインを例外の異なる<xref:System.MissingMethodException>発生することができます。  
  
-   呼び出し元のアプリケーション ドメインが、インスタンスの型を事前バインディングされた呼び出しを行う場合<xref:System.InvalidCastException>インスタンスにキャストしようとしましたがときにスローされることができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyFile" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスは <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求する型を定義しているアセンブリが格納されているファイルの名前 \(パスを含む\)。 アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <c>typeName</c> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。<c>bindingAttr</c> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。<c>binder</c> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<c>args</c> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <c>args</c> から <c>typeName</c> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>新しいインスタンスのラッパーであるオブジェクト。<paramref name="typeName" /> が見つからない場合は <see langword="null" />。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 詳細については、[CreateInstanceFrom メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName> メソッドを参照してください。  
  
 ときに、[CreateInstanceFrom メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.AppDomain.CreateInstanceFrom%2A>メソッドの使用を呼び出しが行われたアプリケーション ドメイン以外のターゲット アプリケーション ドメインでインスタンスを作成、アセンブリは対象のアプリケーション ドメインに読み込まれます。 しかし場合は、インスタンスがラップされた呼び出し元のアプリケーション ドメインで、特定の方法でラップされていないインスタンスを使用してが呼び出し元のアプリケーション ドメインに読み込まれるアセンブリ。 たとえば、インスタンスは、ラップされたが後の型情報が要求される、そのメソッドを呼び出すために遅延バインディング。 アセンブリが呼び出し元のアプリケーション ドメインに読み込まれている場合、例外が発生することができます。  
  
-   同じアセンブリの別のバージョンが呼び出し元のアプリケーション ドメインに読み込まれた場合、または呼び出し元のアプリケーション ドメインの読み込みパスはなど、対象のアプリケーション ドメインを例外の異なる[CreateInstanceFrom メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.MissingMethodException>発生することができます。  
  
-   呼び出し元のアプリケーション ドメインが、インスタンスの型を事前バインディングされた呼び出しを行う場合[CreateInstanceFrom メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.InvalidCastException>インスタンスにキャストしようとしましたがときにスローされることができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyFile" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスは <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求する型を定義しているアセンブリが格納されているファイルの名前 \(パスを含む\)。 アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <c>typeName</c> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。<c>bindingAttr</c> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。<c>binder</c> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<c>args</c> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <c>args</c> から <c>typeName</c> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <param name="securityAttributes">
          <c>typeName</c> の作成を承認するために使用される情報。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>新しいインスタンスのラッパーであるオブジェクト。<paramref name="typeName" /> が見つからない場合は <see langword="null" />。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この方法の詳細については、次を参照してください。、[CreateInstanceFrom メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>メソッドです。  
  
 ときに、[CreateInstanceFrom メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.AppDomain.CreateInstanceFrom%2A>メソッドの使用を呼び出しが行われたアプリケーション ドメイン以外のターゲット アプリケーション ドメインでインスタンスを作成、アセンブリは対象のアプリケーション ドメインに読み込まれます。 しかし場合は、インスタンスがラップされた呼び出し元のアプリケーション ドメインで、特定の方法でラップされていないインスタンスを使用してが呼び出し元のアプリケーション ドメインに読み込まれるアセンブリ。 たとえば、インスタンスは、ラップされたが後の型情報が要求される、そのメソッドを呼び出すために遅延バインディング。 アセンブリが呼び出し元のアプリケーション ドメインに読み込まれている場合、例外が発生することができます。  
  
-   同じアセンブリの別のバージョンが呼び出し元のアプリケーション ドメインに読み込まれた場合、または呼び出し元のアプリケーション ドメインの読み込みパスは、対象のアプリケーション ドメインを例外の異なるなど[CreateInstanceFrom メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.MissingMethodException>発生することができます。  
  
-   呼び出し元のアプリケーション ドメインが、インスタンスの型を事前バインディングされた呼び出しを行う場合[CreateInstanceFrom メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.InvalidCastException>インスタンスにキャストしようとしましたがときにスローされることができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。  
  
 または  
  
 <paramref name="securityAttributes" /> が <see langword="null" /> ではありません。 レガシ CAS ポリシーが有効でない場合は、<paramref name="securityAttributes" /> を <see langword="null" /> にする必要があります。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyFile" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスは <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要求された型を定義するアセンブリのファイル名とパス。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>要求されたオブジェクト。<paramref name="typeName" /> が見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは便利なメソッドを結合する<xref:System.AppDomain.CreateInstanceFrom%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>です。 このメソッドは、既定のコンス トラクターを呼び出します`typeName`です。  
  
 詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName> メソッドを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">パラメーターなしのパブリック コンス トラクターは見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要求された型を定義するアセンブリのファイル名とパス。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します \(<see cref="P:System.Type.FullName" /> プロパティを参照\)。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアントでアクティブ化されるオブジェクトに関連します。クライアントのアクティブ化は、旧バージョンとの互換性のために保持されますが、新規の開発がないことをお勧めするレガシ テクノロジです。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>要求されたオブジェクト。<paramref name="typeName" /> が見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、便利な方法を組み合わせた<xref:System.AppDomain.CreateInstanceFrom%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>です。 このメソッドは、既定のコンス トラクターを呼び出します`typeName`です。  
  
 この方法の詳細については、次を参照してください。、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">パラメーターなしのパブリック コンス トラクターは見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求された型を定義するアセンブリのファイル名とパス。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <c>typeName</c> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。<c>bindingAttr</c> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。<c>binder</c> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<c>args</c> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <c>args</c> から <c>typeName</c> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。型名の大文字と小文字の区別を無視するかどうか、作成する型を選択するために使用されるバインディング属性とバインダー、コンストラクターの引数、カルチャ、およびアクティベーション属性を指定します。</summary>
        <returns>要求されたオブジェクト。<paramref name="typeName" /> が見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは便利なメソッドを結合する[CreateInstanceFromAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.AppDomain.CreateInstanceFrom%2A>と[CreateInstanceFromAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>です。  
  
 この方法の詳細については、次を参照してください。、[CreateInstanceFromAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要求された型を定義するアセンブリのファイル名とパス。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <c>typeName</c> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。<c>bindingAttr</c> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。<c>binder</c> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<c>args</c> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <c>args</c> から <c>typeName</c> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
 このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <param name="securityAttributes">
          <c>typeName</c> の作成を承認するために使用される情報。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>要求されたオブジェクト。<paramref name="typeName" /> が見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは便利なメソッドを結合する[CreateInstanceFromAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.AppDomain.CreateInstanceFrom%2A>と[CreateInstanceFromAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>です。  
  
 この方法の詳細については、次を参照してください。、[CreateInstanceFromAndUnwrap メソッド \(String, String, Boolean, BindingFlags, Binder, Object\[\], CultureInfo, Object\<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">for the ability to read the file containing the assembly manifest. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Threading.Thread" /> に対する現在のアプリケーション ドメインを取得します。</summary>
        <value>現在のアプリケーション ドメイン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、新しいアプリケーション ドメインを作成します。<xref:System.AppDomain.CurrentDomain%2A>を取得するプロパティが使用される、<xref:System.AppDomain>を現在のアプリケーション ドメインを表すオブジェクト。<xref:System.AppDomain.FriendlyName%2A>プロパティは、コマンドラインで表示される現在のアプリケーション ドメインの名前を提供します。  
  
 [!code-cpp[ADApplicationBase\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリのアクセス モード。</param>
        <summary>名前とアクセス モードを指定して、動的アセンブリを定義します。</summary>
        <returns>名前とアクセス モードが指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.  
  
> [!NOTE]
>  During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=fullName> in **parameterReference tag is not supported!!!!**  
> . Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the **parameterReference tag is not supported!!!!**  
>  parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.  
  
   
  
## 例  
 The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  
  
 For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e).  
  
 [!code-cpp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリのアクセス モード。</param>
        <param name="assemblyAttributes">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</param>
        <summary>名前、アクセス モード、およびカスタム属性を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドのオーバー ロードを使用すると、正常に動作しない、動的アセンブリの作成時に適用される場合を除き、属性を指定します。 たとえば、セキュリティなどの属性 <xref:System.Security.SecurityTransparentAttribute> と <xref:System.Security.SecurityCriticalAttribute> 動的アセンブリを作成した後に追加されている場合に正常に機能しません。  
  
 このメソッドは、現在のアプリケーション ドメインで動的アセンブリを定義するときだけ使用する必要があります。 この制限の詳細については、次を参照してください。、 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバー ロードします。  
  
 このメソッドのオーバー ロードがで導入された、 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]です。  
  
   
  
## 例  
 次のコード サンプルを持つ動的アセンブリを作成する方法を示しています、 <xref:System.Security.SecurityTransparentAttribute>です。 属性は、配列の要素として指定する必要があります <xref:System.Reflection.Emit.CustomAttributeBuilder> オブジェクトです。  
  
 作成するのには、まず、 <xref:System.Reflection.Emit.CustomAttributeBuilder> では、属性のコンス トラクターを取得します。 コンス トラクターは、パラメーターを持たないため、 <xref:System.Type.GetConstructor%2A> メソッドには、空の配列が呼び出された <xref:System.Type> パラメーターの型を表すオブジェクト。 2 番目の手順では、その結果を渡す <xref:System.Reflection.ConstructorInfo> オブジェクトのコンス トラクターを <xref:System.Reflection.Emit.CustomAttributeBuilder> 型の空の配列とのクラス <xref:System.Object> に引数を表します。  
  
 結果の <xref:System.Reflection.Emit.CustomAttributeBuilder> に渡されます、 <xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドとして、配列の唯一の要素。  
  
 コード例では、新しい動的アセンブリのモジュールと型を定義し、アセンブリの属性を表示します。  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes\#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes\#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <see langword="Name" /> の <paramref name="name" /> 空白文字で始まるまたは前方または後方のスラッシュが含まれています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <summary>名前、アクセス モード、および証拠を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Only fully trusted callers can supply their **parameterReference tag is not supported!!!!**  
 when defining a dynamic <xref:System.Reflection.Assembly>. The runtime will map the <xref:System.Security.Policy.Evidence>through the security policy to determine the granted permissions. Partially trusted callers must supply a null **parameterReference tag is not supported!!!!**  
. If **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.  
  
 If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.  
  
 This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.  
  
> [!NOTE]
>  During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=fullName> in **parameterReference tag is not supported!!!!**  
> . Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the **parameterReference tag is not supported!!!!**  
>  parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.  
  
   
  
## 例  
 The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  
  
 First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  
  
 The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  
  
 [!code-cpp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">アセンブリを保存するディレクトリの名前。<c>dir</c> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</param>
        <summary>名前、アクセス モード、およびストレージ ディレクトリを指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.  
  
> [!NOTE]
>  During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=fullName> in **parameterReference tag is not supported!!!!**  
> . Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the **parameterReference tag is not supported!!!!**  
>  parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.  
  
   
  
## 例  
 The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  
  
 For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e).  
  
 [!code-cpp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリのアクセス モード。</param>
        <param name="assemblyAttributes">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</param>
        <param name="securityContextSource">セキュリティ コンテキストのソース。</param>
        <summary>名前、アクセス モード、カスタム属性、およびセキュリティ コンテキストのソースを指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドのオーバー ロードを使用すると、正常に動作しない、動的アセンブリの作成時に適用される場合を除き、属性を指定します。 たとえば、セキュリティなどの属性 <xref:System.Security.SecurityTransparentAttribute> と <xref:System.Security.SecurityCriticalAttribute> 動的アセンブリを作成した後に追加されている場合に正常に機能しません。  
  
 このメソッドは、現在のアプリケーション ドメインで動的アセンブリを定義するときだけ使用する必要があります。 この制限の詳細については、次を参照してください。、 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバー ロードします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <see langword="Name" /> の <paramref name="name" /> 空白文字で始まるまたは前方または後方のスラッシュが含まれています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">値 <paramref name="securityContextSource" /> でした列挙値のいずれかです。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">アセンブリを保存するディレクトリの名前。<c>dir</c> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、および証拠を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Only fully trusted callers can supply their **parameterReference tag is not supported!!!!**  
 when defining a dynamic <xref:System.Reflection.Assembly>. The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions. Partially trusted callers must supply a null **parameterReference tag is not supported!!!!**  
. If **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.  
  
 If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.  
  
 This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.  
  
> [!NOTE]
>  During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=fullName> in **parameterReference tag is not supported!!!!**  
> . Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the **parameterReference tag is not supported!!!!**  
>  parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.  
  
   
  
## 例  
 The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  
  
 For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e).  
  
 [!code-cpp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <summary>名前、アクセス モード、およびアクセス許可要求を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The permission requests specified for **parameterReference tag is not supported!!!!**  
, **parameterReference tag is not supported!!!!**  
, and **parameterReference tag is not supported!!!!**  
 are not used unless the dynamic assembly has been saved and reloaded into memory. To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.  
  
> [!NOTE]
>  During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=fullName> in **parameterReference tag is not supported!!!!**  
> . Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the **parameterReference tag is not supported!!!!**  
>  parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.  
  
 This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload .  
  
   
  
## 例  
 The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  
  
 For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e).  
  
 [!code-cpp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">動的アセンブリを保存するディレクトリの名前。<c>dir</c> が <see langword="null" /> の場合、現在のディレクトリが使用されます。</param>
        <param name="isSynchronized">動的アセンブリ内のモジュール、型、およびメンバーの作成を同期する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="assemblyAttributes">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、および同期オプションを指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドのオーバー ロードを使用すると、正常に動作しない、動的アセンブリの作成時に適用される場合を除き、属性を指定します。 たとえば、セキュリティなどの属性 <xref:System.Security.SecurityTransparentAttribute> と <xref:System.Security.SecurityCriticalAttribute> 動的アセンブリを作成した後に追加されている場合に正常に機能しません。  
  
 場合 `isSynchronized` は `true`, 、結果の次のメソッド <xref:System.Reflection.Emit.AssemblyBuilder> を同期する: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, 、<xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, 、<xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, 、<xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, 、<xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 、および <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>です。 これらのメソッドの 2 つは、異なるスレッドで呼び出されると、1 つは、もう一方が完了するまでブロックします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <see langword="Name" /> の <paramref name="name" /> 空白文字で始まるまたは前方または後方のスラッシュが含まれています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <summary>名前、アクセス モード、証拠、およびアクセス許可要求を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The permission requests specified for **parameterReference tag is not supported!!!!**  
, **parameterReference tag is not supported!!!!**  
, and **parameterReference tag is not supported!!!!**  
 are used only if **parameterReference tag is not supported!!!!**  
 is also supplied, or if the dynamic assembly is saved and reloaded into memory.  
  
> [!NOTE]
>  During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=fullName> in **parameterReference tag is not supported!!!!**  
> . Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the **parameterReference tag is not supported!!!!**  
>  parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.  
  
 Only fully trusted callers can supply their **parameterReference tag is not supported!!!!**  
 when defining a dynamic <xref:System.Reflection.Assembly>. The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions. Partially trusted callers must supply a null **parameterReference tag is not supported!!!!**  
. If **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.  
  
 If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.  
  
 This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.  
  
   
  
## 例  
 The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  
  
 For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e).  
  
 [!code-cpp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">アセンブリを保存するディレクトリの名前。<c>dir</c> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、およびアクセス許可要求を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定されたアクセス許可要求 `requiredPermissions`, 、`optionalPermissions`, 、および `refusedPermissions` 動的アセンブリに保存され、メモリに読み込み以外は使用できません。 ディスクのオーバー ロードを使用することはありません保存されている一時アセンブリのアクセス許可要求を指定する、 <xref:System.AppDomain.DefineDynamicAssembly%2A> としても、要求されたアクセス許可、および供給証拠を指定するメソッド、 <xref:System.Security.Policy.Evidence> オブジェクトです。  
  
> [!NOTE]
>  動的アセンブリを生成するコードの開発時にお勧めのオーバー ロードを使用すること、 <xref:System.AppDomain.DefineDynamicAssembly%2A> 証拠とアクセス許可を指定するメソッドがあり、含めるを動的アセンブリを作成証拠を提供 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=fullName> で `refusedPermissions`します。 含む <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> で、 `refusedPermissions` パラメーターは、MSIL を検証することを保証します。 この技法の制限はまた、ある <xref:System.Security.SecurityException> が完全な信頼を要求するコードで使用する場合にスローされます。  
  
 このメソッドは、現在のアプリケーション ドメインで動的アセンブリを定義するのみ使用する必要があります。 詳細については、次を参照してください。、 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバー ロードします。  
  
   
  
## 例  
 次のサンプルでは、 <xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドと <xref:System.AppDomain.AssemblyResolve> イベントです。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 アセンブリの完全修飾名を取得する方法については、次を参照してください。 [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e)します。  
  
 [!code-cpp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">アセンブリを保存するディレクトリの名前。<c>dir</c> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、証拠、およびアクセス許可要求を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The permission requests specified for **parameterReference tag is not supported!!!!**  
, **parameterReference tag is not supported!!!!**  
, and **parameterReference tag is not supported!!!!**  
 are used only if **parameterReference tag is not supported!!!!**  
 is also supplied, or if the dynamic assembly is saved and reloaded into memory.  
  
> [!NOTE]
>  During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=fullName> in **parameterReference tag is not supported!!!!**  
> . Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the **parameterReference tag is not supported!!!!**  
>  parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.  
  
 Only fully trusted callers can supply their **parameterReference tag is not supported!!!!**  
 when defining a dynamic <xref:System.Reflection.Assembly>. The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions. Partially trusted callers must supply a null **parameterReference tag is not supported!!!!**  
. If **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.  
  
 If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.  
  
 This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.  
  
   
  
## 例  
 The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  
  
 For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e).  
  
 [!code-cpp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">動的アセンブリを保存するディレクトリの名前。<c>dir</c> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <param name="isSynchronized">動的アセンブリ内のモジュール、型、およびメンバーの作成を同期する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、証拠、アクセス許可要求、および同期オプションを指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The permission requests specified for **parameterReference tag is not supported!!!!**  
, **parameterReference tag is not supported!!!!**  
, and **parameterReference tag is not supported!!!!**  
 are used only if **parameterReference tag is not supported!!!!**  
 is also supplied, or if the dynamic assembly is saved and reloaded into memory.  
  
> [!NOTE]
>  During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=fullName> in **parameterReference tag is not supported!!!!**  
> . Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the **parameterReference tag is not supported!!!!**  
>  parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.  
  
 Only fully trusted callers can supply their evidence when defining a dynamic <xref:System.Reflection.Assembly>. The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions. Partially trusted callers must supply **languageKeyword tag is not supported!!!!**  
 for the **parameterReference tag is not supported!!!!**  
 parameter. If **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.  
  
 If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.  
  
 If **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. If two of these methods are called on different threads, one will block until the other completes.  
  
   
  
## 例  
 The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  
  
 For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e).  
  
 [!code-cpp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain\_DefineDynamicAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">動的アセンブリを保存するディレクトリの名前。<c>dir</c> が <see langword="null" /> の場合、現在のディレクトリが使用されます。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <param name="isSynchronized">動的アセンブリ内のモジュール、型、およびメンバーの作成を同期する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="assemblyAttributes">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、証拠、アクセス許可要求、同期オプション、およびカスタム属性を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドのオーバー ロードを使用すると、正常に動作しない、動的アセンブリの作成時に適用される場合を除き、属性を指定します。 たとえば、セキュリティなどの属性 <xref:System.Security.SecurityTransparentAttribute> と <xref:System.Security.SecurityCriticalAttribute> 動的アセンブリを作成した後に追加されている場合に正常に機能しません。  
  
 指定されたアクセス許可要求、 `requiredPermissions`, 、`optionalPermissions`, と `refusedPermissions` 場合にのみパラメーターを使用、 `evidence` パラメーターも指定されている場合は、動的アセンブリが保存され、メモリに読み込み、またはです。  
  
> [!NOTE]
>  含めることをお勧め動的アセンブリを生成するコードを開発するときに、 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=fullName> フラグ、 `refusedPermissions` パラメーター。 このフラグを含めることにより、Microsoft 中間言語 \(MSIL\) が検証されます。 この手法では、意図せずに検証できないコードは、それ以外の場合は検出するために非常に困難の生成を検出します。 この技法の制限はまた、ある <xref:System.Security.SecurityException> が完全な信頼を要求するコードで使用している場合にスローされます。  
  
 動的なを定義するときに、完全に信頼された呼び出し元は証拠を提供できます専用 <xref:System.Reflection.Assembly>します。 ランタイムはマップ、 <xref:System.Security.Policy.Evidence> 付与されたアクセス許可を決定するセキュリティ ポリシーを使用します。 部分信頼の呼び出し元を指定する必要があります `null` の `evidence` パラメーター。 場合 `evidence` は `null`, 、ランタイムは、定義する場合、およびポリシーを解決済みとしてマークする動的アセンブリを呼び出し元のアセンブリから \(つまり、現在の付与とセットを拒否\) アクセス許可セットをコピーします。  
  
 動的アセンブリはその後、ディスクに保存の負荷が動的アセンブリを保存する場所に関連付けられているポリシーに基づいて付与を取得します。  
  
 場合 `isSynchronized` は `true`, 、結果の次のメソッド <xref:System.Reflection.Emit.AssemblyBuilder> を同期する: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, 、<xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, 、<xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, 、<xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, 、<xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 、および <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>です。 これらのメソッドの 2 つは、異なるスレッドで呼び出されると、1 つは、もう一方が完了するまでブロックします。  
  
 このメソッドのオーバー ロードがで導入された、 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
 または  
  
 <see langword="Name" /> の <paramref name="name" /> 空白文字で始まるまたは前方または後方のスラッシュが含まれています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">呼び出すメソッドを指定するデリゲート。</param>
        <summary>指定したデリゲートで識別される、別のアプリケーション ドメイン内のコードを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `callBackDelegate` can specify a marshal\-by\-value, <xref:System.MarshalByRefObject>, or <xref:System.ContextBoundObject>.  
  
   
  
## 例  
 The following sample demonstrates using a static <xref:System.AppDomain.DoCallBack%2A> method.  
  
 [!code-cpp[AppDomain\_DoCallBack\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain\_DoCallBack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain\_DoCallBack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by value.  
  
 [!code-cpp[AppDomain\_DoCallBack\#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain\_DoCallBack\#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain\_DoCallBack\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by reference.  
  
 [!code-cpp[AppDomain\_DoCallBack\#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain\_DoCallBack\#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain\_DoCallBack\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインの初期化時にホストから提供されたドメイン マネージャーを取得します。</summary>
        <value>アプリケーション ドメインの初期化時にホストから提供されたドメイン マネージャーを表すオブジェクト。ドメイン マネージャーが提供されなかった場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 An unmanaged host of the common language runtime \(CLR\) can provide a domain manager. The domain manager can participate in initializing the new application domain and supply other managers, such as a <xref:System.Security.HostSecurityManager>, that participate in the operations of the application domain.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.AppDomain" /> をアンロードしようとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.EventHandler> delegate for this event can perform any termination activities before the application domain is unloaded.  
  
 Each application domain that needs to perform processing when it is unloaded should register an event handler for this event. A shared event handler should not be used, because the <xref:System.EventHandler> delegate does not identify the domain that is being unloaded.  
  
> [!NOTE]
>  This event is never raised in the default application domain.  
  
 Do not make assumptions about the thread the event is raised on. The event can be raised on a different thread than the one that called the <xref:System.AppDomain.Unload%2A> method.  
  
 For more information about handling events, see [Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的に作成されたアセンブリを探すためにアセンブリ リゾルバーが使用するディレクトリを取得します。</summary>
        <value>動的に作成されたアセンブリを探すためにアセンブリ リゾルバーが使用するディレクトリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 To set the dynamic directory, assign a base directory path to the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property of the <xref:System.AppDomainSetup> object that will be used to create the new application domain. The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> property, so the format of the base directory is **placeholder tag is not supported!!!!**  
\\**placeholder tag is not supported!!!!**  
. The dynamic directory is a subdirectory of this base directory. Its simple name is the value of the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> property, so its format is **placeholder tag is not supported!!!!**  
\\**placeholder tag is not supported!!!!**  
\\**placeholder tag is not supported!!!!**  
.  
  
   
  
## 例  
 The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  
  
 The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to "Example" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to "C:\\DynamicAssemblyDir". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  
  
> [!NOTE]
>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  
  
 The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the <xref:System.AppDomain.DynamicDirectory%2A> property to retrieve the name of the directory, so it can create the directory. \(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.\)  
  
 The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method \(**languageKeyword tag is not supported!!!!**  
 method in Visual Basic\) named `HelloFromAD`. Calling this method displays the name of the application domain.  
  
 The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  
  
 You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  
  
 [!code-cpp[ADDynamicBase\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path information. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアプリケーション ドメインに関連付けられている <see cref="T:System.Security.Policy.Evidence" /> を取得します。</summary>
        <value>このアプリケーション ドメインに関連付けられた証拠。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <summary>指定したファイルに格納されているアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、 <xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。 使用してアセンブリを実行することも、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを読み込み、 <xref:System.Reflection.Assembly.Load%2A> メソッドです。  
  
 作成する、 <xref:System.AppDomain> を読み込み、実行を使用して、 <xref:System.AppDomain.CreateDomain%2A> メソッドです。  
  
   
  
## 例  
 次のサンプルでは 1 つのオーバー ロードを使用して <xref:System.AppDomain.ExecuteAssembly%2A> 2 つの異なるドメインにあります。  
  
 [!code-cpp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="assemblyFile" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>指定したファイルに格納されているアセンブリを、指定した証拠を使用して実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 <xref:System.AppDomain.ExecuteAssembly%2A> メソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、 <xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。 使用してアセンブリを実行することも、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを読み込み、 <xref:System.Reflection.Assembly.Load%2A> メソッドです。  
  
   
  
## 例  
 次のサンプルでは 1 つのオーバー ロードを使用して <xref:System.AppDomain.ExecuteAssembly%2A> 2 つの異なるドメインにあります。  
  
 [!code-cpp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="assemblyFile" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <param name="args">アセンブリのエントリ ポイントに渡す引数。</param>
        <summary>指定したファイルに格納されているアセンブリを、指定した引数を使用して実行します。</summary>
        <returns>アセンブリのエントリ ポイントから返された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、 <xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。 使用してアセンブリを実行することも、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを読み込み、 <xref:System.Reflection.Assembly.Load%2A> メソッドです。  
  
   
  
## 例  
 次のサンプルでは 1 つのオーバー ロードを使用して <xref:System.AppDomain.ExecuteAssembly%2A> 2 つの異なるドメインにあります。  
  
 [!code-cpp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <param name="assemblySecurity">アセンブリに指定する証拠。</param>
        <param name="args">アセンブリのエントリ ポイントに渡す引数。</param>
        <summary>指定したファイルに格納されているアセンブリを、指定した証拠と引数を使用して実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、 <xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。 使用してアセンブリを実行することも、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを読み込み、 <xref:System.Reflection.Assembly.Load%2A> メソッドです。  
  
   
  
## 例  
 次のサンプルでは 1 つのオーバー ロードを使用して <xref:System.AppDomain.ExecuteAssembly%2A> 2 つの異なるドメインにあります。  
  
 [!code-cpp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="assemblyFile" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> <see langword="null" />です。 レガシーの CAS ポリシーが有効でない場合 <paramref name="assemblySecurity" /> べき <see langword="null" />します。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <param name="args">アセンブリのエントリ ポイントに渡す引数。</param>
        <param name="hashValue">計算されたハッシュ コードの値を表します。</param>
        <param name="hashAlgorithm">アセンブリ マニフェストが使用するハッシュ アルゴリズムを表します。</param>
        <summary>指定したファイルに格納されているアセンブリを、指定した引数、ハッシュ値、およびハッシュ アルゴリズムを使用して実行します。</summary>
        <returns>アセンブリのエントリ ポイントから返された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、 [ExecuteAssembly メソッド \(String, String\[\], Byte\<xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。 使用してアセンブリを実行することも、 [ExecuteAssembly メソッド \(String, String\[\], Byte\<xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを読み込み、 [ExecuteAssembly メソッド \(String, String\[\], Byte\<xref:System.Reflection.Assembly.Load%2A> メソッドです。  
  
   
  
## 例  
 次のサンプルでは 1 つのオーバー ロードを使用して [ExecuteAssembly メソッド \(String, String\[\], Byte\<xref:System.AppDomain.ExecuteAssembly%2A> 2 つの異なるドメインにあります。  
  
 [!code-cpp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <param name="assemblySecurity">アセンブリに指定する証拠。</param>
        <param name="args">アセンブリのエントリ ポイントに渡す引数。</param>
        <param name="hashValue">計算されたハッシュ コードの値を表します。</param>
        <param name="hashAlgorithm">アセンブリ マニフェストが使用するハッシュ アルゴリズムを表します。</param>
        <summary>指定したファイルに格納されているアセンブリを、指定した証拠、引数、ハッシュ値、およびハッシュ アルゴリズムを使用して実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、 [ExecuteAssembly メソッド \(String, Evidence, String\[\], Byte\<xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。 使用してアセンブリを実行することも、 [ExecuteAssembly メソッド \(String, Evidence, String\[\], Byte\<xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを読み込み、 [ExecuteAssembly メソッド \(String, Evidence, String\[\], Byte\<xref:System.Reflection.Assembly.Load%2A> メソッドです。  
  
   
  
## 例  
 次のサンプルのオーバー ロードのいずれかの使用例 [ExecuteAssembly メソッド \(String, Evidence, String\[\], Byte\<xref:System.AppDomain.ExecuteAssembly%2A> 2 つの異なるドメインにあります。  
  
 [!code-cpp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain\_ExecuteAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="assemblyFile" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> <see langword="null" />です。 レガシーの CAS ポリシーが有効でない場合 <paramref name="assemblySecurity" /> べき <see langword="null" />します。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <summary>表示名を指定してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドと同様の機能を提供する、 <xref:System.AppDomain.ExecuteAssembly%2A> メソッドは、表示名でアセンブリを指定する、または <xref:System.Reflection.AssemblyName> ファイルの場所ではなく。 したがって、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> を持つアセンブリを読み込み、 <xref:System.Reflection.Assembly.Load%2A> メソッドではなく、 <xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。  
  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
 作成する、 <xref:System.AppDomain> を読み込み、実行を使用して、 <xref:System.AppDomain.CreateDomain%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定したアセンブリ <paramref name="assemblyName" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">指定したアセンブリ <paramref name="assemblyName" /> 有効なアセンブリではありません。  
  
 または  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="assemblyName" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <exception cref="T:System.IO.FileLoadException">指定したアセンブリ <paramref name="assemblyName" /> が検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for access to a Web site, when a display name is redirected to a URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの名前を表す <see cref="T:System.Reflection.AssemblyName" /> オブジェクト。</param>
        <param name="args">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> を指定し、指定された引数を使用してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントから返された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドと同様の機能を提供する、 <xref:System.AppDomain.ExecuteAssembly%2A> メソッドは、表示名でアセンブリを指定する、または <xref:System.Reflection.AssemblyName> ファイルの場所ではなく。 したがって、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> を持つアセンブリを読み込み、 <xref:System.Reflection.Assembly.Load%2A> メソッドではなく、 <xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。  
  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">指定したアセンブリ <paramref name="assemblyName" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">指定したアセンブリ <paramref name="assemblyName" /> が検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.BadImageFormatException">指定したアセンブリ <paramref name="assemblyName" /> 有効なアセンブリではありません。  
  
 または  
  
 <paramref name="assemblyName" /> 現在読み込まれているバージョンより後の共通言語ランタイムのバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for access to a Web site, when a display name is redirected to a URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>表示名を指定し、指定された証拠を使用してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドと同様の機能を提供する、 <xref:System.AppDomain.ExecuteAssembly%2A> メソッドは、表示名でアセンブリを指定する、または <xref:System.Reflection.AssemblyName> ファイルの場所ではなく。 したがって、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> を持つアセンブリを読み込み、 <xref:System.Reflection.Assembly.Load%2A> メソッドではなく、 <xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。  
  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
> [!NOTE]
>  使用すると、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを <xref:System.Security.Policy.Evidence> パラメーターの証拠がマージされます。 引数として指定された証拠の部分、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドがの証拠をローダーによって提供されるよりも優先されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定したアセンブリ <paramref name="assemblyName" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">指定したアセンブリ <paramref name="assemblyName" /> が検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.BadImageFormatException">指定したアセンブリ <paramref name="assemblyName" /> 有効なアセンブリではありません。  
  
 または  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="assemblyName" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">for access to a Web site, when a display name is redirected to a URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="args">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>表示名を指定し、指定された引数を使用してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントから返された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドと同様の機能を提供する、 <xref:System.AppDomain.ExecuteAssembly%2A> メソッドは、表示名でアセンブリを指定する、または <xref:System.Reflection.AssemblyName> ファイルの場所ではなく。 したがって、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> を持つアセンブリを読み込み、 <xref:System.Reflection.Assembly.Load%2A> メソッドではなく、 <xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。  
  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定したアセンブリ <paramref name="assemblyName" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">指定したアセンブリ <paramref name="assemblyName" /> が検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.BadImageFormatException">指定したアセンブリ <paramref name="assemblyName" /> 有効なアセンブリではありません。  
  
 または  
  
 <paramref name="assemblyName" /> 現在読み込まれているバージョンより後の共通言語ランタイムのバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for access to a Web site, when a display name is redirected to a URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの名前を表す <see cref="T:System.Reflection.AssemblyName" /> オブジェクト。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <param name="args">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> を指定し、指定された証拠および引数を使用してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドと同様の機能を提供する、<xref:System.AppDomain.ExecuteAssembly%2A>メソッドは、表示名でアセンブリを指定する、または<xref:System.Reflection.AssemblyName>ファイルの場所ではなく、します。 したがって、<xref:System.AppDomain.ExecuteAssemblyByName%2A>でアセンブリを読み込む、<xref:System.Reflection.Assembly.Load%2A>メソッドではなく、<xref:System.Reflection.Assembly.LoadFile%2A>メソッドです。  
  
 アセンブリが .NET Framework ヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッドにエントリ ポイント メソッドは実行されません。  
  
> [!NOTE]
>  使用すると、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドの置き換えの証拠をローダーによって指定します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> によって指定したアセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。  
  
 または  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> が <see langword="null" /> ではありません。 レガシ CAS ポリシーが有効でない場合は、<paramref name="assemblySecurity" /> を <see langword="null" /> にする必要があります。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">for access to a Web site, when a display name is redirected to a URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <param name="args">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>表示名を指定し、指定された証拠および引数を使用してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドと同様の機能を提供する、 <xref:System.AppDomain.ExecuteAssembly%2A> メソッドは、表示名でアセンブリを指定する、または <xref:System.Reflection.AssemblyName> ファイルの場所ではなく。 したがって、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> を持つアセンブリを読み込み、 <xref:System.Reflection.Assembly.Load%2A> メソッドではなく、 <xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。  
  
 アセンブリは、.NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスやアプリケーション ドメインは作成しませんし、新しいスレッド上でのエントリ ポイント メソッドは実行されません。  
  
> [!NOTE]
>  使用すると、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを <xref:System.Security.Policy.Evidence> パラメーターの証拠がマージされます。 引数として指定された証拠の部分、 <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドがの証拠をローダーによって提供されるよりも優先されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定したアセンブリ <paramref name="assemblyName" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">指定したアセンブリ <paramref name="assemblyName" /> が検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.BadImageFormatException">指定したアセンブリ <paramref name="assemblyName" /> 有効なアセンブリではありません。  
  
 または  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="assemblyName" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> <see langword="null" />です。 レガシーの CAS ポリシーが有効でない場合 <paramref name="assemblySecurity" /> べき <see langword="null" />します。</exception>
        <exception cref="T:System.MissingMethodException">指定したアセンブリには、エントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">for access to a Web site, when a display name is redirected to a URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">to execute a console application. Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメイン内の例外ハンドラーに対する呼び出し履歴をランタイムが検索する前に、マネージ コード内で例外がスローされた場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、通知のみです。 このイベントを処理例外を処理またはしません後続の例外を任意の方法で処理に影響します。 イベントが発生したイベント ハンドラーが呼び出されて、例外のハンドラーを検索する共通言語ランタイム \(CLR\) が開始されます。<xref:System.AppDomain.FirstChanceException>任意のマネージ例外を確認する最初の機会をアプリケーション ドメインを提供します。  
  
 イベントは、アプリケーション ドメインごとに処理できます。 スレッドが呼び出しの実行中の複数のアプリケーション ドメインを通過、CLR は、そのアプリケーション ドメイン内に一致する例外ハンドラーの検索を開始する前に、イベント ハンドラーに登録されているアプリケーション ドメインごとに、イベントが発生します。 イベントが処理された後は、そのアプリケーション ドメイン内に一致する例外ハンドラーの検索が行われます。 いずれも見つからない場合、イベントは、\[次へ\] のアプリケーション ドメインで発生します。  
  
 イベントのハンドラーで発生するすべての例外を処理する必要があります、<xref:System.AppDomain.FirstChanceException>イベント。 それ以外の場合、<xref:System.AppDomain.FirstChanceException>発生を再帰的には、します。 これは、結果、スタック オーバーフローやアプリケーションが終了します。 例外の通知の処理中に、仮想マシンに影響を与えるからメモリ不足やスタック オーバーフローなどのインフラストラクチャに関連する例外を保持する、制約された実行領域 \(Cer\) として、このイベントに対するイベント ハンドラーを実装することをお勧めします。  
  
 このイベントがない場合は、イベント ハンドラーがセキュリティ クリティカルは、アクセス違反などのプロセスの状態の破損を示す例外の発生しません、<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>属性。  
  
 共通言語ランタイムは、この通知イベントを処理しているときに、スレッドの中止を中断します。  
  
   
  
## 例  
 次の例では、アプリケーション ドメインがという名前の系列`AD0`を通じて`AD3`で、`Worker`各アプリケーション ドメイン内のオブジェクト。 各`Worker`オブジェクトへの参照には、`Worker`を除き、\[次へ\] のアプリケーション ドメイン内のオブジェクト、`Worker`最後のアプリケーション ドメインでします。<xref:System.AppDomain.FirstChanceException>以外のすべてのアプリケーション ドメインでイベントを処理`AD1`です。  
  
> [!NOTE]
>  この例では、複数のアプリケーション ドメインで初回例外通知を示しています、だけでなく単純なユース ケースが見つかります[How to: Receive First\-Chance Exception Notifications](http://msdn.microsoft.com/ja-jp/66f002b8-a97d-4a6e-a503-2cec01689113)です。  
  
 アプリケーション ドメインが作成されると、既定のアプリケーション ドメインを呼び出す、`TestException`メソッドの最初のアプリケーション ドメイン。 各`Worker`オブジェクトの呼び出し、`TestException`メソッドの最後まで、\[次へ\] のアプリケーション ドメインの`Worker`が処理または未処理の例外をスローします。 現在のスレッドが、すべてのアプリケーション ドメインを通過するため、および`TestException`が各アプリケーション ドメイン内のスタックに追加します。  
  
 ときに、最後`Worker`オブジェクト、例外を処理する、<xref:System.AppDomain.FirstChanceException>イベントは、アプリケーションの最後のドメインでのみ発生します。 他のアプリケーション ドメインでは、イベントが発生していないために、例外を処理するされなくなります。  
  
 ときに、最後`Worker`オブジェクトが例外を処理していない、<xref:System.AppDomain.FirstChanceException>をイベント ハンドラーを持つアプリケーション ドメインごとにイベントが発生します。 各イベント ハンドラーが完了したら、既定のアプリケーション ドメインによって、例外がキャッチされるまでをアンワインドするスタックが続行されます。  
  
> [!NOTE]
>  ようにこのイベントは近くの履歴の表示の成長と既定のアプリケーション ドメインに近いを表示する変更`e.Exception.Message`に`e.Exception`で、`FirstChanceHandler`イベント ハンドラー。 場合に`TestException`と呼ばれるアプリケーション ドメインの境界を越えて 2 回表示されます。 プロキシとスタブの 1 回です。  
  
 [!code-csharp[System.AppDomain.FirstChanceException\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインの表示名を取得します。</summary>
        <value>アプリケーション ドメインの表示名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のアプリケーション ドメインのフレンドリ名は、プロセス実行可能ファイルのファイルの名前です。 たとえば、プロセスを開始する実行可能ファイルが使用されている場合は`"c:\MyAppDirectory\MyAssembly.exe"`、既定のアプリケーション ドメインのフレンドリ名は`"MyAssembly.exe"`します。  
  
   
  
## 例  
 次のコード例では、<xref:System.AppDomain.FriendlyName%2A>現在のアプリケーション ドメインのフレンドリ名を取得するプロパティです。 既定のアプリケーション ドメインのフレンドリ名は、アプリケーションの実行可能ファイルの名前です。 このコード例では、アプリケーション ドメインに関する追加情報も表示されます。  
  
 [!code-cpp[ADApplicationBase\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーション ドメインの実行コンテキストに読み込まれているアセンブリを取得します。</summary>
        <returns>アプリケーション ドメイン内のアセンブリの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、<xref:System.AppDomain.GetAssemblies%2A>アプリケーション ドメインに読み込まれているすべてのアセンブリの一覧を取得します。 アセンブリは、コンソールに表示されます。  
  
 このコード例を実行するという名前のアセンブリを作成する必要があります。 `CustomLibrary.dll`、に渡されるアセンブリ名を変更したり、<xref:System.AppDomain.GetAssemblies%2A>メソッドです。  
  
 [!code-cpp[ADGetAssemblies\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドの識別子を取得します。</summary>
        <returns>現在のスレッドの識別子を表す 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>が安定していて、.NET Framework がファイバー \(簡易スレッドは、\) をサポートする環境でホストされている場合にも、プロパティです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to call this method. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">あらかじめ定義されたアプリケーション ドメイン プロパティの名前、または独自に定義したアプリケーション ドメイン プロパティの名前。</param>
        <summary>現在のアプリケーション ドメイン内に格納されている、指定した名前の値を取得します。</summary>
        <returns>
          <paramref name="name" /> プロパティの値。プロパティが存在しない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このインスタンスのプロパティを説明する名前とデータのペアの内部キャッシュのエントリの値を取得するには、このメソッドを使用して<xref:System.AppDomain>です。 なおの比較`name`キー\/値ペアの名前は大文字小文字を区別します。  
  
 キャッシュには、アプリケーション ドメインの作成時に挿入される定義済みのシステム エントリに自動的に含まれています。 その値を検査することができます、<xref:System.AppDomain.GetData%2A>メソッド、またはそれと同等<xref:System.AppDomainSetup>プロパティです。  
  
 挿入またはで独自ユーザー定義の名前とデータの組み合わせを変更することができます、<xref:System.AppDomain.SetData%2A>メソッドとその値を検査し、<xref:System.AppDomain.GetData%2A>メソッドです。  
  
 次の表、`name`それぞれのシステムのエントリとそれに対応する定義済みの<xref:System.AppDomainSetup>プロパティです。  
  
|'Name' の値|プロパティ|  
|---------------|-----------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|  
|"APP\_CONFIG\_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|  
|"APP\_LAUNCH\_URL"|\(プロパティはありません\)<br /><br /> "APP\_LAUNCH\_URL"では、最初にリダイレクトする前に、ユーザーが要求した URL を表します。 使用可能なは、アプリケーションが Internet Explorer などのブラウザーで起動されたときだけです。 すべてのブラウザーでは、この値を提供します。|  
|"APP\_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|  
|"BINPATH\_PROBE\_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|  
|"CACHE\_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|  
|"CODE\_DOWNLOAD\_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|  
|"DEV\_PATH"|\(プロパティはありません\)|  
|"DISALLOW\_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|  
|"DISALLOW\_APP\_BASE\_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|  
|"DISALLOW\_APP\_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|  
|"DYNAMIC\_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|  
|"FORCE\_CACHE\_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|  
|"LICENSE\_FILE"、またはアプリケーションに固有の文字列|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|  
|"LOADER\_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|  
|"LOCATION\_URI"|\(プロパティはありません\)|  
|「場合」|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|  
|"REGEX\_DEFAULT\_MATCH\_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName><br /><br /> "REGEX\_DEFAULT\_MATCH\_TIMEOUT"はシステムのエントリではありませんし、呼び出すことによってその値を設定することができます、<xref:System.AppDomain.SetData%2A>メソッドです。|  
|"SHADOW\_COPY\_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|  
  
   
  
## 例  
 次の例は、新しいアプリケーション ドメインを作成、ドメインのシステム指定の値を設定し、ドメインの新しい値のペアを追加します。 例は、使用する方法を示します、<xref:System.AppDomain.GetData%2A>これら値のペアからデータを取得し、それらをコンソールに表示します。  
  
 [!code-cpp[ADGetData\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the information in the path itself, if the property applies to a path. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスの型を取得します。</summary>
        <returns>現在のインスタンスの型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセス内のアプリケーション ドメインを一意に識別する整数を取得します。</summary>
        <value>アプリケーション ドメインを識別する整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、2 つ目のアプリケーション ドメインを作成し、既定のドメインと、新しいドメインに関する情報を表示します。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リースが作成されないようにすることで、<see cref="T:System.AppDomain" /> に無期限の有効期間を指定します。</summary>
        <returns>常に <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">テストする互換性スイッチ。</param>
        <summary>いずれかの互換性スイッチが設定されているかどうか、設定されている場合は指定の互換性スイッチが設定されているかどうかを示す、null 許容のブール値を取得します。</summary>
        <returns>互換性スイッチが設定されていない場合は null 参照 \(Visual Basic では <see langword="Nothing" />\)。それ以外の場合は、<paramref name="value" /> で指定された互換性スイッチが設定されているかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior \(such as the way strings are sorted\) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  
  
 The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  
  
|Switch|Meaning|  
|------------|-------------|  
|"NetFx40\_LegacySecurityPolicy"|Code access security \(CAS\) for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain. See [\<NetFx40\_LegacySecurityPolicy\> Element](http://msdn.microsoft.com/ja-jp/07132b9c-4a72-4710-99d7-e702405e02d4).|  
|"NetFx40\_Legacy20SortingBehavior"|String sorting defaults for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\<CompatSortNLSVersion\> Element](http://msdn.microsoft.com/ja-jp/782cc82e-83f7-404a-80b7-6d3061a8b6e3).|  
|"NetFx40\_Legacy40SortingBehavior"|String sorting defaults for the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  
|"NetFx40\_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\<TimeSpan\_LegacyFormatMode\> Element](http://msdn.microsoft.com/ja-jp/865e7207-d050-4442-b574-57ea29d5e2d6) and the "Restoring Legacy TimeSpan Formatting" section of the <xref:System.TimeSpan> topic.|  
|"UseRandomizedStringHashAlgorithm"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\<UseRandomizedStringHashAlgorithm\> Element](http://msdn.microsoft.com/ja-jp/c08125d6-56cc-4b23-b482-813ff85dc630).|  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーション ドメインが、プロセスの既定のアプリケーション ドメインであるかどうかを示す値を返します。</summary>
        <returns>現在の <see cref="T:System.AppDomain" /> オブジェクトがプロセスの既定のアプリケーション ドメインを表す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 すべてのマネージ プロセスでは、既定のアプリケーション ドメインを持ちます。 既定のドメインで実行が開始されます。  
  
   
  
## 例  
 次のコード例では、2 つ目のアプリケーション ドメインを作成し、既定のドメインと、新しいドメインに関する情報を表示します。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアプリケーション ドメインがアンロード中で、これに含まれるオブジェクトが共通言語ランタイムによって終了処理されているかどうかを示します。</summary>
        <returns>アプリケーション ドメインがアンロード中で、共通言語ランタイムがファイナライザーの呼び出しを既に開始している場合は <see langword="true" />。これ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オブジェクトのファイナライズ メソッドでは、オブジェクトがガベージ コレクトされる前に、必要なクリーンアップ操作を実行する機会を提供します。 終了後、オブジェクトにはアクセスできが、無効な状態で使用できないためです。 最終的には、ガベージ コレクションが完了し、オブジェクトを解放します。  
  
 オブジェクトのファイナライズ メソッドは、次の状況のいずれかで: ガベージ コレクション中に、共通言語ランタイムがシャット ダウンするとき、またはオブジェクトを含むアプリケーション ドメインがアンロードされます。<xref:System.AppDomain.IsFinalizingForUnload%2A> メソッドが返す `true` 最後のケースでは、だけでは返されません `true` 終了処理ルーチンのガベージ コレクションまたは CLR シャット ダウンからの結果の場合。  
  
> [!NOTE]
>  終了処理の CLR シャット ダウンの原因であるかどうかを確認するのには、使用、 <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> プロパティです。 返す `true` 終了処理は、アプリケーション ドメインがアンロードされるため、CLR がシャット ダウンする場合。  
  
 ドメインのアンロード中、終了メソッドで実行中には、静的フィールドによって参照され、終了メソッドを持つ別のオブジェクトにアクセスすることができます。 ただし、できないに確実にこれを行うアクセス先のオブジェクトが既にファイナライズされているためです。  
  
> [!NOTE]
>  ただし、このルールは、 <xref:System.Console> クラスでは、ストリーム オブジェクトを参照する静的フィールドが含まれていますが実装されているは、常に、ドメインのアンロード、またはシステムのシャット ダウンのときでも、システム コンソールに書き込むことができますので特別です。  
  
 オブジェクトを含むアプリケーション ドメインがアンロード中かどうかを決定するのにオブジェクトのファイナライズ メソッドでこのメソッドを使用します。 場合は、終了メソッドを持ち、静的フィールドにより参照されるオブジェクトを確実にアクセスできません。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーション ドメインに読み込まれたアセンブリが、完全に信頼された状態で実行されるかどうかを示す値を取得します。</summary>
        <value>現在のアプリケーション ドメインに読み込まれたアセンブリが、完全に信頼された状態で実行される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは常に返します`true`デスクトップ上で実行されるアプリケーションの既定のアプリケーション ドメイン。 返します`false`サンド ボックス アプリケーション ドメインを使用して作成されたため、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=fullName>アプリケーション ドメインに与えられているアクセス許可が完全信頼に等価でない場合、メソッドのオーバー ロードします。  
  
   
  
## 例  
 次の例で、<xref:System.AppDomain.IsFullyTrusted%2A>プロパティおよび<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName>完全に信頼できると部分的に信頼されたアプリケーション ドメインを持つプロパティです。 完全に信頼されたアプリケーション ドメインは、アプリケーションの既定のアプリケーション ドメインです。 使用して、部分的に信頼されたアプリケーション ドメインを作成、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=fullName>メソッドのオーバー ロードします。  
  
 この例では、`Worker`から派生するクラスを<xref:System.MarshalByRefObject>ので、アプリケーション ドメインの境界を越えてマーシャ リングすることができます。 例は、作成、`Worker`既定のアプリケーション ドメイン内のオブジェクト。 順に呼び出して、`TestIsFullyTrusted`アプリケーション ドメインに読み込まれている 2 つのアセンブリ、アプリケーション ドメインのプロパティ値を表示する方法: .NET Framework とアセンブリの一部である mscorlib です。 アプリケーション ドメインが、両方のアセンブリが完全に信頼されるように完全に信頼します。  
  
 例では、作成別`Worker`サンド ボックス アプリケーション ドメインと、もう一度呼び出し内のオブジェクト、`TestIsFullyTrusted`メソッドです。 Mscorlib は常に、信頼されても、部分的に信頼されたアプリケーション ドメインで、アセンブリは部分的に信頼されました。  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインに読み込まれたすべてのアセンブリに付与されるアクセス許可セットが、現在のアプリケーション ドメインに存在するかどうかを示す値を取得します。</summary>
        <value>一貫して付与されるアクセス許可セットが現在のアプリケーション ドメインに存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返します`true`のサンド ボックス化されたアプリケーション ドメインを使用して作成された、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=fullName>メソッドのオーバー ロードします。 サンド ボックス アプリケーション ドメインがある同種一連のアクセス許可です。つまり、同じ一連の権限は、アプリケーション ドメインに読み込まれているすべての部分的に信頼されたアセンブリに与えられます。 必要に応じて、サンド ボックス アプリケーション ドメインには、この権限セットにし、代わりに完全信頼で実行から除外されている厳密な名前のアセンブリの一覧があります。  
  
 完全信頼コードで使用できる、<xref:System.AppDomain.PermissionSet%2A>サンド ボックス アプリケーション ドメインの同種の許可セットを決定するプロパティです。  
  
 またこのプロパティを返します`true`デスクトップ アプリケーションの既定のアプリケーション ドメインのため、そのアプリケーション ドメインは、すべてのアセンブリに完全な信頼を付与します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージである <see langword="byte" /> 型配列。</param>
        <summary>生成された <see cref="T:System.Reflection.Assembly" /> を含む COFF \(Common Object File Format\) ベースのイメージを使用して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、このメソッドを使用して読み込まれたアセンブリの信頼レベルは、アプリケーション ドメインの信頼レベルと同じです。  
  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドは、静的なを呼び出すことができない相互運用性の呼び出し元の便宜を図って提供<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>メソッドです。 他のアプリケーション ドメインにアセンブリを読み込むなどの使用方法<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>です。  
  
 このメソッドのすべてのオーバー ロードするが一般的情報については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
   
  
## 例  
 次の例では、生のアセンブリの読み込みの使用を示します。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 アセンブリの完全修飾名を取得する方法については、次を参照してください。[Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e)です。  
  
 [!code-cpp[AppDomain\_LoadRaw\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain\_LoadRaw\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain\_LoadRaw\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">読み込むアセンブリについて記述しているオブジェクト。</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> を指定して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドは、静的なを呼び出すことができない相互運用性の呼び出し元の便宜を図って提供<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>メソッドです。 他のアプリケーション ドメインにアセンブリを読み込むなどの使用方法<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>です。  
  
 要求されたアセンブリのバージョンが既に読み込まれている場合、このメソッドは、別のバージョンが要求される場合でも、読み込まれたアセンブリを返します。  
  
 部分アセンブリ名を指定する`assemblyRef`はお勧めしません。 \(部分的な名前は、1 つまたは複数のカルチャ、バージョン、または公開キー トークンを省略します。 代わりに文字列を受け取るオーバー ロード、<xref:System.Reflection.AssemblyName>オブジェクト、"MyAssembly, バージョン 1.0.0.0 を \="部分的な名前の例に示しますと"MyAssembly, Version 1.0.0.0、カルチャを \= \= neutral, PublicKeyToken \= 18ab3442da84b47"完全名の例に示します\)。 名前の一部には、パフォーマンスに悪影響を及ぼすがあります。 さらに、部分的なアセンブリ名読み込むことができます、アセンブリをグローバル アセンブリ キャッシュからアプリケーションの基本ディレクトリ内のアセンブリの正確なコピーがある場合にのみ \(<xref:System.AppDomain.BaseDirectory%2A>または<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>\)。  
  
 場合、現在<xref:System.AppDomain>オブジェクトは、アプリケーション ドメインを表す`A`、および<xref:System.AppDomain.Load%2A>アプリケーション ドメインからメソッドを呼び出した`B`アセンブリは両方のアプリケーション ドメインに読み込まれます。 たとえば、次のコード負荷`MyAssembly`新しいアプリケーション ドメインに`ChildDomain`ともを実行すると、アプリケーション ドメイン。  
  
 [!code-cpp[System.AppDomain.Load\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 アセンブリが両方のドメインに読み込まれるため<xref:System.Reflection.Assembly>から派生していません<xref:System.MarshalByRefObject>、および戻り値のため、<xref:System.AppDomain.Load%2A>メソッドをマーシャ リングすることはできません。 代わりに、共通言語ランタイムが呼び出し元のアプリケーション ドメインにアセンブリをロードしようとします。 2 つのアプリケーション ドメインに読み込まれるアセンブリは、2 つのアプリケーション ドメインのパスの設定が異なる場合は異なる可能性があります。  
  
> [!NOTE]
>  両方の<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>プロパティおよび<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>プロパティが設定されて、アセンブリを読み込むには、最初の試行は、表示名を使用 \(によって返されるバージョン、カルチャ、およびなどを含む、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>プロパティ\)。 ファイルが見つからない場合、<xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティは、アセンブリの検索に使用します。 使用して、アセンブリが見つかった場合<xref:System.Reflection.AssemblyName.CodeBase%2A>表示名は、アセンブリと照合します。 一致が見つからない場合、<xref:System.IO.FileLoadException>がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> が有効なアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyRef" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <summary>表示名を指定して <see cref="T:System.Reflection.Assembly" /> を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドは、静的なを呼び出すことができない相互運用性の呼び出し元の便宜を図って提供<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>メソッドです。 他のアプリケーション ドメインにアセンブリを読み込むなどの使用方法<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>です。  
  
 このメソッドのすべてのオーバー ロードするが一般的情報については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> は <see langword="null" /> です</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は有効なアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyString" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for the ability to access the location of the assembly if the assembly is not local.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージである <see langword="byte" /> 型配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納している <see langword="byte" /> 型の配列。</param>
        <summary>生成された <see cref="T:System.Reflection.Assembly" /> を含む COFF \(Common Object File Format\) ベースのイメージを使用して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。<see cref="T:System.Reflection.Assembly" /> のシンボルを表す生バイトも読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 、このメソッドを使用して読み込まれるアセンブリの信頼レベルは、アプリケーション ドメインの信頼レベルと同じです。  
  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドは、静的に呼び出すことができないの相互運用性の呼び出し元の便利な機能として提供 [Load メソッド \(Byte\<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> メソッドです。 メソッドのなど、使用を他のアプリケーション ドメインにアセンブリを読み込む、 [Load メソッド \(Byte\<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>です。  
  
 このメソッドのすべてのオーバー ロードするが一般的情報については、次を参照してください。、 [Load メソッド \(Byte\<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバー ロードします。  
  
   
  
## 例  
 次の例では、生のアセンブリの読み込みの使用を示します。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 アセンブリの完全修飾名を取得する方法については、次を参照してください。 [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e)します。  
  
 [!code-cpp[AppDomain\_LoadRaw\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain\_LoadRaw\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain\_LoadRaw\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="rawAssembly" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">読み込むアセンブリについて記述しているオブジェクト。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> を指定して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドは、静的に呼び出すことができないの相互運用性の呼び出し元の便利な機能として提供 <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> メソッドです。 メソッドのなど、使用を他のアプリケーション ドメインにアセンブリを読み込む、 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>です。  
  
 このメソッドのすべてのオーバー ロードするが一般的情報については、次を参照してください。、 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> します。 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="assemblyRef" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">for reading a path that is not in the form "file:\/\/" or "\\\\UNC\\dir\\" or "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>表示名を指定して <see cref="T:System.Reflection.Assembly" /> を読み込みます。</summary>
        <returns>読み込まれるアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドは、静的に呼び出すことができないの相互運用性の呼び出し元の便利な機能として提供 <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> メソッドです。 メソッドのなど、使用を他のアプリケーション ドメインにアセンブリを読み込む、 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>です。  
  
 このメソッドのすべてのオーバー ロードするが一般的情報については、次を参照してください。、 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> します。 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="assemblyString" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for reading a path that is not in the form "file:\/\/" or "\\\\UNC\\dir\\" or "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージである <see langword="byte" /> 型配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納している <see langword="byte" /> 型の配列。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>生成された <see cref="T:System.Reflection.Assembly" /> を含む COFF \(Common Object File Format\) ベースのイメージを使用して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。<see cref="T:System.Reflection.Assembly" /> のシンボルを表す生バイトも読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 、このメソッドを使用して読み込まれるアセンブリの信頼レベルは、アプリケーション ドメインの信頼レベルと同じです。  
  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドは、静的に呼び出すことができないの相互運用性の呼び出し元の便利な機能として提供 [Load メソッド \(Byte\[\], Byte\<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> メソッドです。 メソッドのなど、使用を他のアプリケーション ドメインにアセンブリを読み込む、 [Load メソッド \(Byte\[\], Byte\<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>です。  
  
 このメソッドのすべてのオーバー ロードするが一般的情報については、次を参照してください。、 [Load メソッド \(Byte\[\], Byte\<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバー ロードします。  
  
   
  
## 例  
 次の例では、生のアセンブリの読み込みの使用を示します。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 アセンブリの完全修飾名を取得する方法については、次を参照してください。 [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e)します。  
  
 [!code-cpp[AppDomain\_LoadRaw\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain\_LoadRaw\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain\_LoadRaw\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="rawAssembly" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> <see langword="null" />です。 レガシーの CAS ポリシーが有効でない場合 <paramref name="securityEvidence" /> べき <see langword="null" />します。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">for reading a path that is not in the form "file:\/\/" or "\\\\UNC\\dir\\" or "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のプロセスに対して、アプリケーション ドメインの CPU およびメモリの監視が有効になっているかどうかを示す値を取得または設定します。 プロセスに対して一度有効にした監視を無効にすることはできません。</summary>
        <value>監視が有効になっている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、`static`プロパティ \(`Shared`プロパティ Visual Basic\) CPU およびメモリのプロセス内のすべてのアプリケーション ドメインの監視を制御します。  
  
 このプロパティを設定しようとする場合`false`、<xref:System.ArgumentException>プロパティの現在の値が場合でも、例外がスローされます`false`です。  
  
 監視を有効にするを使用して、 <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>、 <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>、 <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>、および<xref:System.AppDomain.MonitoringTotalProcessorTime%2A>インスタンスのプロパティの個々 のアプリケーション ドメインの CPU およびメモリの使用を監視します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のプロセスがこのプロパティに値 <see langword="false" /> を代入しようとしました。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最後のコレクションの実行後に残された、現在のアプリケーション ドメインによって参照されていることが判明しているバイト数を取得します。</summary>
        <value>残っているバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各ガベージ コレクションでは、統計が更新されます。 ただし、フル ブロッキング コレクションの後にのみ正確である保証は、つまり、すべてのジェネレーションが含まれていると、コレクションの中に、アプリケーションが停止するコレクションが発生します。 たとえば、<xref:System.GC.Collect?displayProperty=fullName>メソッドのオーバー ロードがフル ブロッキング コレクションを実行します。 \(同時実行コレクションはバック グラウンドで発生して、アプリケーションをブロックしません\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> \(Visual Basic では <see langword="Shared" />\) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティが <see langword="false" /> に設定されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最後のコレクションの実行後に残された、プロセス内のすべてのアプリケーション ドメインにおける合計バイト数を取得します。</summary>
        <value>プロセスに残っている合計バイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フル ブロッキング コレクションの後にこの番号は、バイト数は現在ライブで保持マネージ ヒープを使用します。 によって報告される数に近いことが、 <xref:System.GC.GetTotalMemory%2A> メソッドです。 短期コレクションの後にこの番号は、バイト数現在保持されている短期のジェネレーションにライブします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> \(Visual Basic では <see langword="Shared" />\) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティが <see langword="false" /> に設定されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインが作成されてから、そのアプリケーション ドメインで実行されたすべてのメモリ割り当ての合計サイズをバイト単位で取得します。収集されたメモリは差し引かれません。</summary>
        <value>すべてのメモリ割り当ての合計サイズ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> \(Visual Basic では <see langword="Shared" />\) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティが <see langword="false" /> に設定されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが開始されてから、現在のアプリケーション ドメインでの実行中にすべてのスレッドで使用された合計プロセッサ時間を取得します。</summary>
        <value>現在のアプリケーション ドメインの合計プロセッサ時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーション ドメインに報告されている合計時間には、プロセス内の各スレッドは、そのアプリケーション ドメインで実行に費やした時間が含まれます。  
  
 アンマネージ コードを呼び出すスレッドは、アプリケーション ドメインに関連付けられたままと、アンマネージ コードがアプリケーション ドメインの呼び出しが行われたレポートの実行に費やされたプロセッサ時間。  
  
 スレッドがブロックされているか、スリープ状態の場合は消費されない。 プロセッサ時間です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> \(Visual Basic では <see langword="Shared" />\) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティが <see langword="false" /> に設定されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サンドボックス化されたアプリケーション ドメインのアクセス許可セットを取得します。</summary>
        <value>サンドボックス化されたアプリケーション ドメインのアクセス許可セット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サンド ボックス アプリケーション ドメインを使用して作成された、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=fullName>メソッドのオーバー ロードがある同じアクセス許可セットです。 つまり、同じ一連の権限は、アプリケーション ドメインに読み込まれているすべての部分的に信頼されたアセンブリに許可されます。 必要に応じて、サンド ボックス アプリケーション ドメインには、この権限セットにし、代わりに完全信頼で実行から除外されている厳密な名前付きのアセンブリの一覧があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のアプリケーション ドメインの親プロセスが終了した場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.EventHandler>このイベントは、ファイルを閉じるなどの終了活動を実行できるを解放する記憶域など、プロセスが終了する前にします。  
  
 以降、.NET Framework version 2.0 では、このイベントはイベント ハンドラーを登録する各アプリケーション ドメインで発生します。  
  
> [!NOTE]
>  すべての総実行時間<xref:System.AppDomain.ProcessExit>イベント ハンドラーに制限はすべてのファイナライザーの合計実行時間がプロセスのシャット ダウン時に制限されます。 既定では 2 秒です。 アンマネージ ホストは呼び出すことによってこの実行時間を変更することができます、 [iclrpolicymanager::settimeout](http://msdn.microsoft.com/ja-jp/954404fd-d52d-4e68-b582-8692f3a5f608)メソッドを[OPR\_ProcessExit](http://msdn.microsoft.com/ja-jp/5aef6808-5aac-4b2f-a2c7-fee1575c55ed)列挙値。  
  
 .NET Framework バージョン 1.0 および 1.1 では、このイベントは既定のアプリケーション ドメインでのみ発生し、イベント ハンドラーが既定のアプリケーション ドメインに登録されている場合にのみ使用します。  
  
 このイベントのイベント ハンドラーを登録するには、必要なアクセス許可が必要、または<xref:System.Security.SecurityException>がスローされます。  
  
 イベント処理の詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リフレクション専用のコンテキストでアセンブリの解決に失敗した場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 リフレクションのみのコンテキスト内の依存関係が自動的に解決されません。 これらは、プリロードする必要があります。 またはこのイベントのハンドラーによって返されます。 このイベントは、アセンブリがリフレクションのみのコンテキストに既に読み込まれていない依存関係を持つときに発生します。 不明な依存関係が指定された、<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>プロパティです。<xref:System.ResolveEventHandler>のこのイベントは、依存関係を満たしているアセンブリを返す必要があります。 返されるアセンブリは、リフレクション専用コンテキストに読み込まれている必要があります。  
  
> [!IMPORTANT]
>  このイベントは、リフレクション専用コンテキストにロードしているアセンブリの依存関係の欠落に対してのみ \(たとえばを使用して、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>メソッド\)。 ロードしているアセンブリが見つからない場合は発生しません。  
  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>プロパティは、アセンブリを解決できないアセンブリの読み込みを要求したを返します。 要求元のアセンブリの id を知ることは、複数のバージョンが利用可能な場合は、依存関係の正しいバージョンを特定するに便利な場合があります。 詳細については、「<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>」を参照してください。  
  
 このイベントで、<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>プロパティは、ポリシーが適用される前に、アセンブリ名を返します。  
  
 イベント処理の詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーション ドメインのリフレクション専用コンテキストに読み込まれているアセンブリを返します。</summary>
        <returns>アプリケーション ドメインのリフレクション専用コンテキストに読み込まれているアセンブリを表す <see cref="T:System.Reflection.Assembly" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、リフレクションのみのコンテキストに読み込まれているアセンブリを返します。 実行するために読み込まれたアセンブリを取得する、 <xref:System.AppDomain.GetAssemblies%2A> メソッドです。  
  
   
  
## 例  
 次のコード例は、実行コンテキストにし、さらに、リフレクションのみのコンテキストに System.dll アセンブリを読み込みます。<xref:System.AppDomain.GetAssemblies%2A> と <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> メソッドを使用して、それぞれのコンテキストに読み込まれるアセンブリを表示します。  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">操作は、アンロードされたアプリケーション ドメインでしようとします。</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリ リゾルバーがプライベート アセンブリを探す場所を示す、ベース ディレクトリ以下のパスを取得します。</summary>
        <value>アセンブリ リゾルバーがプライベート アセンブリを探す場所を示す、ベース ディレクトリ以下のパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プライベート アセンブリは、アプリケーションと同じディレクトリ構造で展開されます。 パスによって指定される場合、<xref:System.AppDomain.RelativeSearchPath%2A>プロパティは <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>は無視されます。  
  
 このプロパティを使用して設定値を返します<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path information. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソースが正しくリンクされていなかったり、アセンブリに埋め込まれているなどの理由からリソースの解決に失敗した場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.ResolveEventHandler>のこのイベントは、リソースを含むアセンブリを見つけて返すことを試みることができます。  
  
> [!IMPORTANT]
>  有効なリンク リソースのファイルが見つからなかったために、解決が失敗した場合、このイベントは発生しません。 このイベントは、マニフェスト リソース ストリームが見つからない場合は、個々 のリソース キーが見つからない場合は発生しません。  
  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>プロパティにリソースを要求しているアセンブリが含まれています。 詳細については、「<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>」を参照してください。  
  
 このイベントのイベント ハンドラーを登録するには、必要なアクセス許可が必要、または<xref:System.Security.SecurityException>がスローされます。  
  
 イベント処理の詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">セキュリティ ポリシー レベル。</param>
        <summary>アプリケーション ドメインのセキュリティ ポリシー レベルを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリに読み込まれますする前に、このメソッドを呼び出して、<xref:System.AppDomain>のため、セキュリティ ポリシーを有効にします。  
  
   
  
## 例  
 次の例で使用する方法、<xref:System.AppDomain.SetAppDomainPolicy%2A>アプリケーション ドメインのセキュリティ ポリシー レベルを設定します。  
  
 [!code-cpp[ADSetAppDomainPolicy\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Security.Policy.PolicyException">セキュリティ ポリシー レベルは、既に設定されています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">シャドウ コピー先の絶対パス。</param>
        <summary>指定したディレクトリ パスを、アセンブリのシャドウ コピー先として設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合に、キャッシュのパスが無視されますが、 <xref:System.AppDomainSetup.ApplicationName%2A> プロパティが設定されていません。<xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName> プロパティを参照してください。  
  
 シャドウ コピーの詳細については、次を参照してください。 [Shadow Copying Assemblies](http://msdn.microsoft.com/ja-jp/de8b8759-fca7-4260-896b-5a4973157672)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">作成または変更の対象となるユーザー定義アプリケーション ドメイン プロパティの名前。</param>
        <param name="data">プロパティの値。</param>
        <summary>指定したアプリケーション ドメイン プロパティに、指定した値を割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、エントリを挿入またはのこのインスタンスのプロパティを説明する名前とデータのペアの内部キャッシュのエントリの値を変更<xref:System.AppDomain>です。  
  
 キャッシュには、アプリケーション ドメインの作成時に挿入される定義済みのシステム エントリに自動的に含まれています。 挿入または、このメソッドを使用してシステム エントリを変更することはできません。 システム エントリを変更しようとするメソッドの呼び出しも何も起こりません。メソッドは例外をスローしません。 システム エントリの値を検査することができます、<xref:System.AppDomain.GetData%2A>メソッド、またはそれと同等<xref:System.AppDomainSetup>プロパティ」に記載<xref:System.AppDomain.GetData%2A>です。  
  
 値として指定"REGEX\_DEFAULT\_MATCH\_TIMEOUT"で正規表現パターンを評価するための既定のタイムアウト間隔の値を設定するには、このメソッドを呼び出すことができます、`name`引数および<xref:System.TimeSpan>間隔を表す値、タイムアウトの値として、`data`引数。 挿入、またはこのメソッドを使用して、独自のユーザー定義名とデータの組み合わせを変更したり、調べたりできますとその値、<xref:System.AppDomain.GetData%2A>メソッドです。  
  
   
  
## 例  
 次の例で使用する方法、<xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29>メソッドを新しい値のペアを作成します。 使用して、<xref:System.AppDomain.GetData%2A>値を取得し、それをコンソールに表示します。  
  
 [!code-cpp[ADGetData\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">作成または変更の対象となるユーザー定義アプリケーション ドメイン プロパティの名前。</param>
        <param name="data">プロパティの値。</param>
        <param name="permission">プロパティの取得時に呼び出し元に要求するアクセス許可。</param>
        <summary>アプリケーション ドメインの特定のプロパティに対し、指定された値を代入します。プロパティの取得時に呼び出し元に要求するアクセス許可を引数として受け取ります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 挿入または独自のアプリケーション ドメインのプロパティを説明する名前\/データ ペアの内部キャッシュにユーザー定義のエントリを変更するには、このメソッドを使用します。 エントリを挿入するときは、エントリが取得されたときに適用するアクセス許可要求を指定できます。さらに、サプライ"REGEX\_DEFAULT\_MATCH\_TIMEOUT"で正規表現パターンを評価するための既定のタイムアウト間隔の値を設定するには、このメソッドを呼び出すの値として、 `name` 引数と <xref:System.TimeSpan> の値としてのタイムアウト間隔を表す値、 `data` 引数。  
  
 このメソッドを使用して、システム定義のプロパティ文字列をセキュリティ確認要求を割り当てることはできません。  
  
 キャッシュには、アプリケーション ドメインが作成時に挿入される定義済みのシステム エントリに自動的に含まれています。 挿入または、このメソッドを使用してシステム エントリを変更することはできません。 システム エントリを変更しようとするメソッドの呼び出しも何も起こりません。このメソッドは例外をスローしません。 持つシステム エントリの値を調べることができます、 <xref:System.AppDomain.GetData%2A> メソッドまたは同等 <xref:System.AppDomainSetup> の「解説」セクションで説明するプロパティ、 <xref:System.AppDomain.GetData%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> システム定義のプロパティ文字列を指定し、 <paramref name="permission" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">動的に生成されたファイルの格納先となるサブディレクトリに対するベース ディレクトリを指定する絶対パス。</param>
        <summary>動的に生成されたファイルの格納先、およびそのファイルへのアクセス先となるサブディレクトリに対するベース ディレクトリとして、ディレクトリ パスを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、設定、 <xref:System.AppDomainSetup.DynamicBase%2A> 、内部プロパティ <xref:System.AppDomainSetup> このインスタンスに関連付けられています。  
  
   
  
## 例  
 このメソッドは残されていますし、新規の開発は使用しない必要があります。 次の例では、旧式でない代替手段を使用する方法、 <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> プロパティです。 この例の詳細については、次を参照してください。、 <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> プロパティまたは <xref:System.AppDomain.DynamicDirectory%2A> プロパティです。  
  
 [!code-cpp[ADDynamicBase\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">スレッドにアタッチするプリンシパル オブジェクトの型を指定する、<see cref="T:System.Security.Principal.PrincipalPolicy" /> のいずれかの値。</param>
        <summary>アプリケーション ドメインでスレッドを実行中に、スレッドがプリンシパルにバインドしようとした場合に、プリンシパル オブジェクトと ID オブジェクトをそのスレッドに関連付ける方法を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この値に設定されるだけ有効に使用する前に設定した場合、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>プロパティです。 例では、設定した場合の<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>に指定されたプリンシパル \(たとえば、汎用プリンシパル\) としを使用して、<xref:System.AppDomain.SetPrincipalPolicy%2A>設定するメソッドを<xref:System.Security.Principal.PrincipalPolicy>に<xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>、現在のプリンシパルには、汎用プリンシパルは残ります。  
  
   
  
## 例  
 次の例を使用するスレッドへの影響を示しています、<xref:System.AppDomain.SetPrincipalPolicy%2A>をアプリケーション ドメインのプリンシパルのポリシーを変更するメソッド。 使用しての効果も示しています、<xref:System.AppDomain.SetThreadPrincipal%2A>メソッドでのアプリケーション ドメインのスレッドへのアタッチに使用されるプリンシパルを変更します。  
  
 [!code-cpp[ADPrincipal\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for ability to manipulate the principal object. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シャドウ コピーをオンにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シャドウ コピーの詳細については、次を参照してください。[Shadow Copying Assemblies](http://msdn.microsoft.com/ja-jp/de8b8759-fca7-4260-896b-5a4973157672)です。  
  
   
  
## 例  
 このメソッドは、現在使用されていません、し、新規の開発は使用できません。  
  
 [!code-cpp[adproperties\#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties\#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">ディレクトリ名のリスト。各ディレクトリ名はセミコロンで区切られます。</param>
        <summary>指定したディレクトリ パスを、シャドウ コピーするアセンブリがある場所として設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、シャドウ コピーには、調査で見つかったすべてのアセンブリが含まれています。<xref:System.AppDomain.SetShadowCopyPath%2A> メソッドで指定したディレクトリ内のアセンブリへのシャドウ コピーの制限 `path`します。  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A> メソッドがアセンブリを検索する追加のディレクトリを指定します。 シャドウ コピーするアセンブリが既に内になければなりません検索パスの下にある <xref:System.AppDomain.BaseDirectory%2A>です。<xref:System.AppDomain.SetShadowCopyPath%2A> メソッドを指定する検索パスがあるシャドウ コピーの対象とします。  
  
 このメソッドは、設定、 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> 、内部プロパティ <xref:System.AppDomainSetup> このインスタンスに関連付けられています。  
  
 シャドウ コピーの詳細については、次を参照してください。 [Shadow Copying Assemblies](http://msdn.microsoft.com/ja-jp/de8b8759-fca7-4260-896b-5a4973157672)します。  
  
   
  
## 例  
 このメソッドは残されていますし、新規の開発は使用しない必要があります。  
  
 [!code-cpp[ADShadowCopy\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで、操作が試行されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">スレッドに関連付けるプリンシパル オブジェクト。</param>
        <summary>アプリケーション ドメインでスレッドを実行中に、スレッドがプリンシパルにバインドしようとした場合に、そのスレッドに関連付ける既定のプリンシパル オブジェクトを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例を使用しての効果を示しています、<xref:System.AppDomain.SetThreadPrincipal%2A>をアプリケーション ドメインで実行されているスレッドへのアタッチに使用されるプリンシパルを変更するメソッド。 使用するスレッドへの影響も示しています、<xref:System.AppDomain.SetPrincipalPolicy%2A>をアプリケーション ドメインのプリンシパルのポリシーを変更するメソッド。  
  
 [!code-cpp[ADPrincipal\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Security.Policy.PolicyException">スレッドのプリンシパルは、既に設定されています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for ability to manipulate the principal object. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このインスタンスのアプリケーション ドメイン構成情報を取得します。</summary>
        <value>アプリケーション ドメインの初期化情報。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインでファイルのシャドウ コピーを実行するよう設定されているかどうかを示す値を取得します。</summary>
        <value>アプリケーション ドメインでファイルのシャドウ コピーを実行するよう設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 詳細については、<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName> および [Shadow Copying Assemblies](http://msdn.microsoft.com/ja-jp/de8b8759-fca7-4260-896b-5a4973157672) を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetIDsOfNames`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfo`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 \(0 または 1\) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfoCount`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::Invoke`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーション ドメインの表示名とコンテキスト ポリシーを含む文字列形式を取得します。</summary>
        <returns>アプリケーション ドメインの表示名であるリテラル文字列 "Name:" と、コンテキスト ポリシーの文字列形式または "There are no context policies." という文字列のどちらかを連結した文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例の戻り値の表示、<xref:System.AppDomain.ToString%2A>メソッドです。  
  
 [!code-cpp[ADToString\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">現在で表されるアプリケーション ドメイン<see cref="T:System.AppDomain" />がアンロードされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の解決が失敗したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomain.TypeResolve>イベントは、共通言語ランタイムが、要求された型を作成できるアセンブリを特定できない場合に発生します。 これは、型が、動的アセンブリで定義されているまたは型が、動的アセンブリで定義されていませんが、ランタイムには、型がで定義されているアセンブリがわからない場合に発生します。 後者の状況が発生することがとき<xref:System.Type.GetType%2A?displayProperty=fullName>アセンブリ名を持つ型名で修飾されていないと呼びます。  
  
 <xref:System.ResolveEventHandler>このイベントの試行を検索し、型を作成することができます。  
  
 ただし、<xref:System.AppDomain.TypeResolve>イベントでは、特定のアセンブリで型を検索することはできません、ランタイムが認識されている場合は発生しません。 たとえば、型が見つからない場合、静的アセンブリに、ランタイムは、静的アセンブリに型を動的に追加できませんを認識しているために、このイベントは発生しません。  
  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>プロパティには、型を要求しているアセンブリが含まれています。 詳細については、「<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>」を参照してください。  
  
 このイベントのイベント ハンドラーを登録するには、必要なアクセス許可が必要、または<xref:System.Security.SecurityException>がスローされます。  
  
 イベント処理の詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
   
  
## 例  
 次の例は、<xref:System.AppDomain.TypeResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 アセンブリの完全修飾名を取得する方法については、次を参照してください。[Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e)です。  
  
 [!code-cpp[AppDomain\_TypeResolve\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain\_TypeResolve\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain\_TypeResolve\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外がキャッチされない場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、キャッチされない例外の通知を提供します。 これにより、アプリケーションをシステムの既定のハンドラーがユーザーに例外を報告し、アプリケーションを終了する前に、例外に関する情報を記録できます。 その他の操作を行うことがあります、アプリケーションの状態に関する十分な情報が利用可能な場合は、\-など、その後の復旧のプログラム データを保存します。 注意が必要、例外が処理されない場合に、プログラムのデータが破壊されることがあるためです。  
  
> [!NOTE]
>  .NET Framework バージョン 1.0 および 1.1 では、アプリケーションの終了とデバッグ オプションは、ユーザーに報告後はなく、このイベントは、前にします。  
  
 このイベントは、任意のアプリケーション ドメインで処理することができます。 ただし、いない必ずしもイベントは、例外が発生したアプリケーション ドメインでします。 スレッドのスタック全体が解除されたアンワインドため、まず、イベントを発生させることができますが、スレッドが開始したアプリケーション ドメインでは、該当する例外ハンドラーを検索せず場合にのみ、例外は処理ではありません。  
  
> [!NOTE]
>  .NET Framework のバージョン 1.0 および 1.1 では、このイベントは、アプリケーションが開始されたときに、システムによって作成される既定のアプリケーション ドメインに対してのみ発生します。 アプリケーションでは、追加のアプリケーション ドメインを作成する場合は、それらのアプリケーション ドメインでこのイベントのデリゲートを指定することも効果はありません。  
  
 場合、<xref:System.AppDomain.UnhandledException>既定のアプリケーション ドメインでイベントを処理、いずれかのハンドルされない例外でどのようなアプリケーション ドメインに関係なく、任意のスレッド開始されたスレッドの存在は生成です。 イベント ハンドラーを持つアプリケーション ドメインでスレッドを開始するかどうかは<xref:System.AppDomain.UnhandledException>、そのアプリケーション ドメインで、イベントが発生します。 そのアプリケーション ドメインが既定のアプリケーション ドメインと既定のアプリケーション ドメインで、イベント ハンドラーはまた、両方のアプリケーション ドメインで、イベントが発生します。  
  
 たとえば、スレッドの開始あるとします"AD1"のアプリケーション ドメインし、メソッド呼び出し"AD2"のアプリケーション ドメインでそこからメソッドを呼び出す"AD3"のアプリケーション ドメインで、例外をスローします。 最初のアプリケーション ドメイン、<xref:System.AppDomain.UnhandledException>イベントが発生する可能性が"AD1"は、します。 そのアプリケーション ドメインが既定のアプリケーション ドメインでない場合は、イベントも既定のアプリケーション ドメインで発生させることができます。  
  
> [!NOTE]
>  共通言語ランタイムの中断のイベント ハンドラーの中にスレッドの中止、<xref:System.AppDomain.UnhandledException>イベントを実行します。  
  
 イベント ハンドラーがある場合、<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>属性、イベント ハンドラーが制約された実行領域として扱われるよう、適切なフラグです。  
  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、スタック オーバーフローなど、プロセスの状態が破損またはアクセス違反がない場合は、イベント ハンドラーがセキュリティ クリティカルがある例外のこのイベントは発生しません、<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>属性。  
  
 .NET Framework バージョン 1.0 および 1.1 では、アプリケーションのメイン スレッド以外のスレッドで発生した未処理の例外は、ランタイムによってが検出され、アプリケーションが終了されることはないです。 したがって、ことができるよう、<xref:System.AppDomain.UnhandledException>アプリケーションを終了せず発生するイベントです。 以降、.NET Framework version 2.0 では、この安全子スレッドでハンドルされない例外のため、削除されましたサイレントこのような障害の累積的な効果には、パフォーマンスの低下、データの破損、およびデバッグが困難にすべてがハングアップが含まれています。 これで、ランタイムが終了しない、ケースのリストを含む詳細については、次を参照してください。[Exceptions in Managed Threads](http://msdn.microsoft.com/ja-jp/11294769-2e89-43cb-890e-ad4ad79cfbee)です。  
  
 このイベントのイベント ハンドラーを登録するには、必要なアクセス許可が必要、または<xref:System.Security.SecurityException>がスローされます。  
  
 イベント処理の詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
## 未処理の例外の他のイベント  
 特定のアプリケーション モデル、<xref:System.AppDomain.UnhandledException>イベントは、メイン アプリケーション スレッドでハンドルされない例外が発生した場合の他のイベント割り込まことができます。  
  
 Windows フォームを使用するアプリケーションで未処理の例外、メイン アプリケーション スレッドで、<xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>イベントが発生します。 このイベントが処理される場合は既定の動作は、未処理の例外が、アプリケーションを終了しないこと、アプリケーションが不明な状態のままですが。 その場合は、<xref:System.AppDomain.UnhandledException>イベントは発生しません。 アプリケーション構成ファイルを使用するかを使用して、この動作を変更できます、<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>するモードを変更するメソッドを<xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=fullName>する前に、<xref:System.Windows.Forms.Application.ThreadException>イベント ハンドラーをフックします。 これは、メイン アプリケーション スレッドにのみ適用されます。<xref:System.AppDomain.UnhandledException>イベントは他のスレッドでスローされた未処理の例外の発生します。  
  
 Microsoft Visual Studio 2005 以降では、Visual Basic アプリケーション フレームワークは、メイン アプリケーション スレッドでハンドルされない例外の別のイベントを提供します。 参照してください、<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>イベント。 このイベントがイベント引数オブジェクトによって使用されるイベント引数オブジェクトと同じ名前の<xref:System.AppDomain.UnhandledException?displayProperty=fullName>、ですが、さまざまなプロパティです。 具体的には、このイベントの引数オブジェクトが、<xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>プロパティにより、アプリケーションは引き続き実行されている、未処理の例外は無視されます \(および不明な状態で、アプリケーションのまま\) です。 その場合は、<xref:System.AppDomain.UnhandledException?displayProperty=fullName>イベントは発生しません。  
  
   
  
## 例  
 次の例で示します、<xref:System.AppDomain.UnhandledException>イベント。 イベント ハンドラーを定義`MyHandler`既定のアプリケーション ドメインでハンドルされない例外がスローされるたびに呼び出されます。 2 つの例外をスローします。 最初はによって処理される、 **try ブロックと catch**ブロックします。 2 つ目が処理されないと起動、`MyHandle`ルーチン、アプリケーションが終了する前にします。  
  
 [!code-cpp[AppDomain\_UnhandledException\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain\_UnhandledException\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain\_UnhandledException\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">アンロードするアプリケーション ドメイン。</param>
        <summary>指定したアプリケーション ドメインをアンロードします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework version 2.0 では、スレッドがアプリケーション ドメインのアンロードに専用です。 これにより、.NET Framework がホストされている場合は特に、信頼性が向上します。 スレッドを呼び出すと<xref:System.AppDomain.Unload%2A>対象のドメインがアンロード用にマークします。 専用のスレッドが、ドメインをアンロードしようとして、ドメイン内のすべてのスレッドが中止されました。 場合は、スレッドは中止されない、たとえば、アンマネージ コードが実行されているので、またはを実行しているため、`finally`一定の時間後のブロック、<xref:System.CannotUnloadAppDomainException>最初を呼び出したスレッドでスローされた<xref:System.AppDomain.Unload%2A>です。 最終的に中止できなかった、スレッドが終了した場合、ターゲット ドメインはアンロードされません。 したがって、次の .NET Framework version 2.0 のようになります。`domain`実行中のスレッドを終了することができないため、アンロードする保証はありません。  
  
> [!NOTE]
>  場合によっては、呼び出す<xref:System.AppDomain.Unload%2A>、すぐ<xref:System.CannotUnloadAppDomainException>、たとえばファイナライザーで呼び出された場合。  
  
 内のスレッド`domain`が終了を使用して、<xref:System.Threading.Thread.Abort%2A>スローするメソッド、<xref:System.Threading.ThreadAbortException>スレッドでします。 スレッドがすぐに終了する必要がありますが、予期しない時間での実行を続行する、`finally`句。  
  
## バージョンの互換性  
 .NET framework version 1.0 および 1.1 の場合は、スレッドを呼び出す<xref:System.AppDomain.Unload%2A>で実行されている`domain`、アンロード操作を実行する別のスレッドを開始します。 場合`domain`アンロードすることはできません、<xref:System.CannotUnloadAppDomainException>と呼ばれる元のスレッドではなく、そのスレッドでスローされる<xref:System.AppDomain.Unload%2A>です。 ただしかどうか、スレッドを呼び出す<xref:System.AppDomain.Unload%2A>外部で実行中`domain`スレッドが例外を受け取ります。  
  
   
  
## 例  
 次のコード例では、アプリケーション ドメインをアンロードする方法を示します。  
  
 [!code-cpp[ADUnload\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          <paramref name="domain" />アンロードできませんでした。</exception>
        <exception cref="T:System.Exception">アンロード中にエラーが発生しました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to add an event handler for this event. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した COM 型の新しいインスタンスを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しいアプリケーション ドメインを作成します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリを実行します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した型の新しいインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したファイルに格納されているアセンブリを実行します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のアプリケーション ドメインで動的アセンブリを定義します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーション ドメイン プロパティに値を代入します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のアプリケーション ドメインに <see cref="T:System.Reflection.Assembly" /> を読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>