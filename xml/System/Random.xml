<Type Name="Random" FullName="System.Random">
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>擬似乱数ジェネレーターを表します。擬似乱数ジェネレーターは、乱数についての統計的な要件を満たす数値系列を生成するデバイスです。  
  
 この型の .NET Framework ソース コードを参照するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/random.cs#bb77e610694e64ca)します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを参照してください、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/random.cs#bb77e610694e64ca)します。 ソース コードをオンラインで参照、オフライン表示のリファレンスをダウンロードおよびデバッグ中にソース \(パッチや更新を含む\) をステップsee [instructions](http://referencesource.microsoft.com/).  
  
 有限な一連の数字から等しい確率で擬似乱数が選択されます。 数学的アルゴリズムは、それらの選択に使用しますが、実際には十分にランダムなために、選択した数値は完全にランダムではありません。 現在の実装、 <xref:System.Random> クラスは Donald E. クヌースの差分乱数ジェネレーター アルゴリズムの変更済みバージョンに基づいています。 詳細については、D. E. を参照してください。 クヌースします。*プログラミングでは、ボリューム 2 のコンピューターのアート: Seminumerical アルゴリズム*します。 Addison Wesley、読み取り、マサチューセッツ州の第 3 版、1997年します。  
  
 いずれかのランダムなパスワードを作成するのに適したなどの暗号化に使用するセキュリティで保護されたランダムな数値を生成するには使用、 <xref:System.Security.Cryptography.RNGCryptoServiceProvider> クラスからクラスを派生させたり <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=fullName>します。  
  
 このトピックの内容  
  
 [乱数生成器をインスタンス化する](#Instantiate)   
 [複数のインスタンス化を回避する](#Multiple)   
 [、System.Random クラスおよびスレッドの安全性](#ThreadSafety)   
 [さまざまな種類の乱数を生成する](#Functionality)   
 [、独自のアルゴリズムを置き換えて](#Overriding)   
 [の使用方法を System.Random...](#Operations)   
 [ランダムな値の同じシーケンスを取得](#Same)   
 [ランダムな値の一意のシーケンスを取得](#Unique)   
 [指定された範囲の整数を取得](#Range)   
 [指定された桁数を持つ整数を取得](#Digits)   
 [指定された範囲の浮動小数点値を取得](#Floats)   
 [ランダムなブール値を生成する](#Boolean)   
 [64 ビットの整数の乱数を生成](#Long)   
 [指定範囲内のバイトを取得](#Bytes)   
 [配列またはコレクションから要素をランダムに取得](#Array)   
 [の一意の要素を取得配列またはコレクションから](#UniqueArray)  
  
<a name="Instantiate"></a>   
## 乱数生成器をインスタンス化します。  
 シード値 \(擬似乱数生成アルゴリズムの開始値\) を提供することで、乱数ジェネレーターをインスタンス化する、 <xref:System.Random.%23ctor%2A> クラスのコンス トラクターです。  明示的または暗黙的には、シード値を指定できます。  
  
-   <xref:System.Random.%23ctor%28System.Int32%29> コンス トラクターは指定した明示的なシード値を使用します。  
  
-   <xref:System.Random.%23ctor> コンス トラクターでは、システム クロックを使用して、シード値を提供します。 これは、乱数生成器をインスタンス化する最も一般的な方法です。  
  
 同じシードが個別に使用する場合 <xref:System.Random> オブジェクトの場合、同じ一連のランダムな数字が生成されます。 これは、ランダムな値を処理するテスト スイートを作成するため、またはそのデータをランダムな番号から派生したゲームを再生するために役立ちます。 ことができます。 ただし、 <xref:System.Random> 同一のシード値で、インスタンス化している場合でも、異なるバージョンの .NET Framework で実行されるプロセス内のオブジェクトは異なる一連のランダムな番号を返す可能性があります。  
  
 ランダムな数のさまざまなシーケンスを生成することができますシード値時間に依存するの新しいインスタンスごとに別の系列を生成するため <xref:System.Random>です。 パラメーター化された <xref:System.Random.%23ctor%28System.Int32%29> コンス トラクターがかかることが、 <xref:System.Int32> 値に基づいてタイマー刻みの数での現在の時刻は、パラメーターなし <xref:System.Random.%23ctor> コンス トラクターでは、システム クロックを使用して、シード値を生成します。 ただし、時計には、有限の解像度があるために使用してパラメーターなしのコンス トラクターは、作成するさまざまな <xref:System.Random> 連続内のオブジェクトは、ランダムな数の同一のシーケンスを生成する乱数ジェネレーターを作成します。 次の例を 2 つ <xref:System.Random> 連続でインスタンス化されるオブジェクトが同一の一連のランダムな数値を生成します。 ほとんどの Windows システムで <xref:System.Random> 互いの 15 ミリ秒内に作成されたオブジェクトが同一のシード値を持つ可能性があります。  
  
 [!code-cpp[System.Random\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 この問題を回避するには、1 つを作成 <xref:System.Random> 複数のオブジェクトではなくオブジェクトです。  
  
<a name="Multiple"></a>   
## 複数のインスタンス化を回避します。  
 2 つの random number generator またはすばやく連続的に短いループ内の初期化中には、ランダムな数の同一のシーケンスを作成できる 2 つの random number generator が作成されます。 ほとんどの場合、これは開発者の意図ありをインスタンス化して、乱数ジェネレーターの初期化が比較的負荷のかかるプロセスであるため、パフォーマンスの問題に 。  
  
 1 つを作成することをお勧めパフォーマンスを向上させるとの両方を同一の数値のシーケンスを生成する別の random number generator が誤ってを防ぐために、 <xref:System.Random> を新規作成する代わりに、時間の経過と共に多くの乱数を生成するオブジェクト <xref:System.Random> オブジェクトを 1 つの乱数を生成します。  
  
 ただし、 <xref:System.Random> クラスは、スレッド セーフであります。 呼び出した場合 <xref:System.Random> メソッドを複数のスレッドから、次のセクションで説明したガイドラインに従います。  
  
<a name="ThreadSafety"></a>   
## System.Random クラスおよびスレッドの安全性  
 個々 のインスタンスを生成する代わりに <xref:System.Random> オブジェクトの場合、1 つを作成することをお勧め <xref:System.Random> アプリが必要なすべての乱数を生成するインスタンス。 ただし、 <xref:System.Random> オブジェクトはスレッド セーフではありません。 アプリを呼び出す場合 <xref:System.Random> 複数のスレッドからメソッドは、1 つのスレッドが、一度に乱数ジェネレーターをアクセスできるようにする同期オブジェクトを使用する必要があります。 確認しない場合、 <xref:System.Random> オブジェクトがスレッド セーフな方法でアクセスされる、乱数を返すメソッドを呼び出すには 0 が返されます。  
  
 次の例では、c\# 使用 [lock ステートメント](http://msdn.microsoft.com/ja-jp/656da1a4-707e-4ef6-9c6e-6d13b646af42) および Visual Basic [SyncLock ステートメント](http://msdn.microsoft.com/ja-jp/14501703-298f-4d43-b139-c4b6366af176) を単一乱数ジェネレーターにスレッド セーフな方法で 11 のスレッドがアクセスすることを確認します。 各スレッドで 200万乱数を生成し、生成されたランダムな数字の数をカウントの合計を計算し、実行が終了したら、すべてのスレッドの合計を更新します。  
  
 [!code-cpp[System.Random\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 この例では、次のようにスレッド セーフを保証します。  
  
-   <xref:System.ThreadStaticAttribute> 属性を使用して、生成されたランダムな数とそれらの各スレッドの合計の合計数を追跡するスレッド ローカル変数を定義します。  
  
-   ロック \(、 `lock` c\# でステートメントと `SyncLock` Visual Basic でのステートメント\) の合計数とすべてのスレッドで生成されたすべてのランダムな数の合計、変数へのアクセスを保護します。  
  
-   セマフォ \(、 <xref:System.Threading.CountdownEvent> オブジェクト\) を使用して、他のすべてのスレッドまでメイン スレッドのブロックが実行を完了します。  
  
-   この例では、かどうか、乱数ジェネレーターが破損を調べることによってランダムな番号の生成方法を次の 2 つの連続して呼び出すは 0 を返すかどうかを確認します。 この例を使用して破損が検出された場合、 <xref:System.Threading.CancellationTokenSource> オブジェクトからすべてのスレッドをキャンセルする必要があることを通知します。  
  
-   状態を調べ、各スレッドごとの乱数を生成する前に、 <xref:System.Threading.CancellationToken> オブジェクトです。 キャンセルが要求される場合、 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> にスレッドの取り消しメソッドです。  
  
 次の例と同じですがを使用する点を除いて、 <xref:System.Threading.Tasks.Task> オブジェクトとラムダ式の代わりに <xref:System.Threading.Thread> オブジェクトです。  
  
 [!code-csharp[System.Random\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 異なり最初の例では、次のようにします。  
  
-   生成されたランダムな数字の数と各タスクでは、その合計を追跡する変数は、使用する必要はありませんので、タスクは、ローカル、 <xref:System.ThreadStaticAttribute> 属性です。  
  
-   静的な <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> メソッドを使用して、すべてのタスクが完了する前に、メイン スレッドが完了しないことを確認します。 必要はありません、 <xref:System.Threading.CountdownEvent> オブジェクトです。  
  
-   タスクのキャンセルに起因する例外が表示される、 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> メソッドです。 前の例では、各スレッドが処理されます。  
  
<a name="Functionality"></a>   
## さまざまな種類の乱数を生成します。  
 乱数ジェネレーターは、次のような乱数を生成するのに便利なメソッドを提供します。  
  
-   一連の <xref:System.Byte> 値。 戻るには、メソッドが必要な要素の数に初期化された配列を渡すことによってバイト値の数を決定する、 <xref:System.Random.NextBytes%2A> メソッドです。 次の例では、20 バイトを生成します。  
  
     [!code-cpp[System.Random\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   1 つの整数。 最大値に 0 の整数をするかどうかを選択することができます \(<xref:System.Int32.MaxValue?displayProperty=fullName> – 1\) を呼び出して、 <xref:System.Random.Next> メソッドは、0 から呼び出すことによって特定の値までの整数、 <xref:System.Random.Next%28System.Int32%29> メソッド、またはを呼び出して値の範囲内の整数、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドです。 パラメーター化されたオーバー ロードでは指定した最大値が排他的です。生成された実際の最大数は、1 つは、指定した値より小さくします。  
  
     次の例では、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> \-10 ~ 10 で 10 個の乱数を生成します。 メソッドの 2 番目の引数がメソッドによって返されるランダムな値の範囲の上限を指定することに注意してください。 つまり、メソッドは、1 つを返すことができる最大の整数よりも小さい値です。  
  
     [!code-cpp[System.Random\#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   呼び出すことによって 1.0 より小さい 0.0 から単一の浮動小数点値、 <xref:System.Random.NextDouble%2A> メソッドです。 メソッドによって返される乱数の排他的上限値は、実際の上限は 0.99999999999999978 1 です。 次の例では、10 個のランダムな浮動小数点数を生成します。  
  
     [!code-cpp[System.Random\#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドでは、返される乱数の範囲を指定することができます。 ただし、 `maxValue` 範囲の上限に返される数値を指定するパラメーターは、排他、いないを含んでいるため、値。 つまり、このメソッドの呼び出し `Next(0, 100)` 0 ~ 99 の間、および 0 ~ 100 の範囲にない値を返します。  
  
 使用することも、 <xref:System.Random> などのタスクを生成するためのクラス [ランダム T:System.Boolean 値](#Boolean), 生成、 [ランダムな浮動小数点値以外の 0 ~ 1 の範囲で](#Floats), 生成、 [64 ビットの整数の乱数](#Long), と [配列またはコレクションからの一意の要素をランダムに取得する](#UniqueArray)します。 これらおよびその他の一般的なタスクは、次を参照してください。、 [の使用方法を System.Random...](#Operations) セクションです。  
  
<a name="Overriding"></a>   
## 独自のアルゴリズムの置換  
 継承することで、独自の乱数を実装する、 <xref:System.Random> クラスと乱数の生成アルゴリズムを指定します。 オーバーライドする必要があります、独自のアルゴリズムを指定する、 <xref:System.Random.Sample%2A> 乱数生成アルゴリズムを実装するメソッドです。 またをオーバーライドする必要があります、 <xref:System.Random.Next>, 、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, 、および <xref:System.Random.NextBytes%2A> メソッドを呼び出す、オーバーライドされたことを確認 <xref:System.Random.Sample%2A> メソッドです。 オーバーライドする必要はありません、 <xref:System.Random.Next%28System.Int32%29> と <xref:System.Random.NextDouble%2A> メソッドです。  
  
 派生した例については、 <xref:System.Random> クラスし、その既定擬似乱数ジェネレーター、変更を参照してください、 <xref:System.Random.Sample%2A> リファレンス ページです。  
  
<a name="Operations"></a>   
## System.Random を使用するには.  
 以降のセクションでは、について説明し、アプリでランダムな数字を使用する方法をいくつかのサンプル コードを指定します。  
  
<a name="Same"></a>   
### ランダムな値の同じシーケンスを取得します。  
 ソフトウェア テスト シナリオおよびゲームのプレイで同じランダムな数のシーケンスを生成する場合があります。 ランダムな数の同じシーケンスでのテストを使用すると、不具合を検出し、バグの修正を確認できます。 ゲームで同じランダムな数値のシーケンスを使用するには、前のゲームを再生することができます。  
  
 ランダムな数の同じシーケンスを生成するには同じシード値を提供することにより、 <xref:System.Random.%23ctor%28System.Int32%29> コンス トラクターです。 シード値は、擬似乱数生成アルゴリズムの開始値を提供します。 次の例では、任意のシード値として 100100 をでインスタンス化する、 <xref:System.Random> とシード値が引き続き発生する、オブジェクトに 20 個のランダムな浮動小数点値が表示されます。 シード値を復元、新しいランダムな番号ジェネレーターのインスタンスを作成し、20 同じのランダムな浮動小数点値を表示します。  例も、.NET Framework の異なるバージョンを実行する場合に、ランダムな数のさまざまなシーケンスを生成可能性がありますに注意してください。  
  
 [!code-cpp[System.Random\#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### 乱数の一意のシーケンスを取得します。  
 インスタンスに異なるシード値を提供する、 <xref:System.Random> クラスにより各乱数ジェネレーターの値のさまざまなシーケンスを生成します。 いずれかを呼び出して明示的にシード値を指定できる、 <xref:System.Random.%23ctor%28System.Int32%29> コンス トラクター、または暗黙的を呼び出して、 <xref:System.Random.%23ctor> コンス トラクターです。 ほとんどの開発者は、システム クロックを使用してパラメーターなしのコンス トラクターを呼び出します。 次の例は、2 つのインスタンスを作成するこの方法を使用して <xref:System.Random> インスタンス。 各インスタンスには、10 個のランダムな整数の系列が表示されます。  
  
 [!code-cpp[System.Random\#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random\#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random\#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 ただし、有限の解像度のため、システム クロックが約 15 ミリ秒未満である時刻の違いを検出しません。 そのため、コードを呼び出す場合、 <xref:System.Random.%23ctor> 2 つのインスタンスを作成するオーバー ロード <xref:System.Random> する可能性があります誤ってするオブジェクトを提供する、同一のシード値と連続してオブジェクトです。 これを参照する前の例ではコメント アウト、 <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> メソッドの呼び出しとコンパイルと再、例を実行します。  
  
 これが発生しないように、ことをお勧め、1 つのインスタンスを作成する <xref:System.Random> 複数のではなくオブジェクトです。 しかし、 <xref:System.Random> いないスレッド セーフであるにアクセスする場合は、いくつかの同期デバイスを使用する必要があります、 <xref:System.Random> インスタンスの詳細については複数のスレッドからは、「 [、ランダムなクラスおよびスレッドの安全性](#ThreadSafety) このトピックの前です。 遅延メカニズムなどを使用する代わりに、 <xref:System.Threading.Thread.Sleep%2A> メソッドの前の例では、インスタンス化には、15 を超えるミリ秒間隔が発生することを確認するために使用します。  
  
<a name="Range"></a>   
### 指定した範囲の整数を取得します。  
 呼び出して、指定された範囲の整数を取得し、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドで、返される乱数ジェネレーターの数値の上限と下限を指定することができます。 上限の境界は、排他的な包括、いない値です。 つまり、メソッドによって返される値の範囲に含まれていません。 次の例では、このメソッドを使用して、\-10 ~ 10 の間の整数の乱数を生成します。 これは 1 つの値として、目的の値より大きい 11 を指定しているノートの `maxValue` のメソッド呼び出しの引数。  
  
 [!code-cpp[System.Random\#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random\#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random\#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### 指定された桁数を持つ整数を取得します。  
 呼び出すことができます、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを指定した数の数字で番号を取得します。 たとえば、4 桁 \(つまり、1000年から 9999 まで番号\) の番号を取得するを呼び出す、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッドを `minValue` 値は 1000年と `maxValue` 次の例のように、10000 の値。  
  
 [!code-cpp[System.Random\#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### 指定した範囲の浮動小数点値を取得します。  
 <xref:System.Random.NextDouble%2A> メソッド 0 を返しますランダムな浮動小数点値の範囲を 1 未満にします。 ただし、その他のいくつかの範囲にランダムな値を生成するしますは多くの場合。  
  
 によって返される数に目的の開始間隔と 0 の違いを追加するには必要な最小値と最大値までの間隔が 1 の場合、 <xref:System.Random.NextDouble%2A> メソッドです。 次の例は\-1 ~ 0 で 10 個の乱数を生成します。  
  
 [!code-cpp[System.Random\#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random\#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random\#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 浮動小数点乱数を生成するが下限は 0 が、上限は 1 より大きい \(または、負の数値の場合の下限値は\-1 より小さく、上限の値は 0\)、0 以外のバインドによってランダムな数値を乗算します。 次の例は、20,000, 000 を浮動小数点乱数を生成する範囲 0 ~ <xref:System.Int64.MaxValue?displayProperty=fullName>です。 も、メソッドによって生成されたランダムな値の分布を表示します。  
  
 [!code-cpp[System.Random\#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random\#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random\#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 などの任意の値を 2 つの間で浮動小数点乱数を生成する、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 整数のメソッドでは、次の数式を使用します。  
  
```  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 次の例では、11.0 に 10.0 から 100万の乱数の範囲を生成し、その配分を表示します。  
  
 [!code-cpp[System.Random\#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random\#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random\#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### ランダムなブール値を生成します。  
 <xref:System.Random> クラスを生成するメソッドを提供しません <xref:System.Boolean> 値。 ただし、独自のクラスまたはメソッドによって、それを定義できます。 次の例では、クラス、 `BooleanGenerator`, 、単一のメソッドと `NextBoolean`です。`BooleanGenerator` ストアのクラス、 <xref:System.Random> プライベート変数とオブジェクトです。`NextBoolean` メソッドの呼び出し、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> メソッドにより、結果と、 <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=fullName> メソッドです。 ランダムな数の上限を指定する、2 が、引数として使用されることに注意してください。 これは排他的な値であるため、メソッドの呼び出しは、0 または 1 を返します。  
  
 [!code-cpp[System.Random\#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 乱数を生成する別のクラスを作成する代わりに <xref:System.Boolean> 値、例では、1 つのメソッドが定義するだけでした。 ただし、その場合、 <xref:System.Random> オブジェクトを新しくインスタンス化しないようにするクラス レベルの変数として定義する必要があります <xref:System.Random> 各メソッド呼び出しのインスタンス。 として Visual Basic の場合、Random インスタンスを定義することができます、 [静的](http://msdn.microsoft.com/ja-jp/19013910-4658-47b6-a22e-1744b527979e) に変数が、 `NextBoolean` メソッドです。  次の例では、実装を提供します。  
  
 [!code-cpp[System.Random\#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random\#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random\#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### 64 ビットの整数の乱数を生成します。  
 オーバー ロード、 <xref:System.Random.Next%2A> メソッドは、32 ビット整数を返します。 ただし、場合によっては、64 ビット整数値を使用する必要があります。 このことは次のように実行できます。  
  
1.  呼び出す、 <xref:System.Random.NextDouble%2A> 取得倍精度浮動小数点値。  
  
2.  その値に乗算 <xref:System.Int64.MaxValue?displayProperty=fullName>します。  
  
 次の例では、この手法を使用して、20,000, 000 の長整数の乱数を生成するしに 10 個のと同じグループに分類されています。 0 ~ には、各グループの数をカウントすることによってランダムな数の分布を評価し、 <xref:System.Int64.MaxValue?displayProperty=fullName>です。 例の出力に示すように、長整数の範囲を数値は多いか少ない均等に分散されます。  
  
 [!code-cpp[System.Random\#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random\#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random\#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 操作のビットを使用して、もう 1 つの方法では、真の乱数を生成しません。 この手法を呼び出す <xref:System.Random.Next> を 2 つの整数、左シフトの 1 つで 32 ビットおよび Or を生成することです。 この手法では、2 つの制限があります。  
  
1.  31 ビットは符号ビットであるため、結果の長整数のビット 31 の値は常に 0 です。  これは、31 ビットと論理和にランダムな 0 または 1 で、左にシフトを生成することで対処できますで元のランダムな長整数。  
  
2.  重大、ためによって値が返される確率 <xref:System.Random.Next> の場合は 0 には存在する場合は、少数のランダムな数字 0x0 0x00000000FFFFFFFF 範囲内です。  
  
<a name="Bytes"></a>   
### 指定した範囲のバイト数を取得します。  
 オーバー ロード、 <xref:System.Random.Next%2A> メソッドを使用すると、ランダムな数の範囲を指定できますが、 <xref:System.Random.NextBytes%2A> メソッドはありません。 次の例では、実装、 `NextBytes` メソッドが返されるバイトの範囲を指定することができます。 定義、 `Random2` から派生したクラス <xref:System.Random> キーワードおよび overloads その `NextBytes` メソッドです。  
  
 [!code-cpp[System.Random\#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 `NextBytes(Byte[], Byte, Byte)` メソッドへの呼び出しをラップする、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッド最小値と最大値より大きいかを指定し、\(この場合は、0 と 101\) するバイト配列に返されることです。 によって、整数値が返されることを確認しているため、 <xref:System.Random.Next%2A> の範囲内のメソッドは、 <xref:System.Byte> データ型おできます安全にキャストする \(c\#\) または整数からの \(Visual Basic\) でそれらをバイトに変換します。  
  
<a name="Array"></a>   
### 配列またはコレクションからランダムに要素を取得します。  
 ランダムな数は、多くの場合、配列またはコレクションから値を取得するインデックスとして機能します。 ランダム インデックス値を取得するを呼び出すことができます、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> メソッド、および使用の値としての配列の下限値、 `minValue` 引数と 1 つの値として、配列の上限より大きく、 `maxValue` 引数。 0 から始まる配列の場合これは、 <xref:System.Array.Length%2A> プロパティ、またはいずれかによって返される値より大きい、 <xref:System.Array.GetUpperBound%2A?displayProperty=fullName> メソッドです。 次の例は、都市の配列からランダムに米国の都市の名前を取得します。  
  
 [!code-cpp[System.Random\#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### 配列またはコレクションからの一意の要素を取得します。  
 乱数ジェネレーターは、重複する値をいつことができます。 数値の範囲が小さくなります。 または、生成された値の数が大きいほど、重複の可能性が大きくなります。 ランダムな値は一意である他の番号は、パフォーマンスが低下ますます重複を補正するために生成されます。  
  
 このシナリオを処理する方法は数多くあります。 1 つの一般的なソリューションでは、配列またはコレクションを取得する値を含むとランダムな浮動小数点数を格納する並列配列を作成します。 2 番目の配列には、ランダムな数字最初の配列の作成時に、 <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> メソッドを使用して、並列配列の値を使用して最初の配列を並べ替えます。  
  
 たとえば、ソリティア ゲームを開発している場合するそれぞれのカードが 1 回だけ使用されるようにします。 カードとそのカードが処理済みかどうかを追跡を取得する乱数を生成するには、代わりに、山札の並べ替えに使用できるランダムな数の並列配列を作成できます。 山札を並べ替えると、アプリは、山札を次のカードのインデックスを示すへのポインターを維持できます。  
  
 このアプローチの例を次に示します。 定義、 `Card` クラスとトランプを表す `Dealer` 、トランプのシャッフルを処理するクラス。`Dealer` クラスのコンス トラクターは、2 つの配列を設定: `deck` 配列クラス スコープを持つし、デッキとローカルでのすべてのカードを表す `order` が同じ数の要素の配列、 `deck` 配列し、は、ランダムに生成された <xref:System.Double> 値。<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=fullName> を並べ替えるメソッドが呼び出され、 `deck` 内の値に基づいて配列、 `order` 配列。  
  
 [!code-cpp[System.Random\#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## 例  
 次の例は、1 つ乱数ジェネレーターと呼び出しの <xref:System.Random.NextBytes%2A>, 、<xref:System.Random.Next%2A>, 、および <xref:System.Random.NextDouble%2A> さまざまな範囲内でランダムな数のシーケンスを生成するメソッドです。  
  
 [!code-cpp[System.Random\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 次のコード生成のランダムな整数のインデックスとして使用するには、配列から文字列値を取得します。  
  
 [!code-cpp[System.Random.Next\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <see cref="T:System.Random" /> required overriding the <see cref="M:System.Random.Sample" /> method to define a new or modified algorithm for generating random numbers. The derived class could then rely on the base class implementation of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, and <see cref="M:System.Random.NextDouble" /> methods to call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.  
  
 In the .NET Framework 2.0 and later, the behavior of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, and <see cref="M:System.Random.NextBytes(System.Byte[])" /> methods have changed so that these methods do not necessarily call the derived class implementation of the <see cref="M:System.Random.Sample" /> method. As a result, classes derived from <see cref="T:System.Random" /> that target the .NET Framework 2.0 and later should also override these three methods.</para>
    </block>
    <block subset="none" type="usage">
      <para>The implementation of the random number generator in the <see cref="T:System.Random" /> class isn't guaranteed to remain the same across major versions of the .NET Framework. As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Random" /> クラスの時間に依存する既定のシード値を使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のシード値は、システム クロックから派生し、有限の解像度があります。 その結果、異なる <xref:System.Random> 連続で既定のコンス トラクターの呼び出しによって作成されるオブジェクトは、同一の既定のシード値を持つし、そのため、ランダムな数の同一セットが生成されます。 この問題を回避するには、1 つを使用して <xref:System.Random> すべての乱数を生成するオブジェクト。 ことも回避システム クロックによって返されるシード値を変更しにこの新しいシード値を明示的に提供することによって、 <xref:System.Random.%23ctor%28System.Int32%29> コンス トラクターです。 詳細については、次を参照してください。、 <xref:System.Random.%23ctor%28System.Int32%29> コンス トラクターです。  
  
 乱数ジェネレーターを数値のランダム シーケンスを生成する場合は、このコンス トラクターを呼び出します。 同じである異なる乱数ジェネレーターのランダムな数字の順序が決まってを生成するには、呼び出し、 <xref:System.Random.%23ctor%28System.Int32%29> 固定シード値を持つコンス トラクターです。 これは、 <xref:System.Random> ランダムな数字を使用するアプリをテストするときに、コンス トラクター オーバー ロードがよく使用されます。  
  
 乱数生成器をインスタンス化したしたらを呼び出して個々 <xref:System.Random> メソッドなど <xref:System.Random.Next> または <xref:System.Random.NextDouble>, 、乱数を生成します。  
  
   
  
## 例  
 次の例は、3 つのインスタンスを作成する既定のコンス トラクターを使用して <xref:System.Random> オブジェクトし、それぞれの 5 つのランダムな整数のシーケンスが表示されます。 最初の 2 つ <xref:System.Random> 連続でオブジェクトが作成される、システム クロックに基づく同一のシード値を使用してオブジェクトのインスタンスは、そのため、それらを作成したりランダムな数のシーケンスが同じです。 その一方で、3 つ目の既定のコンス トラクター <xref:System.Random> オブジェクトが 2 秒の遅延を呼び出すことによって発生した後に呼び出されると、 <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> メソッドです。 これには、3 番目の異なるシード値が生成されるため <xref:System.Random> オブジェクトのさまざまな一連のランダムな数値が生成されます。  
  
 [!code-csharp[System.Random.Ctor\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">擬似乱数系列の開始値を計算するために使用する数値。 負数を指定した場合、その数値の絶対値が使用されます。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Random" /> クラスの指定したシード値を使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 別のものに、同一のシード値を提供する <xref:System.Random> と、ランダムな数の同一のシーケンスを生成するには、各インスタンスのオブジェクト。 乱数ジェネレーターに依存するアプリケーションをテストするときに、これは行われます。  
  
 アプリケーションは、さまざまなランダムな数値のシーケンスを必要とする場合は、異なるシード値を繰り返し、このコンス トラクターを呼び出します。 固有のシード値を生成する方法の 1 つは、時間に依存するようにすることです。 たとえば、システム クロックからとしてシード値を派生させる、 <xref:System.Random.%23ctor> オーバー ロードです。 ただし、システム クロックでは、異なるシード値をこのコンス トラクターの別の呼び出しを提供するための十分な解像度がないこと。 最初の 2 つに示すように、擬似乱数のと同じシーケンスを生成する乱数ジェネレーターでこの結果 <xref:System.Random> 次の例ではオブジェクトです。 これを防ぐためには、各呼び出しでは、または呼び出しでシード値を区別するためのアルゴリズムを適用、 <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> メソッドを異なるシード値を持つ各コンス トラクターを提供することを確認します。  
  
 [!code-csharp[System.Random.Ctor\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 1 つのインスタンスを作成することもできます <xref:System.Random> オブジェクトの使用して、アプリケーションのすべての乱数を生成することです。 かなり高額では、乱数ジェネレーターをインスタンス化するため、わずかに良いパフォーマンスが得られます。  
  
   
  
## 例  
 次の例 <xref:System.Random> シード パラメーターを受け取るし、ランダムな整数と倍精度小数点数のシーケンスを生成するクラスのコンス トラクターを持つオブジェクト。 例では、同じシーケンスを生成するときに、 <xref:System.Random> コンス トラクターとシード パラメーターを持つオブジェクトを再作成します。  
  
 [!code-cpp[System.Random.Ctor\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0 以上のランダムな整数を返します。</summary>
        <returns>大きいまたは 0 に等しいと小さいの 32 ビット符号付き整数より<see cref="F:System.Int32.MaxValue" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Random.Next%2A?displayProperty=fullName>0 ~ 値の範囲の乱数を生成より小さい<xref:System.Int32.MaxValue?displayProperty=fullName>です。 いくつか他の正の数値に 0 値の範囲の乱数を生成するには、使用、<xref:System.Random.Next%28System.Int32%29?displayProperty=fullName>メソッドのオーバー ロードします。 別の範囲内の乱数を生成するには、使用、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName>メソッドのオーバー ロードします。  
  
   
  
## 例  
 次の例を繰り返し呼び出すので、<xref:System.Random.Next%2A>特定の数のユーザーによって要求された乱数を生成する方法です。<xref:System.Console.ReadLine%2A?displayProperty=fullName>メソッドを使用して、顧客の入力を取得します。  
  
 [!code-cpp[System.Random.Next\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 次の例からクラスを派生する<xref:System.Random>によって生成された一様分布からランダムな数の分布が異なりますのシーケンスを生成する、<xref:System.Random.Sample%2A>基底クラスのメソッドです。 も優先、<xref:System.Random.Sample%2A>メソッドをオーバーライドして、乱数の配布の提供、<xref:System.Random.Next%2A?displayProperty=fullName>一連のランダムな数値を使用する方法です。  
  
 [!code-cpp[System.Random.Sample\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next" /> method. Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used. This behavior improves the overall performance of the <see cref="T:System.Random" /> class. To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next" /> method.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">生成するランダムな数の上限。<c>maxValue</c>0 以上にする必要があります。</param>
        <summary>指定した最大値より小さい 0 以上のランダムな整数を返します。</summary>
        <returns>大きいまたは 0 に等しいと小さいの 32 ビット符号付き整数より<paramref name="maxValue" />; 0 が通常の戻り値の範囲に含まれています、ではなく<paramref name="maxValue" />です。 ただし場合、 <paramref name="maxValue" /> 0 に等しい<paramref name="maxValue" />が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Random.Next%28System.Int32%29>オーバー ロードを返します、ランダムな整数範囲 0 ~ `maxValue` – 1。 ただし場合、`maxValue`が 0 の場合、メソッドは 0 を返します。  
  
   
  
## 例  
 次の例のさまざまなオーバー ロードを持つ整数の乱数を生成する、<xref:System.Random.Next%2A>メソッドです。  
  
 [!code-cpp[System.Random.Next\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 次のコード生成のインデックスとして使用するランダムな整数配列から文字列値を取得します。 配列のインデックスの最大値が 1 つ未満の長さの値であるため、<xref:System.Array.Length%2A?displayProperty=fullName>としてプロパティを指定する、`maxValue`パラメーター。  
  
 [!code-cpp[System.Random.Next\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">ランダムな数の下限が返されます。</param>
        <param name="maxValue">ランダムな数の上限が返されます。<c>maxValue</c>以上にする必要があります<c>minValue</c>です。</param>
        <summary>指定した範囲内のランダムな整数を返します。</summary>
        <returns>大きいまたは等しい 32 ビット符号付き整数<paramref name="minValue" />とより小さい<paramref name="maxValue" />。 つまり、戻り値の範囲に含まれる<paramref name="minValue" />ではなく<paramref name="maxValue" />です。 場合<paramref name="minValue" />equals <paramref name="maxValue" />、<paramref name="minValue" />が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>オーバー ロードはその範囲からランダムな整数を返します`minValue`に`maxValue`– 1。 ただし場合、 `maxValue` equals `minValue`、メソッドを返します`minValue`です。  
  
 他のオーバー ロードとは異なり、<xref:System.Random.Next%2A>メソッドで、のみ負の値を返すには、このメソッドは、負の値のランダムな整数を返すことができます。  
  
   
  
## 例  
 次の例では、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=fullName> 3 つの異なる範囲の整数の乱数を生成する方法です。 例では、実際の出力は、システム提供のシードに渡された値によって異なります、<xref:System.Random>クラスのコンス トラクターです。  
  
 [!code-cpp[System.Random.Next\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 次のコード生成のインデックスとして使用するランダムな整数配列から文字列値を取得します。 配列のインデックスの最大値がより小さい、長さ、値のいずれかであるため、<xref:System.Array.Length%2A?displayProperty=fullName>としてプロパティを指定する、`maxValue`パラメーター。  
  
 [!code-cpp[System.Random.Next\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> が <paramref name="maxValue" /> より大きくなっています。</exception>
        <block subset="none" type="overrides">
          <para>Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload if the difference between the <paramref name="minValue" /> and <paramref name="maxValue" /> parameters is greater than <see cref="F:System.Int32.MaxValue" />. Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used. This behavior improves the overall performance of the <see cref="T:System.Random" /> class. To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">乱数を格納するバイト配列。</param>
        <summary>指定したバイト配列の要素に乱数を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 バイトの配列の各要素に設定されている、ランダムな数より大きいまたは 0 に等しいまたはそれよりも小さいと<xref:System.Byte.MaxValue>です。  
  
 たとえば、ランダムなパスワードを作成するために適切な暗号で保護されたランダムな番号を生成するメソッドなど、使用<xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=fullName>です。  
  
   
  
## 例  
 次の例で使用する方法、<xref:System.Random.NextBytes%2A>メソッドでランダム バイト値を含むバイト配列を設定します。  
  
 [!code-cpp[Classic Random.NextBytes Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="overrides">
          <para>Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method. Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used. This behavior improves the overall performance of the <see cref="T:System.Random" /> class. To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0 以上 1.0 未満のランダムな浮動小数点数を返します。</summary>
        <returns>0.0 以上 1.0 未満の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドによって返されるランダムな数の上限、実際は、0.99999999999999978 です。  
  
 0.0 と 1.0 とは別の範囲内でランダムな浮動小数点値を取得するには、「指定された範囲の浮動小数点値を取得」のセクションを参照してください。、<xref:System.Random>クラスに関するトピック。  
  
 このメソッドは、保護されたメソッドの公開バージョン<xref:System.Random.Sample%2A>します。  
  
   
  
## 例  
 次の例では、<xref:System.Random.NextDouble%2A>のランダムな double 値のシーケンスを生成するメソッド。  
  
 [!code-cpp[System.Random.Ctor\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 次の例では、 <xref:System.Random.NextDouble%2A> 100 の乱数を生成する方法を番号し、その頻度分布が表示されます。  
  
 [!code-csharp[System.Random.NextDouble\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0 と 1.0 の間のランダムな浮動小数点数を返します。</summary>
        <returns>0.0 以上 1.0 未満の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生クラスを別のランダム配布や、異なる乱数ジェネレーターの原則を生成するために、<xref:System.Random>クラスし、オーバーライド、<xref:System.Random.Sample%2A>メソッドです。  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A>メソッドは`protected`、内でのみアクセスできることを意味する、<xref:System.Random>クラスとその派生クラス。 0 および 1 の間の乱数を生成する、<xref:System.Random>インスタンスの呼び出し、<xref:System.Random.NextDouble%2A>メソッドです。  
  
   
  
## 例  
 次の例からクラスを派生する<xref:System.Random>し、上書き、<xref:System.Random.Sample%2A>ランダムな数の分布を生成する方法です。 この分布はによって生成された一様分布とは異なる、<xref:System.Random.Sample%2A>基底クラスのメソッドです。  
  
 [!code-cpp[System.Random.Sample\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the following methods:  
  
-   The <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.  
  
-   The <see cref="M:System.Random.Next" /> method.  
  
-   The <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method, if (<paramref name="maxValue" /> - <paramref name="minValue" />) is greater than <see cref="F:System.Int32.MaxValue" />.  
  
 Instead, the uniform distribution provided by the base <see cref="T:System.Random" /> class is used. This behavior improves the overall performance of the <see cref="T:System.Random" /> class. To modify this behavior to call the implementation of the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the behavior of these three members. The example provides an illustration.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ランダムな整数を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>