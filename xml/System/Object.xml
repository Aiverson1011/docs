<Type Name="Object" FullName="System.Object">
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>.NET Framework クラス階層のすべてのクラスをサポートし、派生クラスに下位レベルのサービスを提供します。 これは、.NET Framework の全クラスの基本クラスであり、型階層のルートです。  
  
 この型の .NET Framework ソース コードを参照するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab)です。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを表示するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース \(パッチや更新を含む\) をステップsee [instructions](http://referencesource.microsoft.com/).  
  
 通常の言語は、クラスからの継承を宣言する必要ありません<xref:System.Object>の継承は暗黙的なためです。  
  
 .NET Framework のすべてのクラスがから派生するため<xref:System.Object>で定義されているすべてのメソッド、<xref:System.Object>クラスは、システム内のすべてのオブジェクトで使用できます。 派生クラスと、これらのメソッドの一部をオーバーライドしないでください。  
  
-   <xref:System.Object.Equals%2A>\-オブジェクト間の比較をサポートしています。  
  
-   <xref:System.Object.Finalize%2A>\-オブジェクトが自動的にクリアされる前のクリーンアップ操作を実行します。  
  
-   <xref:System.Object.GetHashCode%2A>ハッシュ テーブルの使用をサポートするために、オブジェクトの値に対応する番号を生成します。  
  
-   <xref:System.Object.ToString%2A>クラスのインスタンスを記述する人が判読できるテキスト文字列を製造しています。  
  
## パフォーマンスに関する考慮事項  
 どの型のオブジェクトを処理する必要が、コレクションなど、クラスをデザインする場合は、インスタンスを受け入れるクラス メンバーを作成することができます、<xref:System.Object>クラスです。 ただし、ボックス化と型をボックス化解除のプロセスでは、パフォーマンス コストが伴います。 新しいクラスの特定の値型を頻繁に処理することがわかっている場合は、ボックス化のコストを最小限に 2 つの方針のいずれかを使用できます。  
  
-   作成する一般的な方法を受け入れる、<xref:System.Object>型、および頻繁に処理するクラスを期待する各値の型を許容する型固有のメソッド オーバー ロードのセット。 型固有のメソッドを呼び出し元のパラメーター型を受け付けるが存在する場合は、ボックス化が行われず、型固有のメソッドが呼び出されます。 呼び出し元のパラメーターの型に一致するメソッドの引数がない場合は、パラメーターがボックス化され、一般的なメソッドが呼び出されます。  
  
-   ジェネリックを使用するには、種類とそのメンバーをデザインします。 共通言語ランタイムは、クラスのインスタンスを作成し、ジェネリック型引数を指定するときに、クローズ ジェネリック型を作成します。 ジェネリック メソッドは型固有であり、呼び出し元のパラメーターをボックス化しなくても呼び出すことができます。  
  
 受け取るまたは返す汎用クラスを開発するために必要な場合がありますが<xref:System.Object>型も頻繁に使用される型を処理する型固有のクラスを提供することによってパフォーマンスが向上することができます。 たとえばは、特定の設定とブール値を取得するクラスを提供するには、ボックス化とボックス化解除のブール値のコストが削減されます。  
  
   
  
## 例  
 次の例から派生したポイントの種類の定義、<xref:System.Object>クラスし、オーバーライドの仮想メソッドの多くは、<xref:System.Object>クラスです。 さらに、例、静的の多くを呼び出すのメソッドとインスタンス、<xref:System.Object>クラスです。  
  
 [!code-cpp[ObjectX\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 \(<see langword="Shared" /> Visual Basic で\) この型のメンバーは、スレッド セーフであります。 インスタンス メンバーは、スレッド セーフであることを保証はありません。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Object" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは派生クラスでコンス トラクターによって呼び出されますが、直接のインスタンスの作成にも使用できます、<xref:System.Object>クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">現在のオブジェクトと比較するオブジェクト。</param>
        <summary>指定したオブジェクトが、現在のオブジェクトと等しいかどうかを判断します。</summary>
        <returns>指定したオブジェクトが現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在のインスタンス間の比較の種類と`obj`パラメーターは、現在のインスタンスは、参照型または値型かどうかによって異なります。  
  
-   現在のインスタンスが、参照型である場合、<xref:System.Object.Equals%28System.Object%29>参照の等価性のテストのメソッドを呼び出すと、<xref:System.Object.Equals%28System.Object%29>メソッドへの呼び出しには、<xref:System.Object.ReferenceEquals%2A>メソッドです。 参照の等価性は、比較されたオブジェクト変数が同じオブジェクトを参照していることを意味します。 次の例は、このような比較の結果を示しています。 定義、`Person`クラスは、参照型である、および呼び出し、`Person`新しい 2 つのインスタンス化するクラスのコンス トラクター`Person`オブジェクト、`person1a`と`person2`、同じ値であります。 割り当てます`person1a`別のオブジェクト変数に`person1b`です。 例から出力として`person1a`と`person1b`が同じオブジェクトを参照するために等しい。 ただし、`person1a`と`person2`が、同じ値が等しくないです。  
  
     [!code-csharp[System.Object.Equals\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   現在のインスタンスが、値型である場合、<xref:System.Object.Equals%28System.Object%29>値の等価性のテストのメソッドです。 値の等価性には、次のことを意味します。  
  
    -   2 つのオブジェクトでは、同じ型です。 次の例に示すように、 <xref:System.Byte> 12 の値を持つオブジェクトが等しくない、<xref:System.Int32>を 2 つのオブジェクトがある実行時の型が異なるため、12 の値を持つオブジェクト。  
  
         [!code-csharp[System.Object.Equals\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   2 つのオブジェクトのパブリックおよびプライベート フィールドの値が等しいです。 次の例は、値の等価性をテストします。 定義、 `Person` 、構造体は値型と呼び出し、`Person`新しい 2 つのインスタンス化するクラスのコンス トラクター`Person`オブジェクト、`person1`と`person2`、同じ値であります。 2 つのオブジェクト変数、複数のオブジェクトを参照していますが、例からの出力が示すよう`person1`と`person2`がプライベートの同じ値があるために等しい`personName`フィールドです。  
  
         [!code-csharp[System.Object.Equals\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <xref:System.Object>クラスは、.NET Framework のすべての型の基本クラス、<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>メソッドは、他のすべての種類の既定の等値比較を提供します。 ただし、型多くの場合、上書き、<xref:System.Object.Equals%2A>値の等価性を実装するメソッド。 詳細については、の継承元のセクションでは呼び出し元関数とノートのノートを参照します。  
  
## は、[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 呼び出すと、<xref:System.Object.Equals%28System.Object%29>のクラスのメソッドのオーバー ロード、 [!INCLUDE[wrt](~/includes/wrt-md.md)]、しないをオーバーライドするクラスの既定の動作を提供<xref:System.Object.Equals%28System.Object%29>です。 これは、.NET Framework が [!INCLUDE[wrt](~/includes/wrt-md.md)]に提供するサポートの一部です \(「[.NET Framework Support for Windows Store Apps and Windows Runtime](http://msdn.microsoft.com/ja-jp/6fa7d044-ae12-4c54-b8ee-50915607a565)」を参照してください\)。 内のクラス、[!INCLUDE[wrt](~/includes/wrt-md.md)]継承しない<xref:System.Object>、現在実装していないと、<xref:System.Object.Equals%28System.Object%29>メソッドです。 ただし、それらがように見えます<xref:System.Object.ToString%2A>、 <xref:System.Object.Equals%28System.Object%29>、および<xref:System.Object.GetHashCode%2A>メソッド、c\# または Visual Basic コードで使用すると、.NET Framework では、これらのメソッドの既定の動作です。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]c\# または Visual Basic で記述されたクラスをオーバーライドして、<xref:System.Object.Equals%28System.Object%29>メソッドのオーバー ロードします。  
  
## 呼び出し元のノート  
 派生クラスでオーバーライドよく、<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>値の等価性を実装するメソッド。 さらに、型でもよくする追加の厳密に型指定されたオーバー ロードが提供、`Equals`メソッドを実装することで、通常、<xref:System.IEquatable%601>インターフェイスです。 呼び出すと、`Equals`等しいかどうかをテストするメソッド、現在のインスタンスを上書きするかどうかを知っておくべき<xref:System.Object.Equals%2A?displayProperty=fullName>に特定の呼び出し方法を理解して、`Equals`メソッドが解決します。 それ以外の場合、意図したものとは異なる等価性テストを実行して、メソッドは、予期しない値を返す可能性があります。  
  
 具体的な例を次に示します。 3 つをインスタンス化<xref:System.Text.StringBuilder>オブジェクトと同一の文字列とを 4 つの呼び出しを行い、`Equals`メソッドです。 最初のメソッドの呼び出しを返します`true`と残りの 3 つの戻り値`false`です。  
  
 [!code-csharp[System.Object.Equals\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 最初の場合、厳密に型指定<xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=fullName>値の等価性テスト メソッドのオーバー ロードが呼び出されます。 2 つの文字列が割り当てられているため<xref:System.Text.StringBuilder>オブジェクトが等しい、メソッドが返されます`true`です。 ただし、<xref:System.Text.StringBuilder>をオーバーライドしません<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>です。 このため、ときに、<xref:System.Text.StringBuilder>オブジェクトにキャスト、<xref:System.Object>ときに、<xref:System.Text.StringBuilder>インスタンスが型の変数に割り当てられた<xref:System.Object>とタイミング、<xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=fullName>メソッドが渡される 2 つ<xref:System.Text.StringBuilder>オブジェクト、既定値<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>メソッドが呼び出されます。<xref:System.Text.StringBuilder> 、参照型では、これは、2 つを渡すことに相当<xref:System.Text.StringBuilder>オブジェクトを<xref:System.Object.ReferenceEquals%2A>メソッドです。 3 つすべて<xref:System.Text.StringBuilder>オブジェクトと同じ文字列を格納する、3 つの異なるオブジェクトを参照しています。 その結果、これら 3 つのメソッド呼び出しを返す`false`です。  
  
 現在のオブジェクトを別のオブジェクト参照の等価性を比較するには呼び出すことによって、<xref:System.Object.ReferenceEquals%2A>メソッドです。 Visual basic で使用することも、`is`キーワード \(たとえば、 `If Me Is otherObject Then ...`\)。  
  
## 継承時の注意  
 独自の型を定義すると、その型を継承によって定義されている機能、`Equals`その基本型のメソッドです。 次の表に、既定の実装、 `Equals` .NET Framework の型の主なカテゴリのメソッドです。  
  
|型のカテゴリ|によって定義される等価性|コメント|  
|------------|------------------|----------|  
|直接派生したクラス<xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>|参照の等価性です。呼び出すことと同じ<xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>です。|  
|構造体|<xref:System.ValueType.Equals%2A?displayProperty=fullName>|値の等価性です。直接比較するバイトでまたはリフレクションを使用してフィールドの比較できます。|  
|列挙|<xref:System.Enum.Equals%2A?displayProperty=fullName>|値は、同じ列挙型と同じ基になる値が必要です。|  
|Delegate|<xref:System.MulticastDelegate.Equals%2A?displayProperty=fullName>|デリゲートには、同一の呼び出しリストを持つ同じ型が必要です。|  
|インターフェイス|<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>|参照の等価性。|  
  
 値型の場合は常にオーバーライドする<xref:System.Object.Equals%2A>リフレクションに依存する等値テスト パフォーマンスの低下を提供するため、します。 既定の実装を上書きすることもできます。<xref:System.Object.Equals%2A>参照型の参照の等価性ではなく値の等価性をテストすると、値の等価性の正確な意味を定義します。 このような実装の<xref:System.Object.Equals%2A>返す`true`同じインスタンスでない場合でも、2 つのオブジェクトが、同じ値があるかどうか。 型の実行者は、オブジェクトの値の構成内容を決定が、通常一部またはすべてのデータ オブジェクトのインスタンスの変数に格納します。 たとえばの値、<xref:System.String>オブジェクトは、文字列の文字に基づいて、<xref:System.String.Equals%28System.Object%29?displayProperty=fullName>メソッドのオーバーライド、<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>を返すメソッドを`true`任意の 2 つの文字列と同じ順序で同じ文字が含まれているインスタンス。  
  
 次の例は、オーバーライドする方法を示します、<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>値の等価性をテストするメソッド。 も優先、<xref:System.Object.Equals%2A>のメソッド、`Person`クラスです。 場合`Person`の等値をその基本クラス実装を受け入れる次の 2 つ`Person`オブジェクトは 1 つのオブジェクトを参照した場合にのみ、等価になります。 ただし、このケースでは、次の 2 つ`Person`オブジェクトが同じ値がある場合は等しく、`Person.Id`プロパティです。  
  
 [!code-csharp[System.Object.Equals\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 オーバーライドするだけでなく<xref:System.Object.Equals%2A>、実装することができます、<xref:System.IEquatable%601>等値の厳密に型指定されたテストを提供するインターフェイスです。  
  
 次のステートメントは、のすべての実装の場合は true である必要があります、<xref:System.Object.Equals%28System.Object%29>メソッドです。 一覧で、 `x`、 `y`、および`z`れていないオブジェクト参照を表す**null**です。  
  
-   `x.Equals(x)`返します`true`、浮動小数点型に関連する場合は除きます。 ISO と IEC\/IEEE 60559:2011、情報テクノロジ\-\-マイクロプロセッサ システムであり、浮動小数点算術演算子を参照してください。  
  
-   `x.Equals(y)`同じ値を返します`y.Equals(x)`です。  
  
-   `x.Equals(y)`返します`true`両方`x`と`y`は`NaN`します。  
  
-   場合`(x.Equals(y) && y.Equals(z))`返します`true`、し`x.Equals(z)`返します`true`です。  
  
-   連続して呼び出す`x.Equals(y)`によってオブジェクトが参照されている限り、同じ値を返す`x`と`y`は変更されません。  
  
-   `x.Equals(null)` は、`false` を返します。  
  
 実装<xref:System.Object.Equals%2A>は例外をスローする必要がありますいないそれらは常に値を返します。 たとえば場合、`obj`は`null`、<xref:System.Object.Equals%2A>メソッドが返す`false`スローする代わりに、<xref:System.ArgumentNullException>です。  
  
 オーバーライドする場合は、次のガイドラインをに従って<xref:System.Object.Equals%28System.Object%29>:  
  
-   型を実装する<xref:System.IComparable>オーバーライドする必要があります<xref:System.Object.Equals%28System.Object%29>です。  
  
-   型のオーバーライドが<xref:System.Object.Equals%28System.Object%29>もオーバーライドしなければなりません<xref:System.Object.GetHashCode%2A>以外の場合、ハッシュ テーブルが正しく動作しません。  
  
-   実装を検討する必要があります、<xref:System.IEquatable%601>強くをサポートするインターフェイスが等しいかどうかのテストを入力します。<xref:System.IEquatable%601.Equals%2A?displayProperty=fullName>実装と一貫性のある結果を返す必要があります<xref:System.Object.Equals%2A>です。  
  
-   場合は、プログラミング言語は、演算子のオーバー ロードをサポートしている、特定の型に対して、等値演算子をオーバー ロードして、上書きすることも必要があります、<xref:System.Object.Equals%28System.Object%29>等値演算子と同じ結果を返すメソッド。 これにより、そのクラス ライブラリのコードを使用する<xref:System.Object.Equals%2A>\(など<xref:System.Collections.ArrayList>と<xref:System.Collections.Hashtable>\) は、アプリケーション コードで、等値演算子を使用する方法と一致するように動作します。  
  
### 参照型に関するガイドライン  
 オーバーライドするのに次のガイドラインが適用<xref:System.Object.Equals%28System.Object%29>参照型。  
  
-   オーバーライドを検討してください<xref:System.Object.Equals%2A>場合は、型のセマンティクスは、という事実に基づいて、種類がいくつかの値を表します。  
  
-   ほとんどの参照型である必要がありますをオーバーライドする場合でもを等値演算子オーバー ロードしない<xref:System.Object.Equals%2A>です。 ただしなど、複雑な数値型の値のセマンティクスを持つものでは参照型を実装している場合は、等値演算子をオーバーライドする必要があります。  
  
-   オーバーライドしないでください<xref:System.Object.Equals%2A>変更可能な参照型にします。 これは、オーバーライドするため<xref:System.Object.Equals%2A>オーバーライドすることも必要があります、<xref:System.Object.GetHashCode%2A>メソッド、前のセクションで説明したようにします。 つまり、変更可能な参照型のインスタンスのハッシュ コードが、ハッシュ テーブルで、オブジェクトが失われた可能性がありますが、有効期間中に変更できます。  
  
### 値の型に関するガイドライン  
 オーバーライドするのに次のガイドラインが適用<xref:System.Object.Equals%28System.Object%29>値の型に対して。  
  
-   1 つまたは複数のフィールドを含む値の型を定義している場合は参照型の値が、オーバーライドする必要があります<xref:System.Object.Equals%28System.Object%29>です。<xref:System.Object.Equals%28System.Object%29>で提供される実装<xref:System.ValueType>値型がバイト単位の比較を実行のフィールドは、すべての値の型がリフレクションを使用して、その結果、フィールドが参照型を含む値の型のフィールドの比較を実行します。  
  
-   オーバーライドする場合は<xref:System.Object.Equals%2A>開発言語には、演算子のオーバー ロードがサポートしていると、等値演算子をオーバー ロードする必要があります。  
  
-   実装する必要があります、<xref:System.IEquatable%601>インターフェイスです。 厳密に型を呼び出す<xref:System.IEquatable%601.Equals%2A?displayProperty=fullName>メソッドは、ボックス化を回避できます、`obj`引数。  
  
   
  
## 例  
 例を次に、`Point`をオーバーライドするクラス、<xref:System.Object.Equals%2A>値の等価性を提供するメソッドと`Point3D`から派生したクラスを`Point`です。`Point`オーバーライド<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>値の等価性をテストする、<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>メソッドは呼び出されません。 ただし、`Point3D.Equals`呼び出し`Point.Equals`ため`Point`実装<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>で値の等価性を提供できるようにします。  
  
 [!code-csharp[ECMA\-System.Object.Equals2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA\-System.Object.Equals2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 The `Point.Equals` method checks to make sure that the **parameterReference tag is not supported!!!!**  
 argument is not **embeddedLabel tag is not supported!!!!**  
 and that it references an instance of the same type as this object. If either check fails, the method returns **languageKeyword tag is not supported!!!!**  
.  
  
 The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run\-time types of the two objects are identical. If the method used a check of the form `obj is Point` in C\# or `TryCast(obj, Point)` in Visual Basic, the check would return **languageKeyword tag is not supported!!!!**  
 in cases where **parameterReference tag is not supported!!!!**  
 is an instance of a derived class of `Point`, even though **parameterReference tag is not supported!!!!**  
 and the current instance are not of the same run\-time type. Having verified that both objects are of the same type, the method casts **parameterReference tag is not supported!!!!**  
 to type `Point` and returns the result of comparing the instance fields of the two objects.  
  
 In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>, is invoked before anything else is done. Because `Point3D` is a sealed class \(**languageKeyword tag is not supported!!!!**  
 in Visual Basic\), a check in the form `obj is Point` in C\# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that **parameterReference tag is not supported!!!!**  
 is a `Point3D` object. If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>. Only when the inherited `Point.Equals` method returns **languageKeyword tag is not supported!!!!**  
 does the method compare the `z` instance fields introduced in the derived class.  
  
 次の例では定義、`Rectangle`として 2 つの四角形を内部的に実装するクラス`Point`オブジェクト。`Rectangle`クラスも上書き<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>値の等価性を提供します。  
  
 [!code-csharp[ECMA\-System.Object.Equals3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA\-System.Object.Equals3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 C\# および Visual Basic などの一部の言語には、演算子のオーバー ロードがサポートされます。 オーバーライドする必要がありますも、型は、等値演算子をオーバー ロード、ときに、<xref:System.Object.Equals%28System.Object%29>同じ機能を提供するメソッド。 一般に記述して、<xref:System.Object.Equals%28System.Object%29>次の例のように、オーバー ロードされた等値演算子の観点からのメソッドです。  
  
 [!code-csharp[ECMA\-System.Object.Equals4\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA\-System.Object.Equals4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Because `Complex` is a value type, it cannot be derived from.  Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run\-time type of each object, but can instead use the **languageKeyword tag is not supported!!!!**  
 operator in C\# or the **languageKeyword tag is not supported!!!!**  
 operator in Visual Basic to check the type of the **parameterReference tag is not supported!!!!**  
 parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">比較する最初のオブジェクト。</param>
        <param name="objB">比較する 2 番目のオブジェクト。</param>
        <summary>指定されたインスタンスが等しいかどうかを判断します。</summary>
        <returns>オブジェクトが等しいと見なされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。<paramref name="objA" /> と <paramref name="objB" /> の両方が **null** の場合、このメソッドは <see langword="true" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, **parameterReference tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
, are equal. It also enables you to test objects whose value is **embeddedLabel tag is not supported!!!!**  
 for equality. It compares **parameterReference tag is not supported!!!!**  
 and**parameterReference tag is not supported!!!!**  
 for equality as follows:  
  
-   It determines whether the two objects represent the same object reference. If they do, the method returns **languageKeyword tag is not supported!!!!**  
    . This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method. In addition, if both **parameterReference tag is not supported!!!!**  
     and **parameterReference tag is not supported!!!!**  
    are **embeddedLabel tag is not supported!!!!**  
    , the method returns **languageKeyword tag is not supported!!!!**  
    .  
  
-   It determines whether either **parameterReference tag is not supported!!!!**  
     or **parameterReference tag is not supported!!!!**  
     is **embeddedLabel tag is not supported!!!!**  
    . If so, it returns **languageKeyword tag is not supported!!!!**  
    .  
  
-   If the two objects do not represent the same object reference and neither is **embeddedLabel tag is not supported!!!!**  
    , it calls **parameterReference tag is not supported!!!!**  
    .**languageKeyword tag is not supported!!!!**  
    \(**parameterReference tag is not supported!!!!**  
    \) and returns the result. This means that if **parameterReference tag is not supported!!!!**  
     overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method, this override is called.  
  
   
  
## 例  
 The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.  
  
 [!code-csharp[System.Object.Equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オブジェクトが、ガベージ コレクションによって収集される前に、リソースの解放とその他のクリーンアップ操作の実行を試みることができるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Object.Finalize%2A>オブジェクトが破棄される前に、現在のオブジェクトによって保持されているアンマネージ リソースのクリーンアップ操作を実行するメソッドを使用します。 メソッドが保護されているためおよび派生クラスによって、またはこのクラスによってのみアクセスできます。  
  
 このセクションの内容:  
  
-   [終了処理のしくみ](#How)  
  
-   [実装についてのメモ](#Notes)  
  
-   [代替手段としての SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## 終了処理のしくみ  
 <xref:System.Object>クラスの実装を提供なし、<xref:System.Object.Finalize%2A>メソッド、および、ガベージ コレクターから派生した型をマークしません<xref:System.Object>終了がオーバーライドされない限り、<xref:System.Object.Finalize%2A>メソッドです。  
  
 型をオーバーライドしている場合、<xref:System.Object.Finalize%2A>メソッド、ガベージ コレクターにエントリを追加、型のインスタンスごとにファイナライザー キューと呼ばれる内部構造体。 ファイナライザーのキューには、すべてのオブジェクトが終了コードは、ガベージ コレクターが自らのメモリを解放する前に実行する必要があります、マネージ ヒープ内のエントリが含まれています。 ガベージ コレクターを呼び出して、<xref:System.Object.Finalize%2A>メソッドは、次の条件下で自動的に。  
  
-   ガベージ コレクターがオブジェクトへの呼び出しによって終了処理から除外されている場合を除きには、オブジェクトがアクセス可能でないことを検出したら、<xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>メソッドです。  
  
-   アプリケーション ドメインのシャット ダウン中にオブジェクトが終了処理から除外されている場合を除き、します。 シャット ダウン中、引き続きアクセスできるものオブジェクトが完了しました。  
  
 <xref:System.Object.Finalize%2A>自動的に 1 回だけ呼び出す特定のインスタンスでオブジェクトが再などのメカニズムを使用して、登録されている場合を除き、<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=fullName>と<xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>メソッドが、その後に呼び出されていません。  
  
 <xref:System.Object.Finalize%2A>操作には、次の制限があります。  
  
-   ファイナライザーの実行の正確な時間は、定義されていません。 リソースの確定的に解放をように、クラスのインスタンスを実装する、`Close`メソッドを提供したり、<xref:System.IDisposable.Dispose%2A?displayProperty=fullName>実装します。  
  
-   2 つのオブジェクトのファイナライザーは、1 つのオブジェクトを指す他の場合でも、特定の順序で実行する保証はありません。 つまり、オブジェクト A がオブジェクト B への参照を両方ファイナライザーがある場合は、オブジェクト B 可能性がありますが既に終了されているオブジェクトのファイナライザーの開始時にします。  
  
-   ファイナライザーが実行されているスレッドは、指定されていません。  
  
 <xref:System.Object.Finalize%2A>メソッドが完了するまで実行されないか、次の例外的な状況でまったく実行されない可能性があります。  
  
-   別のファイナライザーが無期限にブロックした場合 \(、無限ループに移動しようとすることはありませんを入手してなどのロックの取得\)。 ランタイムがファイナライザーを完了するまで実行しようとするとため、その他のファイナライザー可能性がある場合は呼び出されませんファイナライザー ブロック無期限にします。  
  
-   場合は、ランタイムをクリーンアップする機会を与えることがなく、プロセスを終了します。 この場合、ランタイムのプロセスの終了の最初の通知はあります通知です。  
  
 ランタイムは、ファイナライズ可能なオブジェクトの数が減少し続けます中にのみ、シャット ダウン中にオブジェクトを最終処理を続行します。  
  
 場合<xref:System.Object.Finalize%2A>またはのオーバーライド<xref:System.Object.Finalize%2A>、例外をスローし、ランタイムが、既定のポリシーをオーバーライドするアプリケーションによってホストされていない、プロセスとはアクティブなランタイムが終了する`try`\/`finally`ブロックまたはファイナライザーを実行します。 この動作は、ファイナライザーが解放またはリソースを破棄できない場合、プロセスの整合性を確保します。  
  
<a name="Notes"></a>   
## 実装についてのメモ  
 オーバーライドする必要があります<xref:System.Object.Finalize%2A>などのアンマネージ リソースを使用するクラス ファイル ハンドルやデータベース接続ガベージ コレクション中にそれらを使用するマネージ オブジェクトが破棄されたときに解放する必要があります。  
  
> [!IMPORTANT]
>  場合、<xref:System.Runtime.InteropServices.SafeHandle>オブジェクトが使用可能なアンマネージ リソースをラップする、推奨される代替手段は、セーフ ハンドルの dispose パターンを実装し、無効にする<xref:System.Object.Finalize%2A>です。 詳細については、次を参照してください。[代わりに、SafeHandle](#SafeHandle)セクションです。  
  
 <xref:System.Object.Finalize%2A?displayProperty=fullName>メソッドは既定では、何しますが、オーバーライドする必要があります<xref:System.Object.Finalize%2A>のみ必要であれば、アンマネージ リソースを解放するだけです。 メモリを再利用には、少なくとも 2 つのガベージ コレクションが必要とするために終了操作を実行する場合は、かなり長くかかるに傾向があります。 さらに、オーバーライドする必要があります、<xref:System.Object.Finalize%2A>参照用のメソッドの型だけです。 共通言語ランタイムは、参照型のみを終了します。 値型でファイナライザーは無視されます。  
  
 すべての実装の<xref:System.Object.Finalize%2A>派生型での基本データ型の実装を呼び出す必要があります<xref:System.Object.Finalize%2A>です。 これを呼び出すアプリケーション コードが許可されている場合だけ<xref:System.Object.Finalize%2A>です。  
  
> [!NOTE]
>  C\# コンパイラを上書きすることはできません、<xref:System.Object.Finalize%2A>メソッドです。 実装することでファイナライザーを用意する代わりに、[デストラクター](http://msdn.microsoft.com/ja-jp/1ae6e46d-a4b1-4a49-abe5-b97f53d9e049)クラスです。 C\# のデストラクターでは、その基本クラスのデストラクターは、自動的に呼び出します。  
>   
>  Visual C を実装する独自の構文もが用意されています、<xref:System.Object.Finalize%2A>メソッドです。 詳細については、の「デストラクターとファイナライザー」セクションを参照してください。[How to: Define and Consume Classes and Structs \(C\+\+\/CLI\)](http://msdn.microsoft.com/ja-jp/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)です。  
  
 ガベージ コレクションは非決定的であるため、ガベージ コレクターが終了処理を実行すると正確にわかっていません。 リソースを解放する、すぐにこともできますを実装する、 [dispose パターン](http://msdn.microsoft.com/ja-jp/31a6c13b-d6a2-492b-9a9f-e5238c983bcb)と<xref:System.IDisposable>インターフェイスです。<xref:System.IDisposable.Dispose%2A?displayProperty=fullName> 、アンマネージ リソースを解放する、クラスのコンシューマーによって実装を呼び出すことができ、使用することができます、<xref:System.Object.Finalize%2A>アンマネージ リソースを解放するメソッド イベントで、<xref:System.IDisposable.Dispose%2A>メソッドは呼び出されません。  
  
 <xref:System.Object.Finalize%2A>ガベージ コレクション中にクリーンアップされた後に、オブジェクト \(つまり、オブジェクトにアクセスできるように再度\) 復活させる方法を含む、ほぼすべてのアクションを実行することができます。 ただし、オブジェクトできますのみ再生できるは 1 回です。<xref:System.Object.Finalize%2A>ガベージ コレクション中に再生されたオブジェクトで呼び出すことができません。 1 つのアクションがあることの実装<xref:System.Object.Finalize%2A>を渡す必要があります: が例外をスローする必要がありますしません。  
  
<a name="SafeHandle"></a>   
## 代替手段としての SafeHandle  
 信頼性の高いファイナライザーの作成が多くの場合、困難ですが、アプリケーションの状態に関する仮定をすることはできないためなど、未処理のシステム例外<xref:System.OutOfMemoryException>と<xref:System.StackOverflowException>ファイナライザーを終了します。 派生したオブジェクトを使用するアンマネージ リソースを解放するには、クラスのファイナライザーを実装するには、代わりに、<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>アンマネージ リソースをラップするクラスし、ファイナライザーせず、dispose パターンを実装します。 .NET Framework の次のクラスには、<xref:Microsoft.Win32?displayProperty=fullName>から派生した名前空間<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>ファイル ハンドルのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>メモリ マップト ファイル ハンドルのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>アンマネージ メモリ ブロックへのポインターのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、 <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>、および<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>暗号化ハンドルのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle>パイプ ハンドルのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>レジストリ キーへのハンドルのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>待機ハンドルのラッパー クラスです。  
  
 次の例では、 [dispose パターン](http://msdn.microsoft.com/ja-jp/31a6c13b-d6a2-492b-9a9f-e5238c983bcb)オーバーライドする代わりにセーフ ハンドルを使った、<xref:System.Object.Finalize%2A>メソッドです。 定義する、`FileAssociation`特定のファイル拡張子を持つファイルを処理するアプリケーションのレジストリ情報をラップするクラス。 として返される 2 つのレジストリ ハンドル`out`Windows によってパラメーター [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)関数の呼び出しに渡される、<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>コンス トラクターです。 型の保護された`Dispose`メソッドを呼び出します、`SafeRegistryHandle.Dispose`これら 2 つのハンドルを解放します。  
  
 [!code-csharp[System.Object.Finalize\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## 例  
 次の例では、あることを確認、<xref:System.Object.Finalize%2A>オブジェクトを上書きする場合に、メソッドが呼び出されます<xref:System.Object.Finalize%2A>は破棄されます。 なお、実稼働アプリケーションで、<xref:System.Object.Finalize%2A>オブジェクトによって保持されているアンマネージ リソースを解放するメソッドはオーバーライドされます。 なお、c\# の例にオーバーライドする代わりにデストラクターが提供されている、<xref:System.Object.Finalize%2A>メソッドです。  
  
 [!code-csharp[System.Object.Finalize\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定のハッシュ関数として機能します。</summary>
        <returns>現在のオブジェクトのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ハッシュ コードを挿入し、などハッシュ ベースのコレクション内のオブジェクトの識別に使用される数値の値は、<xref:System.Collections.Generic.Dictionary%602>クラス、<xref:System.Collections.Hashtable>クラスから派生した型、または、<xref:System.Collections.DictionaryBase>クラスです。<xref:System.Object.GetHashCode%2A>メソッドは、アルゴリズムを迅速にオブジェクトの等価性の確認を必要とするためこのハッシュ コードを提供します。  
  
> [!NOTE]
>  ハッシュ テーブルのハッシュ コードを使用する方法に関する情報といくつか追加のハッシュ コードのアルゴリズムを参照してください、 [Hash Function](http://en.wikipedia.org/wiki/Hash_function) Wikipedia で入力します。  
  
 等しいと同じ戻り値のハッシュ コードは、2 つのオブジェクト。 ただし、この逆はできません。 同じハッシュ コードを意味しませんオブジェクトの等価性 \(等しくない\) 別のオブジェクトが同一のハッシュ コードを持てないためです。 さらに、.NET Framework とは限りませんの既定の実装、<xref:System.Object.GetHashCode%2A>メソッド、および、このメソッドから返される値が異なる .NET Framework のバージョンとプラットフォームでは、32 ビットおよび 64 ビットのプラットフォームなどの間です。 これらの理由から、このメソッドの既定の実装固有のオブジェクト識別子としてに使わないハッシュの目的でします。 これから次の 2 つの影響。  
  
-   同じハッシュ コードがオブジェクトの等価性を示すものであると想定する必要があります。  
  
-   永続化したり、同じオブジェクトをアプリケーション ドメイン、プロセス、およびプラットフォーム間でハッシュ可能性がありますのでが作成されたアプリケーション ドメインの外部ハッシュ コードを使用する必要がありますしないでください。  
  
> [!WARNING]
>  ハッシュ コードは、効率的な挿入とハッシュ テーブルに基づいているコレクション内の参照です。 ハッシュ コードは、永続的な値ではありません。 このため。  
>   
>  -   ハッシュ コード値をシリアル化したり、データベースに格納しないでください。  
> -   キー付きのコレクションからオブジェクトを取得するのに、キーとしてハッシュ コードを使用しません。  
> -   アプリケーション ドメインまたはプロセス間では、ハッシュ コードを送信しません。 場合によっては、プロセスごとまたはアプリケーションごとのドメインごとにハッシュ コードを計算することがあります。  
> -   暗号強度が高いハッシュする必要がある場合は、暗号ハッシュ関数によって返される値ではなくハッシュ コードを使用しません。 暗号法のハッシュから派生するクラスを使用して、<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName>または<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName>クラスです。  
> -   2 つのオブジェクトが等しいかどうかを判断するハッシュ コードの等価性をテストしません。 \(等しくないオブジェクトは、同一のハッシュ コードを持つことができます\) 等しいかどうかをテストするには、呼び出し、<xref:System.Object.ReferenceEquals%2A>または<xref:System.Object.Equals%2A>メソッドです。  
  
 <xref:System.Object.GetHashCode%2A>派生型でメソッドをオーバーライドすることができます。 場合<xref:System.Object.GetHashCode%2A>がオーバーライドされていないハッシュ コードを呼び出すことによって計算が参照型、<xref:System.Object.GetHashCode%2A?displayProperty=fullName>ハッシュ コードを計算する、基本クラスのメソッド ベース以外のオブジェクトの参照の詳細についてを参照してください<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName>です。 つまり、2 つのオブジェクトを<xref:System.Object.ReferenceEquals%2A>メソッドを返します。`true`同一のハッシュ コードがあります。 値の型をオーバーライドしない場合<xref:System.Object.GetHashCode%2A>、<xref:System.ValueType.GetHashCode%2A?displayProperty=fullName>基底クラスのメソッドでは、リフレクションを使用して、型のフィールドの値に基づいてハッシュ コードを計算します。 つまり、その結果、フィールドが同じ値を持つ値型では、同じハッシュ コードがあります。 オーバーライドの詳細については<xref:System.Object.GetHashCode%2A>、「ノート継承クラス」を参照してください。  
  
> [!WARNING]
>  オーバーライドする場合、<xref:System.Object.GetHashCode%2A>メソッドもオーバーライドする<xref:System.Object.Equals%2A>、およびその逆です。 場合、オーバーライドされた<xref:System.Object.Equals%2A>メソッドを返します。`true`等しいかどうかを、オーバーライドされた 2 つのオブジェクトをテストするときに<xref:System.Object.GetHashCode%2A>メソッドは、2 つのオブジェクトに対して同じ値を返す必要があります。  
  
 ハッシュ テーブル内のキーとして使用されるオブジェクトがに役立ちます実装を提供していないかどうか<xref:System.Object.GetHashCode%2A>、ハッシュ コード プロバイダーを指定するには指定することによって、<xref:System.Collections.IEqualityComparer>実装のオーバー ロードのいずれかに、<xref:System.Collections.Hashtable>クラスのコンス トラクターです。  
  
## は、[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 呼び出すと、<xref:System.Object.GetHashCode%2A>内のクラスのメソッド、 [!INCLUDE[wrt](~/includes/wrt-md.md)]、しないをオーバーライドするクラスの既定の動作を提供<xref:System.Object.GetHashCode%2A>です。 これは、.NET Framework が [!INCLUDE[wrt](~/includes/wrt-md.md)]に提供するサポートの一部です \(「[.NET Framework Support for Windows Store Apps and Windows Runtime](http://msdn.microsoft.com/ja-jp/6fa7d044-ae12-4c54-b8ee-50915607a565)」を参照してください\)。 内のクラス、[!INCLUDE[wrt](~/includes/wrt-md.md)]継承しない<xref:System.Object>、現在実装していないと、<xref:System.Object.GetHashCode%2A>です。 ただし、それらがように見えます<xref:System.Object.ToString%2A>、 <xref:System.Object.Equals%28System.Object%29>、および<xref:System.Object.GetHashCode%2A>メソッド、c\# または Visual Basic コードで使用すると、.NET Framework では、これらのメソッドの既定の動作です。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]c\# または Visual Basic で記述されたクラスをオーバーライドして、<xref:System.Object.GetHashCode%2A>メソッドです。  
  
   
  
## 例  
 ハッシュ コードを同じか、またはより小さい範囲を持つ数値を計算する最も簡単な方法の 1 つ、<xref:System.Int32>型が単純にその値を返すにします。 次の例では、このような実装、`Number`構造体。  
  
 [!code-csharp[System.Object.GetHashCode\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 多くの場合、型では、ハッシュ コードの生成に含めることができる複数のデータ フィールドがあります。 使用してこれらのフィールドを結合するにはハッシュ コードを生成する方法、`XOR (eXclusive OR)`操作、次の例で示すようにします。  
  
 [!code-csharp[System.Object.GetHashCode\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 前の例は、\(n1、n2\) に対して同じハッシュ コードを返します \(n2、n1\)、および、要件を満たしているよりも多くの競合を生成する可能性があります。 ソリューションの数は、このような場合のハッシュ コードが同じでないようにに利用可能なされます。 1 つのハッシュ コードを返すには、`Tuple`の各フィールドの順序を反映するオブジェクト。 次の例では、使用可能な実装、<xref:System.Tuple%602>クラスです。 ただしをインスタンス化のパフォーマンスのオーバーヘッド、`Tuple`オブジェクトは、ハッシュ テーブルに多数のオブジェクトを格納するアプリケーションの全体的なパフォーマンスに大きく影響可能性があります。  
  
 [!code-csharp[System.Object.GetHashCode\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 2 番目の代替ソリューションには、連続するフィールドのハッシュ コードを 2 つ以上のビットを左シフトして個々 のハッシュ コードを重み付けが含まれます。 最適に、破棄されるのではなくビット 31 を超えてシフトをラップするではなくは破棄されます。 C\# および Visual Basic の両方で左シフト演算子では、ビットが破棄され、以降は、次のように左 shift キーを押し、ラップ メソッドを作成する必要があります。  
  
 [!code-csharp[System.Object.GetHashCode\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 次の例は、のハッシュ コードを計算するこのシフトの折り返し方法を使用して、`Point`前の例で使用される構造体。  
  
 [!code-csharp[System.Object.GetHashCode\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object. Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input. Hash codes should not be computed by using the values of static fields.  
  
 For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality. The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method. You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types. In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:  
  
-   You can compute the hash code from fields that are not mutable; or  
  
-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.  
  
 Otherwise, you might think that the mutable object is lost in the hash table. If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.  
  
 For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection. You should consider overriding it for better performance.  
  
 <block subset="none" type="note"><para>  
 For more information and examples that compute hash codes in a variety of ways, see the Examples section.  
  
</para></block>  
  
 A hash function must have the following properties:  
  
-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value. However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.  
  
-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's <see cref="Overload:System.Object.Equals" /> method. Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.  
  
-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered. An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.  
  
-   Hash functions should be inexpensive to compute.  
  
-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.  
  
 For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values. Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value. Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).  
  
 Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table. In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation). In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(<paramref name="n" />) operation, where <paramref name="n" /> is the number of items in the hash table). A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:  
  
-   When hash functions produce frequent collisions.  
  
-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.  
  
-   When users input the data from which the hash code is computed.  
  
 Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスの <see cref="T:System.Type" /> を取得します。</summary>
        <returns>現在のインスタンスの正確なランタイム型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Object?displayProperty=fullName>の .NET Framework の型システムでは、すべての型の基底クラス、<xref:System.Object.GetType%2A>を返すメソッドを使用できます<xref:System.Type>すべての .NET Framework 型を表すオブジェクト。 .NET Framework には、次の 5 つの種類のカテゴリが認識されます。  
  
-   派生したクラス<xref:System.Object?displayProperty=fullName>、  
  
-   派生した型の値<xref:System.ValueType?displayProperty=fullName>です。  
  
-   派生したインターフェイス<xref:System.Object?displayProperty=fullName>.NET Framework 2.0 を起動します。  
  
-   派生した列挙体は、<xref:System.Enum?displayProperty=fullName>です。  
  
-   派生したデリゲート<xref:System.MulticastDelegate?displayProperty=fullName>です。  
  
 2 つのオブジェクトの`x`と`y`同一のランタイム型がある`Object.ReferenceEquals(x.GetType(),y.GetType())`返します`true`です。 次の例で、<xref:System.Object.GetType%2A>メソッドを<xref:System.Object.ReferenceEquals%2A>メソッドを 1 つの数値が他の 2 つの数値の値と同じ型であるかどうかを判別します。  
  
 [!code-csharp[System.Object.GetType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  オブジェクトはを特定の種類であるかどうかを判断するのには、言語の型比較キーワードを使用したり作成できます。 たとえば、使用することができます、 `TypeOf…Is` Visual Basic で構築または`is`c\# のキーワードです。  
  
 <xref:System.Object.GetType%2A>から派生したすべての型によって継承されたメソッド<xref:System.Object>です。 これは、比較の独自言語のキーワードを使用して、に加えて使用できることを意味、<xref:System.Object.GetType%2A>メソッドを次の例のように、特定のオブジェクトの種類を決定します。  
  
 [!code-csharp[System.Object.GetType\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <xref:System.Type>オブジェクトは、現在のクラスに関連付けられているメタデータを公開<xref:System.Object>です。  
  
   
  
## 例  
 次のコード例では、ことを示します<xref:System.Object.GetType%2A>現在のインスタンスのランタイム型を返します。  
  
 [!code-cpp[ECMA\-System.Object.GetType\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA\-System.Object.GetType\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA\-System.Object.GetType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Object" /> の簡易コピーを作成します。</summary>
        <returns>現在の <see cref="T:System.Object" /> の簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Object.MemberwiseClone%2A>メソッドでは、シャロー コピーを作成して新しいオブジェクトの作成を新しいオブジェクトに現在のオブジェクトの非静的フィールドをコピーします。 フィールドが値型の場合、フィールドのビットごとのコピーは実行されます。 フィールドが参照型の場合、参照はコピーしますが、参照されるオブジェクトではありません。そのため、元のオブジェクトとその複製は、同じオブジェクトを参照します。  
  
 たとえば、オブジェクト A と B をさらに、参照の参照オブジェクト c です。 X と呼ばれるオブジェクトX の簡易コピーを作成もオブジェクト A と B を参照する新しいオブジェクト X2これに対し、X の詳細コピーが A2 と B2、A のコピーである新しいオブジェクトを参照する新しいオブジェクト X2 を作成し、B. B2 がさらに、c ドライブのコピーである新しいオブジェクト C2 を参照例は、shallow と詳細なコピー操作の違いを示しています。  
  
 によって、シャロー コピー操作が実行される場合、詳細なコピー操作を実装する方法はたくさんあります、<xref:System.Object.MemberwiseClone%2A>ニーズを満たしていないメソッドです。 次に例を示します。  
  
-   コピーを最初のオブジェクトから取得したプロパティ値で 2 番目のオブジェクトを作成するオブジェクトのクラスのコンス トラクターを呼び出します。 これは、クラス コンス トラクターによって、オブジェクトの値がまったく定義されていると仮定します。  
  
-   呼び出す、<xref:System.Object.MemberwiseClone%2A>メソッドをオブジェクトのシャロー コピーを作成し、そのプロパティまたはフィールドの値を持つ参照型を元のオブジェクトと同じ値が新しいオブジェクトを割り当てます。`DeepCopy`メソッドの例では、このアプローチを示します。  
  
-   コピーするには、深くするオブジェクトをシリアル化し、別のオブジェクト変数をシリアル化されたデータを復元します。  
  
-   再帰ではリフレクションを使用して、詳細なコピー操作を実行します。  
  
   
  
## 例  
 次の例を示しています、<xref:System.Object.MemberwiseClone%2A>メソッドです。 定義する、`ShallowCopy`メソッドを呼び出す、<xref:System.Object.MemberwiseClone%2A>シャロー コピー操作を実行するメソッド、`Person`オブジェクト。 定義、`DeepCopy`のディープ コピー操作を実行するメソッド、`Person`オブジェクト。  
  
 [!code-csharp[System.Object.MemberwiseClone\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 In this example, the `Person.IdInfo` property returns an `IdInfo` object. As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference. As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property. On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">比較する最初のオブジェクト。</param>
        <param name="objB">比較する 2 番目のオブジェクト。</param>
        <summary>指定した複数の <see cref="T:System.Object" /> インスタンスが同一インスタンスかどうかを判断します。</summary>
        <returns>
          <see langword="true" />場合<paramref name="objA" />と同じインスタンスは、<paramref name="objB" />か、どちら**null**、それ以外の<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 異なり、<xref:System.Object.Equals%2A>メソッドおよび等値演算子、<xref:System.Object.ReferenceEquals%2A>メソッドをオーバーライドすることはできません。 このため、テストする場合は、2 つのオブジェクトが等しいかどうかを参照していないの実装に関することを確認して、`Equals`メソッドが呼び出すことができます、<xref:System.Object.ReferenceEquals%2A>メソッドです。  
  
 ただし、戻り値の<xref:System.Object.ReferenceEquals%2A>メソッドは、これら 2 つのシナリオで異常なできるように表示される可能性があります。  
  
-   ときに、値の型を比較します。 場合`objA`と`objB`は、値の型に渡される前にボックス化されている、<xref:System.Object.ReferenceEquals%2A>メソッドです。 つまり、この両方`objA`と`objB`値の型の同じインスタンスを表す、<xref:System.Object.ReferenceEquals%2A>メソッドを返しますそれにもかかわらず`false`次の例に示すように、します。  
  
     [!code-csharp[System.Object.ReferenceEquals\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     値の型をボックス化については、次を参照してください。[Boxing and Unboxing \(C\# Programming Guide\)](http://msdn.microsoft.com/ja-jp/8da9bbf4-bce9-4b08-b2e5-f64c11c56514)です。  
  
-   文字列を比較する場合。 場合`objA`と`objB`文字列、<xref:System.Object.ReferenceEquals%2A>メソッドを返します。`true`場合は、文字列がインターン プールに存在します。 値の等価性テストを行うことはできません。  次の例では、`s1`と`s2`は等しいためにが 1 つのインターン処理後の文字列の 2 つのインスタンス。 ただし、`s3`と`s4`が等しくない、まったく同じ文字列値がありますは、その文字列がインターンいないためです。  
  
     [!code-csharp[System.Object.ReferenceEquals\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     文字列インターンの使用の詳細については、次を参照してください。<xref:System.String.IsInterned%2A?displayProperty=fullName>です。  
  
   
  
## 例  
 次の例で<xref:System.Object.ReferenceEquals%2A>2 つのオブジェクトが同じインスタンスにします。  
  
 [!code-cpp[ECMA\-System.Object.ReferenceEquals\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA\-System.Object.ReferenceEquals\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA\-System.Object.ReferenceEquals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のオブジェクトを表す文字列を返します。</summary>
        <returns>現在のオブジェクトを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Object.ToString%2A?displayProperty=fullName> メジャーは、.NET Framework のメソッドをフォーマットしています。 表示に適したように、オブジェクトを文字列形式に変換します。 \(.NET Framework でのサポートを書式設定方法の詳細については、次を参照してください [Formatting Types in the .NET Framework](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)。\)。 既定の実装、 <xref:System.Object.ToString%2A?displayProperty=fullName> メソッドがオブジェクトの型の完全修飾名を取得します。  
  
> [!IMPORTANT]
>  別の型のメンバーの一覧からリンクからこのページに達している可能性があります。 これはその型をオーバーライドしないため <xref:System.Object.ToString%2A?displayProperty=fullName>です。 機能を継承する代わりに、 <xref:System.Object.ToString%2A?displayProperty=fullName> メソッドです。  
  
 型は多くの場合、オーバーライド、 <xref:System.Object.ToString%2A?displayProperty=fullName> 特定の種類のより適切な文字列形式を提供するメソッドです。 型でも頻繁にオーバー ロード、 <xref:System.Object.ToString%2A?displayProperty=fullName> 書式指定文字列またはカルチャの書式設定のサポートを提供するメソッドです。  
  
 このセクションの内容:  
  
 [既定の Object.ToString\(\) メソッド](#Default)   
 [Object.ToString\(\) メソッドをオーバーライドします。](#Overriding)   
 [ToString メソッドをオーバー ロード](#Overloading)   
 [Object.ToString メソッドを拡張します。](#Extending)   
 [Windows ランタイムのノート](#WinRT)  
  
<a name="Default"></a>   
## 既定の Object.ToString\(\) メソッド  
 既定の実装、 <xref:System.Object.ToString%2A> メソッドの型の完全修飾名を返します、 <xref:System.Object>, 次の例を示します。  
  
 [!code-cpp[System.Object.ToString\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <xref:System.Object> すべての参照型の基本クラスは、.NET framework では、この動作はオーバーライドしない参照型によって継承、 <xref:System.Object.ToString%2A> メソッドです。 次に例を示します。 という名前のクラスが定義 `Object1` すべての既定の実装を受け入れる <xref:System.Object> メンバーです。 その <xref:System.Object.ToString%2A> メソッドは、オブジェクトの完全修飾型名を返します。  
  
 [!code-cpp[System.Object.ToString\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## Object.ToString\(\) メソッドをオーバーライドします。  
 型は通常、オーバーライド、 <xref:System.Object.ToString%2A?displayProperty=fullName> オブジェクト インスタンスを表す文字列を返します。 基本型など、たとえば、 <xref:System.Char>, 、<xref:System.Int32>, 、および <xref:System.String> 提供 <xref:System.Object.ToString%2A> オブジェクトによって表される値の文字列形式を返す実装します。 次の例は、クラスを定義 `Object2`, 、オーバーライド、 <xref:System.Object.ToString%2A> とその値の型名を返すメソッド。  
  
 [!code-cpp[System.Object.ToString\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 次の表は、.NET Framework の種類のカテゴリを一覧表示し、それらを上書きするかどうかどうかを示す、 <xref:System.Object.ToString%2A?displayProperty=fullName> メソッドです。  
  
|型のカテゴリ|Object.ToString\(\) をオーバーライドします。|動作|  
|------------|--------------------------------------|--------|  
|クラス|適用なし|適用なし|  
|構造体|\[はい\] \(<xref:System.ValueType.ToString%2A?displayProperty=fullName>\)|Object.ToString\(\) と同じ|  
|列挙|\[はい\] \(<xref:System.Enum.ToString?displayProperty=fullName>\)|メンバー名|  
|インターフェイス|いいえ|適用なし|  
|Delegate|いいえ|適用なし|  
  
 オーバーライドの詳細については、継承クラス」の注意を参照してください <xref:System.Object.ToString%2A>します。  
  
<a name="Overloading"></a>   
## ToString メソッドをオーバー ロード  
 パラメーターなしで上書きできるだけでなく <xref:System.Object.ToString?displayProperty=fullName> メソッドでは、さまざまな種類のオーバー ロード、 `ToString` メソッド パラメーターを受け取るメソッドのバージョンを提供します。 ほとんどの場合、これは変数の書式とカルチャの書式設定をサポートするためです。  
  
 次の例のオーバー ロード、 `ToString` のさまざまなフィールドの値を含む結果の文字列を返すメソッドを `Automobile` クラスです。 次の 4 つの書式指定文字列を定義します G、年月日、おモデル名が返されます。D で、モデルの名前、年、および; のドアの数を返しますC で、モデルの名前、年、およびシリンダー; の数を返しますA で、次の 4 つのフィールド値はすべて文字列として返します。  
  
 [!code-csharp[System.Object.ToString\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 次の例では、オーバー ロードされた <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> カルチャが通貨値の書式を表示します。  
  
 [!code-csharp[System.Object.ToString\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 書式指定文字列とカルチャの書式設定の詳細については、次を参照してください。 [Formatting Types](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)します。 書式指定文字列を数値でサポートされている、次を参照してください。 [標準の数値書式指定文字列](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) と [カスタム数値書式指定文字列](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)します。 日付と時刻の値でサポートされている書式指定文字列を参照してください。 [標準の日時書式指定文字列](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b) と [カスタムの日付と時刻の書式指定文字列](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)します。  
  
<a name="Extending"></a>   
## Object.ToString メソッドを拡張します。  
 型が既定値を継承しているため <xref:System.Object.ToString%2A?displayProperty=fullName> メソッド、望ましくない動作を検索して変更します、。 これは特に、配列とコレクション クラスです。 想定されるときに、 `ToString` メソッド配列またはコレクションのメンバーの値を表示するクラスの代わりに表示の種類の完全修飾型名は、次のようです。  
  
 [!code-csharp[System.Object.ToString\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 希望する結果の文字列を生成するいくつかのオプションがあります。  
  
-   型が、配列、コレクション オブジェクトまたはオブジェクトを実装する場合、 <xref:System.Collections.IEnumerable> または <xref:System.Collections.Generic.IEnumerable%601> インターフェイスを使用してその要素を列挙することができます、 `foreach` c\# でのステートメントまたは `For Each...Next` Visual Basic で作成します。  
  
-   クラスがない場合 `sealed` \(c\#\) のまたは `NotInheritable` の基本クラスから継承するラッパー クラスを開発する \(Visual Basic の場合\) で <xref:System.Object.ToString%2A?displayProperty=fullName> をカスタマイズする方法です。 少なくとも以下のこと、これが必要です。  
  
    1.  必要なコンス トラクターを実装します。 派生クラスは、その基本クラス コンス トラクターを継承しません。  
  
    2.  オーバーライド、 <xref:System.Object.ToString%2A?displayProperty=fullName> を希望する結果の文字列を返すメソッド。  
  
     次の例のラッパー クラスを定義する、 <xref:System.Collections.Generic.List%601> クラスです。 これは、上書き、 <xref:System.Object.ToString%2A?displayProperty=fullName> 完全修飾型名ではなく、コレクションの各メソッドの値を表示するメソッドです。  
  
     [!code-csharp[System.Object.ToString\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   開発、 [拡張メソッド](http://msdn.microsoft.com/ja-jp/5de945cb-88f4-49d7-b0e6-f098300cf357) する結果の文字列を返します。 注既定値をオーバーライドすることはできません <xref:System.Object.ToString%2A?displayProperty=fullName> この方法でメソッド \(つまり、拡張機能クラス \(c\#\) または \(Visual Basic\) でモジュールという名前のパラメーターのないメソッドことはできません `ToString` 元の型の代わりに呼び出される `ToString` メソッドです。 パラメーターなしの他のいくつかの名前を指定する必要があります `ToString` 置換します。  
  
     次の例を拡張する 2 つのメソッドを定義する、 <xref:System.Collections.Generic.List%601> クラス: パラメーターなし `ToString2` メソッド、および `ToString` メソッドを <xref:System.String> 書式指定文字列を表すパラメーターです。  
  
     [!code-csharp[System.Object.ToString\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## は、 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 呼び出すと、 <xref:System.Object.ToString%2A> 内のクラスのメソッド、 [!INCLUDE[wrt](~/includes/wrt-md.md)], 、オーバーライドしなければクラスの既定の動作を提供して <xref:System.Object.ToString%2A>します。 これは、.NET Framework が [!INCLUDE[wrt](~/includes/wrt-md.md)]に提供するサポートの一部です \(「[.NET Framework Support for Windows Store Apps and Windows Runtime](http://msdn.microsoft.com/ja-jp/6fa7d044-ae12-4c54-b8ee-50915607a565)」を参照してください\)。 内のクラス、 [!INCLUDE[wrt](~/includes/wrt-md.md)] 継承しない <xref:System.Object>, 、常に実装していないと、 <xref:System.Object.ToString%2A>です。 ただし、常に表示されますが <xref:System.Object.ToString%2A>, 、<xref:System.Object.Equals%28System.Object%29>, 、および <xref:System.Object.GetHashCode%2A> メソッド、c\# または Visual Basic コードで使用すると、.NET Framework では、これらのメソッドの既定の動作です。  
  
 以降で、 [!INCLUDE[net_v451](~/includes/net-v451-md.md)], 、共通言語ランタイムを使用して [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 上、 [!INCLUDE[wrt](~/includes/wrt-md.md)] オブジェクトの既定の実装に戻る前に <xref:System.Object.ToString%2A?displayProperty=fullName>します。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] c\# または Visual Basic で記述されているクラスをオーバーライドして、 <xref:System.Object.ToString%2A> メソッドです。  
  
### [!INCLUDE[wrt](~/includes/wrt-md.md)] と IStringable インターフェイス  
 以降で [!INCLUDE[win81](~/includes/win81-md.md)], 、 [!INCLUDE[wrt](~/includes/wrt-md.md)] を含む、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) インターフェイスが 1 つのメソッド [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), で提供される比較可能な基本の書式設定のサポートを提供 <xref:System.Object.ToString%2A?displayProperty=fullName>します。 あいまいさを回避するのには実装しないでください [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) マネージ型にします。  
  
 ネイティブ コードまたは JavaScript または C\+\+ などの言語で記述されたコードでのマネージ オブジェクトが呼び出されるタイミング\/cli 実装現れる\/CX では、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)します。 共通言語ランタイムはからの呼び出しに自動的にルーティング [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) に <xref:System.Object.ToString%2A?displayProperty=fullName> イベント [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) がマネージ オブジェクトで実装されていません。  
  
> [!WARNING]
>  共通言語ランタイムの自動実装するため [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 内の型のすべての管理 [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] 、アプリをお勧めことを指定しない独自 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 実装します。 実装する [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) が原因で予期しない動作を呼び出す際 `ToString` から、 [!INCLUDE[wrt](~/includes/wrt-md.md)], 、C \+ \+\/CX では、または JavaScript。  
  
 実装を選択する場合は [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) でエクスポートしたパブリック マネージ型で、 [!INCLUDE[wrt](~/includes/wrt-md.md)] コンポーネントでは、次の制限が適用されます。  
  
-   定義する、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) など「クラスが実装する」関係でしかインターフェイス  
  
    ```  
    public class NewClass : IStringable  
    ```  
  
     C\# では、上記のようになります。  
  
    ```  
    Public Class NewClass : Implements IStringable  
    ```  
  
     Visual Basic では、上記のようになります。  
  
-   実装することはできません [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) インターフェイスです。  
  
-   型のパラメーターを宣言することはできません [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)します。  
  
-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) メソッド、プロパティ、またはフィールドの戻り値の型にすることはできません。  
  
-   非表示にすることはできません、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 、次のようなメソッド定義を使用して、基本クラスから実装します。  
  
    ```  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     代わりに、 [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 実装は、基本クラスの実装を常にオーバーライドする必要があります。`ToString` の実装を隠すことができるのは、厳密に型指定されたクラス インスタンスで呼び出す場合だけです。  
  
 なお、さまざまな条件を実装するマネージ型にネイティブ コードから呼び出す [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) の表示と非その [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 実装は、予期しない動作を引き起こすことができます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types. Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface. Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.  
  
 Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:  
  
-   The returned string should be friendly and readable by humans.  
  
-   The returned string should uniquely identify the value of the object instance.  
  
-   The returned string should be as short as possible so that it is suitable for display by a debugger.  
  
-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.  
  
-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.  
  
-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.  
  
-   If the returned string includes sensitive information, you should first demand an appropriate permission. If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.  
  
-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging. For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.  
  
-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つのオブジェクト インスタンスが等しいかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>