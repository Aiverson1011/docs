<Type Name="TypeInitializationException" FullName="System.TypeInitializationException">
  <TypeSignature Language="C#" Value="public sealed class TypeInitializationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit TypeInitializationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.TypeInitializationException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>クラス初期化子によってスローされた例外をラップするラッパーとしてスローされる例外。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 When a class initializer fails to initialize a type, a <xref:System.TypeInitializationException> is created and passed a reference to the exception thrown by the type's class initializer. The <xref:System.Exception.InnerException%2A> property of <xref:System.TypeInitializationException> holds the underlying exception.  
  
 Typically, the <xref:System.TypeInitializationException> exception reflects a catastrophic condition \(the runtime is unable to instantiate a type\) that prevents an application from continuing.  Most commonly, the <xref:System.TypeInitializationException> is thrown in response to some change in the executing environment of the application. Consequently, other than possibly for troubleshooting debug code, the exception should not be handled in a **languageKeyword tag is not supported!!!!**  
\/**languageKeyword tag is not supported!!!!**  
 block. Instead, the cause of the exception should be investigated and eliminated.  
  
 <xref:System.TypeInitializationException> uses the HRESULT COR\_E\_TYPEINITIALIZATION, which has the value 0x80131534.  
  
 For a list of initial property values for an instance of <xref:System.TypeInitializationException>, see the <xref:System.TypeInitializationException.%23ctor%2A> constructors.  
  
 The following sections describe some of the situations in which a <xref:System.TypeInitializationException> exception is thrown.  
  
 [Static constructors and the TypeInitializationException exception](#Static)   
 [Regular expression match timeout values](#Timeout)   
 [Calendars and cultural data](#Calendars)  
  
<a name="Static"></a>   
## Static constructors and the TypeInitializationException exception  
 A static constructor, if one exists, is called automatically by the runtime before creating a new instance of a type. Static constructors can be explicitly defined by a developer. If a static  constructor is not explicitly defined, compilers automatically create one to initialize any **languageKeyword tag is not supported!!!!**  
 \(in C\#\) or **languageKeyword tag is not supported!!!!**  
 \(in Visual Basic\) members of the type.  For more information on static constructors, see [Static Constructors \(C\# Programming Guide\)](http://msdn.microsoft.com/ja-jp/151ec95e-3c4d-4ed7-885d-95b7a3be2e7d).  
  
 Most commonly, a <xref:System.TypeInitializationException> exception is thrown when a static constructor is unable to instantiate a type.  The <xref:System.Exception.InnerException%2A> property indicates why the static constructor was unable to instantiate the type. Some of the more common causes of a <xref:System.TypeInitializationException> exception are:  
  
 An unhandled exception in a static constructor  
 If an exception is thrown in a static constructor, that exception is wrapped in a <xref:System.TypeInitializationException> exception, and the type cannot be instantiated.  
  
 What often makes this exception difficult to troubleshoot is that static constructors are not always explicitly defined in source code. A static constructor exists in a type if:  
  
-   It has been explicitly defined as a member of a type.  
  
-   The type has  **languageKeyword tag is not supported!!!!**  
     \(in C\#\) or **languageKeyword tag is not supported!!!!**  
     \(in Visual Basic\) variables that are declared and initialized in a single statement. In this case, the language compiler generates a static constructor for the type. You can inspect it by using a utility such as [IL Disassembler](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b). For instance, when the C\# and VB compilers compile the following example, they generate the IL for a static constructor that is similar to this:  
  
    ```  
  
    .method private specialname rtspecialname static   
            void  .cctor() cil managed  
    {  
      // Code size       12 (0xc)  
      .maxstack  8  
      IL_0000:  ldc.i4.3  
      IL_0001:  newobj     instance void TestClass::.ctor(int32)  
      IL_0006:  stsfld     class TestClass Example::test  
      IL_000b:  ret  
    } // end of method Example::.cctor  
  
    ```  
  
 The following example shows a <xref:System.TypeInitializationException> exception thrown by a compiler\-generated static constructor. The `Example` class includes a **languageKeyword tag is not supported!!!!**  
 \(in C\#\) or **languageKeyword tag is not supported!!!!**  
 \(in Visual Basic\) field of type `TestClass` that is instantiated by passing a value of 3 to its class constructor.  That value, however, is illegal; only values of 0 or 1 are permitted. As a result, the `TestClass` class constructor throws an <xref:System.ArgumentOutOfRangeException>. Since this exception is not handled, it is wrapped in a <xref:System.TypeInitializationException> exception.  
  
 [!code-csharp[System.TypeInitializationException\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/ctorException1.cs#3)]
 [!code-vb[System.TypeInitializationException\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/CtorException1.vb#3)]  
  
 Note that the exception message displays information about the <xref:System.Exception.InnerException%2A> property.  
  
 A missing assembly or data file  
 A common cause of a <xref:System.TypeInitializationException> exception is that an assembly or data file that was present in an application's development and test environments is missing from its runtime environment. For example, you can compile the following example to an assembly named Missing1a.dll by using the this command\-line syntax:  
  
```csharp  
csc /t:library Missing1a.cs  
```  
  
```vb  
vbc Missing1a.vb /t:library  
```  
  
 [!code-csharp[System.TypeInitializationException\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Missing1a.cs#1)]
 [!code-vb[System.TypeInitializationException\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Missing1a.vb#1)]  
  
 You can then compile the following example to an executable named Missing1.exe by including a reference to Missing1a.dll:  
  
```csharp  
csc Missing1.cs /r:Missing1a.dll  
```  
  
```vb  
vbc Missing1.vb /r:Missing1a.dll  
```  
  
 However, if you rename, move, or delete Missing1a.dll and run the example, it throws a <xref:System.TypeInitializationException> exception and displays the output shown in the example.  Note that the exception message includes information about the <xref:System.Exception.InnerException%2A> property. In this case,  the inner exception is a <xref:System.IO.FileNotFoundException> that is thrown because the runtime cannot find the dependent assembly.  
  
 [!code-csharp[System.TypeInitializationException\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Missing1.cs#2)]
 [!code-vb[System.TypeInitializationException\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Missing1.vb#2)]  
  
> [!NOTE]
>  In this example, a <xref:System.TypeInitializationException> exception was thrown because an assembly could not be loaded. The exception can also be thrown if a static constructor attempts to open a data file, such as a configuration file, an XML file, or a file containing serialized data, that it cannot find.  
  
<a name="Timeout"></a>   
## Regular expression match timeout values  
 You can set the default timeout value for a regular expression pattern matching operation on a per\-application domain basis. The timeout is defined by a specifying a <xref:System.TimeSpan> value for the "REGEX\_DEFAULT\_MATCH\_TIMEOUT" property to the  <xref:System.AppDomain.SetData%2A?displayProperty=fullName> method. The time interval must be a valid <xref:System.TimeSpan> object that is greater than zero and less than approximately 24 days. If these requirements are not met, the attempt to set the default timeout value throws an <xref:System.ArgumentOutOfRangeException>, which in turn is wrapped in a <xref:System.TypeInitializationException> exception.  
  
 The following example shows the <xref:System.TypeInitializationException> that is thrown when the value assigned to the "REGEX\_DEFAULT\_MATCH\_TIMEOUT" property is invalid. To eliminate the exception, set the"REGEX\_DEFAULT\_MATCH\_TIMEOUT" property to a  <xref:System.TimeSpan> value that is greater than zero and less than approximately 24 days.  
  
 [!code-csharp[System.TypeInitializationException\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Regex1.cs#4)]
 [!code-vb[System.TypeInitializationException\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Regex1.vb#4)]  
  
<a name="Calendars"></a>   
## Calendars and cultural data  
 If you attempt to instantiate a calendar but the runtime is unable to instantiate  the <xref:System.Globalization.CultureInfo> object that corresponds to that calendar, it throws a <xref:System.TypeInitializationException> exception. This exception can be thrown by the following calendar class constructors:  
  
-   The default constructor of the <xref:System.Globalization.JapaneseCalendar> class.  
  
-   The default constructor of the <xref:System.Globalization.KoreanCalendar> class.  
  
-   The default constructor of the <xref:System.Globalization.TaiwanCalendar> class.  
  
 Since cultural data for these cultures should be available on all systems, you should rarely, if ever, encounter this exception.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeInitializationException (string fullTypeName, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fullTypeName, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TypeInitializationException.#ctor(System.String,System.Exception)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fullTypeName" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="fullTypeName">初期化に失敗した型の完全修飾名。</param>
        <param name="innerException">現在の例外の原因となった例外。<c>innerException</c> パラメーターが null 参照 \(Visual Basic の場合は <see langword="Nothing" />\) でない場合は、内部例外を処理する <see langword="catch" /> ブロックで現在の例外が発生します。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.TypeInitializationException" /> した既定のエラー メッセージ、指定された型名とこの例外の根本的な原因である内部例外への参照。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 前の例外の直接の結果としてスローされる例外は、<xref:System.Exception.InnerException%2A> プロパティに前の例外への参照を含んでいる場合があります。<xref:System.Exception.InnerException%2A> プロパティは、コンストラクターに渡されたものと同じ値を返します。`Nothing` プロパティによって内部例外値がコンストラクターに渡されなかった場合は、null 参照 \(Visual Basic の場合は <xref:System.Exception.InnerException%2A>\) を返します。  
  
 <xref:System.TypeInitializationException> のインスタンスの初期プロパティ値を次の表に示します。  
  
|プロパティ|値|  
|-----------|-------|  
|<xref:System.Exception.InnerException%2A>|内部例外の参照。|  
|<xref:System.Exception.Message%2A>|ローカライズされたエラー メッセージ文字列。|  
|<xref:System.TypeInitializationException.TypeName%2A>|型の名前。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public override void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TypeInitializationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">スローされた例外に関する、シリアル化されたオブジェクト データを保持する <see cref="T:System.Runtime.Serialization.SerializationInfo" /> です。</param>
        <param name="context">転送元または転送先についてのコンテキスト情報を含む <see cref="T:System.Runtime.Serialization.StreamingContext" /> です。</param>
        <summary>セット、 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 型名と追加の例外情報を持つオブジェクト。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="TypeName">
      <MemberSignature Language="C#" Value="public string TypeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TypeName" />
      <MemberSignature Language="DocId" Value="P:System.TypeInitializationException.TypeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>初期化に失敗した型の完全修飾名を取得します。</summary>
        <value>初期化に失敗した型の完全修飾名。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>