<Type Name="AccessViolationException" FullName="System.AccessViolationException">
  <TypeSignature Language="C#" Value="public class AccessViolationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit AccessViolationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.AccessViolationException" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>保護されたメモリに対して読み取りまたは書き込みを行おうとするとスローされる例外。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 コードでは、読み取りまたは書き込みのメモリを割り当てられていないか、先にアクセスできないしようとすると、アンマネージ コードまたはアンセーフ コードでアクセス違反が発生します。 これは通常、ポインターは無効な値を持つために発生します。 無効なポインターによる読み取りまたは書き込みがすべてアクセス違反になるとは限らないため、通常、アクセス違反は、無効なポインターによって複数の読み取りまたは書き込みが発生したこと、およびメモリが破損している可能性があることを示します。 したがって、アクセス違反はほぼ常に深刻なプログラミング エラーを示します。<xref:System.AccessViolationException>これらの重大なエラーを明確に識別します。  
  
 全体が検証可能なマネージ コードで構成される、プログラムですべての参照が有効であるか、または null、およびアクセス違反は可能でありません。 検証可能なコードがスローされます内の null 参照を参照しようとするすべての操作、<xref:System.NullReferenceException>例外。<xref:System.AccessViolationException>のみと検証可能なマネージ コードを操作または安全でないマネージ コードとアンマネージ コードと発生します。  
  
## AccessViolationException 例外のトラブルシューティング  
 <xref:System.AccessViolationException>安全でないマネージ コードでのみ例外が発生するか、コードがアンマネージ コードとやり取りするとき、検証可能な管理します。  
  
-   安全でないマネージ コードで発生したアクセス違反は、いずれかとして表現できますを<xref:System.NullReferenceException>例外または<xref:System.AccessViolationException>によっては、プラットフォームの例外。  
  
-   マネージ コードにバブルをアンマネージ コードでアクセス違反は、常にラップ、<xref:System.AccessViolationException>例外。  
  
 どちらの場合、識別し、の原因を修正、<xref:System.AccessViolationException>次のように例外。  
  
 アクセスしようとしているメモリが割り当て済みであることを確認します。  
 <xref:System.AccessViolationException>例外がメモリにアクセスする保護された\-\-は、メモリを割り当てられていないか、プロセスを所有していないにアクセスしようとして常にスローされます。  
  
 自動メモリ管理は、共通言語ランタイムが提供するサービスの 1 つです。 マネージ コードでは、unmanagede コードと同じ機能を提供する場合は、この機能を活用するために、マネージ コードに移動する可能性があります。 詳細については、「[Automatic Memory Management](http://msdn.microsoft.com/ja-jp/d4850de5-fa63-4936-a250-5678d118acba)」を参照してください。  
  
 アクセスしようとしているメモリが破損していないことを確認します。  
 無効なポインターによって複数の読み取り操作または書き込み操作が発生すると、メモリが破損する場合があります。 これは通常、定義済みのバッファーの外部アドレスに対して読み取りまたは書き込み時に発生します。  
  
## AccessViolationException と try ブロックと catch ブロック  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.AccessViolationException>で共通言語ランタイムによってスローされた例外は処理されない、`catch`共通言語ランタイムによって予約されるメモリの外部では、例外が発生した場合は、構造化例外ハンドラー内のステートメント。 などを処理するために、<xref:System.AccessViolationException>適用する必要があります、例外、<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>例外がスローされたメソッドに属性します。 この変更には影響しません<xref:System.AccessViolationException>によってキャッチを続行できるユーザー コードによってスローされた例外、`catch`ステートメントです。 再コンパイルし、変更せずに実行する .NET Framework の以前のバージョン用に記述されたコードに対して、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、追加することができます、 [\<legacyCorruptedStateExceptionsPolicy\>](http://msdn.microsoft.com/ja-jp/e0a55ddc-bfa8-4f3e-ac14-d1fc3330e4bb)要素をアプリの構成ファイル\<\/legacyCorruptedStateExceptionsPolicy\>。 また、ハンドラーを定義している場合にも、例外の通知が表示されることができます、<xref:System.AppDomain.FirstChanceException?displayProperty=fullName>または<xref:System.AppDomain.UnhandledException?displayProperty=fullName>イベント。  
  
## バージョン情報  
 .NET Framework 2.0 とそれ以降のバージョンでは、この例外はスローします。 .NET Framework の以前のバージョンで、アンマネージ コードまたは安全でないマネージ コードでアクセス違反がによって表される、<xref:System.NullReferenceException>マネージ コードでします。 A<xref:System.NullReferenceException>データの破損を含まないイベントの発生、検証可能なマネージ コードでは null 参照が逆参照し、バージョン 1.0 または 1.1 では、2 つの状況を区別する手段がないときにもスローされます。  
  
 管理者は、.NET Framework version 1.1 の動作に戻すには、選択したアプリケーションを許可できます。 次の行での配置、[\<runtime\> Element](http://msdn.microsoft.com/ja-jp/1eb2fae3-de4b-45b6-852f-517c39b751bd)アプリケーションの構成ファイルのセクション。  
  
```  
<legacyNullReferenceExceptionPolicy enabled = "1"/>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>エラーを説明するシステム提供のメッセージを使用して、<see cref="T:System.AccessViolationException" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクター、<xref:System.Exception.Message%2A>エラーを説明するシステム提供のメッセージの新しいインスタンスのプロパティなど"しようの読み取りまたは書き込み保護されているメモリ。 これは多くの場合、その他のメモリが破損していることを示す値です。" このメッセージには、現在のシステムのカルチャが考慮されます。  
  
 <xref:System.AccessViolationException> のインスタンスの初期プロパティ値を次の表に示します。  
  
|プロパティ|値|  
|-----------|-------|  
|<xref:System.Exception.InnerException%2A>|`null`。|  
|<xref:System.Exception.Message%2A>|ローカライズされたエラー メッセージ文字列。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">例外を説明するメッセージ。 このコンストラクターの呼び出し元は、この文字列が現在のシステムのカルチャに合わせてローカライズ済みであることを確認しておく必要があります。</param>
        <summary>エラーを説明する指定したメッセージを使用して、<see cref="T:System.AccessViolationException" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AccessViolationException> のインスタンスの初期プロパティ値を次の表に示します。  
  
|プロパティ|値|  
|-----------|-------|  
|<xref:System.Exception.InnerException%2A>|`null`。|  
|<xref:System.Exception.Message%2A>|`message` に指定されたエラー メッセージ文字列。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AccessViolationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">シリアル化されたオブジェクト データを保持する <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">転送元または転送先についてのコンテキスト情報を含む <see cref="T:System.Runtime.Serialization.StreamingContext" /> です。</param>
        <summary>シリアル化したデータを使用して、<see cref="T:System.AccessViolationException" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンストラクターは、逆シリアル化中に、ストリームで送信された例外オブジェクトを再構築するために呼び出されます。 詳細については、「[XML and SOAP Serialization](http://msdn.microsoft.com/ja-jp/832ac524-21bc-419a-a27b-ca8bfc45840f)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.String,System.Exception)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">例外を説明するメッセージ。 このコンストラクターの呼び出し元は、この文字列が現在のシステムのカルチャに合わせてローカライズ済みであることを確認しておく必要があります。</param>
        <param name="innerException">現在の例外の原因となった例外。<c>innerException</c> パラメーターが <see langword="null" /> でない場合は、内部例外を処理する <see langword="catch" /> ブロックで現在の例外が発生します。</param>
        <summary>指定したエラー メッセージおよびこの例外の原因となった内部例外への参照を使用して、<see cref="T:System.AccessViolationException" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 前の例外の直接の結果としてスローされる例外については、<xref:System.Exception.InnerException%2A> プロパティに、前の例外への参照が格納されます。<xref:System.Exception.InnerException%2A> プロパティは、コンストラクターに渡されたものと同じ値を返します。`null` プロパティによって内部例外値がコンストラクターに渡されなかった場合は、<xref:System.Exception.InnerException%2A> を返します。  
  
 <xref:System.AccessViolationException> のインスタンスの初期プロパティ値を次の表に示します。  
  
|プロパティ|値|  
|-----------|-------|  
|<xref:System.Exception.InnerException%2A>|`null`。|  
|<xref:System.Exception.Message%2A>|`message` に指定されたエラー メッセージ文字列。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.AccessViolationException" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>