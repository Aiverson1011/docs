<Type Name="Type" FullName="System.Type">
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>型宣言を表します。型には、クラス型、インターフェイス型、配列型、値型、列挙型、型パラメーター、ジェネリック型定義、およびオープン構築ジェネリック型またはクローズ構築ジェネリック型があります。  
  
 この型の .NET Framework ソース コードを参照するには、[参照ソース](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3)をご覧ください。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3). You can browse through the source code online, download the reference for offline viewing, and step through the sources \(including patches and updates\) during debugging; see [instructions](http://referencesource.microsoft.com/).  
  
 `Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata. Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type \(such as the constructors, methods, fields, properties, and events of a class\), as well as the module and the assembly in which the class is deployed.  
  
 No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels. No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation. However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>. See [Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5).  
  
 `Type` is an abstract base class that allows multiple implementations. The system will always provide the derived class `RuntimeType`. In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.  
  
> [!NOTE]
>  In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to **languageKeyword tag is not supported!!!!**  
>  data. Other code, over which you have no control, might also lock your class type. This might result in a deadlock. Instead, synchronize access to static data by locking a private **languageKeyword tag is not supported!!!!**  
>  object.  
  
> [!NOTE]
>  A derived class can access protected members of the calling code's base classes. Also, access is allowed to assembly members of the calling code's assembly. As a rule, if you are allowed access in early\-bound code, then you are also allowed access in late\-bound code.  
  
> [!NOTE]
>  Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.  
  
 In this section:  
  
 [What types does a Type object represent?](#WhatTypes)   
 [Retrieving a Type object](#Retrieve)   
 [Comparing type objects for equality](#Equality)  
  
<a name="WhatTypes"></a>   
## What types does a Type object represent?  
 This class is thread safe; multiple threads can concurrently read from an instance of this type. An instance of the <xref:System.Type> class can represent any of the following types:  
  
-   Classes  
  
-   Value types  
  
-   Arrays  
  
-   Interfaces  
  
-   Enumerations  
  
-   Delegates  
  
-   Constructed generic types and generic type definitions  
  
-   Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions  
  
<a name="Retrieve"></a>   
## Retrieving a Type object  
 The <xref:System.Type> object associated with a particular type can be obtained in the following ways:  
  
-   The instance <xref:System.Object.GetType%2A?displayProperty=fullName> method returns a <xref:System.Type> object that represents the type of an instance. Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.  
  
     The following example calls the <xref:System.Object.GetType%2A?displayProperty=fullName> method to determine the runtime type of each object in an object array.  
  
     [!code-cpp[System.Type\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   The static <xref:System.Type.GetType%2A?displayProperty=fullName> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.  
  
-   The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=fullName>, <xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=fullName> methods return **languageKeyword tag is not supported!!!!**  
     objects that represent the types defined in a module. The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module. \(You can obtain an instance of **languageKeyword tag is not supported!!!!**  
     through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=fullName> method, or through the <xref:System.Type.Module%2A?displayProperty=fullName> property.\)  
  
-   The <xref:System.Reflection.Assembly?displayProperty=fullName> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=fullName>.  
  
-   The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.  
  
-   The <xref:System.Type.GetElementType%2A> method returns a **languageKeyword tag is not supported!!!!**  
     object that represents the element.  
  
-   The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.  
  
-   The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects. The objects are specified with an array of type <xref:System.Object>.  
  
-   The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability. They return a <xref:System.Type> object that represents the type specified by a **languageKeyword tag is not supported!!!!**  
     or **languageKeyword tag is not supported!!!!**  
    .  
  
-   The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability. It returns a **languageKeyword tag is not supported!!!!**  
     object that represents the type specified by a class handle.  
  
-   The C\# **languageKeyword tag is not supported!!!!**  
     operator, the C\+\+ **languageKeyword tag is not supported!!!!**  
     operator, and the Visual Basic **languageKeyword tag is not supported!!!!**  
     operator obtain the **languageKeyword tag is not supported!!!!**  
     object for a type.  
  
-   The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns **languageKeyword tag is not supported!!!!**  
    , and a closed constructed type otherwise. A generic type can be instantiated only if it is closed.  
  
-   The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter \(**languageKeyword tag is not supported!!!!**  
     in C\#, **languageKeyword tag is not supported!!!!**  
     in Visual Basic\).  
  
<a name="Equality"></a>   
## Comparing type objects for equality  
 A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type. This allows for comparison of <xref:System.Type> objects using reference equality. The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.  
  
 [!code-cpp[System.Type\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## 例  
 The following  example shows a few representative features of <xref:System.Type>. The C\# **languageKeyword tag is not supported!!!!**  
 operator \(**languageKeyword tag is not supported!!!!**  
 operator in Visual Basic, **languageKeyword tag is not supported!!!!**  
 operator in Visual C\+\+\) is used to get a <xref:System.Type> object representing <xref:System.String>. From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A> overload that takes a starting location and a length.  
  
 To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing **languageKeyword tag is not supported!!!!**  
 \(**languageKeyword tag is not supported!!!!**  
 in Visual Basic\).  
  
> [!NOTE]
>  To be precise, the array contains two references to the instance of <xref:System.Type> that represents **languageKeyword tag is not supported!!!!**  
>  in the current application domain. For any type, there is only one instance of <xref:System.Type> per application domain.  
  
 The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World\!", and displays the result.  
  
 [!code-cpp[System.Type\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>When you inherit from <see langword="Type" />, you must override the following members:  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Type" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは、型のオブジェクトの作成中に、派生クラスによって呼び出されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が宣言される <see cref="T:System.Reflection.Assembly" /> を取得します。 ジェネリック型の場合は、ジェネリック型が定義される <see cref="T:System.Reflection.Assembly" /> を取得します。</summary>
        <value>現在の型を含むアセンブリを説明する <see cref="T:System.Reflection.Assembly" /> インスタンス。 ジェネリック型の場合、インスタンスは特定の構築型を作成および使用するアセンブリではなく、ジェネリック型定義を含むアセンブリを説明します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、現在<xref:System.Type>オブジェクトが構築されたジェネリック型を表し、このプロパティは、ジェネリック型定義を含むアセンブリを返します。 たとえば、ジェネリック型定義を含む MyGenerics.dll をという名前のアセンブリを作成する`MyGenericStack<T>`\(`MyGenericStack(Of T)` Visual basic で`generic<T> ref class MyGenericStack`C\+\+ で\)。 インスタンスを作成する場合`MyGenericStack<int>`\(`MyGenericStack(Of Integer)` Visual Basic で\) 別のアセンブリ内、<xref:System.Type.Assembly%2A>構築された型のプロパティを返します、 <xref:System.Reflection.Assembly> MyGenerics.dll を表すオブジェクト。  
  
 同様に場合、現在<xref:System.Type>オブジェクト未割り当てのジェネリック パラメーターを表す`T`、このプロパティは、ジェネリック型定義を格納するアセンブリを返します`T`です。  
  
 場合、 <xref:System.Type.Assembly%2A?displayProperty=fullName> .NET Core またはユニバーサル Windows プラットフォームなど、特定の .NET プラットフォームで利用可能なプロパティは、使用して、`System.Reflection.TypeInfo.Assembly`プロパティ代わりにします。?qualifyHint=False&autoUpgrade=True  
  
 このプロパティは読み取り専用です。  
  
   
  
## 例  
 次の例では、クラスに関連付けられているアセンブリ名と型の完全修飾名が表示されます。  
  
 [!code-cpp[Type\_Assembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type\_Assembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type\_Assembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> オブジェクトの読み込み元であるアセンブリの名前を含む型のアセンブリ修飾名を取得します。</summary>
        <value>
          <see cref="T:System.Type" /> の読み込み元であるアセンブリの名前を含む、<see cref="T:System.Type" /> のアセンブリ修飾名。現在のインスタンスがジェネリック型パラメーターを表す場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型のアセンブリ修飾名は、アセンブリの表示名を続けて、コンマの後にその名前空間を含む型の名前で構成されます。 使用してアセンブリの表示名を取得、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>プロパティです。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture \= msil"です。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Type.AssemblyQualifiedName%2A>互換性のためのプロパティです。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>」を参照してください。  
  
 共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を生成し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。  
  
|区切り記号|説明|  
|-----------|--------|  
|円記号 \(\\\)|文字をエスケープします。|  
|コンマ \(,\)|アセンブリ名の前にします。|  
|プラス記号 \(\+\)|入れ子になったクラスが前に付きます。|  
|ピリオド \(.\)|名前空間の識別子を表します。|  
|角かっこ \(\)|型名の後に、その型の配列を表します。<br /><br /> または<br /><br /> ジェネリック型のジェネリック型引数リストが含まれます。<br /><br /> または<br /><br /> 型引数リスト内で、アセンブリ修飾型を囲みます。|  
  
 たとえば、クラスのアセンブリ修飾名は、次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 名前空間には、たとえば TopNamespace.Sub\+Namespace、プラス記号が含まれている場合、プラス記号 \(\+\) が前に、入れ子の区切り記号として解釈されないようにエスケープ文字 \(\\\) です。 リフレクションでは、次のようにこの文字列を出力は。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 A"では"が"\\ \+ \\ \+"、および「\\」「\\\\」になります。  
  
 この修飾名を永続化し、後で読み込むために使用することができます、<xref:System.Type>です。 検索して読み込む、<xref:System.Type>を使用して<xref:System.Type.GetType%2A>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。<xref:System.Type.GetType%2A>型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリにし、システム アセンブリです。<xref:System.Type.GetType%2A>アセンブリ修飾型名は探します、<xref:System.Type>任意のアセンブリにします。  
  
 型名には、型は、参照型、ポインター型または配列型かどうかの種類に関する追加情報を示す末尾の文字が含まれます。 このような末尾の文字型の名前を取得する`t.GetElementType().ToString()`ここで、`t`型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントの該当します。 アセンブリ名に ',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型のジェネリック引数は、アセンブリ名で修飾された自体です。 などのアセンブリ修飾型名で`MyGenericClass<int>`\(`MyGenericClass(Of Integer)` Visual Basic で\)、`int`のアセンブリ修飾型名に拡張された<xref:System.Int32>です。  
  
 場合、現在<xref:System.Type>オブジェクトは、ジェネリック パラメーターを表す、このプロパティを返します`null`です。  
  
   
  
## 例  
 次の例では、クラスに関連付けられているアセンブリ名と型の完全修飾名が表示されます。  
  
 [!code-cpp[type\_assembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type\_assembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type\_assembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 次の例で返される文字列の比較、<xref:System.Type.ToString%2A>メソッドおよび`Name`、 <xref:System.Type.FullName%2A>、および<xref:System.Type.AssemblyQualifiedName%2A>プロパティです。  
  
 [!code-csharp[System.Type.ToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> に関連付けられている属性を取得します。</summary>
        <value>
          <see cref="T:System.Reflection.TypeAttributes" /> の属性セットを表す <see cref="T:System.Type" /> オブジェクト。ただし、<see cref="T:System.Type" /> がジェネリック型パラメーターを表す場合、値は未指定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 一部のメンバー、<xref:System.Reflection.TypeAttributes>列挙体は値のグループを表すマスク。 各グループには、基になる値が 0、1 つのメンバーが含まれています。 たとえば、基になる値の<xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=fullName>内のメンバー、<xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=fullName>グループは、0 の場合は、<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=fullName>内のメンバー、<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=fullName>グループ。 このため、それらの値をテストする前に、マスクを使用する必要があります。 具体的な例を次に示します。  
  
> [!TIP]
>  ほとんどの目的のプロパティと同様に<xref:System.Type.IsClass%2A>、<xref:System.Type.IsAutoLayout%2A>、および<xref:System.Type.IsSpecialName%2A>型の属性より簡単に使用されます。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、ジェネリック型定義の属性を返します。 に対して返される属性など、 `MyGenericClass<int>` \(`MyGenericClass(Of Integer)` Visual Basic で\) の属性`MyGenericClass<T>`\(`MyGenericClass(Of T)` Visual Basic で\)。  
  
 場合、現在<xref:System.Type>がジェネリック型パラメーターを表す\-は場合、<xref:System.Type.IsGenericParameter%2A>プロパティから返される`true`—、<xref:System.Reflection.TypeAttributes>このプロパティによって返される値は指定されていません。  
  
   
  
## 例  
 次の例ポイント<xref:System.Type.Attributes%2A>プロパティです。  
  
 [!code-csharp[System.Type.Attributes\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の直接の継承元である型を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> の直接の継承元の <see cref="T:System.Type" />。現在の <see langword="null" /> が <see langword="Type" /> クラスまたはインターフェイスを表す場合は <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 基本データ型は、現在の型の直接の継承元となる型です。<xref:System.Object> そのため、基本型を持たない唯一の種類は、 `null` の基本型として返される <xref:System.Object>です。  
  
 インターフェイスに 0 個以上の基本インターフェイスから継承します。したがって、このプロパティが返されます `null` 場合、 `Type` オブジェクトは、インターフェイスを表します。 基本インターフェイスを確定できる <xref:System.Type.GetInterfaces%2A> または <xref:System.Type.FindInterfaces%2A>です。  
  
 場合は、現在 <xref:System.Type> 構築されたジェネリック型を表します、基本型がジェネリック引数を反映します。 たとえば、次の宣言があるとします。  
  
 [!code-cpp[System.Type.BaseType\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 構築された型の `C<int>` \(`C(Of Integer)` Visual Basic で\)、 <xref:System.Type.BaseType%2A> プロパティを返します。 `B<int>`します。  
  
 場合は、現在 <xref:System.Type> 、ジェネリック型定義の型パラメーターを表す <xref:System.Type.BaseType%2A> クラス制約の型パラメーターを継承する必要がありますクラスであるを返します。 クラスの制約がない場合は <xref:System.Type.BaseType%2A> 返します <xref:System.Object?displayProperty=fullName>します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## 例  
 次の例を使用して、 <xref:System.Type.BaseType%2A> プロパティです。  
  
 [!code-cpp[TestBaseType\#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType\#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 次の例では、再帰を使用して、アセンブリに含まれる各クラスの完全な継承階層を一覧表示します。 例では、という名前のクラスを定義する `C` という名前のクラスから派生した `B`, 、これはという名前のクラスから派生、 `A`です。  
  
 [!code-csharp[System.Type.BaseType\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> オブジェクトが特定の型で置き換えられていない型パラメーターを持っているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> オブジェクト自体がジェネリック型パラメーターであるか、特定の型が指定されていない型パラメーターを持っている場合は <see cref="T:System.Type" />。そうでない場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型のインスタンスを作成するために必要がありますいないジェネリック型定義または型自体の外側のジェネリック型、または要素の中で、型の型引数でオープン構築型。 言い換えると、別の方法は、再帰的を調べたときに、型はジェネリック型パラメーターを含める必要がありますではありません。  
  
 型指定できますが、任意の複雑なので、この決定を行うは困難です。 便宜上、およびエラーの可能性を低減する、<xref:System.Type.ContainsGenericParameters%2A>プロパティは、インスタンス化できる、クローズ構築型を区別するために標準的な方法を提供およびオープン構築型で、このことはできません。 場合、<xref:System.Type.ContainsGenericParameters%2A>プロパティから返される`true`型がインスタンス化することはできません。  
  
 <xref:System.Type.ContainsGenericParameters%2A>プロパティが型パラメーターに対して再帰的を検索します。 たとえばを返します`true`要素が型配列の`A<T>`\(`A(Of T)` Visual Basic で\)、配列は汎用の自体がないにもかかわらず、します。 これは、動作と、<xref:System.Type.IsGenericType%2A>を返すプロパティ`false`配列。  
  
 一連の例のクラスとの値を示す表に、<xref:System.Type.ContainsGenericParameters%2A>プロパティを参照してください<xref:System.Type.IsGenericType%2A>です。  
  
   
  
## 例  
 次の例では、次の 2 つの型パラメーターを持つジェネリック クラスを定義し、最初のクラスから派生する 2 番目のジェネリック クラスを定義します。 派生クラスの基本クラスは、次の 2 つの型引数を持つ: 1 つは<xref:System.Int32>2 番目の派生型の型パラメーターです。 によって報告この例では、これらのジェネリック クラスに関する情報を表示、位置を含む、<xref:System.Type.GenericParameterPosition%2A>プロパティです。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.MethodBase" /> がジェネリック メソッドの型パラメーターを表している場合に、宣言するメソッドを表す <see cref="T:System.Type" /> を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> がジェネリック メソッドの型パラメーターを表している場合は、宣言メソッドを表す <see cref="T:System.Reflection.MethodBase" />。それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The declaring method is a generic method definition. That is, if <xref:System.Type.DeclaringMethod%2A> does not return **languageKeyword tag is not supported!!!!**  
, then `DeclaringMethod.IsGenericMethodDefinition` returns **languageKeyword tag is not supported!!!!**  
.  
  
 The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:  
  
-   If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.  
  
-   If the <xref:System.Type.DeclaringMethod%2A> property returns **languageKeyword tag is not supported!!!!**  
    , then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.  
  
-   Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is **languageKeyword tag is not supported!!!!**  
     throws an <xref:System.InvalidOperationException>.  
  
 The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.  
  
> [!NOTE]
>  In the .NET Framework version 2.0, generic constructors are not supported.  
  
 For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.  
  
   
  
## 例  
 The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method. It also displays information about the generic method definition and the constructed method. When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.  
  
 [!code-cpp[MethodInfo.Generics\#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics\#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の入れ子にされた型またはジェネリック型パラメーターを宣言する型を取得します。</summary>
        <value>現在の型が入れ子にされた型である場合、包含する型を表す <see cref="T:System.Type" /> オブジェクト。現在の型がジェネリック型の型パラメーターである場合、ジェネリック型定義。現在の型がジェネリック メソッドの型パラメーターである場合、ジェネリック メソッドを宣言する型。それ以外の場合、<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合は、現在 <xref:System.Type> オブジェクトがジェネリック型の型パラメーターを表し、このプロパティは、ジェネリック型定義を返します。  
  
 場合は、現在 <xref:System.Type> オブジェクトがジェネリック メソッドの型パラメーターを表し、このプロパティは、ジェネリック メソッド定義を含む型を返します。 型がジェネリックである場合は、ジェネリック型定義が返されます。 つまり、次のコードに返さのジェネリック型定義、 <xref:System.Collections.Generic.List%601> を含むジェネリック クラス、 <xref:System.Collections.Generic.List%601.ConvertAll%2A> ジェネリック メソッド。  
  
 [!code-cpp[System.Type.DeclaringType\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 場合、現在 <xref:System.Type> ジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す、 <xref:System.Type.DeclaringType%2A> と <xref:System.Type.DeclaringMethod%2A> プロパティがジェネリック型定義またはジェネリック型パラメーターが最初に定義されたジェネリック メソッド定義を識別します。  
  
-   場合、 <xref:System.Type.DeclaringMethod%2A> プロパティを返します。、 <xref:System.Reflection.MethodInfo>, 、その <xref:System.Reflection.MethodInfo> ジェネリック メソッド定義と現在を表す <xref:System.Type> オブジェクトはそのジェネリック メソッド定義の型パラメーターを表します。  
  
-   場合、 <xref:System.Type.DeclaringMethod%2A> プロパティを返します。 `null`, 、、 <xref:System.Type.DeclaringType%2A> プロパティは常に返します、 <xref:System.Type> オブジェクトの現在のジェネリック型定義を表す <xref:System.Type> オブジェクトはそのジェネリック型定義の型パラメーターを表します。  
  
-   取得する、 <xref:System.Type.DeclaringType%2A> 型のプロパティを持つ <xref:System.Type.IsGenericParameter%2A> プロパティは、 `false` をスロー、 <xref:System.InvalidOperationException>です。  
  
   
  
## 例  
 この例では、派生クラスのメソッドの宣言型を表示します。  
  
 [!code-cpp[Classic Type.DeclaringType Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のバインダーへの参照を取得します。このバインダーは、<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> によって呼び出される適切なメンバーを選択するための内部規則を実装します。</summary>
        <value>システムで使用される既定のバインダーへの参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The default binder provided with the common language runtime is applicable in all but the most specialized circumstances. If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the **parameterReference tag is not supported!!!!**  
 parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.  
  
 Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>. This is consistent with lookup of members that are protected, private, and so on.  
  
 The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data. An example of a widening conversion is converting a value that is a 32\-bit signed integer to a value that is a 64\-bit signed integer. This is distinguished from a narrowing conversion, which may lose data. An example of a narrowing conversion is converting a 64\-bit signed integer to a 32\-bit signed integer.  
  
 The following table lists the conversions supported by the default binder.  
  
|Source Type|Target Type|  
|-----------------|-----------------|  
|Any type|Its base type.|  
|Any type|The interface it implements.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Non\-reference|By\-reference.|  
  
   
  
## 例  
 The following example gets the default binder from the **languageKeyword tag is not supported!!!!**  
 property, and invokes a member of MyClass by passing the **languageKeyword tag is not supported!!!!**  
 value as a parameter to <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type\_DefaultBinder\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type\_DefaultBinder\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type\_DefaultBinder\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> の名前空間で、複数の名前を区切ります。 このフィールドは読み取り専用です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> 型の空の配列を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following code example shows the **languageKeyword tag is not supported!!!!**  
 field used in one of the **languageKeyword tag is not supported!!!!**  
 methods to get a constructor that takes no parameters.  
  
 [!code-cpp[Classic Type.EmptyTypes Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">基になるシステム型が、現在の <see cref="T:System.Type" /> の基になるシステム型との比較対象になるオブジェクト。 成功すると、比較 <c>o</c> 型のオブジェクトに変換またはキャストできる必要があります   <see cref="T:System.Type" />します。</param>
        <summary>基になるシステムが現在の型かどうかを <see cref="T:System.Type" /> オブジェクトは、指定した基になるシステム型と同じ <see cref="T:System.Object" />します。</summary>
        <returns>
          <see langword="true" /> の基になるシステム型が現在の <paramref name="o" /> の基になるシステム型と同じである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。 このメソッドが戻るも <see langword="false" /> 場合: です。  
  
-   <paramref name="o" /> は <see langword="null" /> です。  
  
-   <paramref name="o" /> キャストまたは変換することはできません、 <see cref="T:System.Type" /> オブジェクトです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは <xref:System.Object.Equals%2A?displayProperty=fullName>です。 またこの `o` 型のオブジェクトに <xref:System.Type> を呼び出すと、 <xref:System.Type.Equals%28System.Type%29?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 次の例では使用 <xref:System.Type.Equals%28System.Object%29> さまざまなとを比較する <xref:System.Type> オブジェクト インスタンスと各種 <xref:System.Object> インスタンス。  
  
 [!code-csharp[System.Type.Equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 次の 2 つは、特に注意してくださいの例については。  
  
-   比較した結果、 <xref:System.Type> を表す整数を表すオブジェクト、 <xref:System.Reflection.TypeInfo> を戻り値の整数を表すオブジェクト `true` ため <xref:System.Reflection.TypeInfo> から派生した <xref:System.Type>します。  
  
-   比較した結果、  <xref:System.Type> を表すオブジェクト、 <xref:System.Collections.Generic.IList%601> オブジェクト \(オープン ジェネリック型\)、 `List(Of String)` オブジェクト \(クローズ ジェネリック型\) から返される `false`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">基になるシステム型が、現在の <see cref="T:System.Type" /> の基になるシステム型との比較対象になるオブジェクト。</param>
        <summary>現在の <see cref="T:System.Type" /> の基になるシステム型が、指定した <see cref="T:System.Type" /> の基になるシステム型と同じかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> の基になるシステム型が現在の <paramref name="o" /> の基になるシステム型と同じである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following example uses **languageKeyword tag is not supported!!!!**  
 to compare two types.  
  
 [!code-csharp[Classic Type.Equals1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>属性に適用するメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このフィールドによって使用されるデリゲートへの参照を保持する、 <xref:System.Type.FindMembers%2A> メソッドです。 このデリゲートによってカプセル化されるメソッドは、2 つのパラメーターを受け取ります。 1 つは、 <xref:System.Reflection.MemberInfo> オブジェクトと、2 つ目は、、 `Object`です。 メソッドを決定するかどうか、 `MemberInfo` オブジェクトで指定された条件に一致する、 `Object`です。`Object` クラスのフィールドのいずれかの値を割り当てることは <xref:System.Reflection.FieldAttributes>, 、<xref:System.Reflection.MethodAttributes>, 、または <xref:System.Reflection.MethodImplAttributes>です。  
  
 たとえば、 `Object` からフィールドの値を割り当てることができる `FieldAttributes` Public などです。 その場合は、 `FilterAttribute` デリゲートが呼び出されるが返されます `true` メソッドがによって表される場合にのみ、 `MemberInfo` オブジェクトがメタデータにパブリック フィールドの属性で修飾されました。  
  
   
  
## 例  
 次の例を取得、 `FilterAttribute` を委任し、パラメーターとして渡して、 <xref:System.Type.FindMembers%2A> メソッド、および指定されたメンバーとその属性が表示されます。  
  
 [!code-cpp[Type\_FilterAttribute\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type\_FilterAttribute\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type\_FilterAttribute\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に適用され、大文字と小文字を区別するメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このフィールドによって使用されるデリゲートへの参照を保持する、 <xref:System.Type.FindMembers%2A> メソッドです。 このデリゲートによってカプセル化されるメソッドは、2 つのパラメーターを受け取ります。 1 つは、 <xref:System.Reflection.MemberInfo> オブジェクトと、2 つ目は、、 `Object`です。 メソッドを決定するかどうか、 `MemberInfo` オブジェクトで指定された条件に一致する、 `Object`です。`Object` 末尾を含む文字列値が割り当てられた"\*"ワイルドカード文字です。 のみワイルドカード終了文字列の比較はサポートされています。  
  
 たとえば、 `Object` 「バイト \*」値を割り当てることができます。 その場合はときに、 `FilterName` デリゲートが呼び出されるが返されます `true` メソッドがによって表される場合にのみ、 `MemberInfo` 「バイト」で始まる名前が付きます。  
  
   
  
## 例  
 次のコード例は、ユーザー定義に関連付けられたメソッドを取得 `Application` 型です。  
  
 [!code-cpp[Classic Type.FilterName Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に適用され、大文字と小文字を区別しないメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このフィールドによって使用されるデリゲートへの参照を保持する、 <xref:System.Type.FindMembers%2A> メソッドです。 このデリゲートによってカプセル化されるメソッドは、2 つのパラメーターを受け取ります。 1 つは、 <xref:System.Reflection.MemberInfo> オブジェクトと、2 つ目は、、 `Object`です。 メソッドを決定するかどうか、 `MemberInfo` オブジェクトで指定された条件に一致する、 `Object`です。`Object` 末尾を含む文字列値が割り当てられた"\*"ワイルドカード文字です。 のみワイルドカード終了文字列の比較はサポートされています。  
  
 たとえば、 `Object` 「バイト \*」値を割り当てることができます。 その場合は、 `FilterName` デリゲートが呼び出される、それは true を返すだけで表示されるメソッド、 `MemberInfo` 「バイト」、大文字と小文字で始まる名前が付きます。  
  
   
  
## 例  
 次の例では取得、 `MemberFilter` を委任し、パラメーターとして渡して、 <xref:System.Type.FindMembers%2A> メソッド、メソッドとその属性の表示、 `String` 大文字と小文字を無視すると、文字"c"で始まるクラスです。  
  
 [!code-cpp[Type\_FilterNameIgnoreCase\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type\_FilterNameIgnoreCase\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type\_FilterNameIgnoreCase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">インターフェイスを <c>filterCriteria</c> と比較するデリゲート。</param>
        <param name="filterCriteria">返される配列に、検出したインターフェイスを含めるかどうかを判断する検索条件。</param>
        <summary>現在の <see cref="T:System.Type" /> によって実装または継承されているインターフェイスのフィルター適用済みリストを表す、<see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> によって実装または継承されたインターフェイスのフィルター処理されたリストを表している <see cref="T:System.Type" /> オブジェクトの配列。フィルターに一致するインターフェイスが現在の <see cref="T:System.Type" /> によって実装または継承されていない場合は、型 <see cref="T:System.Type" /> の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=fullName>と<xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=fullName>によって提供されるデリゲート、<xref:System.Reflection.Module?displayProperty=fullName>の lieu で、クラスも使用できます、<xref:System.Reflection.TypeFilter?displayProperty=fullName>委任します。  
  
 基底クラスまたはこのクラス自体で宣言されているかどうか、検索中にこのクラスで実装されたインターフェイスのすべてと見なされます。  
  
 このメソッドは、これらのインターフェイスを実装の各クラスは、すべての一致するだけでなく、一致するインターフェイスの各インターフェイスを返す、基本クラスの階層構造を検索 \(つまり、一致するインターフェイスの推移的閉包が返されます\)。 重複するインターフェイスが返されません。  
  
 場合、現在<xref:System.Type>がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す<xref:System.Type.FindInterfaces%2A>型パラメーターに対する制約で宣言されているすべてのインターフェイスを検索し、インターフェイスによって継承されたすべてのインターフェイスの制約内で宣言します。 場合、現在<xref:System.Type>がジェネリック型の引数の型を表す<xref:System.Type.FindInterfaces%2A>制約に一致するかどうか、型によって実装されたすべてのインターフェイスを検索します。  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A>ジェネリックな型の場合でも、ジェネリック インターフェイスを返すことができます。 たとえば、非ジェネリック型を実装`IEnumerable<int>`\(`IEnumerable(Of Integer)` Visual Basic で\)。  
  
   
  
## 例  
 次の例では、指定されたインターフェイスが実装されているまたは、指定した型によって継承され、インターフェイス名を表示しを検索します。  
  
 [!code-cpp[Type\_FindInterfaces\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type\_FindInterfaces\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type\_FindInterfaces\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">静的初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">検索するメンバーの型を示すオブジェクト。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す場合は 0。</param>
        <param name="filter">比較を実行して、現在調べているメンバーが <see langword="true" /> に一致する場合は <c>filterCriteria</c> を返し、それ以外の場合は <see langword="false" /> を返すデリゲート。 このクラスで提供される <see langword="FilterAttribute" /> デリゲート、<see langword="FilterName" /> デリゲート、および <see langword="FilterNameIgnoreCase" /> デリゲートを使用できます。 1 つ目のデリゲートは、検索条件として <see langword="FieldAttributes" />、<see langword="MethodAttributes" />、<see langword="MethodImplAttributes" /> の各フィールドを使用し、他の 2 つのデリゲートは、検索条件として <see langword="String" /> オブジェクトを使用します。</param>
        <param name="filterCriteria">
          <see langword="MemberInfo" /> オブジェクトの配列でメンバーが返されたかどうかを判断する検索条件。  
  
 <see langword="FieldAttributes" />、<see langword="MethodAttributes" />、<see langword="MethodImplAttributes" /> の各フィールドは、このクラスで提供される <see langword="FilterAttribute" /> デリゲートと組み合わせて使用できます。</param>
        <summary>指定したメンバー型の <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列にフィルターを適用して返します。</summary>
        <returns>指定したメンバー型の <see cref="T:System.Reflection.MemberInfo" /> オブジェクトのフィルター適用済みの配列。  
  
 \-または\-  
  
 現在の <see cref="T:System.Reflection.MemberInfo" /> に、フィルター条件に一致する <see cref="T:System.Type" /> 型のメンバーが存在しない場合は、<paramref name="memberType" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Instance`検索でインスタンス メンバーを含めるようにします。  
  
-   指定`BindingFlags.Static`検索に静的メンバーを含める。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メンバー \(つまり、プライベート、内部、およびプロテクト メンバー\)、します。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 有効な値<xref:System.Type.MemberType%2A>で定義された<xref:System.Reflection.MemberInfo>です。 このようなメンバーが見つからない場合は、空の配列が返されます。  
  
 このメソッドを使用してクラス初期化子 \(.cctor\) を取得する必要がありますを指定する<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> in Visual Basic\). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 場合、現在<xref:System.Type>ジェネリック型またはジェネリック メソッドの型パラメーターを表す<xref:System.Type.FindMembers%2A>クラス制約と型パラメーターのインターフェイスの制約で宣言された任意のメンバーを処理します。  
  
   
  
## 例  
 次の例では、指定した検索条件に一致するクラス内のすべてのメンバーを検索し、一致するメンバーを表示します。  
  
 [!code-cpp[Type\_FindMembers\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type\_FindMembers\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type\_FindMembers\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の完全修飾名を取得します。その名前空間を含みますが、アセンブリは含みません。</summary>
        <value>型の完全修飾名で、名前空間を含むが、アセンブリは含まないもの。現在のインスタンスが、ジェネリック型パラメーター、配列型、ポインター型、または型パラメーターに基づく<see langword="null" /> 型、またはジェネリック型定義ではないが未解決の型パラメーターを含むジェネリック型を表す場合は、<see langword="byref" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 たとえば、完全修飾名の <xref:System.String> 型は `System.String`です。 これによって返されるアセンブリ修飾名に対し、 <xref:System.Type.AssemblyQualifiedName%2A> プロパティで、完全な名前と完全なアセンブリ名で構成されます。  
  
 によって、型引数は、文字列が返される現在の型はクローズ ジェネリック型を表している場合、 <xref:System.Type.FullName%2A>自体のジェネリック型の文字列形式が、完全なアセンブリ名で修飾されていない場合でも、プロパティが、完全なアセンブリ名で修飾します。 次の例は、FullName プロパティをジェネリック型定義を表す型、クローズ ジェネリック型を表す 1 つの違いを示しています。  
  
 [!code-csharp[System.Type.FullName\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 このプロパティを返します `null` 場合。  
  
-   現在 <xref:System.Type> オブジェクトがジェネリック型の型パラメーターを表します。  
  
     次の例の型パラメーターの取得、 <xref:System.Nullable%601> 型と、表示しようとその <xref:System.Type.FullName%2A> プロパティです。  
  
     [!code-csharp[System.Type.FullName\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   現在 <xref:System.Type> オブジェクトが配列型、ポインター型を表す、または `byref` がジェネリック型パラメーターに基づく型です。  
  
     次の例は、ジェネリック型を定義 `Generictype1<T>`, 、3 つのメソッド: `Display(T[])`, 、T 型の配列が渡される三部 `HandleT(T)`, 、T は渡されたと `ChangeValue(ref T)`, 、T オブジェクト参照によって渡されました。 C\# および Visual Basic が内のポインターとして T を定義することに許可されていないため、 `HandleT` を呼び出すメソッドがある、 <xref:System.Type.MakePointerType%2A> メソッドを <xref:System.Type> ジェネリック型へのポインターを作成するメソッドのパラメーターの型を表すオブジェクト。 例の出力を示していますを 3 つのすべてのケースで、 <xref:System.Type.FullName%2A> プロパティは `null`です。  
  
     [!code-csharp[System.Type.FullName\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   現在の型には、特定の型で置き換えられていないジェネリック型パラメーターが含まれています \(つまり、 <xref:System.Type.ContainsGenericParameters%2A> プロパティを返します。 `true`\)、ですが、型がジェネリック型定義ではありません \(つまり、、 <xref:System.Type.IsGenericTypeDefinition%2A> プロパティを返します。 `false`  
  
     次の例で `Derived<T>` から継承 `Base<T>`します。<xref:System.Type.BaseType%2A> プロパティは、  <xref:System.Type> の基本データ型を表すオブジェクト `Derived<T>`, 、およびその <xref:System.Type.FullName%2A> プロパティを返します。 `null`します。  
  
     [!code-csharp[System.Type.FullName\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     取得する、 <xref:System.Type.FullName%2A> 外にある `null`, 、使用することができます、 <xref:System.Type.GetGenericTypeDefinition%2A> 例に示すように、ジェネリック型定義を取得します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## 例  
 次の例では、指定した型の完全名を表示します。  
  
 [!code-cpp[TestFullName\#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName\#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 によって返される文字列を比較する例を次の <xref:System.Type.ToString%2A> メソッドおよび `Name`, 、<xref:System.Type.FullName%2A>, 、および <xref:System.Type.AssemblyQualifiedName%2A> プロパティです。  
  
 [!code-csharp[System.Type.ToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のジェネリック型パラメーターの共変性および特殊な制約を説明する <see cref="T:System.Reflection.GenericParameterAttributes" /> フラグの組み合わせを取得します。</summary>
        <value>現在のジェネリック型パラメーターの共変性と特殊な制約を表す <see cref="T:System.Reflection.GenericParameterAttributes" /> 値のビットごとの組み合わせ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの値には、現在のジェネリック型パラメーターは共変であるかどうかを示すフラグと特殊な制約を記述するフラグが含まれています。 使用して、<xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=fullName>値の共変性フラグを選択してを使用して、<xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=fullName>制約フラグを選択する値。  
  
 ジェネリックのリフレクションで使用される用語に対するインバリアント条件の一覧は、次を参照してください。、<xref:System.Type.IsGenericType%2A>プロパティ解説します。  
  
   
  
## 例  
 次のコード例は、ジェネリック型を定義`Test`異なる制約を持つ 2 つの型パラメーターを使用します。 使用して、制約を調べる、プログラムを実行するとき、<xref:System.Type.GenericParameterAttributes%2A>プロパティおよび<xref:System.Type.GetGenericParameterConstraints%2A>メソッドです。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Type" /> オブジェクトは、ジェネリック型パラメーターではありません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> プロパティが <see langword="false" /> を返します。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> オブジェクトがジェネリック型またはジェネリック メソッドの型パラメーターを表す場合に、パラメーターを宣言したジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置を取得します。</summary>
        <value>パラメーターを定義するジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置。 位置の番号は 0 で始まります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GenericParameterPosition%2A> プロパティは、型パラメーターが最初に定義されているのジェネリック型定義またはジェネリック メソッド定義のパラメーター リストで、型パラメーターの位置を返します。<xref:System.Type.DeclaringType%2A> と <xref:System.Type.DeclaringMethod%2A> プロパティがジェネリック型またはジェネリック メソッド定義を識別します。  
  
-   場合、 <xref:System.Type.DeclaringMethod%2A> プロパティを返します。、 <xref:System.Reflection.MethodInfo>, 、その <xref:System.Reflection.MethodInfo> ジェネリック メソッド定義と現在を表す <xref:System.Type> オブジェクトはそのジェネリック メソッド定義の型パラメーターを表します。  
  
-   場合、 <xref:System.Type.DeclaringMethod%2A> プロパティを返します。 `null`, 、、 <xref:System.Type.DeclaringType%2A> プロパティは常に返します、 <xref:System.Type> オブジェクトの現在のジェネリック型定義を表す <xref:System.Type> オブジェクトはそのジェネリック型定義の型パラメーターを表します。  
  
 値に正しいコンテキストを提供する、 <xref:System.Type.GenericParameterPosition%2A> プロパティは、ジェネリック型または型パラメーターが属するメソッドを識別するために必要です。 たとえば、ジェネリック メソッドの戻り値 `GetSomething` 次のコードにします。  
  
 [!code-cpp[System.Type.GenericParameterPosition\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 によって返される型 `GetSomething` クラスに指定された型引数に依存 `A` にされ、 `GetSomething` 自体です。 取得することができます、 <xref:System.Reflection.MethodInfo> の `GetSomething`, から戻り値の型を取得したりできます。 戻り値の型の型パラメーターを確認するときに <xref:System.Type.GenericParameterPosition%2A> 両方に対しては 0 を返します。 位置 `V` ためには 0 `V` クラスの型パラメーター リストの最初の型パラメーターは、 `A`です。 位置 `X` ためには 0 `X` の型パラメーター リストの最初の型パラメーターは、 `GetSomething`です。  
  
> [!NOTE]
>  呼び出す、 <xref:System.Type.GenericParameterPosition%2A> プロパティ例外が発生した場合、現在 <xref:System.Type> 型パラメーターではありません。 オープン構築型の型引数を確認する際に使用して、 <xref:System.Type.IsGenericParameter%2A> は型パラメーターと型を指定するプロパティです。<xref:System.Type.IsGenericParameter%2A> プロパティを返します。 `true` ;、型パラメーターを使用できます、 <xref:System.Type.GenericParameterPosition%2A> の位置を取得して使用するメソッド、 <xref:System.Type.DeclaringMethod%2A> と <xref:System.Type.DeclaringType%2A> を一般的な方法を決定するかを定義している定義を入力します。  
  
   
  
## 例  
 次の例では、2 つの型パラメーターを持つジェネリック クラスを定義し、最初のクラスから派生する 2 番目の汎用クラスを定義します。 派生クラスの基本クラスは、2 つの型引数を持つ: 1 つは、 <xref:System.Int32>, 、もう 1 つの派生型の型パラメーターであるとします。 によって報告された、位置などの例では、これらの汎用クラスに関する情報を表示、 <xref:System.Type.GenericParameterPosition%2A> プロパティです。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型は型パラメーターを表していません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> は <see langword="false" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型のジェネリック型引数の配列を取得します。</summary>
        <value>この型のジェネリック型引数の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを取得したジェネリック型引数のみです。つまり、現在の型のジェネリック型パラメーターで指定されている型。 現在の型がジェネリック型定義の場合は、このプロパティは空の配列を返します。  
  
> [!NOTE]
>  別のジェネリック型またはジェネリック メソッドでジェネリック型を使用する場合は、外側のメソッドまたは型のジェネリック型パラメーター、ジェネリック型引数のいくつかの可能性があります。  
  
 ジェネリック型定義を表す型のジェネリック型パラメーターを取得する、<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=fullName>プロパティです。 取得する、<xref:System.Reflection.TypeInfo>現在のオブジェクト<xref:System.Type>オブジェクトを使用して、<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=fullName>拡張メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>配列の次元数を取得します。</summary>
        <returns>現在の型の次元数である整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、配列の次元数を表示します。  
  
 [!code-cpp[Type\_GetArrayRank\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type\_GetArrayRank\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type\_GetArrayRank\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドの機能は、基底クラスではサポートされていないため、代わりに派生クラスで実装する必要があります。</exception>
        <exception cref="T:System.ArgumentException">現在の型は配列ではありません。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、<see cref="P:System.Type.Attributes" /> プロパティを実装し、<see cref="T:System.Type" /> に関連付けられている属性を示すビットマスクを取得します。</summary>
        <returns>
          <see cref="T:System.Reflection.TypeAttributes" /> の属性のセットを表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">目的のコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列。 このような空の配列は、<see langword="static" /> フィールド <see cref="F:System.Type.EmptyTypes" /> によって提供されます。</param>
        <summary>指定した配列の型に一致するパラメーターが設定されているパブリック インスタンス コンストラクターを検索します。</summary>
        <returns>パラメーター型配列の型と一致するパラメーターが設定されているパブリック インスタンス コンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドのオーバー ロードは、パブリック インスタンス コンス トラクターは検索し、クラス初期化子 \(.cctor\) を取得するのには使用できません。 クラス初期化子を取得するを受け取るオーバー ロードを使用<xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> in Visual Basic\). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 要求されたコンス トラクターが非パブリックのかどうか、このメソッドが戻る`null`です。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>型パラメーターを適切な型引数によって置き換えられます。 場合、現在<xref:System.Type>このメソッドは常にジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`null`です。  
  
   
  
## 例  
 次の例の種類を取得する`MyClass`、取得、<xref:System.Reflection.ConstructorInfo>オブジェクト、およびコンス トラクターのシグネチャが表示されます。  
  
 [!code-cpp[Type\_GetConstructor\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type\_GetConstructor\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type\_GetConstructor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 \-または\-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />\)。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 \(Type\[\] types \= new Type\[0\]\)。  
  
 または  
  
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">パラメーター型配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーは、このパラメーターを処理しません。</param>
        <summary>指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 厳密な一致が存在しない場合、`binder`で指定されたパラメーター型を強制的に試みます、`types`配列、一致項目を選択するためにします。 場合、`binder`が、一致するものを選択し、できない`null`が返されます。  
  
 次[GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるにどのコンス トラクターを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないコンス トラクター \(つまり、プライベート、内部、および保護されたコンス トラクター\) を含める。  
  
 詳細については、「[GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 このメソッドのオーバー ロードを使用したクラス初期化子 \(.cctor\) を取得する必要がありますを指定する[GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>&#124;[GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \([GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`[GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> in Visual Basic\). 使用して、クラス初期化子を取得することも、[GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略できません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在[GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、[GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Reflection.ConstructorInfo>型パラメーターを適切な型引数によって置き換えられます。 場合、現在[GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Type>このメソッドは常にジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`null`です。  
  
   
  
## 例  
 次のプログラムの種類を取得する`MyClass1`クラス、取得、[GetConstructor メソッド \(BindingFlags, Binder, Type\<xref:System.Reflection.ConstructorInfo>オブジェクトの指定したバインディング フラグに一致して、コンス トラクターのシグネチャが表示されます。  
  
 [!code-cpp[Type\_GetConstructor2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type\_GetConstructor2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type\_GetConstructor2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 \-または\-  
  
 <see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see langword="Nothing" />\)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 \(Type\[\] types \= new Type\[0\]\)。</param>
        <param name="modifiers">
          <c>types</c> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーは、このパラメーターを処理しません。</param>
        <summary>指定したバインディング制約および指定した呼び出し規則を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のバインダーが処理されませんが[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.ParameterModifier>\(、`modifiers`パラメーター\)、abstract を使用することができます[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.Binder?displayProperty=fullName>を処理するカスタムのバインダーを記述するクラス`modifiers`です。`ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみが処理されます。  
  
 厳密な一致が存在しない場合、`binder`で指定されたパラメーター型を強制的に試みます、`types`配列、一致項目を選択するためにします。 場合、`binder`が、一致するものを選択し、できない`null`が返されます。  
  
 次[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるにどのコンス トラクターを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないコンス トラクター \(つまり、プライベート、内部、および保護されたコンス トラクター\) を含める。  
  
 詳細については、「[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 このメソッドを使用してクラス初期化子 \(.cctor\) を取得する必要がありますを指定する[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>&#124;[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \([GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> in Visual Basic\). 使用して、クラス初期化子を取得することも、[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略できません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.ConstructorInfo>型パラメーターを適切な型引数によって置き換えられます。 場合、現在[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Type>このメソッドは常にジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`null`です。  
  
   
  
## 例  
 次の例の種類を取得する`MyClass1`、取得、[GetConstructor メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.ConstructorInfo>指定したバインディング フラグに一致し、コンス トラクターのシグネチャを表示するオブジェクト。  
  
 [!code-cpp[Type\_GetConstructor3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type\_GetConstructor3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type\_GetConstructor3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 \-または\-  
  
 <see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see langword="Nothing" />\)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 \(Type\[\] types \= new Type\[0\]\)。</param>
        <param name="modifiers">
          <c>types</c> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーは、このパラメーターを処理しません。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のバインダーが処理されませんが [GetConstructorImpl メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.ParameterModifier> \(、 `modifiers` パラメーター\)、抽象を使用することができます [GetConstructorImpl メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.Binder?displayProperty=fullName> クラスが、処理するカスタム バインダーを記述する `modifiers`です。`ParameterModifier` COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターだけが処理されます。  
  
 厳密な一致が存在しない場合、 `binder` で指定されたパラメーター型を強制的に試みます、 `types` に一致するものを選択するために配列。 場合、 `binder` が、一致を選択し、できない `null` が返されます。  
  
 次 [GetConstructorImpl メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags> フィルター フラグを使用するには、検索に含める場合は、どのコンス トラクターを定義します。  
  
-   どちらかを指定する必要があります `BindingFlags.Instance` または `BindingFlags.Static` 戻り値を取得するためにします。  
  
-   指定 `BindingFlags.Public` パブリック コンス トラクターを検索します。  
  
-   指定 `BindingFlags.NonPublic` 、検索条件に非パブリック コンス トラクター \(つまり、プライベート、内部、および保護されているコンス トラクター\) を含める。  
  
 詳細については、「[GetConstructorImpl メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 このメソッドは、[GetConstructorImpl メソッド \(BindingFlags, Binder, CallingConventions, Type\<xref:System.Type.GetConstructor%2A> を実装します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" /> または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> に対して定義されているパブリック コンストラクターをすべて返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.ConstructorInfo" /> に対して定義されたすべてのパブリック インスタンス コンストラクター \(ただし、型初期化子 \(静的コンストラクター\) を除く\) を表している <see cref="T:System.Type" /> オブジェクトの配列。 パブリック インスタンス コンストラクターが現在の <see cref="T:System.Type" /> に対して定義されている場合、または現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <see cref="T:System.Reflection.ConstructorInfo" /> の空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetConstructors%2A>メソッドでは、宣言の順序など、特定の順序では、コンス トラクターは返しません。 コードする必要がありますに依存、コンス トラクターが返される順序のためする順序が異なります。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想の両方\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 このメソッドのオーバー ロードを呼び出す、<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>メソッド オーバー ロードで<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> in Visual Basic\). クラス初期化子 \(.cctor\) は検索されません。 クラス初期化子を検索するを受け取るオーバー ロードを使用して<xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> in Visual Basic\). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。 たとえば場合、クラス`C<T>`コンス トラクターを持つ`C(T t1)`\(`Sub New(ByVal t1 As T)` Visual Basic で\) を呼び出す<xref:System.Type.GetConstructors%2A>で`C<int>` を返します、<xref:System.Reflection.ConstructorInfo>を表す`C(int t1)`\(C\#\) \(`Sub New(ByVal t1 As Integer)` Visual Basic で\)。  
  
 場合、現在<xref:System.Type>がジェネリック型パラメーターを表す、<xref:System.Type.GetConstructors%2A>メソッドが空の配列を返します。  
  
   
  
## 例  
 この例の出力を示しています、<xref:System.Type.GetConstructors%2A>オーバー ロードの 2 つのインスタンス コンス トラクターおよび静的コンス トラクターを持つクラスであるからです。  
  
 [!code-cpp[Classic Type.GetConstructors Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 このコードの出力です。  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Type.GetConstructors>のみ使用するオーバー ロード<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>と<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName>、によって、静的コンス トラクターがカウントされるも、`for`式によって評価も`IsStatic`します。  
  
 静的コンス トラクターを検索する、<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>過負荷、および組み合わせを渡す \(論理`OR`\) の<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>、 <xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>、 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>、<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName>次のコード例のように。  
  
 [!code-cpp[Classic Type.GetConstructors Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 これで、出力です。  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す場合は 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定した <see langword="BindingFlags" /> を使用して、現在の <see cref="T:System.Type" /> に対して定義されているコンストラクターを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> にコンストラクターが定義されている場合は、型初期化子を含め、定義されているコンストラクターのうち指定したバインディング制約に一致するすべてのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクトの配列。 現在の <see cref="T:System.Reflection.ConstructorInfo" /> に対してコンストラクターが定義されていない場合、または現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <see cref="T:System.Type" /> の空の配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetConstructors%2A>メソッドでは、宣言の順序など、特定の順序では、コンス トラクターは返しません。 コードする必要がありますに依存、コンス トラクターが返される順序のためする順序が異なります。  
  
 `bindingAttr`パブリック コンス トラクターまたはパブリックと非パブリックの両方のコンス トラクターのみを返すかどうかを指定するために使用します。  
  
 厳密な一致が存在しない場合、`binder`で指定されたパラメーター型を強制的に試みます、`types`配列、一致項目を選択するためにします。 場合、`binder`が、一致するものを選択し、できない`null`が返されます。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるにどのコンス トラクターを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないコンス トラクター \(つまり、プライベート、内部、および保護されたコンス トラクター\) を含める。 基本クラスのコンス トラクターは返されません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 このメソッドのオーバー ロードを使用したクラス初期化子 \(.cctor\) を取得する必要がありますを指定する<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> in Visual Basic\). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。 たとえば場合、クラス`C<T>` コンス トラクターを持つ`C(T t1)`\(`Sub New(ByVal t1 As T)` Visual Basic で\) を呼び出す<xref:System.Type.GetConstructors%2A>で`C<int>`を返します、<xref:System.Reflection.ConstructorInfo>を表す`C(int t1)`\(C\#\) \(`Sub New(ByVal t1 As Integer)` Visual Basic で\)。  
  
 場合、現在<xref:System.Type>がジェネリック型パラメーターを表す、<xref:System.Type.GetConstructors%2A>メソッドが空の配列を返します。  
  
   
  
## 例  
 この例の出力を示しています、<xref:System.Type.GetConstructors>オーバー ロードの 2 つのインスタンス コンス トラクターおよび静的コンス トラクターを持つクラスであるからです。  
  
 [!code-cpp[Classic Type.GetConstructors Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 このコードの出力です。  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Type.GetConstructors%2A>のみ使用するオーバー ロード<xref:System.Reflection.BindingFlags.Public>と<xref:System.Reflection.BindingFlags.Instance>、によって、静的コンス トラクターがカウントされるも、`for`式によって評価も`IsStatic`します。  
  
 静的コンス トラクターを検索する、<xref:System.Type.GetConstructors%2A>過負荷との組み合わせ \(論理 OR\) を渡す<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>、 <xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>、 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>、<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName>次のコード例のように。  
  
 [!code-cpp[Classic Type.GetConstructors Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 これで、出力です。  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が設定されている現在の <see cref="T:System.Reflection.DefaultMemberAttribute" /> に定義されているメンバーを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> のすべての既定メンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.MemberInfo" /> に既定のメンバーがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetDefaultMembers%2A> メソッドは返しませんメンバーを特定の順序でなど、アルファベット順または宣言の順序。 コードに依存できません、メンバーが返される順序のため順序が変化します。  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 次の表は返される基本クラスのメンバー、 `Get` メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによる隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャによる隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想\) のメソッドは、名前による隠ぺいまたは名前と署名によって非表示にできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャによる隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる隠ぺいは、型、パラメーターの型、sentinel、およびアンマネージ呼び出し規約を返すすべてのカスタム修飾子を含む、シグネチャの一部と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによる隠ぺいします。 基底クラスで get と set アクセサーの両方でプロパティがある場合は、派生クラスには、get アクセサーだけ派生クラスのプロパティには、基本クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合は、現在 <xref:System.Type> このメソッドが戻る構築されたジェネリック型を表す、 <xref:System.Reflection.MemberInfo> 適切な型の引数に置き換え、型パラメーターを持つオブジェクト。 たとえば場合、クラス `C<T>` プロパティがあります `P` を返す `T`, 、呼び出し元 <xref:System.Type.GetDefaultMembers%2A> に `C<int>` を返します `int P` C\# の場合 \(`Property P As Integer` Visual Basic で\)。  
  
 場合は、現在 <xref:System.Type> を表しますがジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメンバーまたはのメンバーを検索 <xref:System.Object> クラスの制約が存在しない場合。  
  
   
  
## 例  
 次の例の既定のメンバー情報を取得する `MyClass` し、既定のメンバーを表示します。  
  
 [!code-cpp[Type\_GetDefaultMembers\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type\_GetDefaultMembers\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type\_GetDefaultMembers\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <see cref="T:System.Type" /> を返します。</summary>
        <returns>現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <see cref="T:System.Type" />。現在の <see langword="null" /> が配列またはポインターではない場合、参照によって渡されない場合、ジェネリック型やジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、<see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る`null`の<xref:System.Array>クラスです。  
  
   
  
## 例  
 次の例では、使用方法を示します、`GetElementType`メソッドです。  
  
 [!code-cpp[TestGetElementType\#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType\#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">名前を取得する対象の値。</param>
        <summary>現在の列挙型の指定された値を持つ定数の名前を返します。</summary>
        <returns>指定された値を持つ現在の列挙型のメンバーの名前。そのような定数が見つからない場合は、<see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。  
  
 または  
  
 <paramref name="value" /> は、現在の型ではなく、基になる型が現在の型と同じでもありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型のメンバーの名前を返します。</summary>
        <returns>列挙型のメンバーの名前が含まれている配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 戻り値の配列の要素は、列挙型定数のバイナリ値 \(つまり、符号なしの値\) に基づいて並べ替えられます。 配列に同じ値を持つ列挙定数が含まれている場合の対応する名前の順序は指定されません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型の基になる型を返します。</summary>
        <returns>現在の列挙型の基になる型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 C\# および Visual Basic で列挙型の基になる型は、既定では、 <xref:System.Int32>です。 その他の整数型を指定することができます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。  
  
 または  
  
 列挙型に複数のインスタンス フィールドが含まれているため、無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型の定数の値の配列を返します。</summary>
        <returns>値を格納する配列。 配列の要素は列挙定数のバイナリ値 \(符号なしの値\) に基づいて並べ替えられます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントの名前を格納する文字列。</param>
        <summary>指定したパブリック イベントを表す <see cref="T:System.Reflection.EventInfo" /> オブジェクトを返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で宣言または継承されている指定パブリック イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 少なくとも 1 つのメソッドまたはパブリック アクセサーがある場合、このイベントはリフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 検索`name`小文字が区別されます。 検索には、static および public インスタンスのパブリック イベントが含まれています。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想の両方\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.EventInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## 例  
 次の例を作成、<xref:System.Reflection.EventInfo>オブジェクトし、指定されたイベントに対してボタン クラスのイベントを取得します。  
  
 [!code-cpp[Type\_GetEvent\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type\_GetEvent\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type\_GetEvent\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す場合は 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定されたバイディング制約を使用して、指定されたイベントを表わす <see cref="T:System.Reflection.EventInfo" /> オブジェクトを返します。</summary>
        <returns>存在する場合は、現在の <see cref="T:System.Type" /> で宣言または継承されている指定されたイベントを表すオブジェクト、それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次<xref:System.Reflection.BindingFlags>検索に含めるイベントを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック イベントを含めます。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないイベント \(つまり、プライベート、内部、および保護されたイベント\) を含めます。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`大文字と小文字を無視する`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されているイベントのみを検索する、 <xref:System.Type>、継承されたイベントされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 イベントは、少なくとも 1 つのメソッドまたはパブリックであるアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.EventInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## 例  
 次のコード例では、<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29>パブリックまたはパブリックでないイベントの「クリックして」という名前ではない型を検索するメソッド`static`\(`Shared` Visual Basic で\)。  
  
 [!code-cpp[Type\_GetEvent1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type\_GetEvent1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type\_GetEvent1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で宣言または継承されているすべてのパブリック イベントを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.EventInfo" /> で宣言または継承されているすべてのパブリック イベントを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.EventInfo" /> にパブリック イベントがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベントは、少なくとも 1 つのメソッドまたはパブリックであるアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 <xref:System.Type.GetEvents%2A>メソッドで返されないイベントを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、イベントが返される順序のためする順序が異なります。  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.EventInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## 例  
 次の例の配列を取得する<xref:System.Reflection.EventInfo>オブジェクト、すべてのイベントを取得、`Button`クラス、およびイベント名が表示されます。 Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type\_GetEvents1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type\_GetEvents1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type\_GetEvents1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> で宣言または継承されているイベントを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.EventInfo" /> で宣言または継承されているイベントのうち、指定したバインディング制約に一致するすべてのイベントを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.EventInfo" /> にイベントが存在しないか、またはイベントの中にバインディング制約に一致するものがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetEvents%2A> メソッドは返しませんイベントで、特定の順序など、アルファベット順または宣言の順序。 コードに依存できません、イベントが返される順序のため順序が変化します。  
  
 次 <xref:System.Reflection.BindingFlags> フィルター フラグを使用するには、検索に含めるには、どのイベントを定義します。  
  
-   どちらかを指定する必要があります `BindingFlags.Instance` または `BindingFlags.Static` 戻り値を取得するためにします。  
  
-   指定 `BindingFlags.Public` 検索にパブリック イベントを含めます。  
  
-   指定 `BindingFlags.NonPublic` 検索にパブリックでないイベント \(つまり、プライベート、内部、および保護されたイベント\) を含めます。 のみ保護されており、基本クラスの内部のイベントが返されます。基底クラスにプライベートのイベントは返されません。  
  
-   指定 `BindingFlags.FlattenHierarchy` に含める `public` と `protected` 上位階層の静的メンバー `private` 継承するクラスで静的メンバーは含まれません。  
  
 次 <xref:System.Reflection.BindingFlags> 修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly` 宣言されているイベントのみを検索する、 <xref:System.Type>, 、継承されたイベントしません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 イベントは、少なくとも 1 つのメソッドまたはパブリック アクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic を使用して値を組み合わせて `Or`\)これを取得します。  
  
 場合は、現在 <xref:System.Type> このメソッドが戻る構築されたジェネリック型を表す、 <xref:System.Reflection.EventInfo> 適切な型の引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合は、現在 <xref:System.Type> 型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドはクラスの制約のイベントを検索します。  
  
   
  
## 例  
 次の例の配列を取得する <xref:System.Reflection.EventInfo> 指定したバインディング フラグと一致するオブジェクトのすべてのイベントの取得、 `Button` クラス、およびイベント名が表示されます。 Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type\_GetEvents2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type\_GetEvents2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type\_GetEvents2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するデータ フィールドの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック フィールドを検索します。</summary>
        <returns>指定した名前のパブリック フィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス フィールドが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.FieldInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドはクラスの制約のフィールドを検索します。  
  
   
  
## 例  
 次の例を取得、 `Type` 、指定したクラス オブジェクトを取得、<xref:System.Reflection.FieldInfo>フィールドに、オブジェクトとフィールドの値を表示します。  
  
 [!code-cpp[Type\_GetField\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type\_GetField\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type\_GetField\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">この <see cref="T:System.Type" /> オブジェクトは、<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> メソッドがまだ呼び出されていない <see cref="T:System.Reflection.Emit.TypeBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するデータ フィールドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す場合は 0。</param>
        <summary>指定したバインディング制約を使用して、指定したフィールドを検索します。</summary>
        <returns>指定した要件と一致するフィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想の両方\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるフィールドを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック フィールドを含める。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないフィールド \(つまり、プライベート、内部、および保護されている\) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`大文字と小文字を無視する`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されているフィールドのみを検索する、<xref:System.Type>で単に継承されたフィールドではなくです。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.FieldInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のフィールドを検索します。  
  
   
  
## 例  
 次の例を取得、 `Type` 、指定したクラスのオブジェクトとは、取得、<xref:System.Reflection.FieldInfo>フィールドを指定したバインディング フラグに一致し、フィールドの値を表示するためのオブジェクト。  
  
 [!code-cpp[Type\_GetField\#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type\_GetField\#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type\_GetField\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック フィールドを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.FieldInfo" /> に対して定義されているすべてのパブリック フィールドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.FieldInfo" /> に対してパブリック フィールドが定義されていない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetFields%2A>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、フィールドが返される順序のためする順序が異なります。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想の両方\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.FieldInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のパブリック フィールドを検索します。  
  
   
  
## 例  
 次の例を使用して、`GetFields()`メソッドです。  
  
 [!code-cpp[FieldInfo\_IsSpecialName\#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo\_IsSpecialName\#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo\_IsSpecialName\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているフィールドを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> に対して定義されているフィールドのうち、指定したバインディング制約に一致するすべてのフィールドを表す <see cref="T:System.Reflection.FieldInfo" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.FieldInfo" /> に対してフィールドが定義されていないか、または定義されているフィールドの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetFields%2A>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、フィールドが返される順序のためする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるフィールドを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック フィールドを含める。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないフィールド \(つまり、プライベート、内部、および保護されている\) を含める。 のみ保護され、基本クラスの内部のフィールドが返されます。基本クラスにプライベート フィールドには返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly`宣言されているフィールドのみを検索する、 <xref:System.Type>、単に継承されたフィールドではなくです。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.FieldInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドはクラス制約のパブリック フィールドを検索します。  
  
   
  
## 例  
 次の例を使用して、`GetFields(BindingFlags)`メソッドです。  
  
 [!code-cpp[Classic MethodBase.Attributes Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>クローズ ジェネリック型の型引数またはジェネリック型定義の型パラメーターを表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>ジェネリック型の型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。 現在の型がジェネリック型でない場合は空の配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 配列の要素は、ジェネリック型の型引数の一覧に表示される順序で返されます。  
  
-   現在の型がクローズ構築型である場合 \(つまり、<xref:System.Type.ContainsGenericParameters%2A>プロパティから返される`false`\)、によって返される配列、<xref:System.Type.GetGenericArguments%2A>メソッドにジェネリック型定義のジェネリック型パラメーターに割り当てられている型が含まれています。  
  
-   現在の型がジェネリック型定義の場合は、配列には、型パラメーターが含まれています。  
  
-   現在の型がオープン構築型の場合 \(つまり、<xref:System.Type.ContainsGenericParameters%2A>プロパティから返される`true`\) すべての型パラメーターと外側のジェネリック型またはメソッドの型パラメーターにどのような種類が割り当てられていないで、配列には、型と型の両方が含まれていますパラメーター。 使用して、<xref:System.Type.IsGenericParameter%2A>プロパティを見分けます。 このシナリオの例については、のコード例を参照してください、<xref:System.Type.ContainsGenericParameters%2A>プロパティです。  
  
 ジェネリックのリフレクションで使用される用語に対するインバリアント条件の一覧は、次を参照してください。、<xref:System.Type.IsGenericType%2A>プロパティ解説します。  
  
   
  
## 例  
 次のコード例では、<xref:System.Type.GetGenericArguments%2A>構築された型の型引数とそのジェネリック型定義の型パラメーターを表示するメソッド。  
  
 このコード例に示されている例の一部である、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティです。 サンプル出力の例を参照してください。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のジェネリック型パラメーターの制約を表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>現在のジェネリック型パラメーターの制約を表す <see cref="T:System.Type" /> の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各パラメーターの制約をジェネリック型がで表される、<xref:System.Type>オブジェクト。 使用して、<xref:System.Type.IsClass%2A>プロパティの制約が基底クラスの制約がかどうか以外のかどうか、プロパティを返します`false`制約がインターフェイスの制約。 型パラメーターにクラス制約のないおよびインターフェイス制約がない場合は、空の配列が返されます。  
  
 ジェネリックのリフレクションで使用される用語に対するインバリアント条件の一覧は、次を参照してください。、<xref:System.Type.IsGenericType%2A>プロパティ解説します。  
  
   
  
## 例  
 次のコード例は、ジェネリック型を定義`Test`異なる制約を持つ 2 つの型パラメーターを使用します。 使用して、制約がチェックされるプログラムを実行するとき、<xref:System.Type.GenericParameterAttributes%2A>プロパティおよび<xref:System.Type.GetGenericParameterConstraints%2A>メソッドです。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Type" /> オブジェクトは、ジェネリック型パラメーターではありません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> プロパティが <see langword="false" /> を返します。</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のジェネリック型を構築する元になるジェネリック型定義を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型を構築する元になるジェネリック型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ジェネリック型定義は、他の型を構築するためのテンプレートです。 たとえば、ジェネリック型定義から`G<T>`\(c\# の構文で表現します。`G(Of T)` Visual basic または`generic <typename T> ref class G`C\+\+ で\) を構築し、型のインスタンスを作成できます`G<int>`\(`G(Of Integer)` Visual Basic で\)。 指定された、<xref:System.Type>これを表すオブジェクトの構築型を<xref:System.Type.GetGenericTypeDefinition%2A>メソッドがジェネリック型定義を返します。  
  
 2 つの構築された型が同じジェネリック型定義から作成する場合は、同じの型引数を使用して、<xref:System.Type.GetGenericTypeDefinition%2A>メソッドは、同じを返します<xref:System.Type>両方の種類のオブジェクト。  
  
 呼び出した場合、<xref:System.Type.GetGenericTypeDefinition%2A>メソッドを<xref:System.Type>既に、ジェネリック型定義を表すオブジェクト、現在を返して、<xref:System.Type>です。  
  
> [!IMPORTANT]
>  ジェネリック型の配列は、ジェネリックではないです。 C\# コードで`A<int>[] v;`または Visual Basic コード`Dim v() As A(Of Integer)`、変数の型`v`ジェネリックではありません。 使用して<xref:System.Type.IsGenericType%2A>型が呼び出しの前にジェネリックかどうかを判断する<xref:System.Type.GetGenericTypeDefinition%2A>です。  
  
 ジェネリック リフレクションで使用される用語に対するインバリアント条件の一覧は、次を参照してください。、<xref:System.Type.IsGenericType%2A>プロパティ解説します。  
  
   
  
## 例  
 次のコード例が通常のインスタンスの作成を使用して構築された型のインスタンスを作成し、使用、<xref:System.Type.GetType%2A>と<xref:System.Type.GetGenericTypeDefinition%2A>構築型とジェネリック型定義を取得するメソッド。 この例は、ジェネリックを使用して<xref:System.Collections.Generic.Dictionary%602>型以外の構築型を表す、<xref:System.Collections.Generic.Dictionary%602>の`Test`文字列キーを持つオブジェクト。  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型はジェネリック型ではありません。  つまり、<see cref="P:System.Type.IsGenericType" /> は <see langword="false" /> を返します。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>対象のインスタンスのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは<xref:System.Object.GetHashCode%2A?displayProperty=fullName>します。  
  
   
  
## 例  
 次の例のハッシュ コードを表示する、`System.Windows.Forms.Button`クラスです。  
  
 [!code-cpp[Type\_GetHashCode\_GetFields\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type\_GetHashCode\_GetFields\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type\_GetHashCode\_GetFields\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するインターフェイスの名前を格納している文字列。 ジェネリック インターフェイスの場合、これは完全修飾名です。</param>
        <summary>指定した名前のインターフェイスを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 検索`name`小文字が区別されます。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Type>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、インターフェイスの制約とクラスまたはインターフェイスの制約から継承するインターフェイスを検索します。  
  
> [!NOTE]
>  ジェネリック インターフェイスの場合、`name`パラメーターは、抑音アクセント \('\) と型パラメーターの数で終わる、完全修飾名。 これは、ジェネリック インターフェイスの定義と構築されたジェネリック インターフェイスの両方に当てはまります。 たとえば、検索する`IExample<T>`\(`IExample(Of T)` Visual Basic で\) または`IExample<string>`\(`IExample(Of String)` Visual Basic で\)、検索`"IExample`1"`です。  
  
   
  
## 例  
 次のコード例では、<xref:System.Type.GetInterface%28System.String%29>を検索するメソッド、<xref:System.Collections.Hashtable>のクラス、<xref:System.Runtime.Serialization.IDeserializationCallback>インターフェイス、およびインターフェイスのメソッドの一覧です。  
  
 コード例も示します、<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>メソッドのオーバー ロードおよび<xref:System.Type.GetInterfaceMap%2A>メソッド。  
  
 [!code-cpp[Type\_GetInterface\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type\_GetInterface\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type\_GetInterface\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">現在の <see cref="T:System.Type" /> は、別の型の引数と同じジェネリック インターフェイスを実装する型を表します。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">取得するインターフェイスの名前を格納している文字列。 ジェネリック インターフェイスの場合、これは完全修飾名です。</param>
        <param name="ignoreCase">単純なインターフェイス名を指定する <see langword="true" /> の部分 \(名前空間が大文字と小文字を厳密に区別することを指定されている部分\) で大文字と小文字の区別を無視する場合は、<c>name</c>。  
  
 \-または\-  
  
 <see langword="false" /> のすべての部分の検索時に大文字と小文字を区別する場合は、<c>name</c>。</param>
        <summary>派生クラスでオーバーライドされた場合、インターフェイス名の大文字と小文字を区別するかどうかを指定して、指定したインターフェイスを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `ignoreCase`パラメーターは名前空間ではないシンプルなインターフェイス名にのみ適用されます。 部分`name`名前空間が正しい場合は、必要またはインターフェイスは検出されませんを指定します。 たとえば、"System.icomparable"を検索文字列、<xref:System.IComparable>が、文字列"system.icomparable"しません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Type>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、インターフェイスの制約とクラスまたはインターフェイスの制約から継承するインターフェイスを検索します。  
  
> [!NOTE]
>  ジェネリック インターフェイスの場合、`name`パラメーターは、抑音アクセント \('\) と型パラメーターの数で終わる、完全修飾名。 これは、ジェネリック インターフェイスの定義と構築されたジェネリック インターフェイスの両方に当てはまります。 たとえば、検索する`IExample<T>`\(`IExample(Of T)` Visual Basic で\) または`IExample<string>`\(`IExample(Of String)` Visual Basic で\)、検索`"IExample`1"`です。  
  
   
  
## 例  
 次のコード例では、<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>の大文字と小文字の検索を実行するメソッド、<xref:System.Collections.Hashtable>のクラス、<xref:System.Collections.IEnumerable>インターフェイスです。  
  
 このコード例も示します、<xref:System.Type.GetInterface%28System.String%29>メソッドのオーバー ロードおよび<xref:System.Type.GetInterfaceMap%2A>メソッドです。  
  
 [!code-cpp[Type\_GetInterface\#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type\_GetInterface\#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type\_GetInterface\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">現在の <see cref="T:System.Type" /> は、別の型の引数と同じジェネリック インターフェイスを実装する型を表します。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">割り当ての取得対象であるインターフェイス型。</param>
        <summary>指定したインターフェイス型に対するインターフェイスの割り当てを返します。</summary>
        <returns>
          <paramref name="interfaceType" /> に対するインターフェイスの割り当てを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インターフェイス マップは、そのインターフェイスを実装するクラスの実際のメンバーにインターフェイスをマップする方法を示します。  
  
 場合、現在<xref:System.Type>構築ジェネリック型パラメーターに置換された要素に適切な型引数の型を表す、<xref:System.Reflection.InterfaceMapping>このメソッドによって返されます。  
  
   
  
## 例  
 次の例では、<xref:System.Type.GetInterfaceMap%2A>メソッドを呼び出せば確認方法、<xref:System.IFormatProvider>インターフェイスにマップ<xref:System.Globalization.CultureInfo>メソッド、方法、および<xref:System.IAppDomainSetup>インターフェイスにマップ<xref:System.AppDomainSetup>プロパティです。 注意してください。、<xref:System.IAppDomainSetup>インターフェイスは、返されたプロパティのセットを定義<xref:System.Reflection.InterfaceMapping>オブジェクトを含む独立した<xref:System.Reflection.MethodInfo>プロパティの get および set アクセサーのオブジェクト。  
  
 [!code-csharp[System.Type.GetInterfaceMap\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" /> は、現在の型では実装されていません。  
  
 または  
  
 <paramref name="interfaceType" /> パラメーターは、インターフェイスを参照しません。  
  
 または  
  
 <paramref name="interfaceType" /> ジェネリック インターフェイスで、現在の型は配列型です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Type" /> はジェネリック型パラメーターを表しています。つまり、<see cref="P:System.Type.IsGenericParameter" /> は <see langword="true" /> です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラス内でオーバーライドされた場合、現在の <see cref="T:System.Type" /> で実装または継承されているすべてのインターフェイスを取得します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているすべてのインターフェイスを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetInterfaces%2A>メソッドで返されないインターフェイス、特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、インターフェイスが返される順序のためする順序が異なります。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Type>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、インターフェイスの制約とクラスまたはインターフェイスの制約から継承するインターフェイスを検索します。  
  
   
  
## 例  
 次の例では、指定したクラスの型を取得し、型を実装または継承するすべてのインターフェイスを表示します。 Visual Basic の例をコンパイルするには、次のコンパイラ コマンドを使用します。  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type\_GetInterfaces1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type\_GetInterfaces1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type\_GetInterfaces1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">静的初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メンバーの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック メンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メンバーが含まれています。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMember%2A>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存しません、メンバーが返される順序のためオーダーが変化します。  
  
 このメソッドのオーバー ロードでは、クラス初期化子 \(.cctor\) は検索されません。 クラス初期化子を検索するを受け取るオーバー ロードを使用して<xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> in Visual Basic\). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想の両方\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MemberInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c\# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## 例  
 次の例のすべてのメンバーの表示、`String`文字 C で始まるクラス  
  
 [!code-cpp[Type\_GetMember\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type\_GetMember\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type\_GetMember\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するメンバーの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 または  
  
 空の配列を返す場合は 0。</param>
        <summary>指定したバインディング制約を使用して、指定したメンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMember%2A>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メンバー \(つまり、プライベート、内部、およびプロテクト メンバー\)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 このメソッドのオーバー ロードを使用したクラス初期化子 \(.cctor\) を取得する必要がありますを指定する「.cctor」の`name`、および<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> in Visual Basic\) for `bindingAttr`. 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MemberInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c\# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## 例  
 次の例のすべてのパブリック静的メンバーの表示、`myString`文字 C で始まるクラス  
  
 [!code-cpp[Type\_GetMember\#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type\_GetMember\#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type\_GetMember\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するメンバーの名前を含む文字列。</param>
        <param name="type">検索する値。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 または  
  
 空の配列を返す場合は 0。</param>
        <summary>指定されたバインディング制約を使用して、指定されたメンバー型の指定されたメンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMember%2A> メソッドは返しませんメンバーを特定の順序でなど、アルファベット順または宣言の順序。 コードに依存できません、メンバーが返される順序のため順序が変化します。  
  
 次 <xref:System.Reflection.BindingFlags> フィルター フラグを使用するには、検索に含めるには、どのメンバーを定義します。  
  
-   どちらかを指定する必要があります `BindingFlags.Instance` または `BindingFlags.Static` 戻り値を取得するためにします。  
  
-   指定 `BindingFlags.Public` 、検索にパブリック メンバーを含める。  
  
-   指定 `BindingFlags.NonPublic` 、検索条件に非パブリック メンバー \(つまり、プライベート、内部、および protected メンバー\) を含める。  
  
-   指定 `BindingFlags.FlattenHierarchy` に含める `public` と `protected` 上位階層の静的メンバー `private` 継承するクラスで静的メンバーは含まれません。  
  
 次 <xref:System.Reflection.BindingFlags> 修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 小文字を区別しない `name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメンバーのみを検索する、 <xref:System.Type>, 、継承されたメンバーされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 このメソッドのオーバー ロードを使用してクラス初期化子 \(.cctor\) を取得するには、「.cctor」を指定する必要があります `name`, 、<xref:System.Reflection.MemberTypes.Constructor?displayProperty=fullName> の `type`, 、および  <xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> Visual basic\) の `bindingAttr`です。 使用してクラス初期化子を取得することも、 <xref:System.Type.TypeInitializer%2A> プロパティです。  
  
 場合は、現在 <xref:System.Type> このメソッドが戻る構築されたジェネリック型を表す、 <xref:System.Reflection.MemberInfo> 適切な型の引数に置き換え、型パラメーターです。  
  
 場合は、現在 <xref:System.Type> を表しますがジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメンバーまたはのメンバーを検索 <xref:System.Object> クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドは含まれませんで型引数 `name`します。 たとえば、C\# の場合、コード `GetMember("MyMethod<int>")` テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく `MyMethod` 型の 1 つのジェネリック引数を持つ `int`です。  
  
   
  
## 例  
 次の例のすべてのメソッドを表示する、 `myString` 文字 C で始まるクラス  
  
 [!code-cpp[Type\_GetMember\#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type\_GetMember\#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type\_GetMember\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">派生クラスにより実装が提供される必要があります。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック メンバーを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> のすべてのパブリック メンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.MemberInfo" /> にパブリック メンバーが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMembers%2A>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。  
  
 このメソッドのオーバー ロードを呼び出す、<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>メソッド オーバー ロードを<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> in Visual Basic\). クラス初期化子 \(.cctor\) は検索されません。 クラス初期化子を検索するを受け取るオーバー ロードを使用して<xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> in Visual Basic\). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MemberInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>を表します、ジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
   
  
## 例  
 次のコード例は、使用する方法を示します、<xref:System.Type.GetMembers>メソッドのオーバー ロードを指定したクラスのすべてのパブリック メンバーに関する情報を収集します。  
  
 [!code-cpp[Type\_GetMembers1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type\_GetMembers1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type\_GetMembers1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 または  
  
 空の配列を返す場合は 0 \(<see cref="F:System.Reflection.BindingFlags.Default" />\)。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているメンバーを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> に対して定義されているメンバーのうち、指定したバインディング制約に一致するすべてのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.MemberInfo" /> に対してメンバーが定義されていないか、または定義されているメンバーの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMembers%2A> メソッドは返しませんメンバーを特定の順序でなど、アルファベット順または宣言の順序。 コードに依存できません、メンバーが返される順序のため順序が変化します。  
  
 次 <xref:System.Reflection.BindingFlags> フィルター フラグを使用するには、検索に含めるには、どのメンバーを定義します。  
  
-   どちらかを指定する必要があります `BindingFlags.Instance` または `BindingFlags.Static` 戻り値を取得するためにします。  
  
-   指定 `BindingFlags.Public` 、検索にパブリック メンバーを含める。  
  
-   指定 `BindingFlags.NonPublic` 、検索条件に非パブリック メンバー \(つまり、プライベート、内部、および protected メンバー\) を含める。 のみ保護され、基底クラスに内部メンバーが返されます。基底クラスにプライベート メンバーは返されません。  
  
-   指定 `BindingFlags.FlattenHierarchy` に含める `public` と `protected` 上位階層の静的メンバー `private` 継承するクラスで静的メンバーは含まれません。  
  
 次 <xref:System.Reflection.BindingFlags> 修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメンバーのみを検索する、 <xref:System.Type>, 、継承されたメンバーされません。  
  
 だけを持つには、このメソッドを呼び出して、 `Public` フラグまたはのみ、 `NonPublic` フラグは、指定したメンバーを返しますを必要し、しないその他のフラグ。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 このメソッドのオーバー ロードを使用してクラス初期化子 \(.cctor\) を取得するには、指定する必要があります <xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> \(<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> Visual Basic で\)。 使用してクラス初期化子を取得することも、 <xref:System.Type.TypeInitializer%2A> プロパティです。  
  
 このメソッドが戻るかどうかは、現在は構築されたジェネリック型を表す、 <xref:System.Reflection.MemberInfo> 適切な型の引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合は、現在 <xref:System.Type> を表しますがジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメンバーまたはのメンバーを検索 <xref:System.Object> クラスの制約が存在しない場合。  
  
   
  
## 例  
 次のコード例では、使用して、 <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> メソッドのオーバー ロードは、指定したクラスのすべてのパブリック インスタンス メンバーに関する情報を収集します。  
  
 [!code-cpp[Type\_GetMembers2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type\_GetMembers2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type\_GetMembers2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック メソッドを検索します。</summary>
        <returns>指定した名前のパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メソッドが含まれています。  
  
 メソッドはオーバー ロードされ、1 つ以上のパブリック メソッドを持つ場合、<xref:System.Type.GetMethod%28System.String%29>メソッドがスローされます、<xref:System.Reflection.AmbiguousMatchException>例外。 次の例では、例外がスローの 1 つ以上のパブリック オーバー ロードがあるので、<xref:System.Int32.ToString%2A?displayProperty=fullName>メソッドです。  その一方で、ための`Person.ToString`メソッドのオーバーライド<xref:System.Object.ToString%2A?displayProperty=fullName>したがってが過負荷とでは、<xref:System.Type.GetMethod%28System.String%29>メソッドが取得できるの<xref:System.Reflection.MethodInfo>オブジェクト。  
  
 [!code-csharp[System.Type.GetMethod\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 特定のメソッドを取得するには、次のいずれかの操作を行うことができます。  
  
-   呼び出す、<xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29>メソッドを指定し、`bindingAttr`メソッドを一意に識別する引数。 たとえば、静的およびインスタンスのオーバー ロードに型が含まれるため、例外がスローされた場合を指定できます、`bindingAttr`の引数<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName>です。  
  
-   オーバー ロードを呼び出して、<xref:System.Type.GetMethod%2A>メソッドを含む、`types`メソッドのパラメーターの型を定義するパラメーターです。  
  
-   呼び出す、<xref:System.Type.GetMethods>すべての型に属しているパブリック メソッドを格納する配列を取得します。 反復処理するという名前の重複するメソッドを識別するために`name`です。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`です。 たとえば、c\# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"をという名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## 例  
 次の例は、という名前のメソッドを取得`MethodA`です。  
  
 [!code-cpp[Type\_GetMethod1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type\_GetMethod1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type\_GetMethod1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のメソッドが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>指定したバインディング制約を使用して、指定したメソッドを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   どちらかを指定する必要があります<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName>または<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>戻り値を取得するためにします。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>パブリック メソッドを検索します。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>検索に含める非パブリック メソッド \(つまり、プライベート、内部、および保護されたメソッド\)、します。  
  
-   指定<xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=fullName>に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=fullName>小文字を区別しない`name`です。  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=fullName>宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 メソッドはオーバー ロードされ、複数のオーバー ロードによって指定された制約を満たしている場合は`bindingAttr`引数、メソッドをスローする<xref:System.Reflection.AmbiguousMatchException>例外。 次の例では、ため、例外がスローされます。  
  
-   `TestClass`型の 2 つのパブリック インスタンス オーバー ロードを持つ、`DisplayValue`メソッド、`DisplayValue(String)`と`DisplayValue(String, Object[])`です。  
  
-   `TestClass`型の 2 つのパブリック インスタンス オーバー ロードを持つ、`Equals`から継承されたうちの 1 つは、メソッド<xref:System.Object>:`Equals(TestClass)`および`Equals(Object)`です。  
  
 [!code-csharp[System.Type.GetMethod\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 特定のメソッドを取得するには、次のいずれかの操作を行うことができます。  
  
-   バインディング制約を変更します。 前の例では、パブリック インスタンスを取得しようとして`Equals`は型で宣言され、正常に継承されないメソッドは、取得`Equals(TestClass)`です。  
  
-   オーバー ロードを呼び出して、<xref:System.Type.GetMethod%2A>メソッドを含む、`types`メソッドのパラメーターの型を定義するパラメーターです。  
  
-   呼び出す、<xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>すべての型に属している、指定したバインディング属性を持つメソッドを格納する配列を取得します。 反復処理するという名前の重複するメソッドを識別するために`name`です。 このアプローチは、前の例のハンドラーで説明されて、<xref:System.Reflection.AmbiguousMatchException>例外。  
  
 場合、現在<xref:System.Type>を返しますが構築ジェネリック型を表す、<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合は現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c\# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## 例  
 次の例では、指定したバインディング フラグに一致するメソッドを取得します。  
  
 [!code-cpp[Type\_GetMethod2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type\_GetMethod2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type\_GetMethod2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 \-または\-  
  
 パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 \(<see cref="F:System.Type.EmptyTypes" /> フィールドで指定\)。</param>
        <summary>指定したパブリック メソッドのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されたパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メソッドが含まれています。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>クラス制約のメソッドまたはのメソッドにはジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターの検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  `name`パラメーターは、型引数を含めることはできません。 たとえば、c\# コード`GetMethod("MyGenericMethod<int>")`テキストの名前を持つメソッドを検索"`MyGenericMethod<int>`"、という名前のメソッドではなく`MyGenericMethod`型の 1 つのジェネリック引数を持つ`int`します。 代わりに、`GetMethod("MyGenericMethod")`で適切なパラメーターを持つ、`types`配列。  
  
   
  
## 例  
 次の例の特定のオーバー ロードを検索する`MethodA`さまざまな引数の型を指定します。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]例が必要です、`/unsafe`コンパイラ オプション。  
  
 [!code-cpp[Type\_GetMethod4\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type\_GetMethod4\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type\_GetMethod4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 次の例では取得<xref:System.Reflection.MethodInfo>オブジェクトを表す、`Add`非ジェネリック型のメソッド \(、<xref:System.Collections.ArrayList>クラス\)、オープン ジェネリック型 \(、<xref:System.Collections.Generic.List%601>クラス\)、およびクローズ ジェネリック型 \(、`List(Of String)`型です。  
  
 [!code-csharp[System.Type.GetMethod\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object. To provide the **parameterReference tag is not supported!!!!**  
 argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=fullName> method. To provide the **parameterReference tag is not supported!!!!**  
 argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=fullName> property.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 \-または\-  
  
 パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 \(<see cref="F:System.Type.EmptyTypes" /> フィールドで指定\)。</param>
        <param name="modifiers">
          <c>types</c> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーは、このパラメーターを処理しません。</param>
        <summary>指定したパブリック メソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のバインダーが処理されませんが[GetMethod メソッド \(String, Type\<xref:System.Reflection.ParameterModifier>\(、`modifiers`パラメーター\)、abstract を使用することができます[GetMethod メソッド \(String, Type\<xref:System.Reflection.Binder?displayProperty=fullName>を処理するカスタム バインダーを記述するクラス`modifiers`です。`ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メソッドが含まれています。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、[GetMethod メソッド \(String, Type\<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在[GetMethod メソッド \(String, Type\<xref:System.Type>クラス制約のメソッドまたはのメソッドを表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーター検索[GetMethod メソッド \(String, Type\<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c\# コード`GetMethod("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。 代わりに、`GetMethod("MyMethod")`で適切なパラメーターを持つ、`types`配列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="modifiers" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 \-または\-  
  
 <see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see langword="Nothing" />\)。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 \-または\-  
  
 パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 \(<see cref="F:System.Type.EmptyTypes" /> フィールドで指定\)。</param>
        <param name="modifiers">
          <c>types</c> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーは、このパラメーターを処理しません。</param>
        <summary>指定したバインディング制約を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のバインダーが処理されませんが[GetMethod メソッド \(String, BindingFlags, Binder, Type\<xref:System.Reflection.ParameterModifier>\(、`modifiers`パラメーター\)、abstract を使用することができます[GetMethod メソッド \(String, BindingFlags, Binder, Type\<xref:System.Reflection.Binder?displayProperty=fullName>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。`ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 次[GetMethod メソッド \(String, BindingFlags, Binder, Type\<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メソッドを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メソッド \(つまり、プライベート、内部、および保護されたメソッド\)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次[GetMethod メソッド \(String, BindingFlags, Binder, Type\<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメソッドのみを検索する、 [GetMethod メソッド \(String, BindingFlags, Binder, Type\<xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「[GetMethod メソッド \(String, BindingFlags, Binder, Type\<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、[GetMethod メソッド \(String, BindingFlags, Binder, Type\<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在[GetMethod メソッド \(String, BindingFlags, Binder, Type\<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索[GetMethod メソッド \(String, BindingFlags, Binder, Type\<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c\# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## 例  
 次の例の特定のオーバー ロードを検索する`MethodA`、バインディング制約と、さまざまな引数の型を指定します。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]例が必要です、`/unsafe`コンパイラ オプション。  
  
 [!code-cpp[Type\_GetMethod5\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type\_GetMethod5\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type\_GetMethod5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="modifiers" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 \-または\-  
  
 <see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see langword="Nothing" />\)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップの方法に関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 \-または\-  
  
 パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 \(<see cref="F:System.Type.EmptyTypes" /> フィールドで指定\)。</param>
        <param name="modifiers">
          <c>types</c> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーは、このパラメーターを処理しません。</param>
        <summary>指定したバインディング制約および指定した呼び出し規約を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のバインダーが処理されませんが[GetMethod メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.ParameterModifier>\(、`modifiers`パラメーター\)、abstract を使用することができます[GetMethod メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.Binder?displayProperty=fullName>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。`ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 次の表は、基本クラスのメンバーがによって返される、`GetXXX`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次[GetMethod メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メソッドを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メソッド \(つまり、プライベート、内部、および保護されたメソッド\)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次[GetMethod メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメソッドのみを検索する、 [GetMethod メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「[GetMethod メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略できません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 かどうか、現在は構築されたジェネリック型を表す、このメソッドが戻る、[GetMethod メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在[GetMethod メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索[GetMethod メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c\# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## 例  
 次の例の特定のオーバー ロードを検索する`MethodA`、バインディング制約を指定する、呼び出し規約、引数の型のさまざまなです。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]例が必要です、`/unsafe`コンパイラ オプション。  
  
 [!code-cpp[Type\_GetMethod3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type\_GetMethod3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type\_GetMethod3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="modifiers" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 \-または\-  
  
 <see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see langword="Nothing" />\)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックをクリーンアップするプロセスに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 パラメーターをとらないメソッドを取得するための、<see cref="T:System.Type" /> 型の空の配列 \(Type\[\] types \= new Type\[0\]\)。  
  
 または  
  
 <see langword="null" />。<c>types</c> が<see langword="null" /> の場合、引数は一致していません。</param>
        <param name="modifiers">
          <c>types</c> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーは、このパラメーターを処理しません。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規約を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のバインダーが処理されませんが [GetMethodImpl メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.ParameterModifier> \(、 `modifiers` パラメーター\)、抽象を使用することができます [GetMethodImpl メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.Binder?displayProperty=fullName> クラスが、処理するカスタム バインダーを記述する `modifiers`です。`ParameterModifier` COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターだけが処理されます。  
  
 `types` が`null` の場合、引数は一致していません。  
  
 次 [GetMethodImpl メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags> フィルター フラグを使用するには、検索に含めるには、どのメソッドを定義します。  
  
-   どちらかを指定する必要があります `BindingFlags.Instance` または `BindingFlags.Static` 戻り値を取得するためにします。  
  
-   指定 `BindingFlags.Public` 、検索にパブリック メソッドを含める。  
  
-   指定 `BindingFlags.NonPublic` 、検索条件に非パブリック メソッド \(つまり、プライベート、内部、および保護されたメソッド\) を含める。  
  
-   指定 `BindingFlags.FlattenHierarchy` に含める `public` と `protected` 上位階層の静的メンバー `private` 継承するクラスで静的メンバーは含まれません。  
  
 次 [GetMethodImpl メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags> 修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 小文字を区別しない `name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメソッドのみを検索する、 [GetMethodImpl メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Type>, 、継承されたメソッドされません。  
  
 詳細については、「[GetMethodImpl メソッド \(String, BindingFlags, Binder, CallingConventions, Type\<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" /> または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック メソッドを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MethodInfo" /> に対して定義されているすべてのパブリック メソッドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.MethodInfo" /> に対してパブリック メソッドが定義されていない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetMethods%2A>メソッドで返されないメソッド、特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メソッドが返される順序のためする順序が異なります。  
  
 コンス トラクターは、この呼び出しによって返されるメソッドの配列には含まれません。 別の呼び出しを行う`GetConstructors()`コンス トラクター メソッドを取得します。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想の両方\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているメソッドを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> に対して定義されているメソッドのうち、指定したバインディング制約に一致するすべてのメソッドを表す <see cref="T:System.Reflection.MethodInfo" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.MethodInfo" /> に対してメソッドが定義されていないか、または定義されているメソッドの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetMethods%2A>メソッドで返されないメソッドを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メソッドが返される順序のためする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メソッドを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メソッド \(つまり、プライベート、内部、および保護されたメソッド\)、します。 のみ保護され、基本クラスの内部メソッドが返されます。基本クラスのプライベート メソッドは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>クラス制約のメソッドまたはのメソッドを表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーター検索<xref:System.Object>クラスの制約が存在しない場合。  
  
   
  
## 例  
 次の例は、2 つのパブリック メソッドと 1 つの保護されたメソッドを使用するクラスを作成、作成、`Type`オブジェクトに対応する`MyTypeClass`、すべてのパブリックと非パブリック メソッドを取得し、その名前を表示します。  
  
 [!code-cpp[Type\_GetMethods2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type\_GetMethods2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type\_GetMethods2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得対象の入れ子にされた型の名前を格納している文字列。</param>
        <summary>指定した名前を持つ入れ子にされたパブリックな型を検索します。</summary>
        <returns>存在する場合は、指定された名前を持つ入れ子にされたパブリックな型を表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 検索`name`小文字が区別されます。  
  
 入れ子になったクラスの簡易名を使用して`name`です。 外側のクラスの名前では、修飾しません。 入れ子になったのジェネリック クラスの完全修飾名を使用して\-は、アクサン グラーブと汎用引数の数を追加します。 たとえば、文字列を使用して"内部 ' 1"入れ子になったクラスをジェネリック`Inner<T>`\(`Inner(Of T)` Visual Basic で\)。 型パラメーターの言語固有の構文を含めないでください。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想の両方\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c\#、Visual Basic、または C\+\+ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。 これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、[Ilasm.exe \(IL Assembler\)](http://msdn.microsoft.com/ja-jp/4ca3a4f0-4400-47ce-8936-8e219961c76f)です。  
  
 については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得対象の入れ子にされた型の名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、指定されている入れ子にされた型を検索します。</summary>
        <returns>指定した要件と一致し、入れ子にされた型が存在する場合は、その型を表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 入れ子になったクラスの簡易名を使用して`name`です。 外側のクラスの名前では、修飾しません。 入れ子になったのジェネリック クラスの完全修飾名を使用して: つまり、抑音アクセントとジェネリック パラメーターの数を追加します。 たとえば、文字列を使用"内部 ' 1"入れ子になったクラスをジェネリック`Inner<T>`\(`Inner(Of T)` Visual Basic で\)。 型パラメーターの言語固有の構文を含めないでください。  
  
 次<xref:System.Reflection.BindingFlags>フィルターを定義する入れ子になったフラグを使用することができますが、検索に含める型します。  
  
-   どちらかを指定する必要があります<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>または<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>戻り値を取得します。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>検索にパブリックな入れ子になった型を含める。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>検索に含める非パブリックの入れ子にされた型 \(つまり、プライベート、内部、および保護されている入れ子になった型\)、します。  
  
 このメソッドは、現在の型の入れ子にされた型のみを返します。 現在の型の基本クラスを検索しません。 基本クラスに入れ子にされた型を呼び出し、継承階層を見つける必要があります<xref:System.Type.GetNestedType%2A>レベルごとにします。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName>および<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>は無視されます。  
  
 だけでは、このメソッドを呼び出し、<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>フラグまたはのみ、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>フラグは、指定した入れ子になった型を必要し、しないその他の任意のフラグを返します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c\#、Visual Basic、または C\+\+ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。 これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、[Ilasm.exe \(IL Assembler\)](http://msdn.microsoft.com/ja-jp/4ca3a4f0-4400-47ce-8936-8e219961c76f)です。  
  
 については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> 内で入れ子になっているすべてのパブリック型を返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> 内で入れ子になっているパブリック型を表す <see cref="T:System.Type" /> オブジェクトの配列 \(検索は非再帰的\)。または、現在の <see cref="T:System.Type" /> で入れ子になっているパブリック型がない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetNestedTypes%2A>メソッドで返されないの種類を特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存しません、型が返される順序のためオーダーが変化します。  
  
 現在の型ですぐに入れ子にされたパブリック型のみが返されます。検索は、再帰的ではありません。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想の両方\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c\#、Visual Basic、または C\+\+ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。 これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、[Ilasm.exe \(IL Assembler\)](http://msdn.microsoft.com/ja-jp/4ca3a4f0-4400-47ce-8936-8e219961c76f)です。  
  
 については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>です。  
  
   
  
## 例  
 次の例は、入れ子になったクラスを定義し、`struct`で`MyClass`の型を使用して入れ子にされた型のオブジェクトを取得し、`MyClass`です。  
  
 [!code-cpp[Type\_GetNestedTypes\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type\_GetNestedTypes\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type\_GetNestedTypes\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> 内で入れ子になっている型を検索します。</summary>
        <returns>指定したバインディング制約と一致する現在の <see cref="T:System.Type" /> で入れ子にされたすべての型を表す <see cref="T:System.Type" /> オブジェクトの配列 \(検索は非再帰的\)。または、バインディング制約と一致する入れ子にされた型が見つからない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 入れ子にされた型の検索は、再帰的ではありません。  
  
 <xref:System.Type.GetNestedTypes%2A>メソッドで返されないの種類を特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存しません、型が返される順序のためオーダーが変化します。  
  
 次<xref:System.Reflection.BindingFlags>検索に含める入れ子になったを定義するフラグを使用できるフィルターの種類します。  
  
-   どちらかを指定する必要があります<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>または<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>を戻り値を取得します。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>検索にパブリックな入れ子になった型を含める。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>検索に含める非パブリックの入れ子にされた型 \(つまり、プライベート、内部、および保護されている入れ子になった型\)、します。  
  
 このメソッドは、現在の型の入れ子にされた型のみを返します。 現在の型の基本クラスを検索しません。 基本クラスに入れ子にされた型を呼び出して、継承階層を見つける必要があります<xref:System.Type.GetNestedTypes%2A>レベルごとにします。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName>および<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName>は無視されます。  
  
 だけを持つには、このメソッドを呼び出すの<xref:System.Reflection.BindingFlags.Public?displayProperty=fullName>フラグまたはのみの<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>フラグは、指定した入れ子にされた型を必要し、しないその他の任意のフラグを返します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c\#、Visual Basic、または C\+\+ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。 これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、[Ilasm.exe \(IL Assembler\)](http://msdn.microsoft.com/ja-jp/4ca3a4f0-4400-47ce-8936-8e219961c76f)です。  
  
 についてそれらのジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型では、次を参照してください。<xref:System.Type.MakeGenericType%2A>です。  
  
   
  
## 例  
 次の例では、次の 2 つの入れ子になったパブリック クラスと 2 つの入れ子になったプロテクト クラスを作成し、指定したバインディング制約に一致するクラスの情報が表示されます。  
  
 [!code-cpp[Type\_GetNestedClassesAbs\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type\_GetNestedClassesAbs\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type\_GetNestedClassesAbs\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック プロパティを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.PropertyInfo" /> のすべてのパブリック プロパティを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.PropertyInfo" /> にパブリック プロパティが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a **parameterReference tag is not supported!!!!**  
 argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C\# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic. It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.  
  
 A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(in Visual Basic, combine the values using **languageKeyword tag is not supported!!!!**  
\) to get it.  
  
 The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.  
  
 The following table shows what members of a base class are returned by the **languageKeyword tag is not supported!!!!**  
 methods when reflecting on a type.  
  
|Member Type|Static|Non\-Static|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Field|No|Yes. A field is always hide\-by\-name\-and\-signature.|  
|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide\-by\-name\-and\-signature. See note 2 below.|  
|Method|No|Yes. A method \(both virtual and non\-virtual\) can be hide\-by\-name or hide\-by\-name\-and\-signature.|  
|Nested Type|No|No|  
|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide\-by\-name\-and\-signature. See note 2 below.|  
  
1.  Hide\-by\-name\-and\-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  
  
2.  For reflection, properties and events are hide\-by\-name\-and\-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  
  
3.  Custom attributes are not part of the common type system.  
  
 If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.  
  
 If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  
  
   
  
## 例  
 The following example demonstrates the use of the **languageKeyword tag is not supported!!!!**  
 method.  
  
 [!code-cpp[Type\_GetTypeCode\#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type\_GetTypeCode\#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type\_GetTypeCode\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> のプロパティを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> のプロパティのうち、指定したバインディング制約に一致するすべてのプロパティを表す <see cref="T:System.Reflection.PropertyInfo" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.PropertyInfo" /> にプロパティが設定されていないか、またはプロパティの中でバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 <xref:System.Type.GetProperties%2A>メソッドで返されないプロパティを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存しません、プロパティが返される順序のためオーダーが変化します。  
  
 次<xref:System.Reflection.BindingFlags>検索に含める入れ子になったを定義するフラグを使用できるフィルターの種類します。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`非パブリック プロパティ \(つまり、プライベート、内部、および保護されたプロパティ\) を検索に含めます。 のみ保護され、基本クラスの内部プロパティが返されます。基本クラスのプライベート プロパティは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly`宣言されたプロパティのみを検索する、 <xref:System.Type>、継承されたプロパティされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
   
  
## 例  
 次の例は、という名前のクラスを定義`PropertyClass`6 つのプロパティを含む: 2 つはパブリック、1 つは、プライベート、いずれかが保護されている、1 つは内部 \(`Friend` Visual Basic で\)、いずれかが保護されている内部および \(`Protected Friend` Visual Basic で\)。 いくつかの基本的なプロパティの情報を表示します \(プロパティの名前と種類、かどうかは読み取り\/書き込み、およびの可視性、`get`と`set`アクセサー\) の指定したバインディング制約に一致するプロパティです。  
  
 [!code-cpp[Type\_GetProperties2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type\_GetProperties2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type\_GetProperties2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック プロパティを検索します。</summary>
        <returns>指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス プロパティが含まれています。  
  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドはクラス制約のプロパティを検索します。  
  
 場合に、<xref:System.Reflection.AmbiguousMatchException>が発生した、次のとおりです。  
  
-   型には 2 つが同じであるインデックス付きプロパティの名前が異なる数のパラメーターです。 あいまいさを解決するには、オーバー ロードを使用して、<xref:System.Type.GetProperty%2A>パラメーターの型を指定するメソッド。  
  
-   派生型を使用して、同じ名前を持つ継承されたプロパティを非表示にするプロパティを宣言する、`new`修飾子 \(`Shadows` Visual Basic で\)。 あいまいさを解決するを使用して、<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29>メソッドのオーバー ロードを追加、<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=fullName>継承されていないメンバーに、検索を制限するフラグ。  
  
## インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]` \(`myList(3)` Visual Basic で\) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C\# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c\# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C\# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>テストするためのメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティは、既定のプロパティの名前を返します。  
  
   
  
## 例  
 次の例では、取得、`Type`ユーザー定義のクラスのオブジェクトが、そのクラスのプロパティを取得し、プロパティ名を表示します。  
  
 [!code-cpp[Type\_GetProperty1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type\_GetProperty1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type\_GetProperty1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 内部的には、このプロパティは、メタデータ内で参照名「項目」 取得しようとすると`PropertyInfo`リフレクションを使用して正しくを返すためにこの内部名を指定する必要があります、`PropertyInfo`プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のプロパティが複数個見つかりました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>指定されたバインディング制約を使用して、指定されたプロパティを検索します。</summary>
        <returns>存在する場合は、指定した要件と一致するプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるプロパティを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`非パブリック プロパティ \(つまり、プライベート、内部、および保護されたプロパティ\) を検索に含めます。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたプロパティのみを検索する、 <xref:System.Type>、継承されたプロパティされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
 場合に、<xref:System.Reflection.AmbiguousMatchException>が発生した、次のとおりです。  
  
-   型には 2 つが同じであるインデックス付きプロパティの名前が異なる数のパラメーターです。 あいまいさを解決するには、オーバー ロードを使用して、<xref:System.Type.GetProperty%2A>パラメーターの型を指定するメソッド。  
  
-   派生型が、同じ名前を持つ継承されたプロパティを非表示にするプロパティを宣言を使用して、`new`修飾子 \(`Shadows` Visual Basic で\)。 あいまいさを解決するには、含める<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=fullName>継承されていないメンバーへの検索を制限します。  
  
## インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]` \(`myList(3)` Visual Basic で\) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C\# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c\# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C\# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## 例  
 次の例は、ユーザー定義のクラスの型を取得、そのクラスのプロパティを取得し、指定したバインディング制約に一致するプロパティ名を表示します。  
  
 [!code-cpp[Type\_GetProperty2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type\_GetProperty2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type\_GetProperty2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 1 つ以上のプロパティが存在します。 「解説」を参照してください。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <summary>指定した名前および戻り値の型を持つパブリック プロパティを検索します。</summary>
        <returns>指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス プロパティが含まれています。  
  
 場合、現在<xref:System.Type>、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]` \(`myList(3)` Visual Basic で\) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C\# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c\# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C\# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## 例  
 次の例では、1 つのプロパティを持つクラスを定義し、名前およびプロパティの型を取得します。  
  
 [!code-cpp[Type\_GetProperty\_Types\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type\_GetProperty\_Types\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type\_GetProperty\_Types\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のプロパティが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> であるか、または <paramref name="returnType" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 \(Type\[\] types \= new Type\[0\]\)。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス プロパティが含まれています。  
  
 場合、現在<xref:System.Type>、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]` \(`myList(3)` Visual Basic で\) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C\# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c\# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C\# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## 例  
 次の例では取得、`Type`ユーザー定義のクラスのオブジェクトが、そのクラスのプロパティを取得しに渡される引数で指定されたプロパティの名前とプロパティの型が表示されます`GetProperty`です。  
  
 [!code-cpp[Type\_GetProperty3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type\_GetProperty3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type\_GetProperty3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 \(Type\[\] types \= new Type\[0\]\)。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 検索する`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス プロパティが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]` \(`myList(3)` Visual Basic で\) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C\# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c\# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C\# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 \(Type\[\] types \= new Type\[0\]\)。</param>
        <param name="modifiers">
          <c>types</c> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります[GetProperty メソッド \(String, Type, Type\<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;[GetProperty メソッド \(String, Type, Type\<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;[GetProperty メソッド \(String, Type, Type\<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 既定のバインダーが処理されませんが[GetProperty メソッド \(String, Type, Type\<xref:System.Reflection.ParameterModifier>\(、`modifiers`パラメーター\)、abstract を使用することができます[GetProperty メソッド \(String, Type, Type\<xref:System.Reflection.Binder?displayProperty=fullName>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。`ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス プロパティが含まれています。  
  
 場合、現在[GetProperty メソッド \(String, Type, Type\<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、[GetProperty メソッド \(String, Type, Type\<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在[GetProperty メソッド \(String, Type, Type\<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 [GetProperty メソッド \(String, Type, Type\<xref:System.Collections.ArrayList>、構文`myList[3]` \(`myList(3)` Visual Basic で\) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C\# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c\# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、クラス ライブラリの開発者が使用して、[GetProperty メソッド \(String, Type, Type\<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、[GetProperty メソッド \(String, Type, Type\<xref:System.String>クラスという名前のインデクサーには、[GetProperty メソッド \(String, Type, Type\<xref:System.String.Chars%2A>です。 C\# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには[GetProperty メソッド \(String, Type, Type\<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、[GetProperty メソッド \(String, Type, Type\<xref:System.Reflection.DefaultMemberAttribute>属性。 型が[GetProperty メソッド \(String, Type, Type\<xref:System.Reflection.DefaultMemberAttribute>、[GetProperty メソッド \(String, Type, Type\<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## 例  
 次の例では取得、`Type`オブジェクトに対応する`MyPropertyClass`に渡される引数を使用して、このクラスのインデックス付きプロパティを取得し、`GetProperty`メソッドです。  
  
 [!code-cpp[Type\_GetProperty5\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type\_GetProperty5\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type\_GetProperty5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定された引数の型および修飾子に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 \-または\-  
  
 <see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see langword="Nothing" />\)。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 \(Type\[\] types \= new Type\[0\]\)。</param>
        <param name="modifiers">
          <c>types</c> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーは、このパラメーターを処理しません。</param>
        <summary>指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定された指定のプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=fullName>&#124;[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.BindingFlags.Instance?displayProperty=fullName> &#124;[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.BindingFlags.Static?displayProperty=fullName> \(Visual basic での結合を使用して値`Or`\) それを取得します。  
  
 既定のバインダーが処理されませんが[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.ParameterModifier>\(、`modifiers`パラメーター\)、abstract を使用することができます[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.Binder?displayProperty=fullName>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。`ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想の両方\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.BindingFlags>検索に含めるプロパティを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`非パブリック プロパティ \(つまり、プライベート、内部、および保護されたプロパティ\) を検索に含めます。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたプロパティのみを検索する、 [GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Type>、継承されたプロパティされません。  
  
 詳細については、「[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 場合、現在[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 [GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Collections.ArrayList>、構文`myList[3]` \(`myList(3)` Visual Basic で\) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C\# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c\# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.String>クラスという名前のインデクサーには、[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.String.Chars%2A>です。 C\# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>テストするためのメソッド、[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.DefaultMemberAttribute>属性。 型が[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.DefaultMemberAttribute>、[GetProperty メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 \-または\-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメンバーの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 または  
  
 <see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see langword="Nothing" />\)。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 \(Type\[\] types \= new Type\[0\]\)。</param>
        <param name="modifiers">
          <c>types</c> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーは、このパラメーターを処理しません。</param>
        <summary>派生クラス内でオーバーライドされるときに、指定のバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されたプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のバインダーが処理されませんが [GetPropertyImpl メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.ParameterModifier> \(、 `modifiers` パラメーター\)、抽象を使用することができます [GetPropertyImpl メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.Binder?displayProperty=fullName> クラスが、処理するカスタム バインダーを記述する `modifiers`です。`ParameterModifier` COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターだけが処理されます。  
  
 次 [GetPropertyImpl メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.BindingFlags> フィルター フラグを使用するには、検索に含めるには、どのプロパティを定義します。  
  
-   どちらかを指定する必要があります `BindingFlags.Instance` または `BindingFlags.Static` 戻り値を取得するためにします。  
  
-   指定 `BindingFlags.Public` 、検索にパブリック プロパティを含める。  
  
-   指定 `BindingFlags.NonPublic` 非パブリック プロパティ \(つまり、プライベート、内部、および保護されているプロパティ\) を検索に含めます。  
  
-   指定 `BindingFlags.FlattenHierarchy` に含める `public` と `protected` 上位階層の静的メンバー `private` 継承するクラスで静的メンバーは含まれません。  
  
 次 [GetPropertyImpl メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.BindingFlags> 修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 小文字を区別しない `name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたプロパティのみを検索する、 [GetPropertyImpl メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Type>, 、継承されたプロパティされません。  
  
 詳細については、「[GetPropertyImpl メソッド \(String, BindingFlags, Binder, Type, Type\<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" />、または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>現在の <see cref="T:System.Type" /> です。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 「<see cref="P:System.Type.AssemblyQualifiedName" />」を参照してください。 型が現在実行中のアセンブリまたは Mscorlib.dll 内にある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <summary>大文字小文字を区別する検索を実行して、指定された名前の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>存在する場合は、指定された名前を持つ型。それ以外の場合には <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することができます、 <xref:System.Type.GetType%2A> を入手する方法、 <xref:System.Type> 名前空間で修飾された名前がわかっている場合は、別のアセンブリ内の型のオブジェクトします。<xref:System.Type.GetType%2A> 指定されたアセンブリの読み込みを発生させます `typeName`します。 使用してアセンブリを読み込むことも、 <xref:System.Reflection.Assembly.Load%2A> メソッド、およびその後で使用、 <xref:System.Type.GetType%2A> または <xref:System.Reflection.Assembly.GetTypes%2A> のメソッド、 <xref:System.Reflection.Assembly> クラスに <xref:System.Type> オブジェクトです。 C\# の場合は、使用する方が効率的では、型がコンパイル時に、プログラムに認識されているアセンブリ内にある場合は、 <xref:System.Type.GetType%2A> Visual Basic、または C\+\+ です。  
  
> [!NOTE]
>  場合 `typeName` が見つからないことを呼び出し、 <xref:System.Type.GetType%28System.String%29> メソッドが返す `null`します。 例外はスローされません。 オーバー ロードを呼び出す必要を制御するかどうか、例外がスローされますが、 <xref:System.Type.GetType%2A> メソッドを持つ、 `throwOnError` パラメーター。  
  
 <xref:System.Type.GetType%2A>GetType は、ディスクから読み込まれるアセンブリでのみ機能します。 呼び出した場合 <xref:System.Type.GetType%2A> を使用して定義されている動的アセンブリで定義された型を検索する、 <xref:System.Reflection.Emit> サービス、一貫性のない動作を取得する可能性があります。 動的アセンブリが異なります永続的を使用して作成、動作、 `RunAndSave` または `Save` アクセスのモード、 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> 列挙します。 動的アセンブリは永続性であり、前にディスクに書き込まれたかどうか `GetType` が呼び出されると、ローダーはディスク上、保存されたアセンブリを検索、そのアセンブリが読み込まれるおよびそのアセンブリから型を取得します。 アセンブリがディスクに保存されていない場合 `GetType` と呼ばれる、メソッドが戻る `null`します。`GetType` 一時動的アセンブリ; を認識しませんそのため、 `GetType` 動的アセンブリを返す一時的に型を取得するのには `null`です。  
  
 使用する `GetType` 動的モジュールでは、サブスクライブできるようにする、 <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> イベントと呼び出し `GetType` 保存する前にします。 それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。  
  
 次の表は返される基本クラスのメンバー、 `Get` メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによる隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャによる隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想\) のメソッドは、名前による隠ぺいまたは名前と署名によって非表示にできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャによる隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる隠ぺいは、型、パラメーターの型、sentinel、およびアンマネージ呼び出し規約を返すすべてのカスタム修飾子を含む、シグネチャの一部と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによる隠ぺいします。 基底クラスで get と set アクセサーの両方でプロパティがある場合は、派生クラスには、get アクセサーだけ派生クラスのプロパティには、基本クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は検索されませんの利用可能なクラスのテーブルに読み込まれていない限り。  
  
 `typeName` 型名で修飾できます、名前空間またはアセンブリ修飾名はアセンブリ名の指定が含まれています。 「<xref:System.Type.AssemblyQualifiedName%2A>」を参照してください。  
  
 場合 `typeName` 名前空間は、アセンブリ名ではなく、このメソッドはこの順序で呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll だけを検索します。 型名は、部分的または完全なアセンブリ名を持つ完全に修飾されている場合、このメソッドは、指定したアセンブリで検索します。 アセンブリに厳密な名前がある場合は、アセンブリの完全名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A> プロパティは、入れ子にされた型、アセンブリ名、およびジェネリック型引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラは入れ子になったクラスの簡易名を出力し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id が追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture \= msil"です。 ただし、いないに含まれているによって返される文字列、 <xref:System.Type.AssemblyQualifiedName%2A> 互換性のためのプロパティです。 作成することで、型を読み込むことも、 <xref:System.Reflection.AssemblyName> オブジェクトとの適切なオーバー ロードに渡す、 <xref:System.Reflection.Assembly.Load%2A> メソッドです。 使用して、 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> アセンブリから型を読み込むにはメソッドです。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>」も参照してください。  
  
|区切り記号|説明|  
|-----------|--------|  
|円記号 \(\\\)|文字をエスケープします。|  
|バックティック \('\)|ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字を先頭に付きます。|  
|角かっこ \(\)|構築されたジェネリック型のジェネリック型引数リストを囲む型の引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ \(,\)|アセンブリ名の前にします。|  
|ピリオド \(.\)|名前空間の識別子を表します。|  
|プラス記号 \(\+\)|入れ子になったクラスを前に付きます。|  
  
 たとえば、クラスの完全修飾名は、次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 場合、名前空間 TopNamespace.Sub\+Namespace、し、文字列必要がありますプラス記号 \(\+\) の前に入れ子の区切り記号として解釈されないようにエスケープ文字 \(\\\) です。 リフレクションでは、次のようにこの文字列を生成します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A"では"が"\\ \+ \\ \+"、および「\\」「\\\\」になります。  
  
 この修飾名を保存および読み込みに使用された後で、 <xref:System.Type>です。 検索して読み込む、 <xref:System.Type>, を使用して <xref:System.Type.GetType%2A> のみ、またはアセンブリ修飾型名を持つという名前を型のいずれかです。<xref:System.Type.GetType%2A> 型と名前のみが探します、 <xref:System.Type> 、呼び出し元のアセンブリにおよび、システム アセンブリです。<xref:System.Type.GetType%2A> アセンブリ修飾型名は探します、 <xref:System.Type> 任意のアセンブリにします。  
  
 型名の末尾の文字を表すかどうか、型が参照型、ポインター型または配列型など、種類に関する追加情報があります。 このような末尾の文字型の名前を取得する `t.GetElementType().ToString()`, ここで、 `t` 型です。  
  
 スペースは、アセンブリ名を除くすべての型名コンポーネントに関連します。 アセンブリ名に ',' 区切り記号の前に空白は意味が、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、後のジェネリック型引数の数を表す数字が続くバックティック \('\) で終わります。 名前の完全修飾の目的は、ジェネリック型と同じ名前が、型パラメーターの数値が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可するようにです。 たとえば、リフレクションが完全修飾名を返します `Tuple`1` と `Tuple`2` ジェネリック メソッドから `Tuple(Of T)` と `Tuple(Of T0, T1)` Visual basic でまたは `Tuple<T>` および組`<T0, T1>` Visual C\# の場合。  
  
 ジェネリック型の型の引数リストは、角かっこで囲まれ、型引数がコンマで区切られます。 たとえば、ジェネリック <xref:System.Collections.Generic.Dictionary%602> は 2 つの型パラメーターがあります。 A <xref:System.Collections.Generic.Dictionary%602> の `MyType` 型のキーを持つ <xref:System.String> 次のように表される可能性があります。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型の引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。 それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切るとして解釈されます。 たとえば、 <xref:System.Collections.Generic.Dictionary%602> の `MyType` から型のキーを持つ、MyAssembly.dll <xref:System.String>, 、次のように指定することがあります。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  型パラメーター リスト内に表示されるときにのみ、アセンブリ修飾の型をかっこで囲むことができます。 型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するためのルールは、修飾および非修飾の非ジェネリック型の場合と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 値を許容 <xref:System.Int32> "System.Nullable'1\[System.Int32\]"の文字列として表されます。  
  
> [!NOTE]
>  C\#、C\+\+、および Visual Basic で、型の演算子を使用して null 許容型を取得することもできます。 たとえば、null 許容 <xref:System.Boolean> から返された型 `typeof(Nullable<bool>)` 、C\# の場合は、によって `Nullable<Boolean>::typeid` C\+\+ では、および `GetType(Nullable(Of Boolean))` Visual Basic でします。  
  
 次の表で使用する構文 `GetType` さまざまな種類です。  
  
|取得するには|用途|  
|------------|--------|  
|Null 許容型 <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|アンマネージ ポインター `MyType`|`Type.GetType("MyType*")`|  
|ポインターへのアンマネージ ポインター `MyType`|`Type.GetType("MyType**")`|  
|マネージ ポインターまたはへの参照 `MyType`|`Type.GetType("MyType&")`。 ポインターとは異なりを参照は、1 つのレベルに制限します。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限を 0 と 1 次元配列|`Type.GetType("MyType[]")`|  
|不明な下限を持つ 1 次元配列|`Type.GetType("MyType[*]")`|  
|N 次元の配列|合計 n\-1 回角かっこ内のコンマ \(,\) です。 たとえば、 `System.Object[,,]` 、3 次元を表す `Object` 配列。|  
|1 次元配列の配列|`Type.GetType("MyType[][]")`|  
|下限が不明の四角形の 2 次元配列|`Type.GetType("MyType[,]")`|  
|1 つの型引数を持つジェネリック型|`Type.GetType("MyGenericType`1[MyType]")`|  
|2 つの型引数を持つジェネリック型|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|2 つのアセンブリ修飾型引数を持つジェネリック型|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|アセンブリ修飾型引数を持つアセンブリ修飾のジェネリック型|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|型引数が 2 つの型引数を持つジェネリック型のジェネリック型|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## 例  
 次の例の種類を取得する `System.Int32` し、その型のオブジェクトを使用して、表示、 <xref:System.Type.FullName%2A> の `System.Int32`です。  
  
 [!code-cpp[Type\_GetType\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type\_GetType\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type\_GetType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
 \-または\-  
  
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
 \-または\-  
  
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">  
<para>  
 [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154), 、基本クラスの例外をキャッチ <see cref="T:System.IO.IOException" />, 、代わりにします。  
  
</para>  
</block>  
  
 アセンブリ、またはその依存関係のうちの 1 つは見つかりましたが、読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 \-または\-  
  
 共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 「<see cref="P:System.Type.AssemblyQualifiedName" />」を参照してください。 型が現在実行されているアセンブリ内または Mscorlib.dll にある場合は、名前空間で修飾された型名を提供するだけで十分です。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <summary>大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace\-qualified name. <xref:System.Type.GetType%2A> causes loading of the assembly specified in **parameterReference tag is not supported!!!!**  
. You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use **languageKeyword tag is not supported!!!!**  
 in C\#, <xref:System.Type.GetType%2A> in Visual Basic, or **languageKeyword tag is not supported!!!!**  
 in C\+\+.  
  
 `GetType` only works on assemblies loaded from disk. If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration. If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when `GetType` is called, the method returns `null`. `GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.  
  
 To use **languageKeyword tag is not supported!!!!**  
 on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call **languageKeyword tag is not supported!!!!**  
 before saving. Otherwise, you will get two copies of the assembly in memory.  
  
 The **parameterReference tag is not supported!!!!**  
 parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of **parameterReference tag is not supported!!!!**  
. For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
.  
  
 The following table shows what members of a base class are returned by the **languageKeyword tag is not supported!!!!**  
 methods when reflecting on a type.  
  
|Member Type|Static|Non\-Static|  
|-----------------|------------|-----------------|  
|Constructor|No|No|  
|Field|No|Yes. A field is always hide\-by\-name\-and\-signature.|  
|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide\-by\-name\-and\-signature. See note 2 below.|  
|Method|No|Yes. A method \(both virtual and non\-virtual\) can be hide\-by\-name or hide\-by\-name\-and\-signature.|  
|Nested Type|No|No|  
|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide\-by\-name\-and\-signature. See note 2 below.|  
  
1.  Hide\-by\-name\-and\-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  
  
2.  For reflection, properties and events are hide\-by\-name\-and\-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  
  
3.  Custom attributes are not part of the common type system.  
  
 Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.  
  
 `typeName` can be the type name qualified by its namespace or an assembly\-qualified name that includes an assembly name specification. See <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 If **parameterReference tag is not supported!!!!**  
 includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.  
  
 The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  
  
> [!NOTE]
>  In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, "ProcessorArchitecture\=msil". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.  
  
|Delimiter|Meaning|  
|---------------|-------------|  
|Backslash \(\\\)|Escape character.|  
|Backtick \(\`\)|Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.|  
|Brackets \(\[\]\)|Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly\-qualified type.|  
|Comma \(,\)|Precedes the Assembly name.|  
|Period \(.\)|Denotes namespace identifiers.|  
|Plus sign \(\+\)|Precedes a nested class.|  
  
 For example, the fully qualified name for a class might look like this:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 If the namespace were TopNamespace.Sub\+Namespace, then the string would have to precede the plus sign \(\+\) with an escape character \(\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "\+\+" becomes "\\\+\\\+", and a "\\" becomes "\\\\".  
  
 This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  
  
 Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where **parameterReference tag is not supported!!!!**  
 is the type.  
  
 Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.  
  
 The name of a generic type ends with a backtick \(\`\) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C\#.  
  
 For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters. A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 To specify an assembly\-qualified type within a type argument list, enclose the assembly\-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly\-qualified name are interpreted as delimiting additional type arguments. For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  An assembly\-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.  
  
 Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1\[System.Int32\]".  
  
> [!NOTE]
>  In C\#, C\+\+, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C\#, by `Nullable<Boolean>::typeid` in C\+\+, and by `GetType(Nullable(Of Boolean))` in Visual Basic.  
  
 The following table shows the syntax you use with **languageKeyword tag is not supported!!!!**  
 for various types.  
  
|To Get|Use|  
|------------|---------|  
|A nullable <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|An unmanaged pointer to `MyType`|`Type.GetType("MyType*")`|  
|An unmanaged pointer to a pointer to `MyType`|`Type.GetType("MyType**")`|  
|A managed pointer or reference to `MyType`|`Type.GetType("MyType&")`. Note that unlike pointers, references are limited to one level.|  
|A parent class and a nested class|`Type.GetType("MyParentClass+MyNestedClass")`|  
|A one\-dimensional array with a lower bound of 0|`Type.GetType("MyArray[]")`|  
|A one\-dimensional array with an unknown lower bound|`Type.GetType("MyArray[*]")`|  
|An n\-dimensional array|A comma \(,\) inside the brackets a total of n\-1 times. For example, `System.Object[,,]` represents a three\-dimensional **languageKeyword tag is not supported!!!!**<br /> array.|  
|A two\-dimensional array's array|`Type.GetType("MyArray[][]")`|  
|A rectangular two\-dimensional array with unknown lower bounds|`Type.GetType("MyArray[,]")`|  
|A generic type with one type argument|`Type.GetType("MyGenericType`1[MyType]")`|  
|A generic type with two type arguments|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|A generic type with two assembly\-qualified type arguments|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|An assembly\-qualified generic type with an assembly\-qualified type argument|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|A generic type whose type argument is a generic type with two type arguments|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## 例  
 The following example retrieves the type of **languageKeyword tag is not supported!!!!**  
 and uses that type object to display the <xref:System.Type.FullName%2A> property of **languageKeyword tag is not supported!!!!**  
. If a type object refers to an assembly that does not exist, this example throws an exception.  
  
 [!code-cpp[Type\_GetType\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type\_GetType\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type\_GetType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
 または  
  
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> が <see langword="true" /> で、<paramref name="typeName" /> に正しくない構文が含まれています。 例: "MyType\[,\*,\]"。  
  
 または  
  
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
 \-または\-  
  
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
 \-または\-  
  
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">  
<para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154)では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>  
</block>  
  
 アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 \-または\-  
  
 共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 「<see cref="P:System.Type.AssemblyQualifiedName" />」を参照してください。 型が現在実行されているアセンブリ内または Mscorlib.dll にある場合は、名前空間で修飾された型名を提供するだけで十分です。</param>
        <param name="throwOnError">型が見つからないときに例外をスローする場合は <see langword="true" />。<see langword="null" /> を返す場合は <see langword="false" />。<see langword="false" /> を指定すると、他の一部の例外条件も抑制されることがあります。 「例外」をご覧ください。</param>
        <param name="ignoreCase">大文字と小文字を区別せずに <see langword="true" /> の検索を実行するには <c>typeName</c>。大文字と小文字を区別して <see langword="false" /> の検索を実行するには <c>typeName</c>。</param>
        <summary>指定した名前を持つ <see cref="T:System.Type" /> を取得します。型が見つからない場合に例外をスローするかどうかと、大文字と小文字を区別する検索を実行するかどうかも指定します。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することができます、<xref:System.Type.GetType%2A>を取得するメソッド、<xref:System.Type>わかっている場合、その名前空間で修飾された名前に、別のアセンブリ内の型のオブジェクトします。<xref:System.Type.GetType%2A>指定されたアセンブリの読み込みを発生させます`typeName`です。 使用してアセンブリを読み込むことも、<xref:System.Reflection.Assembly.Load%2A>メソッド、およびしを使用して、<xref:System.Type.GetType%2A>または<xref:System.Reflection.Assembly.GetTypes%2A>のメソッド、<xref:System.Reflection.Assembly>クラスを取得する<xref:System.Type>オブジェクト。 使用する方が効率的では、型がコンパイル時に、プログラムを既知のアセンブリ内にある場合は、 `typeof` 、C\# の場合は、 <xref:System.Type.GetType%2A> Visual basic、または`typeid`C\+\+ でします。  
  
 `GetType`ディスクから読み込まれるアセンブリでのみ機能します。 呼び出す場合`GetType`を使用して定義された動的アセンブリで定義された型を検索する、 <xref:System.Reflection.Emit> services, 一貫性のない動作を取得する可能性があります。 動作するかどうか、動的はアセンブリが、永続的なによって異なりますを使用して作成、`RunAndSave`または`Save`アクセスのモード、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName>列挙します。 かどうか、動的アセンブリが永続的なとが前にディスクに書き込まれた`GetType`が呼び出されると、ローダー ディスク上の保存されたアセンブリを検索、そのアセンブリが読み込まれ、そのアセンブリから型を取得します。 アセンブリがディスクに保存されていない場合`GetType`が呼び出されると、このメソッドを返します`null`です。`GetType`一時動的アセンブリ; は理解していませんそのため、`GetType`動的アセンブリを返しますを一時的に型を取得する`null`です。  
  
 使用する`GetType`動的モジュールをサブスクライブ、<xref:System.AppDomain.AssemblyResolve?displayProperty=fullName>イベントと呼び出し`GetType`保存する前に。 それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。  
  
 `throwOnError`パラメーターは、例外セクションで説明した型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。 値に関係なく一部の例外がスローされた`throwOnError`です。 たとえば、種類が見つかりましたが、アンロードすることはできません、<xref:System.TypeLoadException>スローされる場合でも`throwOnError`は`false`します。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|------------|------------|--------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 \(仮想および非仮想の両方\) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は検索されませんの使用可能なクラスのテーブルに読み込まれていない限り、します。  
  
 `typeName`型名で修飾できます、名前空間またはアセンブリ修飾名はアセンブリ名の指定が含まれています。 「<xref:System.Type.AssemblyQualifiedName%2A>」を参照してください。  
  
 場合`typeName`には、名前空間が、アセンブリ名ではなく、このメソッドは、呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll のみがこの順序で検索します。 TypeName は、部分的または完全なアセンブリ名を持つ完全に修飾されている場合、このメソッドは、指定したアセンブリで検索します。 アセンブリの厳密な名前が、アセンブリの完全名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>プロパティは入れ子にされた型、アセンブリ名と型引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラは入れ子になったクラスの簡易名を出力し、リフレクションは次の規則に従って、照会されたときに、完全修飾名。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture \= msil"です。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Type.AssemblyQualifiedName%2A>互換性のためのプロパティです。 作成することで、型を読み込むことも、<xref:System.Reflection.AssemblyName>オブジェクトとの適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッドです。 使用してできます、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>アセンブリから型のメソッドを読み込めません。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>」も参照してください。  
  
|区切り記号|説明|  
|-----------|--------|  
|円記号 \(\\\)|文字をエスケープします。|  
|バッククォート \('\)|ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字を先頭に付きます。|  
|角かっこ \(\)|構築されたジェネリック型のジェネリック型引数リストを囲む型引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ \(,\)|アセンブリ名の前にします。|  
|ピリオド \(.\)|名前空間の識別子を表します。|  
|プラス記号 \(\+\)|入れ子になったクラスが前に付きます。|  
  
 たとえば、クラスの完全修飾名は、次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 場合、名前空間 TopNamespace.Sub\+Namespace、文字列必要がありますプラス記号 \(\+\) の前に、エスケープ文字 \(\\\) を入れ子の区切り記号として解釈されるを防ぐためにします。 リフレクションでは、次のようにこの文字列を生成します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A"\+ \+"になります"\\ \+ \\ \+"、および「\\」「\\\\」になります。  
  
 この修飾名を永続化し、読み込みに使用された後で、<xref:System.Type>です。 検索して読み込む、<xref:System.Type>を使用して<xref:System.Type.GetType%2A>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。<xref:System.Type.GetType%2A>型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリにし、システム アセンブリです。<xref:System.Type.GetType%2A>アセンブリ修飾型名は探します、<xref:System.Type>任意のアセンブリにします。  
  
 型名には、型は、参照型、ポインター型または配列型かどうかの種類に関する追加情報を示す後続の文字が含まれます。 このような末尾の文字型の名前を取得する`t.GetElementType().ToString()`ここで、`t`型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名に ',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、ジェネリック型引数の数を表す桁の数字の後にあるバックティック \('\) で終わります。 この名前のマングルの目的は、ジェネリック型と同じ名前が、型パラメーターの数値が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可します。 たとえば、リフレクションは完全修飾名を返します`Tuple`1`と`Tuple`2`ジェネリック メソッドから`Tuple(Of T)`と`Tuple(Of T0, T1)`Visual basic でまたは `Tuple<T>`と組`<T0, T1>` Visual C\# の場合。  
  
 ジェネリック型の型引数リストが角かっこで囲まれているし、型引数がコンマで区切られます。 たとえば、ジェネリック<xref:System.Collections.Generic.Dictionary%602>2 つの型パラメーターです。 A<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ<xref:System.String>次のように表される可能性があります。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。 それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切るとして解釈されます。 たとえば、<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ、MyAssembly.dll から<xref:System.String>、次のように指定する場合があります。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  アセンブリ修飾の型は、型パラメーター リスト内に表示されるときにのみに角かっこで囲むことができます。 型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するための規則は、修飾および非修飾の非ジェネリック型の規則と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 許容<xref:System.Int32>"System.Nullable'1\[System.Int32\]"の文字列として表されます。  
  
> [!NOTE]
>  C\#、C\+\+、および Visual Basic で、型の演算子を使用して、null 許容型を取得することもできます。 たとえば、null 値を許容<xref:System.Boolean>によって型が返される`typeof(Nullable<bool>)`、C\# の場合は、によって`Nullable<Boolean>::typeid`C\+\+ では、および`GetType(Nullable(Of Boolean))`Visual Basic でします。  
  
 次の表で使用する構文を示しています。`GetType`さまざまな種類です。  
  
|取得するには|用途|  
|------------|--------|  
|Null 許容型<xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|アンマネージ ポインター`MyType`|`Type.GetType("MyType*")`|  
|ポインターへのアンマネージ ポインター`MyType`|`Type.GetType("MyType**")`|  
|マネージ ポインターまたは参照先`MyType`|`Type.GetType("MyType&")`。 ポインターとは異なりことに注意して、参照は 1 つのレベルに制限されます。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限を 0 と 1 次元配列|`Type.GetType("MyArray[]")`|  
|不明な下限を持つ 1 次元配列|`Type.GetType("MyArray[*]")`|  
|N 次元の配列|合計 n\-1 回角かっこ内のコンマ \(,\) です。 たとえば、 `System.Object[,,]` 、3 次元を表す`Object`配列。|  
|2 次元配列の配列|`Type.GetType("MyArray[][]")`|  
|不明な下限四角形の 2 次元配列|`Type.GetType("MyArray[,]")`|  
|1 つの型引数を持つジェネリック型|`Type.GetType("MyGenericType`1[MyType]")`|  
|2 つの型引数を持つジェネリック型|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|2 つのアセンブリ修飾型引数を持つジェネリック型|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|アセンブリ修飾型引数を持つアセンブリ修飾の汎用型|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|型引数が 2 つの型引数を持つジェネリック型のジェネリック型|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。埋め込まれたタブなどの正しくない文字が <paramref name="typeName" /> に含まれています。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は正しくないサイズの配列型を表します。  
  
 または  
  
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> が <see langword="true" /> で、<paramref name="typeName" /> に正しくない構文が含まれています。 例: "MyType\[,\*,\]"。  
  
 または  
  
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
 \-または\-  
  
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
 \-または\-  
  
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリ、またはその依存関係のうちの 1 つは見つかりましたが、読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 \-または\-  
  
 共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。<c>typeResolver</c> パラメーターを指定する場合は、<c>typeResolver</c> が解決できる任意の文字列を型名として使用できます。<c>assemblyResolver</c> パラメーターを指定する場合、または標準の型解決を使用する場合は、<c>typeName</c> をアセンブリ修飾名にする必要があります \(<see cref="P:System.Type.AssemblyQualifiedName" />を参照\)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="assemblyResolver">で指定されたアセンブリを特定して返すメソッド。<c>typeName</c>.<c>assemblyResolver</c> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。<c>typeName</c> にアセンブリの名前が含まれていない場合、<c>assemblyResolver</c> は呼び出されません。<c>assemblyResolver</c> を指定しない場合は、標準のアセンブリ解決が実行されます。  
  
 注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver">
          <c>typeName</c> で指定された型を、<c>assemblyResolver</c> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。 アセンブリが指定されていない場合は、<c>typeResolver</c> メソッドで指定できます。 このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <see langword="false" /> が渡されます。  
  
 注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</param>
        <summary>指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定された名前の型。型が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの詳細な使用シナリオ、`assemblyResolver`と`typeResolver`パラメーターは含まれて、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  場合`typeName`が見つからないことを呼び出し、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>メソッドを返します。`null`です。 例外はスローされません。 制御するかどうか、例外がスローされますのオーバー ロードを呼び出して、<xref:System.Type.GetType%2A>メソッドが、`throwOnError`パラメーター。  
  
 呼び出した場合と同じではこのメソッドのオーバー ロードを呼び出して、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードを指定して`false`の`throwOnError`と`ignoreCase`パラメーター。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> が型名とアセンブリ名に解析された際にエラーが発生します \(たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など\)。  
  
 または  
  
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
 \-または\-  
  
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
 \-または\-  
  
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリ、またはその依存関係のうちの 1 つが見つかったが、読み込めませんでした。  
  
 または  
  
 <paramref name="typeName" /> に無効なアセンブリ名が含まれています。  
  
 または  
  
 <paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリ、またはその依存関係のうちの 1 つが無効です。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。<c>typeResolver</c> パラメーターを指定する場合は、<c>typeResolver</c> が解決できる任意の文字列を型名として使用できます。<c>assemblyResolver</c> パラメーターを指定する場合、または標準の型解決を使用する場合は、<c>typeName</c> をアセンブリ修飾名にする必要があります \(<see cref="P:System.Type.AssemblyQualifiedName" />を参照\)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="assemblyResolver">で指定されたアセンブリを特定して返すメソッド。<c>typeName</c>.<c>assemblyResolver</c> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。<c>typeName</c> にアセンブリの名前が含まれていない場合、<c>assemblyResolver</c> は呼び出されません。<c>assemblyResolver</c> を指定しない場合は、標準のアセンブリ解決が実行されます。  
  
 注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver">
          <c>typeName</c> で指定された型を、<c>assemblyResolver</c> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。 アセンブリが指定されていない場合は、このメソッドで指定できます。 このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <see langword="false" /> が渡されます。  
  
 注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <summary>型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの詳細な使用シナリオ、`assemblyResolver`と`typeResolver`パラメーターは含まれて、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
 このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードを指定して`false`の`ignoreCase`パラメーター。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。埋め込まれたタブなどの正しくない文字が <paramref name="typeName" /> に含まれています。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は正しくないサイズの配列型を表します。  
  
 または  
  
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> が型名とアセンブリ名に解析される際にエラーが発生します \(たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など\)。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に無効な構文 \("MyType\[,\*,\]" など\) が含まれています。  
  
 または  
  
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
 \-または\-  
  
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
 \-または\-  
  
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。ファイル、またはその依存関係のうちの 1 つが見つかりませんでした。  
  
 または  
  
 <paramref name="typeName" /> に無効なアセンブリ名が含まれています。  
  
 または  
  
 <paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリ、またはその依存関係のうちの 1 つが見つかったが、読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。<c>typeResolver</c> パラメーターを指定する場合は、<c>typeResolver</c> が解決できる任意の文字列を型名として使用できます。<c>assemblyResolver</c> パラメーターを指定する場合、または標準の型解決を使用する場合は、<c>typeName</c> をアセンブリ修飾名にする必要があります \(<see cref="P:System.Type.AssemblyQualifiedName" />を参照\)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="assemblyResolver">で指定されたアセンブリを特定して返すメソッド。<c>typeName</c>.<c>assemblyResolver</c> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。<c>typeName</c> にアセンブリの名前が含まれていない場合、<c>assemblyResolver</c> は呼び出されません。<c>assemblyResolver</c> を指定しない場合は、標準のアセンブリ解決が実行されます。  
  
 注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver">
          <c>typeName</c> で指定された型を、<c>assemblyResolver</c> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。 アセンブリが指定されていない場合は、このメソッドで指定できます。 このメソッドは、大文字小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには、<c>ignoreCase</c> の値が渡されます。  
  
 注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <param name="ignoreCase">大文字と小文字を区別せずに <see langword="true" /> の検索を実行するには <c>typeName</c>。大文字と小文字を区別して <see langword="false" /> の検索を実行するには <c>typeName</c>。</param>
        <summary>大文字と小文字を区別せずに検索を実行するかどうか、および型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドのオーバー ロードと関連付けられているオーバー ロードを使用して \(<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>と<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>\) の既定の実装を置き換える、<xref:System.Type.GetType%2A>より柔軟な実装を持つメソッドです。 型名およびこれらを含むアセンブリの名前を解決するメソッドを提供するには、次の操作を行います。  
  
-   型が読み込まれたアセンブリのバージョンを制御します。  
  
-   アセンブリ名を含まない型名を検索する別の場所を提供します。  
  
-   部分アセンブリ名を使用してアセンブリを読み込みます。  
  
-   サブクラスを返す<xref:System.Type?displayProperty=fullName>を共通言語ランタイム \(CLR\) では作成されません。  
  
 たとえば、バージョン トレラントなシリアル化でこのメソッドを使用する部分名を使用して"best fit"のアセンブリを検索します。 他のオーバー ロード、<xref:System.Type.GetType%2A>メソッドに必要なアセンブリ修飾型名、バージョン番号が含まれています。  
  
 型システムの代替実装のサブクラスを返す必要があります<xref:System.Type?displayProperty=fullName>は、CLR では作成されません。 すべての型の他のオーバー ロードによって返される、<xref:System.Type.GetType%2A>メソッドはランタイム型。  
  
<a name="usage_notes"></a>   
## 使用上の注意  
 このメソッドのオーバー ロードと関連付けられているオーバー ロードを解析`typeName`型と、アセンブリの名前の名前にし、名前を解決します。 アセンブリ名の解決は、アセンブリのコンテキストで、型名を解決する必要があるために、型名の解決の前に発生します。  
  
> [!NOTE]
>  アセンブリ修飾型名の概念を理解されていない場合、<xref:System.Type.AssemblyQualifiedName%2A>プロパティです。  
  
 場合`typeName`アセンブリ修飾名ではないアセンブリの解決はスキップされます。 Mscorlib.dll または実行中のアセンブリのコンテキストでの非修飾型名を解決することも、内のアセンブリを使用できます必要に応じて、`typeResolver`パラメーター。 などのさまざまな種類の名前解決はで表形式で表示されているは、アセンブリ名を省略すると効果、[混合名前解決](#mixed_name_resolution)セクションです。  
  
 一般的な使用法に関する注意事項:  
  
-   メソッドは渡さないように`assemblyResolver`または`typeResolver`不明または信頼されていない呼び出し元から送られてきた場合。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。  
  
    > [!CAUTION]
    >  不明または信頼されていない呼び出し元からメソッドを使用すると、悪意のあるコードの特権の昇格する可能性があります。  
  
-   省略した場合、`assemblyResolver`や`typeResolver`パラメーター、値の`throwOnError`パラメーターは既定の解決を実行するメソッドに渡されます。  
  
-   場合`throwOnError`は`true`、このメソッドがスローされます、<xref:System.TypeLoadException>とき`typeResolver`を返します`null`、および<xref:System.IO.FileNotFoundException>とき`assemblyResolver`を返します`null`です。  
  
-   このメソッドによってスローされる例外をキャッチしません`assemblyResolver`と`typeResolver`です。 リゾルバー メソッドによってスローされる例外を担当しています。  
  
<a name="resolving_assemblies"></a>   
### アセンブリの解決  
 `assemblyResolver`メソッドは受信、<xref:System.Reflection.AssemblyName>オブジェクトに含まれている文字列のアセンブリ名を解析することによって生成される`typeName`です。 場合`typeName`アセンブリ名を含まない`assemblyResolver`が呼び出されないと`null`に渡される`typeResolver`。  
  
 場合`assemblyResolver`指定された、標準のアセンブリではないアセンブリの検索に使用を調査します。 場合`assemblyResolver`が指定されて、<xref:System.Type.GetType%2A>メソッドでは、標準のプローブは実行しません。 その場合はことを確認、`assemblyResolver`渡すするすべてのアセンブリを処理することができます。  
  
 `assemblyResolver`メソッドが返す`null`場合は、アセンブリを解決することはできません。 場合`assemblyResolver`が返されます`null`、`typeResolver`は呼び出されませんそれ以上の処理が行われます。 さらに、場合`throwOnError`は`true`、<xref:System.IO.FileNotFoundException>がスローされます。  
  
 場合、<xref:System.Reflection.AssemblyName>に渡される`assemblyResolver`部分は、名前、1 つ以上の一部が`null`です。 たとえば、バージョン、設定されていない場合、<xref:System.Reflection.AssemblyName.Version%2A>プロパティは`null`します。 場合、<xref:System.Reflection.AssemblyName.Version%2A>プロパティ、<xref:System.Reflection.AssemblyName.CultureInfo%2A>プロパティ、および<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>メソッドのすべての戻り`null`、アセンブリの簡易名だけが指定されました。`assemblyResolver`メソッドを使用したり、アセンブリ名のすべての部分を無視します。  
  
 別のアセンブリ解決のオプションの効果が内でテーブルとして表示されます、[混合名前解決](#mixed_name_resolution)セクション、および単純なアセンブリ修飾型名にします。  
  
<a name="resolving_types"></a>   
### 型の解決  
 場合`typeName`、アセンブリ名を指定しない`typeResolver`は必ず呼び出されます。 場合`typeName`、アセンブリ名を指定`typeResolver`はアセンブリ名が正常に解決された場合にのみ呼び出されます。 場合`assemblyResolver`または標準のアセンブリのプローブを返します`null`、`typeResolver`は呼び出されません。  
  
 `typeResolver`メソッドが 3 つの引数を受け取ります。  
  
-   検索するアセンブリまたは`null`場合`typeName`にアセンブリ名がありません。  
  
-   型の簡易名。 入れ子にされた型の場合、これは、最も外側の格納先の型です。 ジェネリック型の場合、ジェネリック型の単純名です。  
  
-   ブール値である`true`場合型名の大文字と小文字は無視されます。  
  
 実装では、これらの引数の使用方法を決定します。`typeResolver`メソッドが返す`null`型を解決できない場合。 場合`typeResolver`返します`null`と`throwOnError`は`true`のこのオーバー ロード<xref:System.Type.GetType%2A>スロー、<xref:System.TypeLoadException>です。  
  
 別の型解決オプションの効果は内のテーブルとして表示されます、[混合名前解決](#mixed_name_resolution)セクション、および単純なアセンブリ修飾型名にします。  
  
#### 入れ子にされた型を解決します。  
 場合`typeName`は入れ子にされた型、最も外側の名前だけに渡される型を含む`typeResolver`です。 ときに`typeResolver`この型を返します、<xref:System.Type.GetNestedType%2A>メソッドは再帰的に最も内側の入れ子にされた型が解決するまでです。  
  
#### ジェネリック型の解決  
 <xref:System.Type.GetType%2A>のジェネリック型を解決するのには再帰呼び出しは: 自体には、ジェネリック型を解決するのには、最初にし、型引数を解決するのには、します。 場合は、型引数はジェネリック<xref:System.Type.GetType%2A>再帰的に、型引数を解決するためには、呼び出されます。  
  
 組み合わせ`assemblyResolver`と`typeResolver`この再帰のすべてのレベルの解決に対応する必要がありますを指定することです。 たとえば、指定した、`assemblyResolver`の読み込みを制御する`MyAssembly`です。 ジェネリック型を解決する対象とすると`Dictionary<string, MyType>`\(`Dictionary(Of String, MyType)` Visual Basic で\)。 次のジェネリック型の名前を渡すことがあります。  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 注意して`MyType`のみのアセンブリ修飾の型引数です。 名前、<xref:System.Collections.Generic.Dictionary%602>と<xref:System.String>クラスは、アセンブリ修飾します。`typeResolver`できるハンドルである必要があります、どちらかのアセンブリまたは`null`受信するため、`null`の<xref:System.Collections.Generic.Dictionary%602>と<xref:System.String>です。 オーバー ロードを呼び出すことによってそのケースを処理できる、<xref:System.Type.GetType%2A>を両方の非修飾型名は Mscorlib.dll にあるため、文字列を受け取るメソッド。  
  
 [!code-csharp[GetTypeOnSteroids\#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver`辞書の型と文字列型に対しては、それらの型名はアセンブリ修飾ではないためメソッドは呼び出されません。  
  
 現在の代わりにするものとします`System.String`、最初の汎用引数の型が`YourType`から`YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 このアセンブリは、Mscorlib.dll も実行中のアセンブリには、解決できない場合は`YourType`アセンブリ修飾名がない場合。`assemblyResolve`は再帰的に呼び出されると、その必要がありますこのケースを処理することができます。 返す代わりに`null`以外のアセンブリの`MyAssembly`を使用して、指定されたアセンブリの読み込みを今すぐ実行<xref:System.Reflection.AssemblyName>オブジェクト。  
  
 [!code-csharp[GetTypeOnSteroids\#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 戻る[使用上の注意](#usage_notes)です。  
  
#### 特殊文字を含む型名の解決  
 特定の文字では、アセンブリ修飾名で特殊な意味があります。 単純な型名にこれらの文字が含まれている場合、文字では、簡易名は、アセンブリ修飾名の一部で、解析エラーが発生します。 解析エラーを避けるためには前に、アセンブリ修飾名を渡すことができます、円記号で特殊文字をエスケープする必要があります、<xref:System.Type.GetType%2A>メソッドです。 たとえば、型が名前付き`Strange]Type`、エスケープ文字を次のように、角かっこの前追加する必要があります:`Strange\]Type`です。  
  
> [!NOTE]
>  などの特殊文字が付いているは、Visual Basic または C\# の場合で作成することはできませんが、Microsoft intermediate language \(MSIL\) を使用するか、動的アセンブリを生成することによって作成されたことができます。  
  
 次の表は、型名に特殊文字を示しています。  
  
|文字|説明|  
|--------|--------|  
|, \(コンマ\)|アセンブリ修飾名の区切り記号。|  
|\(角かっこ\)|サフィックス ペアとして、配列型を示します区切り記号のペアとして、汎用引数リストとアセンブリ修飾名を囲みます。|  
|& \(アンパサンド\)|サフィックスとして、種類が参照型であることを示します。|  
|\* \(アスタリスク\)|サフィックスとして、型、ポインター型であることを示します。|  
|\+ \(正符号 \+\)|入れ子にされた型の区切り記号。|  
|\\ \(円記号\)|文字をエスケープします。|  
  
 などのプロパティ<xref:System.Type.AssemblyQualifiedName%2A>正しくエスケープされた文字列を返します。 正しくエスケープされた文字列を渡す必要があります、<xref:System.Type.GetType%2A>メソッドです。 さらに、<xref:System.Type.GetType%2A>メソッドは成功を正しくエスケープされた名前`typeResolver`と既定値の型解決方法です。 内のエスケープ解除された名に名前を比較する必要があるかどうかは`typeResolver`、エスケープ文字を削除する必要があります。  
  
 戻る[使用上の注意](#usage_notes)です。  
  
<a name="mixed_name_resolution"></a>   
## 混合名前解決  
 次の表に、間の相互作用`assemblyResolver`、 `typeResolver`、型名とアセンブリ名のすべての組み合わせに対して、既定の名前解決および`typeName`:  
  
|型名の内容|アセンブリ リゾルバー メソッド|型競合回避モジュールのメソッド|結果|  
|-----------|----------------------|---------------------|--------|  
|アセンブリの種類|null|null|呼び出すことと同等、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName>メソッドのオーバー ロードします。|  
|アセンブリの種類|指定されました。|null|`assemblyResolver`アセンブリを返しますまたは、返す`null`アセンブリを解決できない場合。 アセンブリが解決される場合、<xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName>メソッドのオーバー ロードがアセンブリから型の読み込みに使用される。 それ以外の場合、型の解決を試行は不要です。|  
|アセンブリの種類|null|指定されました。|アセンブリ名を変換と同じ、<xref:System.Reflection.AssemblyName>オブジェクトと呼び出し元、<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=fullName>アセンブリを取得するメソッドのオーバー ロードします。 渡されるが、アセンブリが解決した場合は、 `typeResolver`、それ以外の`typeResolver`は呼び出されません型の解決を試行することはありません。|  
|アセンブリの種類|指定されました。|指定されました。|`assemblyResolver`アセンブリを返しますまたは、返す`null`アセンブリを解決できない場合。 渡されるが、アセンブリが解決した場合は、 `typeResolver`、それ以外の`typeResolver`は呼び出されません型の解決を試行することはありません。|  
|型|null に指定されました。|null|呼び出すことと同等、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName>メソッドのオーバー ロードします。 アセンブリ名が指定されていないために、Mscorlib.dll および実行中のアセンブリのみが検索されます。 場合`assemblyResolver`は、指定した場合は無視されます。|  
|型|null に指定されました。|指定されました。|`typeResolver`呼び出されると`null`アセンブリが渡されました。`typeResolver`目的のロード アセンブリも含め、任意のアセンブリから型を提供できます。 場合`assemblyResolver`は、指定した場合は無視されます。|  
|アセンブリ|null に指定されました。|null に指定されました。|A<xref:System.IO.FileLoadException>スローされると、アセンブリ修飾型名の場合と同様に、アセンブリ名が解析されるためです。 これは、結果、無効なアセンブリ名。|  
  
 戻る:[使用上の注意](#usage_notes)、[アセンブリを解決する](#resolving_assemblies)、[型の解決](#resolving_types)です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。埋め込まれたタブなどの正しくない文字が <paramref name="typeName" /> に含まれています。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は正しくないサイズの配列型を表します。  
  
 または  
  
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> が型名とアセンブリ名に解析される際にエラーが発生します \(たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など\)。  
  
 または  
  
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に無効な構文 \("MyType\[,\*,\]" など\) が含まれています。  
  
 または  
  
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
 \-または\-  
  
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
 \-または\-  
  
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリ、またはその依存関係のうちの 1 つが見つかったが、読み込めませんでした。  
  
 または  
  
 <paramref name="typeName" /> に無効なアセンブリ名が含まれています。  
  
 または  
  
 <paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリ、またはその依存関係のうちの 1 つが無効です。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">型を確認する対象のオブジェクトの配列。</param>
        <summary>指定した配列内のオブジェクトの型を取得します。</summary>
        <returns>
          <paramref name="args" /> 内の対応する要素の型を表す <see cref="T:System.Type" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次のコード例を使用する方法を示しています、<xref:System.Type.GetTypeArray%2A>メソッドを配列の要素の種類を一覧表示されます。  
  
 [!code-cpp[Type\_GetTypeCode\#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type\_GetTypeCode\#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type\_GetTypeCode\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="args" /> の要素の 1 つ以上が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラスの初期化子が呼び出され、少なくとも 1 つは例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">基になる型コードを取得する対象となる型。</param>
        <summary>指定した <see cref="T:System.Type" /> の基になる型コードを取得します。</summary>
        <returns>
          <paramref name="type" /> が <see langword="null" /> の場合、基になる型または <see cref="F:System.TypeCode.Empty" /> のコード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 継承する場合<xref:System.Type>、オーバーライドしてこのメソッドの動作を変更することができます、<xref:System.Type.GetTypeCodeImpl%2A>メソッドです。  
  
   
  
## 例  
 次のコード例を示しています、<xref:System.TypeCode>列挙体を使用することができます。 内の判断ブロックで、`WriteObjectInfo`メソッド、<xref:System.TypeCode>の<xref:System.Object>パラメーターが調べられ、適切なメッセージがコンソールに書き込まれます。  
  
 [!code-cpp[System.TypeCode\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Type" /> インスタンスの基になる型コードを返します。</summary>
        <returns>基になる型の型コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの実装を提供する、 `static` \(C\# の場合\) または`Shared`\(Visual Basic\) の<xref:System.Type.GetTypeCode%28System.Type%29>メソッドです。 継承する場合<xref:System.Type>、独自の実装を提供するには、このメソッドをオーバーライドすることができます<xref:System.Type.GetTypeCode%2A>です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <summary>指定したクラス識別子 \(CLSID\) に関連付けられている型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id \(CLSID\) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey\_classes\_root \\clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id \(ProgID\) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>オブジェクトを表す、`__ComObject`呼び出すことによって、CLSID に対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッドです。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> COM オブジェクトをインスタンス化するメソッド。  
  
 図については、例を参照してください。  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29>オーバー ロードが、インスタンス化するときに発生するすべての例外は無視されます、<xref:System.Type>オブジェクトに基づいて、`clsid`引数。 例外はスローされません注`clsid`はレジストリに存在しません。  
  
   
  
## 例  
 次の例は、Microsoft Word の CLSID [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) Microsoft Word アプリケーションを表す COM 型を取得します。 呼び出して、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=fullName>メソッドを呼び出すことによってが閉じると、 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)メソッドです。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>This method is intended for use when working with COM objects, not with .NET Framework objects. All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property. Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
 \-または\-  
  
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したクラス ID \(CLSID\) に関連付けられた型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id \(CLSID\) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey\_classes\_root \\clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id \(ProgID\) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>を表すオブジェクト、`__ComObject`呼び出すことによって、CLSID に対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッドです。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> COM オブジェクトをインスタンス化するメソッド。  
  
 図については、例を参照してください。  
  
 ような例外<xref:System.OutOfMemoryException>を指定する場合にスローされる`true`の`throwOnError`、未登録の Clsid に対しては失敗しませんが、します。  
  
   
  
## 例  
 次の例は、Microsoft Word の CLSID [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) Microsoft Word アプリケーションを表す COM 型を取得します。 呼び出して、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=fullName>メソッドを呼び出すことによってが閉じると、 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)メソッドです。 型の読み込み中にエラーが発生した場合、例外がスローされます。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>This method is intended for use when working with COM objects, not with .NET Framework objects. All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property. Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <summary>指定したサーバーから、指定したクラス ID \(CLSID\) に関連付けられている型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id \(CLSID\) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey\_classes\_root \\clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id \(ProgID\) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>オブジェクトを表す、`__ComObject`呼び出すことによって、CLSID に対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッドです。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> COM オブジェクトをインスタンス化するメソッド。  
  
   
  
## 例  
 次の例は、Microsoft Word の CLSID [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) computer17.central.contoso.com をという名前のサーバーから Microsoft Word アプリケーションを表す COM 型を取得します。 呼び出して、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=fullName>メソッドを呼び出すことによってが閉じると、 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)メソッドです。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>This method is intended for use when working with COM objects, not with .NET Framework objects. All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property. Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
 \-または\-  
  
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したクラス ID \(CLSID\) に関連付けられた型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.GetTypeFromCLSID%2A> メソッドをサポートしています遅延バインディング アクセス アンマネージ COM オブジェクトへの .NET Framework アプリケーションから COM オブジェクトのクラス id \(CLSID\) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey\_classes\_root \\clsid キーで定義されます。 値を取得する、 <xref:System.Type.IsCOMObject%2A> プロパティをこのメソッドによって返される型が COM オブジェクトであるかどうかを確認します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM への遅延バインディング アクセスの方法がわかっているがプログラム id \(ProgID\) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージ COM オブジェクトをインスタンス化します。  
  
1.  取得、 <xref:System.Type> を表すオブジェクト、 `__ComObject` 呼び出すことによって、CLSID に対応する、 <xref:System.Type.GetTypeFromCLSID%2A> メソッドです。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> COM オブジェクトをインスタンス化するメソッドです。  
  
 ような例外 <xref:System.OutOfMemoryException> を指定する場合にスローされる `true` の `throwOnError`, が登録されていない Clsid に対しては失敗しません。  
  
   
  
## 例  
 次のコードの例では、Microsoft Word の CLSID [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) computer17.central.contoso.com という名前のサーバーから Microsoft Word のアプリケーションを表す COM 型を取得します。 呼び出して、型をインスタンス化、 <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> メソッドを呼び出して終了し、 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) メソッドです。 型の読み込み中にエラーが発生した場合は、例外がスローされます。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>This method is intended for use when working with COM objects, not with .NET Framework objects. All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property. Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">型を参照するオブジェクト。</param>
        <summary>指定した型ハンドルによって参照される型を取得します。</summary>
        <returns>指定した <see cref="T:System.RuntimeTypeHandle" /> によって参照される型。または <paramref name="handle" /> の <see cref="P:System.RuntimeTypeHandle.Value" /> プロパティが <see langword="null" /> の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ハンドルは、取得されたアプリケーション ドメイン内でのみ有効です。  
  
   
  
## 例  
 次の例では<xref:System.Type.GetTypeFromHandle%2A>取得するメソッドを<xref:System.Type>オブジェクトからは<xref:System.RuntimeTypeHandle>で提供されるの<xref:System.Type.GetTypeHandle%2A>メソッドです。  
  
 [!code-cpp[Type\_GetTypeFromHandle\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type\_GetTypeFromHandle\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type\_GetTypeFromHandle\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の ProgID。</param>
        <summary>指定されたプログラム ID \(ProgID\) に関連付けられている型を取得し、<see cref="T:System.Type" /> の読み込み中にエラーが発生した場合は null を返します。</summary>
        <returns>
          <paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定された ProgID に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは提供の COM サポートします。 Progid は、名前空間の概念によって置き換えられたため、Microsoft .NET Framework では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の ProgID。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
 \-または\-  
  
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定されたプログラム ID \(ProgID\) に関連付けられた型を取得します。</summary>
        <returns>
          <paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定されたプログラム ID \(ProgID\) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは提供の COM サポートします。 プログラム Id は、名前空間の概念によって置き換えられたために、Microsoft .NET Framework では使用されません。  
  
   
  
## 例  
 次の例では、ProgID が有効でない場合は、例外をスローするかどうかを指定する、ProgID を渡すことによって、型を取得します。 すべての該当する例外のメッセージと共に、ProgID に関連する ClassID を表示します。  
  
 [!code-cpp[Type\_GetTypeFromProgID2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type\_GetTypeFromProgID2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type\_GetTypeFromProgID2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">指定された ProgID が登録されていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の progID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <summary>指定したサーバーから、指定したプログラム ID \(progID\) に関連付けられている型を取得し、型の読み込み中にエラーが発生した場合は null を返します。</summary>
        <returns>
          <paramref name="progID" /> がレジストリの正しいエントリで、型がそれに関連付けられている場合は、指定したプログラム ID \(progID\) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは提供の COM サポートします。 プログラム Id は、名前空間の概念によって置き換えられたために、Microsoft .NET Framework では使用されません。  
  
   
  
## 例  
 次の例では、ProgID とサーバー名を渡すことによって、型を取得します。 例は次、ProgID に関連する ClassID が表示されますか、ProgID、またはサーバー名が有効でない場合は、例外をスローします。  
  
 [!code-cpp[Type\_GetTypeFromProgID3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type\_GetTypeFromProgID3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type\_GetTypeFromProgID3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">取得する <see cref="T:System.Type" /> の progID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
 \-または\-  
  
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したプログラム ID \(progID\) に関連付けられた型を取得します。</summary>
        <returns>
          <paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID \(progID\) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが提供される COM サポートします。 プログラム Id は、名前空間の概念によって置き換えられたために、Microsoft .NET Framework では使用されません。  
  
   
  
## 例  
 次の例では、ProgID とサーバー名を渡すことによって、型を取得します。 プログラム Id、ProgID、またはサーバー名が有効でない場合は、例外をスローするかどうかを指定することに関連する ClassID を表示します。  
  
 [!code-cpp[Type\_GetTypeFromProgID4\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type\_GetTypeFromProgID4\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type\_GetTypeFromProgID4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">指定された progID が登録されていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">型ハンドルの取得対象となるオブジェクト。</param>
        <summary>指定したオブジェクトの <see cref="T:System.Type" /> のハンドルを取得します。</summary>
        <returns>指定した <see cref="T:System.Type" /> の <see cref="T:System.Object" /> のハンドル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ハンドルは、取得されたアプリケーション ドメイン内でのみ有効です。  
  
   
  
## 例  
 次の例は、クラスを定義`MyClass1`のインスタンスを取得し、オブジェクトのランタイム ハンドルを取得します。  
  
 [!code-cpp[Type\_GetTypeHandle\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type\_GetTypeHandle\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type\_GetTypeHandle\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> に関連付けられている GUID を取得します。</summary>
        <value>
          <see cref="T:System.Type" /> に関連付けられている GUID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 GUID は型を使用して、関連付け、<xref:System.Runtime.InteropServices.GuidAttribute>属性。  
  
   
  
## 例  
 次の例は、クラスを作成`MyClass1`のパブリック メソッドを作成、`Type`オブジェクトに対応する`MyClass1`を取得し、<xref:System.Guid>構造体を使用して、`GUID`のプロパティ、`Type`クラスです。  
  
 [!code-cpp[Type\_Guid\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type\_Guid\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type\_Guid\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が別の型を包含または参照しているかどうか、つまり現在の <see cref="T:System.Type" /> が配列、ポインター、または参照渡しかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が配列やポインターであるか、参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 たとえば、Type.GetType\("Int32\[\]"\) です。HasElementType 返します`true`が Type.GetType\("Int32"\) です。HasElementType 返します`false`です。 HasElementType も返します`true`の「Int32 \*」と"Int32 \>\/documents\/report1.rdl」の"です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`です。  
  
   
  
## 例  
 次の例を返します`true`または`false`オブジェクトは、配列、参照型またはポインターかどうかによって異なります。  
  
 [!code-cpp[Type\_HasElementType\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type\_HasElementType\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type\_HasElementType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、<see cref="P:System.Type.HasElementType" /> プロパティを実装し、現在の <see cref="T:System.Type" /> が別の型を包含または参照しているかどうか、つまり現在の <see cref="T:System.Type" /> が配列やポインターであるか、参照渡しかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が配列やポインターであるか、参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 たとえば、Type.GetType\("Int32\[\]"\) です。HasElementTypeImpl 返します`true`が Type.GetType\("Int32"\) です。HasElementTypeImpl 返します`false`です。 HasElementTypeImpl も返します`true`の「Int32 \*」と"Int32 \>\/documents\/report1.rdl」の"です。  
  
   
  
## 例  
 次の例は、クラスを定義`MyTypeDelegator`が優先、`HasElementTypeImpl`メソッドです。 メイン クラスには、チェック、`HasElementType`要素が型プロパティを表示します。  
  
 [!code-cpp[Type\_HasElementTypeImpl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type\_HasElementTypeImpl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type\_HasElementTypeImpl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
 \-または\-  
  
 既定メンバーを呼び出すための空の文字列 \(""\)。  
  
 \-または\-  
  
 <see langword="IDispatch" /> メンバーの場合は、"\[DispID\=3\]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 \-または\-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />\)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <summary>指定したバインディング制約を使用し、指定した引数リストと照合して、指定したメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  使用することはできません <xref:System.Type.InvokeMember%2A> ジェネリック メソッドを呼び出します。  
  
 次 <xref:System.Reflection.BindingFlags> フィルター フラグを使用するには、検索に含めるには、どのメンバーを定義します。  
  
-   指定 `BindingFlags.Public` 、検索にパブリック メンバーを含める。  
  
-   指定 `BindingFlags.NonPublic` 、検索条件に非パブリック メンバー \(つまり、プライベート、プロテクト メンバー\) を含める。  
  
-   指定 `BindingFlags.FlattenHierarchy` 、階層の静的メンバーを含めるようにします。  
  
 次 <xref:System.Reflection.BindingFlags> 修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 小文字を区別しない `name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメンバーのみを検索する、 <xref:System.Type>, 、継承されたメンバーされません。  
  
 次 <xref:System.Reflection.BindingFlags> 呼び出しフラグは、メンバーを取得するには、どのような操作を示すために使用できます。  
  
-   `CreateInstance` コンス トラクターが呼び出されます。`name` 無視されます。 他の呼び出しフラグは無効です。  
  
-   `InvokeMethod` コンス トラクターまたは型初期化子ではできませんが、メソッドが呼び出されます。 有効でない `SetField` または `SetProperty`です。 場合 `InvokeMethod` 自体は、指定された `BindingFlags.Public`, 、`BindingFlags.Instance`, 、および `BindingFlags.Static` は自動的に追加します。  
  
-   `GetField` フィールドの値を取得します。 有効でない `SetField`します。  
  
-   `SetField` フィールドの値を設定します。 有効でない `GetField`します。  
  
-   `GetProperty` プロパティを取得します。 有効でない `SetProperty`します。  
  
-   `SetProperty` プロパティを設定します。 有効でない `GetProperty`します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=fullName>」を参照してください。  
  
 次の条件の両方に該当する場合、メソッドが呼び出されます。  
  
-   メソッドの宣言のパラメーターの数の引数の数に等しく、 `args` 配列 \(メンバーの既定の引数が定義されていない場合、 `BindingFlags.OptionalParamBinding` が指定されている\)。  
  
-   各引数の型は、バインダーによって、パラメーターの型に変換できます。  
  
 バインダーは、すべての一致するメソッドに紹介します。 要求されたバインディングの種類に基づくこれらのメソッドが検出された \(<xref:System.Reflection.BindingFlags> 値 `InvokeMethod`, 、`GetProperty`, など\)。 メソッドのセットは、名前、引数の数およびバインダーで定義されている検索修飾子のセットでフィルター処理します。  
  
 メソッドを選択すると後に、呼び出されます。 ユーザー補助機能がその時点でチェックされます。 検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。<xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> のメソッド、 <xref:System.Reflection.Binder> クラスが呼び出されるメソッドを選択します。 既定のバインダーは、最も限定的な一致を選択します。  
  
 完全に信頼されたコードのアクセスの制限は無視されます。つまり、private のコンス トラクター、メソッド、フィールド、およびプロパティにアクセスしてを通じて呼び出された <xref:System.Reflection> するたびに、コードが完全に信頼します。  
  
 使用する `Type.InvokeMember` を指定して特定の値にフィールドを設定する <xref:System.Reflection.BindingFlags.SetField?displayProperty=fullName>です。 たとえば、クラス C、および F に F をという名前のパブリック インスタンス フィールドを設定する場合は、 `String`, などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 F の場合、 `String[]`, などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 この新しい配列に F フィールドが初期化されます。 使用することも `Type.InvokeMember` を次のようなコードを使用して、値とし、次の値のインデックスを指定することによって配列内の位置を設定します。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 これにより、F が文字列"b"を保持する配列の文字列"z"が変更されます。  
  
 呼び出した場合、 `IDispatch` メンバー、メンバー名の代わりに、文字列形式を使用して DispID を指定する"\[DispID \= \#\#\]"です。 たとえば、MyComMethod DispID が 3 の場合は、文字列を指定できます"\[DispID \= 3\]""MyComMethod"の代わりにします。 DispID でメンバーを呼び出すことは、メンバー名で検索することよりも高速です。 複雑な集計のシナリオでは、DispID と、目的のメンバーを呼び出す唯一の方法でがあります。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーをアクセスに使用できます <xref:System.Security.Permissions.ReflectionPermission> で、 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=fullName> フラグを設定し、非パブリック メンバーの許可セットが、呼び出し元に制限されている場合は、セット、またはそのサブセットを付与します。 \(「[Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5)」を参照\)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## 例  
 次の例では使用 `InvokeMember` 型のメンバーにアクセスします。  
  
 [!code-cpp[InvokeMem\#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem\#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> のいずれかが含まれていません。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に、<see langword="CreateInstance" /> と <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> との組み合わせが含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" /> の両方が含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" /> の両方が含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に、<see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" /> との組み合わせが含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、<paramref name="args" /> に複数の要素があります。  
  
 \-または\-  
  
 COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。  
  
 \-または\-  
  
 名前付きパラメーター配列の 1 つに、<see langword="null" /> である文字列が含まれています。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
 \-または\-  
  
 現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.NotSupportedException">現在、.NET Compact Framework は、このメソッドをサポートしていません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for accessing non\-public members regardless of their grant set. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to call unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
 \-または\-  
  
 既定メンバーを呼び出すための空の文字列 \(""\)。  
  
 \-または\-  
  
 <see langword="IDispatch" /> メンバーの場合は、"\[DispID\=3\]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 \-または\-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />\)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <param name="culture">使用するグローバリゼーション ロケールを表すオブジェクト。これは、<see cref="T:System.String" /> 型の数値を <see cref="T:System.Double" /> に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。  
  
 \-または\-  
  
 現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see langword="Nothing" />\)。</param>
        <summary>指定したバインディング制約を使用し、指定したメンバーのうち、指定した引数リストおよびカルチャと一致するメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Although the default binder does not process [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Globalization.CultureInfo> \(the **parameterReference tag is not supported!!!!**  
parameter\), you can use the abstract [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process **parameterReference tag is not supported!!!!**  
.  
  
> [!NOTE]
>  You cannot use [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Type.InvokeMember%2A> to invoke a generic method.  
  
 The following [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  
  
-   Specify **languageKeyword tag is not supported!!!!**  
     to include public members in the search.  
  
-   Specify **languageKeyword tag is not supported!!!!**  
     to include non\-public members \(that is, private, internal, and protected members\) in the search.  
  
-   Specify **languageKeyword tag is not supported!!!!**  
     to include static members up the hierarchy.  
  
 The following [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  
  
-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  
  
-   `BindingFlags.DeclaredOnly` to search only the members declared on the [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Type>, not members that were simply inherited.  
  
 The following [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:  
  
-   `CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.  
  
-   `InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.  
  
-   `GetField` to get the value of a field. Not valid with `SetField`.  
  
-   `SetField` to set the value of a field. Not valid with `GetField`.  
  
-   `GetProperty` to get a property. Not valid with `SetProperty`.  
  
-   `SetProperty` to set a property. Not valid with `GetProperty`.  
  
 See [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  
  
 A method will be invoked if both of the following conditions are true:  
  
-   The number of parameters in the method declaration equals the number of arguments in the **parameterReference tag is not supported!!!!**  
     array \(unless default arguments are defined on the member and **languageKeyword tag is not supported!!!!**  
     is specified\).  
  
-   The type of each argument can be converted by the binder to the type of the parameter.  
  
 The binder will find all of the matching methods. These methods are found based upon the type of binding requested \([InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Reflection.BindingFlags> values **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, and so on\). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  
  
 After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  
  
 Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.  
  
 You can use **languageKeyword tag is not supported!!!!**  
 to set a field to a particular value by specifying [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Reflection.BindingFlags.SetField?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a **languageKeyword tag is not supported!!!!**  
 you can use code such as:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 If F is a **languageKeyword tag is not supported!!!!**  
, you can use code such as:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 which will initialize the field F to this new array. You can also use **languageKeyword tag is not supported!!!!**  
 to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 This will change string "z" in the array that F holds to string "b".  
  
 When you invoke an **unmanagedCodeEntityReference tag is not supported!!!!**  
 member you can specify the DispID instead of the member name, using the string format "\[DispID\=\#\#\]". For example, if the DispID of MyComMethod is 3, you can specify the string "\[DispID\=3\]" instead of "MyComMethod". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non\-public members if the caller has been granted [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Security.Permissions.ReflectionPermission> with the [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=fullName> flag and if the grant set of the non\-public members is restricted to the caller’s grant set, or a subset thereof. \(See [Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5).\)  
>   
>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> のいずれかが含まれていません。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に、<see langword="CreateInstance" /> と <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> との組み合わせが含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" /> の両方が含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" /> の両方が含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に、<see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" /> との組み合わせが含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、<paramref name="args" /> に複数の要素があります。  
  
 \-または\-  
  
 COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。  
  
 \-または\-  
  
 名前付きパラメーター配列の 1 つに、<see langword="null" /> である文字列が含まれています。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
 \-または\-  
  
 現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for accessing non\-public members regardless of their grant set. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to call unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
 \-または\-  
  
 既定メンバーを呼び出すための空の文字列 \(""\)。  
  
 \-または\-  
  
 <see langword="IDispatch" /> メンバーの場合は、"\[DispID\=3\]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 \-または\-  
  
 <see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 \(Visual Basic の場合は Nothing\)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <param name="modifiers">
          <c>args</c> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 パラメーターに関連付けられた属性は、メンバーのシグネチャに格納されます。  
  
 既定のバインダーは、COM コンポーネントを呼び出す場合のみ、このパラメーターを処理します。</param>
        <param name="culture">使用するグローバリゼーション ロケールを表す <see cref="T:System.Globalization.CultureInfo" /> オブジェクト。これは、String 型の数値を Double に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。  
  
 \-または\-  
  
 現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> を使用する場合は、null 参照 \(Visual Basic の場合は <see langword="Nothing" />\)。</param>
        <param name="namedParameters">
          <c>args</c> 配列内の値が渡されるパラメーターの名前を格納する配列。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用し、指定した引数リスト、修飾子、カルチャと照合して、指定されたメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.  
  
> [!NOTE]
>  You cannot use [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Type.InvokeMember%2A> to invoke a generic method.  
  
 When you invoke an **unmanagedCodeEntityReference tag is not supported!!!!**  
 member you can specify the DispID instead of the member name, using the string format "\[DispID\=\#\#\]". For example, if the DispID of MyComMethod is 3, you can specify the string "\[DispID\=3\]" instead of "MyComMethod". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  
  
 Although the default binder does not process [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.ParameterModifier> or [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Globalization.CultureInfo> \(the **parameterReference tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
 parameters\), you can use the abstract [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process **parameterReference tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
. **languageKeyword tag is not supported!!!!**  
 is only used when calling through COM interop, and only parameters that are passed by reference are handled.  
  
 Each parameter in the **parameterReference tag is not supported!!!!**  
 array gets the value in the corresponding element in the **parameterReference tag is not supported!!!!**  
 array. If the length of **parameterReference tag is not supported!!!!**  
 is greater than the length of **parameterReference tag is not supported!!!!**  
, the remaining argument values are passed in order.  
  
 The **parameterReference tag is not supported!!!!**  
 array can be used to change the order of arguments in an input array. For example, given the method `M(string a, int b)` \(`M(ByVal a As String, ByVal b As Integer)` in Visual Basic\) and the input array `{ 42, "x" }`, the input array can be passed unchanged to **parameterReference tag is not supported!!!!**  
 if the array `{ "b", "a" }` is supplied for **parameterReference tag is not supported!!!!**  
.  
  
 The following [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  
  
-   Specify **languageKeyword tag is not supported!!!!**  
     to include public members in the search.  
  
-   Specify **languageKeyword tag is not supported!!!!**  
     to include non\-public members \(that is, private, internal, and protected members\) in the search.  
  
-   Specify **languageKeyword tag is not supported!!!!**  
     to include static members up the hierarchy.  
  
 The following [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  
  
-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  
  
-   `BindingFlags.DeclaredOnly` to search only the members declared on the [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Type>, not members that were simply inherited.  
  
 The following [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:  
  
-   `CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.  
  
-   `InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.  
  
-   `GetField` to get the value of a field. Not valid with `SetField`.  
  
-   `SetField` to set the value of a field. Not valid with `GetField`.  
  
-   `GetProperty` to get a property. Not valid with `SetProperty`.  
  
-   `SetProperty` to set a property. Not valid with `GetProperty`.  
  
 See [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  
  
 A method will be invoked if both of the following conditions are true:  
  
-   The number of parameters in the method declaration equals the number of arguments in the **parameterReference tag is not supported!!!!**  
     array \(unless default arguments are defined on the member and **languageKeyword tag is not supported!!!!**  
     is specified\).  
  
-   The type of each argument can be converted by the binder to the type of the parameter.  
  
 The binder will find all of the matching methods. These methods are found based upon the type of binding requested \([InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.BindingFlags> values **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, and so on\). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  
  
 After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  
  
 `InvokeMember` can be used to invoke methods with parameters that have default values. To bind to these methods, Reflection requires [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=fullName> to be specified. For a parameter that has a default value, you can either supply a different value, or supply [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.Missing.Value?displayProperty=fullName> to use the default value.  
  
 For example, consider a method such as MyMethod\(int x, float y \= 2.0\). To invoke this method with only the first argument as MyMethod\(4\), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and **languageKeyword tag is not supported!!!!**  
 for the second argument. Unless you use **languageKeyword tag is not supported!!!!**  
, you may not omit optional parameters with the **languageKeyword tag is not supported!!!!**  
 method. If you must do so, use **languageKeyword tag is not supported!!!!**  
 instead.  
  
 Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection> whenever the code is fully trusted.  
  
 You can use **languageKeyword tag is not supported!!!!**  
 to set a field to a particular value by specifying [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Reflection.BindingFlags.SetField?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a **languageKeyword tag is not supported!!!!**  
, you can use code such as:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 If F is a **languageKeyword tag is not supported!!!!**  
, you can use code such as:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 which will initialize the field F to this new array. You can also use **languageKeyword tag is not supported!!!!**  
 to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 This will change string "z" in the array that F holds to string "b".  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non\-public members if the caller has been granted [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Security.Permissions.ReflectionPermission> with the [InvokeMember メソッド \(String, BindingFlags, Binder, Object, Object\[\], ParameterModifier\<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=fullName> flag and if the grant set of the non\-public members is restricted to the caller’s grant set, or a subset thereof. \(See [Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5).\)  
>   
>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> と <paramref name="modifiers" /> の長さが同じではありません。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> のいずれかが含まれていません。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に、<see langword="CreateInstance" /> と <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> との組み合わせが含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" /> の両方が含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" /> の両方が含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に、<see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" /> との組み合わせが含まれています。  
  
 \-または\-  
  
 <paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、<paramref name="args" /> に複数の要素があります。  
  
 \-または\-  
  
 名前付きパラメーター配列が、引数配列よりも長くなっています。  
  
 \-または\-  
  
 COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。  
  
 \-または\-  
  
 名前付きパラメーター配列の 1 つに、<see langword="null" /> である文字列が含まれています。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
 \-または\-  
  
 <paramref name="namedParameters" /> の中で引数名が指定されているメンバーが見つかりません。  
  
 \-または\-  
  
 現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for accessing non\-public members regardless of their grant set. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to call unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が抽象型で、オーバーライドする必要があるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が抽象である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.IsAbstract%2A>プロパティから返される`true`次の場合。  
  
-   現在の型が抽象です。つまり、インスタンス化できませんが、派生クラスの基底クラスとしてのみ使用できます。 C\# の場合は、抽象クラスが付いて、[abstract \(C\# Reference\)](http://msdn.microsoft.com/ja-jp/b0797770-c1f3-4b4d-9441-b9122602a6bb)というキーワードでマークされている Visual basic で、[MustInherit \(Visual Basic\)](http://msdn.microsoft.com/ja-jp/b8f05185-90e3-4dd7-adc2-90d852fab5b4)キーワード。  
  
-   現在の型は、インターフェイスです。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`です。  
  
   
  
## 例  
 次の例の配列を作成する<xref:System.Type>、次の種類を表すオブジェクト: 戻り値が含まれています`true`場合は、指定したオブジェクト`abstract`以外の場合が返されます`false`です。  
  
-   `AbstractClass`、抽象クラス \(としてマークされているクラス`abstract`C\# の場合と`MustInherit`Visual Basic で\)。  
  
-   `DerivedClass`、から継承するクラスを`AbstractClass`です。  
  
-   `SingleClass`を非継承可能なクラスです。 として定義されて`sealed`C\# の場合と`NotInheritable`Visual Basic でします。  
  
-   `ITypeInfo`、インターフェイスです。  
  
-   `ImplementingClass`を実装するクラス、`ITypeInfo`インターフェイスです。  
  
 メソッドを返します`true`に対してのみ`AbstractClass`、抽象クラス、および`ITypeInfo`、インターフェイスです。  
  
 [!code-csharp[System.Type.IsAbstract\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="AnsiClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />に、文字列書式属性として<see langword="AnsiClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>文字列書式属性を選択します。 文字列形式の属性では、文字列の解釈方法を定義することで相互運用性が向上します。  
  
 場合、現在<xref:System.Type>型を構築する元になるジェネリック型定義に関連する、ジェネリック型をこのプロパティを表します。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`\(`MyGenericType(Of Integer)` Visual Basic で\)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
   
  
## 例  
 次の例は、フィールドの情報を取得し、確認、`AnsiClass`属性。  
  
 [!code-cpp[Type\_IsAnsiClass\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type\_IsAnsiClass\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type\_IsAnsiClass\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が配列かどうかを示す値を返します。</summary>
        <value>現在の型が配列である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.IsArray%2A>プロパティから返される`false`の<xref:System.Array>クラスです。 返します`false`、現在のインスタンスがある場合、<xref:System.Type>型はコレクションまたはコレクションで作業をように設計されたインターフェイスを表すオブジェクト<xref:System.Collections.IEnumerable>または<xref:System.Collections.Generic.IEnumerable%601>です。  
  
 配列をチェックするには、ようコードを使用します。  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 現在の型がジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す場合、このプロパティは常に返します`false`です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## 例  
 次の例では、使用方法を示します、<xref:System.Type.IsArray%2A>プロパティです。  
  
 [!code-csharp[System.Type.IsArray\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsArray" /> プロパティを実装し、<see cref="T:System.Type" /> が配列かどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が配列である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンス、 <xref:System.Array> クラスを返す必要があります `false` 配列ではなく、オブジェクトであるためです。  
  
   
  
## 例  
 次の例、 `IsArrayImpl` メソッドに、 `MyTypeDelegator` クラスかをチェックする変数は、配列と、結果が表示されます。  
  
 [!code-cpp[Type\_IsArrayImpl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type\_IsArrayImpl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type\_IsArrayImpl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">現在の型と比較する型。</param>
        <summary>指定した型のインスタンスを現在の型のインスタンスに割り当てできるかどうかを決定します。</summary>
        <returns>
          <see langword="true" /> が返されるのは、以下のいずれかの条件が満たされる場合です。  
  
-   <paramref name="c" /> と現在のインスタンスが同じ型を表す。  
  
-   <paramref name="c" /> が、現在のインスタンスから直接または間接に派生している。<paramref name="c" /> 現在のインスタンスから継承していない場合は、現在のインスタンスから直接派生します。 <paramref name="c" /> は間接的に取得、現在のインスタンスから現在のインスタンスから継承するクラスが 1 つまたは複数の連続してから継承していない場合。  
  
-   現在のインスタンスが、<paramref name="c" /> が実装するインターフェイスである。  
  
-   <paramref name="c" /> がジェネリック型パラメーターであり、現在のインスタンスが <paramref name="c" /> の定数の 1 つを表している。  
  
     現在のインスタンスは、次の例では、 <see cref="T:System.Type" /> を表すオブジェクト、 <see cref="T:System.IO.Stream" /> クラスです。<c>GenericWithConstraint</c> 型のジェネリック型パラメーターを持つ必要があります、ジェネリック型は、    <see cref="T:System.IO.Stream" />です。 ジェネリック型のパラメーターを渡して、 <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> にジェネリック型パラメーターのインスタンスを割り当てることがあることを示します、 <see cref="T:System.IO.Stream" /> オブジェクトです。  
  
     [!code-csharp[System.Type.IsAssignableFrom\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <paramref name="c" /> が値型を表し、現在のインスタンスが <c>Nullable&lt;c&gt;</c> \(Visual Basic では <c>Nullable(Of c)</c>\) を表している。  
  
 <see langword="false" /> が返されるのは、これらの条件がいずれも満たされない場合、または <paramref name="c" /> が <see langword="null" /> である場合です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.IsAssignableFrom%2A> のインスタンスかどうかを判断するメソッドを使用できる `c` 割り当てることができる、現在の型のインスタンスに、メソッドが便利なデザイン時の型が不明のオブジェクトを処理するときとでは、次の例のように、条件付き割り当てします。  
  
 [!code-csharp[System.Type.IsAssignableFrom\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 このためようにスローすることがなく実行時に実行、次のようなコードの行、 <xref:System.InvalidCastException> 例外または同様の例外。  
  
 [!code-csharp[System.Type.IsAssignableFrom\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
> [!NOTE]
>  ジェネリック型定義は、クローズ構築型から割り当てることができません。 つまり、クローズ構築型を割り当てることはできません `MyGenericList<int>` \(`MyGenericList(Of Integer)` Visual Basic で\) 型の変数に `MyGenericList<T>`します。  
  
 場合、 `c` パラメーターのデータ型 <xref:System.Reflection.Emit.TypeBuilder>, 、結果が構築される型に基づきます。 次のコード例を示しますという名前の組み込み型を使用して `B`します。  
  
 [!code-csharp[System.Type.IsAssignableFrom\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## 例  
 次の例は、 `IsAssignableFrom` クラス、整数の配列、およびジェネリック メソッドを使用して定義します。  
  
 [!code-cpp[TestIsAssignableFrom\#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom\#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="AutoClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />に、文字列書式属性として<see langword="AutoClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>文字列書式属性を選択します。 文字列形式の属性では、文字列の解釈方法を定義することで相互運用性が向上します。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`\(`MyGenericType(Of Integer)` Visual Basic で\)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、共通言語ランタイムによって自動的に配置されているかどうかを示す値を取得します。</summary>
        <value>現在の型の<see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、便利な機能として提供されます。 また、使用することができます、 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=fullName>型レイアウト属性と、\[テストをするかどうかを選択する列挙値 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=fullName> が設定されます。<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=fullName>,、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=fullName>, 、および <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=fullName> 列挙値は、型のフィールドがメモリにレイアウトする方法を示します。  
  
 動的な型を指定できます <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=fullName> 型を作成する場合。 コードでは、適用、 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性を <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=fullName> 型にランタイムに、クラスのレイアウトに適切な方法を決定する列挙値。  
  
> [!NOTE]
>  使用することはできません、 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドを呼び出せば確認するかどうか、 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 型に適用されています。  
  
 場合は、現在 <xref:System.Type> 表します構築ジェネリック型、このプロパティは、型が構築されたジェネリック型定義に適用されます。 などの場合、現在 <xref:System.Type> を表します `MyGenericType<int>` \(`MyGenericType(Of Integer)` Visual Basic で\)、このプロパティの値はによって決まります `MyGenericType<T>.`  
  
 場合は、現在 <xref:System.Type> このプロパティは常に返しますジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す `false`します。  
  
   
  
## 例  
 次の例は、型のインスタンスを作成し、表示、 <xref:System.Type.IsAutoLayout%2A> プロパティです。  
  
 [!code-cpp[Type\_IsAutoLayout\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type\_IsAutoLayout\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type\_IsAutoLayout\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が参照渡しかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 実際の型に、参照によって渡された型を逆参照して、呼び出す<xref:System.Type.GetElementType%2A>でその型にします。  
  
   
  
## 例  
 次の例での使用、`IsByRef`プロパティを指定した型が参照によって渡されるかどうかを確認します。 例では、クラスを定義する`MyTypeDelegator`が優先、`HasElementTypeImpl`メソッドです。 メイン クラスには、チェック、`HasElementType`要素が型プロパティを表示します。  
  
 [!code-cpp[Type\_HasElementTypeImpl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type\_HasElementTypeImpl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type\_HasElementTypeImpl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsByRef" /> プロパティを実装し、<see cref="T:System.Type" /> が参照渡しかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> がクラスまたはデリゲートである \(つまり値型やインターフェイスではない\) かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がクラスである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返します`true`クラスとしてのデリゲート。 返します`false`値型の構造および列挙体\) \(ボックス化されている場合でもです。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`true`です。場合、現在<xref:System.Type>このプロパティを返しますが構築ジェネリック型を表す`true`場合は、ジェネリック型定義は、クラス定義です。 つまり、は定義しませんインターフェイスまたは値型です。  
  
> [!NOTE]
>  このプロパティを返します`true`の`Type`インスタンスを表す、<xref:System.Enum>と<xref:System.ValueType>クラスです。 これら 2 つのクラスは、列挙型の基本型と値型の場合は、それぞれが列挙型または値型自体ではありません。 詳細については、次を参照してください。、<xref:System.Type.IsValueType%2A>と<xref:System.Type.IsEnum%2A>プロパティです。  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=fullName>列挙値としてクラスまたはインターフェイスの型宣言を区別します。ただし、クラスおよび値型の両方が付いて、<xref:System.Reflection.TypeAttributes.Class?displayProperty=fullName>属性。 型の属性のプロパティと使用の値を取得する場合、<xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=fullName>も呼び出す必要がありますが、型が値型ではなくクラスかどうかを決定する値、<xref:System.Type.IsValueType%2A>プロパティです。 例を<xref:System.Reflection.TypeAttributes>列挙型には、追加情報と例が含まれています。  
  
 このプロパティは読み取り専用です。  
  
   
  
## 例  
 次の例では、型のインスタンスを作成し、型がクラスであるかどうかを示します。  
  
 [!code-cpp[Type\_IsClass\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type\_IsClass\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type\_IsClass\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が COM オブジェクトかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が COM オブジェクトである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る `false` COM インターフェイスのオブジェクトではないためです。 Microsoft .NET Framework のオブジェクトは COM インターフェイスを実装できます。  
  
 また COM クラスの読み込みし、取得、 `Type` を使用してその COM クラスのオブジェクト、 [&#91;\<topic:\/\/cpgrftypelibraryimportertlbimpexe\>&#93;](http://msdn.microsoft.com/ja-jp/ec0a8d63-11b3-4acd-b398-da1e37e97382) ツールです。  
  
 場合は、現在 <xref:System.Type> 表します構築ジェネリック型、このプロパティは、型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在 <xref:System.Type> を表します `MyGenericType<int`\> \(`MyGenericType(Of Integer)` Visual Basic で\)、によってこのプロパティの値を決定 `MyGenericType<T>`します。  
  
 場合は、現在 <xref:System.Type> このプロパティは常に返しますジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す `false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsCOMObject" /> プロパティを実装し、<see cref="T:System.Type" /> が COM オブジェクトかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が COM オブジェクトである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る `false` COM インターフェイスのオブジェクトではないためです。 Microsoft .NET Framework のオブジェクトは COM インターフェイスを実装できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このオブジェクトが構築ジェネリック型かどうかを示す値を取得します。 構築ジェネリック型のインスタンスを作成できます。</summary>
        <value>このオブジェクトが構築ジェネリック型を表している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 構築されたジェネリック型は、明示的な型のすべてのジェネリック型パラメーターに指定されました。 クローズ ジェネリック型とも呼ばれます。  
  
 このプロパティが`true`、現在の型のインスタンスを作成することができます。 これはと`false`、することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> をコンテキスト内で管理できるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> をコンテキスト内でホストできる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コンテキストは、クラス メンバーへの呼び出しをインターセプトし、同期などのクラスに適用されるポリシーを強制します。 リモート処理コンテキストに関する情報の詳細を参照してください。 <xref:System.Runtime.Remoting.Contexts.Context>します。  
  
 場合は、現在 <xref:System.Type> このプロパティは常に返しますジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す `false`します。  
  
   
  
## 例  
 次の例は、 `IsContextful`, 、<xref:System.Type.IsMarshalByRef%2A>, 、および <xref:System.Type.IsPrimitive%2A> のプロパティ、 <xref:System.Type> クラスです。 これは、型がプリミティブ データ型であるかどうかと、参照によってマーシャ リングできるかどうか、コンテキストでは、指定された型をホストすることができるかどうかを確認します。  
  
 [!code-cpp[Type\_IsContextful\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type\_IsContextful\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type\_IsContextful\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Type.IsContextful" /> プロパティを実装し、<see cref="T:System.Type" /> をコンテキスト内で管理できるかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> をコンテキスト内でホストできる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 コンテキストは、クラス メンバーへの呼び出しをインターセプトし、同期などのクラスに適用されるポリシーを適用します。  
  
   
  
## 例  
 次の例では、使用、 `IsContextfulImpl` メソッドです。  
  
 [!code-cpp[Type\_IsContextfulImpl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type\_IsContextfulImpl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type\_IsContextfulImpl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が列挙体であるどうかを示す値を取得します。</summary>
        <value>現在の <see langword="true" /> が列挙体を表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返します`true`、列挙型対応のではなく、<xref:System.Enum>自体を入力します。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`\(`MyGenericType(Of Integer)` Visual Basic で\)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## 例  
 次の例で使用する方法、`IsEnum`プロパティです。  
  
 [!code-cpp[TestIsEnum\#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum\#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">テスト対象の値。</param>
        <summary>指定された値が現在の列挙型に存在するかどうかを示す値を返します。</summary>
        <returns>指定された値が現在の列挙型のメンバーである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> は、列挙体の基になる型にできない型です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">現在の型と等しいかどうかをテストする COM 型。</param>
        <summary>2 つの COM 型が同じ ID を持ち、型の同値の対象になるかどうかを判断します。</summary>
        <returns>両方の COM 型が等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドは、一方の型が実行のために読み込まれたアセンブリに存在し、もう一方の型がリフレクションのみのコンテキストに読み込まれたアセンブリに存在する場合にも <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、共通言語ランタイムは、COM 型のマネージ アセンブリ相互運用機能アセンブリからの COM 型の型情報を取得するを必要とするのではなく、マネージ アセンブリに直接の型情報の埋め込みをサポートしています。 埋め込み型情報には、型とマネージ アセンブリで実際に使用されるメンバーのみが含まれているために、2 つのマネージ アセンブリは、同じ COM 型の非常に異なるビューがあります。 各マネージ アセンブリが、異なる<xref:System.Type>COM 型のビューを表すオブジェクト。 共通言語ランタイムは、これらの異なるビューのインターフェイス、構造体、列挙型、およびデリゲートの間で型の等価性をサポートします。  
  
 型の等価性は、受信側のアセンブリ内の型がマネージ アセンブリ別には、適切なにキャストできる 1 つから渡される COM オブジェクトに管理されていることを意味します。<xref:System.Type.IsEquivalentTo%2A>メソッドが可能にする別のアセンブリから取得した COM オブジェクトが、COM と同じ id の最初のアセンブリの独自埋め込まれた相互運用機能型のいずれかであると判断し、そのため、その型にキャストすることができます。  
  
 詳細については、「[Type Equivalence and Embedded Interop Types](http://msdn.microsoft.com/ja-jp/78892eba-2a58-4165-b4b1-0250ee2f41dc)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、明示的に指定したオフセット位置に配置されているかどうかを示す値を取得します。</summary>
        <value>現在の型の<see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、便利な機能として提供されます。 また、使用することができます、 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=fullName>型のレイアウト属性と、\[テストをするかどうかを選択する列挙値 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=fullName> が設定されます。<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=fullName>, 、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=fullName>, 、および <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=fullName> 列挙値は、型のフィールドがメモリにレイアウトする方法を示します。  
  
 動的な型を指定できます <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=fullName> 型を作成する場合。 コードでは、適用、 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性を <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=fullName> 型のフィールドを開始するオフセットが明示的に指定されているかを指定する列挙値。  
  
> [!NOTE]
>  使用することはできません、 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドを呼び出せば確認するかどうか、 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 型に適用されています。  
  
 場合は、現在 <xref:System.Type> 表します構築ジェネリック型、このプロパティは、型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在 <xref:System.Type> を表します `MyGenericType<int>` \(`MyGenericType(Of Integer)` Visual Basic で\)、によってこのプロパティの値を決定 `MyGenericType<T>`します。  
  
 場合は、現在 <xref:System.Type> このプロパティは常に返しますジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す `false`します。  
  
   
  
## 例  
 次の例は、型のインスタンスを作成しの値を表示、 <xref:System.Type.IsExplicitLayout%2A> プロパティです。 使用して、 `MySystemTime` クラスのコード例でもは <xref:System.Runtime.InteropServices.StructLayoutAttribute>です。  
  
 [!code-csharp[Type\_IsExplicitLayout\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type\_IsExplicitLayout\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> オブジェクトがジェネリック型定義またはジェネリック メソッド定義の型パラメーターを表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type>ジェネリック型パラメーターを表すオブジェクトを呼び出すことによって取得できます、<xref:System.Type.GetGenericArguments%2A>のメソッド、 <xref:System.Type> 、ジェネリック型定義を表しているオブジェクトまたは<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>のメソッド、<xref:System.Reflection.MethodInfo>ジェネリック メソッド定義を表すオブジェクト。  
  
-   ジェネリック型またはジェネリック メソッド定義の<xref:System.Type.IsGenericParameter%2A>プロパティから返される`true`の結果の配列のすべての要素。  
  
-   クローズ構築型またはメソッドに対して、<xref:System.Type.IsGenericParameter%2A>プロパティから返される`false`によって返される配列の各要素に対して、<xref:System.Type.GetGenericArguments%2A>メソッドです。  
  
-   オープン構築型またはメソッドは、いくつかの要素の配列の特定の種類があり、型パラメーターがあります。<xref:System.Type.IsGenericParameter%2A>返します`false`の型と`true`の型パラメーターです。 コード例を<xref:System.Type.ContainsGenericParameters%2A>プロパティ型と型パラメーターの組み合わせがあるジェネリック クラスをについて説明します。  
  
 ジェネリックのリフレクションで使用される用語に対するインバリアント条件の一覧は、次を参照してください。、<xref:System.Type.IsGenericType%2A>プロパティ解説します。  
  
   
  
## 例  
 次の例では、<xref:System.Type.IsGenericParameter%2A>プロパティをジェネリック型のジェネリック型パラメーターをテストします。  
  
 [!code-cpp[System.Type.IsGenericParameter\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型がジェネリック型かどうかを示す値を取得します。</summary>
        <value>現在の型がジェネリック型の場合は <see langword="true" />。それ以外の場合は<see langword=" false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、<xref:System.Type.IsGenericType%2A>プロパティを決定するかどうか、<xref:System.Type>オブジェクトがジェネリック型を表します。 使用して、<xref:System.Type.ContainsGenericParameters%2A>プロパティを決定するかどうか、<xref:System.Type>オブジェクトは、オープン構築型またはクローズ構築型を表します。  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A>プロパティから返される`false`即時の型がジェネリックでない場合。 たとえば、要素が配列型の`A<int>`\(`A(Of Integer)` Visual Basic で\) 自体ではなく、ジェネリック型です。  
  
 次の表では、汎用のリフレクションで使用される一般的な用語に対するインバリアント条件をまとめたものです。  
  
|用語|インバリアント|  
|--------|-------------|  
|ジェネリック型定義|<xref:System.Type.IsGenericTypeDefinition%2A> プロパティが `true` です。<br /><br /> ジェネリック型を定義します。 呼び出すことによって構築された型を作成、<xref:System.Type.MakeGenericType%2A>メソッドを<xref:System.Type>ジェネリック型定義を表すオブジェクトを型引数の配列を指定します。<br /><br /> <xref:System.Type.MakeGenericType%2A>ジェネリック型定義でのみ呼び出すことができます。<br /><br /> 任意のジェネリック型定義は、ジェネリック型 \(、<xref:System.Type.IsGenericType%2A>プロパティは`true`\) がその逆は true ではありません。|  
|ジェネリック型|<xref:System.Type.IsGenericType%2A> プロパティが `true` です。<br /><br /> ジェネリック型定義、オープン構築型またはクローズ構築型を指定できます。<br /><br /> 配列型要素型がジェネリック自体ではなく、ジェネリック型です。 場合も、同様、<xref:System.Type>ジェネリック型へのポインターを表すオブジェクト。|  
|オープン構築型|<xref:System.Type.ContainsGenericParameters%2A> プロパティが `true` です。<br /><br /> 例としては、ジェネリック型の型パラメーターが割り当てられていないこと、またはジェネリック型定義で、オープン構築型で入れ子になっている型またはジェネリック型を型引数を持つ、<xref:System.Type.ContainsGenericParameters%2A>プロパティは`true`します。<br /><br /> オープン構築型のインスタンスを作成することはできません。<br /><br /> 開いているすべての構築された型が汎用的なことに注意してください。 たとえば、配列要素型がジェネリック型定義はジェネリックではありませんし、オープン構築型へのポインターはジェネリックではありません。|  
|クローズ構築型|<xref:System.Type.ContainsGenericParameters%2A> プロパティが `false` です。<br /><br /> ときに検証した再帰、型では、未割り当てのジェネリック パラメーターはありません。|  
|ジェネリック型パラメーター|<xref:System.Type.IsGenericParameter%2A> プロパティが `true` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> プロパティが `true` です。<br /><br /> ジェネリック型定義では、後で割り当てられる型のプレース ホルダーです。|  
|ジェネリック型引数|ジェネリック型パラメーターを含む任意の型を指定できます。<br /><br /> 型引数の配列として指定されます<xref:System.Type>にオブジェクトが渡される、<xref:System.Type.MakeGenericType%2A>メソッドが構築ジェネリック型を作成するときにします。 結果の型のインスタンスを作成する場合、<xref:System.Type.ContainsGenericParameters%2A>プロパティである必要があります`false`のすべての型引数。|  
  
 次のコード例と表は、これらの条項と不変式の一部を示しています。`Derived`クラス特に関心があるは、その基本データ型は、型引数リスト内の型と型パラメーターの組み合わせが構築された型であるためです。  
  
 [!code-cpp[System.Type.IsGenericType\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 次の表に、クラスの作成および使用する例を示します`Base`、 `Derived`、および`G`です。 C\+\+ および c\# のコードが同じ場合は、1 つのエントリが表示されます。  
  
|例|インバリアント|  
|-------|-------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|この型には。<br /><br /> <xref:System.Type.IsGenericType%2A> は `true` です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `true` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `true` です。|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|この型には。<br /><br /> <xref:System.Type.IsGenericType%2A> は `true` です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `true` です。|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|変数の型の`d`:<br /><br /> <xref:System.Type.IsGenericType%2A> `false`ため`d`配列です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `false` です。|  
|`T`、 `U`、および`V`\(すべての場所で表示される\)|<xref:System.Type.IsGenericParameter%2A> は `true` です。<br /><br /> <xref:System.Type.IsGenericType%2A> `false`ジェネリック型の型パラメーターを制約する方法がないためです。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> `true`ため`T`、 `U`、および`V`それ自体がジェネリック型パラメーターです。 後でそれらに割り当てられている型の引数について何もこの意味しません。|  
|フィールドの種類 `F`|<xref:System.Type.IsGenericType%2A> は `true` です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> `false`型が割り当てられているために、型パラメーターに`G`です。 これを呼び出すことと同じことに注意してください、<xref:System.Type.MakeGenericType%2A>メソッドです。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> `true`ためフィールドの種類 `F`オープン構築型を型引数を持ちます。 構築された型がオープンための型引数 \(つまり、 `Base`\) は、ジェネリック型定義。 これは、再帰的な性質を示しています、<xref:System.Type.IsGenericType%2A>プロパティです。|  
|入れ子になったクラス`Nested`|<xref:System.Type.IsGenericType%2A> `true`場合でも、`Nested`クラスには、独自のジェネリック型パラメーターがないジェネリック型に入れ子にされているためです。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `true` です。 つまり、呼び出すことができます、<xref:System.Type.MakeGenericType%2A>メソッドと外側の型の型パラメーターを供給`Derived`です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> `true`型、それを囲むため`Derived`、ジェネリック型パラメーターを持ちます。 これは、再帰的な性質を示しています、<xref:System.Type.ContainsGenericParameters%2A>プロパティです。|  
  
   
  
## 例  
 次のコード例の値を表示する、 <xref:System.Type.IsGenericType%2A>、 <xref:System.Type.IsGenericTypeDefinition%2A>、 <xref:System.Type.IsGenericParameter%2A>、および<xref:System.Type.ContainsGenericParameters%2A>「解説」セクションで説明されている型のプロパティです。 プロパティ値の詳細については、「解説」表を参照してください。  
  
 [!code-cpp[System.Type.IsGenericType\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が、他のジェネリック型を構築できるジェネリック型の定義を表しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> オブジェクトがジェネリック型定義を表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ジェネリック型定義は、他の型を構築するためのテンプレートです。 たとえば、ジェネリック型定義から`G<T>`\(c\# の構文で表現します。`G(Of T)` Visual Basic でまたは`generic <typename T> ref class G`C\+\+ では\) 作成して、型のインスタンスを作成`G<int>`\(`G(Of Integer)` Visual Basic で\)、呼び出すことによって、<xref:System.Type.MakeGenericType%2A>メソッドを含む汎用引数リストを<xref:System.Int32>型です。 指定された、<xref:System.Type>これを表すオブジェクトの構築型を<xref:System.Type.GetGenericTypeDefinition%2A>メソッドは、取得、ジェネリック型定義戻る再度です。  
  
 使用して、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティを現在の型から新しい種類を作成できるかどうかを判断します。 場合、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティから返される`true`、呼び出すことができます、<xref:System.Type.MakeGenericType%2A>新しいジェネリック型を作成します。  
  
 ジェネリックのリフレクションで使用される用語に対するインバリアント条件の一覧は、次を参照してください。、<xref:System.Type.IsGenericType%2A>プロパティ解説します。  
  
   
  
## 例  
 次の例では、ジェネリック型定義であるかどうかなど、型に関する情報を表示します。 構築された型、そのジェネリック型定義、および通常の型は、情報が表示されます。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> に <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 属性が適用されているかどうかを示す \(つまり、COM タイプ ライブラリからインポートされたかどうかを示す\) 値を取得します。</summary>
        <value>
          <see langword="true" /> が <see cref="T:System.Type" /> を持っている場合は <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合は、現在 <xref:System.Type> 表します構築ジェネリック型、このプロパティは、型が構築されたジェネリック型定義に適用されます。 などの場合、現在 <xref:System.Type> を表します `MyGenericType<int>` \(`MyGenericType(Of Integer)` Visual Basic で\)、このプロパティの値はによって決まります `MyGenericType<T>.`  
  
 場合は、現在 <xref:System.Type> このプロパティは常に返しますジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す `false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">現在の型と比較するオブジェクト。</param>
        <summary>指定したオブジェクトが現在の <see cref="T:System.Type" /> のインスタンスかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が返されるのは、現在の <see langword="Type" /> が <paramref name="o" /> によって表されるオブジェクトの継承可能な階層内にある場合、または現在の <see langword="Type" /> が <paramref name="o" /> によって実装されているインターフェイスである場合です。<see langword="false" /> が返されるのは、これらの条件のいずれも満たされない場合、または <paramref name="o" /> が <see langword="null" /> であるか、現在の <see langword="Type" /> がオープン ジェネリック型である \(つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返す\) 場合です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、派生クラスでオーバーライドできます。  
  
> [!NOTE]
>  構築された型は、そのジェネリック型定義のインスタンスではありません。 つまり、 `MyGenericList<int>` \(`MyGenericList(Of Integer)` Visual Basic で\) のインスタンスではない`MyGenericList<T>`\(`MyGenericList(Of T)` Visual Basic で\)。  
  
   
  
## 例  
 `IsInstanceOfType` メソッドの使用例を次に示します。  
  
 [!code-cpp[TestIsInstanceOfType\#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType\#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> がインターフェイスである \(つまり値型やクラスではない\) ことを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がインターフェイスである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask>クラス、インターフェイスまたは値の型として型の宣言を区別します。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## 例  
 次の例は、インターフェイスを作成、インターフェイス型をチェックし、クラスがあるかどうかを示す、`IsInterface`プロパティ セットです。  
  
 [!code-cpp[Type\_IsInterface\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type\_IsInterface\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type\_IsInterface\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、定義済みまたはメタデータに対して出力された順序で、連続して配置されているかどうかを示す値を取得します。</summary>
        <value>現在の型の<see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、便利な機能として提供されます。 また、使用することができます、 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=fullName>型レイアウト属性と、\[テストをするかどうかを選択する列挙値 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=fullName> が設定されます。<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=fullName>, 、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=fullName>, 、および <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=fullName> 列挙値は、型のフィールドがメモリにレイアウトする方法を示します。  
  
 動的な型を指定できます <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=fullName> 型を作成する場合。 コードでは、適用、 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性を <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=fullName> 型の連続したレイアウトを指定する列挙値。  
  
> [!NOTE]
>  使用することはできません、 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドを呼び出せば確認するかどうか、 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 型に適用されています。  
  
 詳細については、共通言語基盤 \(CLI\) ドキュメントについては、"Partition II:: Metadata Definition and Semantics"仕様のセクション 9.1.2 を参照してください。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) Ecma International Web サイトにします。  
  
 場合は、現在 <xref:System.Type> 表します構築ジェネリック型、このプロパティは、型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在 <xref:System.Type> を表します `MyGenericType<int>` \(`MyGenericType(Of Integer)` Visual Basic で\)、によってこのプロパティの値を決定 `MyGenericType<T>`します。  
  
 場合は、現在 <xref:System.Type> このプロパティは常に返しますジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す `false`します。  
  
   
  
## 例  
 次の例では、クラスのインスタンスを作成する、 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=fullName>列挙値、 <xref:System.Runtime.InteropServices.StructLayoutAttribute> クラスが設定されているを確認、 <xref:System.Type.IsLayoutSequential%2A> プロパティには、結果を表示します。  
  
 [!code-cpp[Type\_IsLayoutSequential\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type\_IsLayoutSequential\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type\_IsLayoutSequential\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が参照渡しでマーシャリングされるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が参照渡しでマーシャリングされる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例は、 `IsContextful`, 、<xref:System.Type.IsMarshalByRef%2A>, 、および <xref:System.Type.IsPrimitive%2A> のプロパティ、 <xref:System.Type> クラスです。 これは、型がプリミティブ データ型であるかどうかと、参照によってマーシャ リングできるかどうか、コンテキストでは、指定された型をホストすることができるかどうかを確認します。  
  
 [!code-cpp[Type\_IsContextful\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type\_IsContextful\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type\_IsContextful\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Type.IsMarshalByRef" /> プロパティを実装し、<see cref="T:System.Type" /> が参照渡しでマーシャリングされるかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が参照渡しでマーシャリングされる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、派生クラスでオーバーライドできます。  
  
   
  
## 例  
 次の例では、指定された型が参照によってマーシャ リングし、結果を表示するかどうかを決定します。  
  
 [!code-cpp[Type\_IsMarshalByRefImpl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type\_IsMarshalByRefImpl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type\_IsMarshalByRefImpl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> オブジェクトが、別の型の定義内に入れ子になっている定義で定義された型を表しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が別の型に入れ子になっている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.IsNested%2A>プロパティから返される`true`すべての型の可視性に関係なく、入れ子にします。 同時に、入れ子、可視性をテストするに関連するプロパティを使用して<xref:System.Type.IsNestedAssembly%2A>、 <xref:System.Type.IsNestedFamily%2A>、 <xref:System.Type.IsNestedFamANDAssem%2A>、 <xref:System.Type.IsNestedFamORAssem%2A>、 <xref:System.Type.IsNestedPrivate%2A>、または<xref:System.Type.IsNestedPublic%2A>です。  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask>列挙体のメンバーが型の可視性属性を選択します。  
  
   
  
## 例  
 次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。 可視性に関連する数の値を取得し<xref:System.Type>親の型およびその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合は、現在 <xref:System.Type> ジェネリック型の型パラメーターを表しているこのプロパティは常に返します `false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=fullName> 表示\/非表示属性を選択します。  
  
   
  
## 例  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が、外部クラスを作成します。 表示\/非表示に関連する多数の値を取得し <xref:System.Type> の親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合は、現在 <xref:System.Type> ジェネリック型の型パラメーターを表しているこのプロパティは常に返します `false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=fullName> 表示\/非表示属性を選択します。  
  
> [!NOTE]
>  C\# および Visual Basic の言語では、独自のアセンブリに保護されている型にのみ表示されている入れ子になった型を定義するためのセマンティクスは含まれません。`protected internal` c\# での可視性と `Protected Friend` Visual Basic での可視性は、保護されている型と同じアセンブリ内の型の両方に表示されている入れ子にされた型を定義します。  
  
 A <xref:System.Type> オブジェクトのファミリが同じすべてのオブジェクトとして定義されている <xref:System.Type> とそのサブタイプ。  
  
   
  
## 例  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が、外部クラスを作成します。 表示\/非表示に関連する多数の値を取得し <xref:System.Type> の親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合は、現在 <xref:System.Type> ジェネリック型の型パラメーターを表しているこのプロパティは常に返します `false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=fullName> 表示\/非表示属性を選択します。  
  
 A <xref:System.Type> オブジェクトのファミリが、実際のすべてのオブジェクトとして定義されている同じ <xref:System.Type> とそのサブタイプ。  
  
   
  
## 例  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が、外部クラスを作成します。 表示\/非表示に関連する多数の値を取得し <xref:System.Type> の親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型の可視性がある場合 `protected internal` C\# の場合、または `Protected Friend` Visual basic で、 <xref:System.Type.IsNestedFamORAssem%2A> プロパティを返します。 `true`します。  
  
 場合は、現在 <xref:System.Type> ジェネリック型の型パラメーターを表しているこのプロパティは常に返します `false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=fullName> 表示\/非表示属性を選択します。  
  
 A <xref:System.Type> オブジェクトのファミリが、実際のすべてのオブジェクトとして定義されている同じ <xref:System.Type> とそのサブタイプ。  
  
   
  
## 例  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が、外部クラスを作成します。 表示\/非表示に関連する多数の値を取得し <xref:System.Type> の親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が入れ子になっていて、プライベートとして宣言されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が入れ子になっていて、プライベートとして宣言されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合は、現在 <xref:System.Type> ジェネリック型の型パラメーターを表しているこのプロパティは常に返します `false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=fullName> 表示\/非表示属性を選択します。  
  
   
  
## 例  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が、外部クラスを作成します。 表示\/非表示に関連する多数の値を取得し <xref:System.Type> の親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クラスが入れ子になっていて、パブリックとして宣言されているかどうかを示す値を取得します。</summary>
        <value>クラスが入れ子になっていて、パブリックとして宣言されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合は、現在 <xref:System.Type> ジェネリック型の型パラメーターを表しているこのプロパティは常に返します `false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=fullName> 表示\/非表示属性を選択します。  
  
   
  
## 例  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が、外部クラスを作成します。 表示\/非表示に関連する多数の値を取得し <xref:System.Type> の親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> がパブリックとして宣言されていないかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がパブリックとして宣言されていなくて、入れ子にされた型でない場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 入れ子にされた型です。 このプロパティを使用しないでください。使用して、<xref:System.Type.IsNestedPublic%2A>プロパティ代わりにします。  
  
 場合、現在<xref:System.Type>このプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
   
  
## 例  
 この例のポイント`IsNotPublic`型の可視性を取得するプロパティです。  
  
 [!code-cpp[Classic Type.IsNotPublic Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 次のコード例では、使用できない理由を示します`IsPublic`と`IsNotPublic`の入れ子になったクラスです。  
  
 [!code-cpp[Classic Type.IsNotPublic Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 入れ子になったクラスは、結果を無視する`IsPublic`と`IsNotPublic`のみの結果に注意を払って`IsNestedPublic`と`IsNestedPrivate`です。 次のコードのリフレクション出力は次のようになります。  
  
|クラス|IsNotPublic|IsPublic|なった|し|  
|---------|-----------------|--------------|---------|-------|  
|A|FALSE|TRUE|FALSE|FALSE|  
|B|FALSE|FALSE|TRUE|FALSE|  
|C|FALSE|FALSE|FALSE|TRUE|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> がポインターかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がポインターである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## 例  
 次の例を使用して、`IsPointer`プロパティです。  
  
 [!code-cpp[Type\_HasElementTypeImpl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type\_HasElementTypeImpl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type\_HasElementTypeImpl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsPointer" /> プロパティを実装し、<see cref="T:System.Type" /> がポインターかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> がポインターである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> がプリミティブ型の 1 つかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がプリミティブ型の 1 つである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`です。  
  
   
  
## 例  
 次の例で、 `IsContextful`、 <xref:System.Type.IsMarshalByRef%2A>、および<xref:System.Type.IsPrimitive%2A>のプロパティ、<xref:System.Type>クラスです。 これは、コンテキストでは、指定された型をホストすることができるかどうか型がプリミティブ データ型であるかどうかと、参照によってマーシャ リングできるかどうかを確認します。  
  
 [!code-cpp[Type\_IsContextful\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type\_IsContextful\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type\_IsContextful\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsPrimitive" /> プロパティを実装し、<see cref="T:System.Type" /> がプリミティブ型の 1 つかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> がプリミティブ型の 1 つである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.  
  
   
  
## 例  
 次の例では、指定された型はプリミティブ型であり結果を表示するかどうかを判断します。  
  
 [!code-cpp[Type\_IsPrimitiveImpl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type\_IsPrimitiveImpl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type\_IsPrimitiveImpl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> がパブリックとして宣言されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がパブリックとして宣言されていて、入れ子にされた型でない場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 入れ子にされた型は使用しないでください。使用して <xref:System.Type.IsNestedPublic%2A> 代わりにします。  
  
 場合は、現在 <xref:System.Type> ジェネリック型の型パラメーターを表しているこのプロパティを返します `true`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=fullName> 表示\/非表示属性を選択します。  
  
   
  
## 例  
 次の例のインスタンスを作成する `MyTestClass`, のチェック、 `IsPublic` プロパティには、結果を表示します。  
  
 [!code-cpp[Type.IsPublic\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 入れ子になったクラスは、結果を無視する `IsPublic` と `IsNotPublic` の結果にのみ注意を払って <xref:System.Type.IsNestedPublic%2A> と <xref:System.Type.IsNestedPrivate%2A>です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が sealed として宣言されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が sealed として宣言されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合は、現在 <xref:System.Type> ジェネリック型の型パラメーターを表しているこのプロパティは常に返します `true`します。  
  
   
  
## 例  
 次の例のインスタンスを作成する、 `sealed` クラスのチェック、 `IsSealed` プロパティには、結果を表示します。  
  
 [!code-cpp[Type\_IsSealed\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type\_IsSealed\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type\_IsSealed\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルであり、重要な操作を実行できるかどうかを示す値を取得します。</summary>
        <value>現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の型が透過的な場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.IsSecurityCritical%2A>, 、<xref:System.Type.IsSecuritySafeCritical%2A>, 、および <xref:System.Type.IsSecurityTransparent%2A> プロパティは、共通言語ランタイム \(CLR\) によって決定される、現在の信頼レベルで型の透過度をレポートします。 次の表では、これらのプロパティの組み合わせを示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|----------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透過的|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション \(たとえば、サンド ボックス アプリケーション ドメイン\) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。 アセンブリとそのすべての型を透過的に処理されます。 ランタイムは、そのアセンブリが \(たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン\) に完全に信頼されたアプリケーション ドメインに読み込まれる場合にのみ部分的に信頼されたアセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ \(つまり、厳密な名前付きアセンブリがグローバル アセンブリ キャッシュにインストールされている\) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは常に完全に信頼されました。 使用してアセンブリおよびアプリケーション ドメインの現在の信頼レベルを指定できます、 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> プロパティです。  
  
 リフレクションと透過性の詳細については、次を参照してください。 [Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5)します。 透過性の詳細については、次を参照してください。 [Security Changes in the .NET Framework](http://msdn.microsoft.com/ja-jp/5e87881c-9c13-4b52-8ad1-e34bb46e8aaa)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルであり、重要な操作を実行でき、透過的なコードからアクセスできるかどうかを示す値を取得します。</summary>
        <value>現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の型がセキュリティ クリティカルまたは透過的な場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.IsSecurityCritical%2A>, 、<xref:System.Type.IsSecuritySafeCritical%2A>, 、および <xref:System.Type.IsSecurityTransparent%2A> プロパティは、共通言語ランタイム \(CLR\) によって決定される、現在の信頼レベルで型の透過度をレポートします。 次の表では、これらのプロパティの組み合わせを示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|----------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透過的|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション \(たとえば、サンド ボックス アプリケーション ドメイン\) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。 アセンブリとそのすべての型を透過的に処理されます。 ランタイムは、そのアセンブリが \(たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン\) に完全に信頼されたアプリケーション ドメインに読み込まれる場合にのみ部分的に信頼されたアセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ \(つまり、厳密な名前付きアセンブリがグローバル アセンブリ キャッシュにインストールされている\) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは常に完全に信頼されました。 使用してアセンブリおよびアプリケーション ドメインの現在の信頼レベルを指定できます、 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> プロパティです。  
  
 リフレクションと透過性の詳細については、次を参照してください。 [Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5)します。 透過性の詳細については、次を参照してください。 [Security Changes in the .NET Framework](http://msdn.microsoft.com/ja-jp/5e87881c-9c13-4b52-8ad1-e34bb46e8aaa)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルで透過的であり、重要な操作を実行できないかどうかを示す値を取得します。</summary>
        <value>現在の型が現在の信頼レベルで透過的セキュリティである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返す場合 `true`, 、 <xref:System.Type.IsSecurityCritical%2A> と <xref:System.Type.IsSecuritySafeCritical%2A> プロパティの戻り値 `false`です。  
  
 <xref:System.Type.IsSecurityCritical%2A>, 、<xref:System.Type.IsSecuritySafeCritical%2A>, 、および <xref:System.Type.IsSecurityTransparent%2A> プロパティは、共通言語ランタイム \(CLR\) によって決定される、現在の信頼レベルで型の透過度をレポートします。 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション \(たとえば、サンド ボックス アプリケーション ドメイン\) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。 アセンブリとそのすべての型を透過的に処理されます。 ランタイムは、そのアセンブリが \(たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン\) に完全に信頼されたアプリケーション ドメインに読み込まれる場合にのみ部分的に信頼されたアセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ \(つまり、厳密な名前付きアセンブリがグローバル アセンブリ キャッシュにインストールされている\) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは常に完全に信頼されました。 使用してアセンブリおよびアプリケーション ドメインの現在の信頼レベルを指定できます、 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> プロパティです。  
  
 リフレクションと透過性の詳細については、次を参照してください。 [Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5)します。 透過性の詳細については、次を参照してください。 [Security Changes in the .NET Framework](http://msdn.microsoft.com/ja-jp/5e87881c-9c13-4b52-8ad1-e34bb46e8aaa)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> をシリアル化できるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> をシリアル化できる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`\(`MyGenericType(Of Integer)` Visual Basic で\)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
   
  
## 例  
 次の例のインスタンスを作成する`MyTestClass`クラスは、\[Serializable\] 属性を設定し、チェック、`IsSerializable`プロパティ`true`または`false`です。  
  
 [!code-cpp[Type\_IsSerializable\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type\_IsSerializable\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type\_IsSerializable\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が特別な処理を必要とする名前を持っているかどうかを示す値を取得します。</summary>
        <value>型の名前が特別な処理を必要とする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 始まるか、アンダー スコア文字 \(\_\)、プロパティ アクセサー、および演算子のオーバー ロードが含まれている名前は、一部のコンパイラで特別な処理が必要となる型の例を示します。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、型の構築元となるジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`\(`MyGenericType(Of Integer)` Visual Basic で\)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">現在の型と比較する型。</param>
        <summary>現在の <see cref="T:System.Type" /> が、指定した <see cref="T:System.Type" /> から派生しているかどうかを判断します。</summary>
        <returns>現在の <see langword="Type" /> が <paramref name="c" /> から派生している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。<see langword="false" /> と現在の <paramref name="c" /> とが等価の場合も、このメソッドは <see langword="Type" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すことができます、<xref:System.Type.IsSubclassOf%2A>メソッドを次のいずれかを判断します。  
  
-   かどうか別の 1 つのクラスを取得します。  
  
-   型がから派生するかどうか<xref:System.ValueType>です。 ただし、<xref:System.Type.IsValueType%2A>がより効率的な型が値型であるかどうかを判別します。  
  
-   型がから派生するかどうか<xref:System.Enum>です。 ただし、<xref:System.Type.IsEnum%2A>メソッドは、型が列挙型であるかどうかを決定するより効率的な方法です。  
  
-   かどうか、型がデリゲート、つまり、いずれかから派生しているかどうか<xref:System.Delegate>または<xref:System.MulticastDelegate>です。  
  
 <xref:System.Type.IsSubclassOf%2A>インターフェイスが別のインターフェイスから派生しているかどうかや、クラスがインターフェイスを実装するかどうかを判断するメソッドを使用できません。 使用して、<xref:System.Type.IsAssignableFrom%2A>次の例のように、そのような目的のメソッドです。  
  
 [!code-csharp[System.Type.IsSubclassOf\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、そのクラスの制約またはからに派生した<xref:System.Object?displayProperty=fullName>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  以外の場合に、インターフェイスで使用される<xref:System.Type.IsSubclassOf%2A>反対の<xref:System.Type.IsAssignableFrom%2A>します。 つまり場合、`t1.IsSubclassOf(t2)`は`true`、し`t2.IsAssignableFrom(t1)`も`true`します。  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
   
  
## 例  
 次の例は、という名前のクラスを作成`Class1`という名前の派生クラスと`DerivedC1`です。 呼び出す、<xref:System.Type.IsSubclassOf%2A>ことを示すためのメソッド`DerivedC1`のサブクラスは、`Class1`です。  
  
 [!code-csharp[TestIsSubclassOf\#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> は <see langword="null" /> です。</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="UnicodeClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />に、文字列書式属性として<see langword="UnicodeClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> を使用して、文字列形式の属性を選択します。 文字列形式の属性は、文字列の解釈方法を定義することで相互運用性を向上します。  
  
 場合は、現在 <xref:System.Type> 表します構築ジェネリック型、このプロパティは、型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在 <xref:System.Type> を表します `MyGenericType<int>` \(`MyGenericType(Of Integer)` Visual Basic で\)、によってこのプロパティの値を決定 `MyGenericType<T>`します。  
  
 場合は、現在 <xref:System.Type> このプロパティは常に返しますジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す `false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> が値型かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が値型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値の型は、ビットの数値のシーケンスとして表される型値の型は、クラスまたはインターフェイスではありません。 値の型は、一部のプログラミング言語で「構造体」と呼びます。 列挙型は、値型の特殊なケースです。  
  
 このプロパティを返します`false`の<xref:System.ValueType>クラス、ため<xref:System.ValueType>自体の値型ではありません。 これは、すべての値の型の基本クラスとして任意の値型を割り当てることがそのためです。 これができない場合<xref:System.ValueType>値の型がそれ自体です。 型のフィールドに割り当てられているときに、値の型がボックス化<xref:System.ValueType>です。  
  
 このプロパティを返します`true`列挙体の場合のではなく、<xref:System.Enum>自体を入力します。 この動作を示す例を次を参照してください。<xref:System.Type.IsEnum%2A>です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## 例  
 次の例は、型の変数を作成`MyEnum`、確認、`IsValueType`プロパティ、し、結果を表示します。  
  
 [!code-cpp[Type\_IsValueType\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type\_IsValueType\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type\_IsValueType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Type.IsValueType" /> プロパティを実装するとともに、<see cref="T:System.Type" /> が値型である \(つまり、クラスやインターフェイスでない\) かどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が値型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、代替の型システムの実装を有効にする提供されています。 これはアプリケーション コードでは一般的に使用されません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> にアセンブリの外側のコードからアクセスできるかどうかを示す値を取得します。</summary>
        <value>現在の<see langword="true" /> がパブリック型である場合、またはすべての包含する型がパブリックであるような入れ子にされたパブリック型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを使用して、型がコンポーネント アセンブリのパブリック インターフェイスの一部であるかどうかを判別します。  
  
   
  
## 例  
 次のコード例では、一方のみが、アセンブリ外部から参照できる、2 つのクラスをテストします。  
  
 [!code-cpp[System.Type.IsVisible\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.MakeArrayType%2A>メソッドは実行時に計算は要素型を持つ配列型を生成する方法を提供します。  
  
 **注**共通言語ランタイムではベクトル \(つまり、1 次元配列は常に 0 から始まる\) を区別や多次元配列です。 ベクターは、常に 1 つだけディメンションを持つは、多次元配列を 1 つだけディメンションを持っているのと同じではないです。 このメソッドのオーバー ロードは、ベクター型を作成する場合にのみ使用でき、ベクター型を作成する唯一の方法であります。 使用して、<xref:System.Type.MakeArrayType%28System.Int32%29>多次元配列型を作成するメソッドのオーバー ロードします。  
  
   
  
## 例  
 次のコード例は、配列を作成`ref`\(`ByRef` Visual Basic で\)、およびポインター型の`Test`クラスです。  
  
 [!code-cpp[System.Type.MakeXxxType\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
 または  
  
 現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">配列の次元数。 この数値は 32 以下である必要があります。</param>
        <summary>次元数を指定して現在の型の配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>次元数を指定して現在の型の配列を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.MakeArrayType%2A>メソッドは実行時に計算は要素型を持つ配列型を生成する方法を提供します。  
  
> [!NOTE]
>  共通言語ランタイムではベクトル \(つまり、1 次元配列は常に 0 から始まる\) を区別や多次元配列です。 ベクターは、常に 1 つだけディメンションを持つは、1 つだけディメンションを持つ多次元配列と同じではないです。 このメソッドのオーバー ロードを使用して、ベクター型を作成することはできません。場合`rank`1 の場合は、このメソッドのオーバー ロードが 1 つのディメンションを持つ多次元配列の型を返します。 使用して、<xref:System.Type.MakeArrayType>ベクター型を作成するメソッドのオーバー ロードします。  
  
   
  
## 例  
 次のコード例は、配列を作成`ref`\(`ByRef` Visual Basic で\)、およびポインター型の`Test`クラスです。  
  
 [!code-cpp[System.Type.MakeXxxType\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> が正しくありません。 たとえば、0 または負の値です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
 または  
  
 現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。  
  
 または  
  
 <paramref name="rank" /> が 32 を超えています。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see langword="ref" /> パラメーター \(Visual Basic の場合は <see langword="ByRef" /> パラメーター\) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>
          <see langword="ref" /> パラメーター \(Visual Basic の場合は <see langword="ByRef" /> パラメーター\) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.MakeByRefType%2A>メソッドを生成する方法を提供する`ref`型 \(`ByRef` Visual Basic で\) パラメーター リストが表示されます。  
  
 場合は、Microsoft intermediate language \(MSIL\) の構文を使用して、現在<xref:System.Type>オブジェクトが表す<xref:System.Int32>、このメソッドが戻る、<xref:System.Type>オブジェクトを表す`Int32&`です。  
  
   
  
## 例  
 次のコード例、配列の作成`ref`\(`ByRef` Visual Basic で\)、およびポインター型の`Test`クラスです。  
  
 [!code-cpp[System.Type.MakeXxxType\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
 または  
  
 現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">現在のジェネリック型の型パラメーターに置き換えられる型の配列。</param>
        <summary>型の配列の要素を現在のジェネリック型定義の型パラメーターで置き換え、結果の構築型を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>
          <paramref name="typeArguments" /> の要素を現在のジェネリック型の型パラメーターで置き換えることによって作られる構築型を表す <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.MakeGenericType%2A> メソッドでは、特定の種類を作成するため、ジェネリック型定義の型パラメーターに代入するコードを記述することができます、 <xref:System.Type> を特定の構築型を表すオブジェクト。 これを行うこともできます <xref:System.Type> 構築された型の実行時のインスタンスを作成するオブジェクト。  
  
 型を使用して構築 <xref:System.Type.MakeGenericType%2A> 開くことができる、型引数の一部は、外側のジェネリック メソッドや型の型パラメーターを指定できます。 動的アセンブリを生成するときに、このようなオープン構築型を使用する場合があります。 たとえば、クラス `Base` と `Derived` 次のコードにします。  
  
 [!code-cpp[System.Type.MakeGenericType\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 生成する `Derived` 、動的アセンブリではその基本データ型を構築する必要です。 これを行うには、呼び出し、 <xref:System.Type.MakeGenericType%2A> メソッドを <xref:System.Type> クラスを表すオブジェクト `Base`, 、ジェネリック型引数を使用して <xref:System.Int32> 、型パラメーター `V` から `Derived`します。 型およびジェネリック型パラメーターの両方がによって表されるので <xref:System.Type> オブジェクトの両方を含む配列に渡すことが、 <xref:System.Type.MakeGenericType%2A> メソッドです。  
  
> [!NOTE]
>  ように構築された型 `Base<int, V>` 有益とは、コードの出力が、呼び出すことはできません、 <xref:System.Type.MakeGenericType%2A> この型のメソッドがジェネリック型定義ではないためです。 インスタンス化できるクローズ構築型を作成するには、まず、 <xref:System.Type.GetGenericTypeDefinition%2A> 取得するメソッド、 <xref:System.Type> 、ジェネリック型定義を表すオブジェクトを呼び出します <xref:System.Type.MakeGenericType%2A> 目的の型引数を使用します。  
  
 <xref:System.Type> によって返されるオブジェクト <xref:System.Type.MakeGenericType%2A> と同じ、 <xref:System.Type> 呼び出すことによって取得、 <xref:System.Object.GetType%2A> 、生成されたメソッドの構築型、または <xref:System.Object.GetType%2A>のいずれかのメソッドは、同じの型引数を使用して、同じジェネリック型定義から作成された型を構築します。  
  
> [!NOTE]
>  ジェネリック型の配列自体ではなく、ジェネリック型。 呼び出すことができない <xref:System.Type.MakeGenericType%2A> など、配列で入力 `C<T>[]` \(`Dim ac() As C(Of T)` Visual Basic で\)。 クローズ ジェネリック型を構築する `C<T>[]`, 、呼び出す <xref:System.Type.GetElementType%2A> ジェネリック型定義を取得する `C<T>`; を呼び出す <xref:System.Type.MakeGenericType%2A> 上に構築された型を作成し、最後を呼び出して、ジェネリック型定義、 <xref:System.Type.MakeArrayType%2A> 配列型の作成に構築された型のメソッドです。 ポインター型の場合も同様ですし、 `ref` 型 \(`ByRef` Visual Basic で\)。  
  
 一般的なリフレクションで使用される用語に対するインバリアント条件の一覧は、次を参照してください。、 <xref:System.Type.IsGenericType%2A> プロパティ解説します。  
  
## 入れ子にされた型  
 ジェネリック型を定義する場合 c\#、C\+\+、または Visual Basic を使用して、入れ子にされた型はすべてジェネリックです。 これは、入れ子にされた型には、独自の型パラメーターがあるないため、3 つすべての言語は、入れ子にされた型の型パラメーター リストの包含する型の型パラメーターを含む場合でも当てはまります。 次のクラスを考慮してください。  
  
 [!code-cpp[System.Type.MakeGenericType\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 入れ子になったクラスの型パラメーター リスト `Inner` 2 つの型パラメーターを持ちます `T` と `U`, 、まずその外側のクラスの型パラメーターであります。 入れ子になったクラスの型パラメーター リスト同様に、 `Innermost1` 3 つの型パラメーターを持ちます `T`, 、`U`, と `V`, と `T` と `U` 、外側のクラスに由来します。 入れ子になったクラス `Innermost2` 2 つの型パラメーターを持つ `T` と `U`, 、その外側のクラスから発生します。  
  
 外側の型のパラメーター リストは、1 つ以上の型パラメーターを持つ、入れ子にされた型の型パラメーター リスト内の順序ですべての型パラメーターが含まれます。  
  
 入れ子にされた型のジェネリック型定義からジェネリック型を構築するには、呼び出し、 <xref:System.Type.MakeGenericType%2A> すべての包含する型、最も外側のジェネリック型で始まると、入れ子になったの型引数の配列で終了するまでの型引数の配列を連結して形成される配列を持つメソッド型自体には、独自の型パラメーターがある場合。 インスタンスを作成する `Innermost1`, を呼び出す、 <xref:System.Type.MakeGenericType%2A> T、U、および V に割り当てるには、次の 3 つの型を含む配列を持つメソッドです。インスタンスを作成する `Innermost2`, を呼び出す、 <xref:System.Type.MakeGenericType%2A> T と U に割り当てるには、2 つの型を含む配列を持つメソッド  
  
 言語は、外側の型のこのような形で外側の型の型パラメーターを使用するには入れ子にされた型のフィールドを定義するための型パラメーターを伝達します。 それ以外の場合、型パラメーターは、入れ子にされた型の本文内のスコープにはできません。 外側の型の動的アセンブリ内のコードを出力するかを使用して、型パラメーターを伝達することがなく、入れ子にされた型を定義することは、 [Ilasm.exe \(IL Assembler\)](http://msdn.microsoft.com/ja-jp/4ca3a4f0-4400-47ce-8936-8e219961c76f)です。 MSIL アセンブラーは、次のコードを考慮してください。  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 この例では型のフィールドを定義する `T` または `U` クラスで `Innermost`, 、これらの型パラメーターがスコープに存在しないためです。 次のアセンブラー コードでは、C\+\+、Visual Basic および c\# で定義されている場合と同じように動作する入れ子になったクラスを定義します。  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 使用することができます、 [Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b) 高級言語で定義されている入れ子になったクラスを確認し、この名前付け方法を確認します。  
  
   
  
## 例  
 次の例では、 <xref:System.Type.MakeGenericType%2A> のジェネリック型定義から構築された型を作成する方法、 <xref:System.Collections.Generic.Dictionary%602> 型です。 構築された型を表す、 <xref:System.Collections.Generic.Dictionary%602> の `Test` 文字列キーを持つオブジェクト。  
  
 [!code-cpp[System.Type.BindGenericParameters\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型はジェネリック型の定義を表していません。 つまり、<see cref="P:System.Type.IsGenericTypeDefinition" /> は <see langword="false" /> を返します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> が <see langword="null" /> です。  
  
 または  
  
 <paramref name="typeArguments" /> のいずれかの要素が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArguments" /> 内の要素数は現在のジェネリック型定義の型パラメーター数と同じではありません。  
  
 または  
  
 <paramref name="typeArguments" /> のいずれかの要素が、現在のジェネリック型の対応する型パラメーターに指定された制約を満たしていません。  
  
 または  
  
 <paramref name="typeArguments" /> には、ポインター型 \(<see cref="P:System.Type.IsPointer" /> は <see langword="true" /> を返します\)、参照渡し型 \(<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します\)、または <see cref="T:System.Void" /> である要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の型へのポインターを表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型へのポインターを表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type.MakePointerType%2A>メソッドはパラメーター リストのポインター型を生成する方法を提供します。  
  
 場合は、Microsoft intermediate language \(MSIL\) の構文を使用して、現在<xref:System.Type>オブジェクトが表す<xref:System.Int32>、このメソッドが戻る、<xref:System.Type>オブジェクトを表す`Int32*`です。  
  
   
  
## 例  
 次のコード例は、配列を作成`ref`\(`ByRef` Visual Basic で\)、およびポインター型の`Test`クラスです。  
  
 [!code-cpp[System.Type.MakeXxxType\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
 または  
  
 現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーが型であるか、または入れ子にされた型であるかを示す <see cref="T:System.Reflection.MemberTypes" /> 値を取得します。</summary>
        <value>このメンバーが型であるか、または入れ子にされた型であるかを示す <see cref="T:System.Reflection.MemberTypes" /> 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティのオーバーライド<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=fullName>です。 セットを確認すると、そのため、<xref:System.Reflection.MemberInfo>オブジェクト — たとえば、によって返される配列<xref:System.Type.GetMembers%2A>—、<xref:System.Reflection.MemberInfo.MemberType%2A>プロパティから返される<xref:System.Reflection.MemberTypes.NestedType?displayProperty=fullName>入れ子にされた型が指定されたメンバーの場合。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、型の構築元となるジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`\(`MyGenericType(Of Integer)` Visual Basic で\)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=fullName>です。  
  
   
  
## 例  
 次のコード例は、`MemberType`フィールドへのパラメーターとして、`GetMember`メソッド。  
  
 [!code-cpp[Classic Type.MemberType Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> 情報に不足している値を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、`Missing`パラメーターの既定値を取得するリフレクションの呼び出しに対応するフィールドです。 場合、`Missing`フィールド、パラメーター値が渡され、そのパラメーターの既定値はありません、<xref:System.ArgumentException>がスローされます。  
  
   
  
## 例  
 次のコード例の使用を示しています、`Missing`フィールドを既定の引数を持つメソッドを呼び出します。  
  
 [!code-cpp[Classic Type.Missing Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 このコードを実行すると、次の出力が生成されます。  
  
 10 を \= b 55.3 c \= 12 を \=  
  
 10 を \= b 1.3 c \= 1 を \=  
  
 10 を \= b 1.2 c \= 1 を \=  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が定義されているモジュール \(DLL\) を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> が定義されているモジュールです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、ジェネリック型定義が定義されているモジュールを返します。 インスタンスを作成する場合など`MyGenericStack<int>`、<xref:System.Type.Module%2A>構築された型のプロパティでは、モジュールを返しますを`MyGenericStack<T>`が定義されています。  
  
 同様に場合、現在<xref:System.Type>ジェネリック パラメーターを表す`T`、このプロパティを定義するジェネリック型を含むアセンブリを返します`T`です。  
  
   
  
## 例  
 この次の例を使用して、<xref:System.Type.Namespace%2A>と`Module`プロパティおよび<xref:System.Type.ToString%2A>メソッドの<xref:System.Type>します。  
  
 [!code-cpp[Type\_ToString\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type\_ToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type\_ToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> の名前空間を取得します。</summary>
        <value>
          <see cref="T:System.Type" /> の名前空間。現在のインスタンスに名前空間がない場合、または現在のインスタンスがジェネリック パラメーターを表す場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 名前空間は、論理デザイン時名前付け利便性のため、主に、アプリケーションでスコープを定義し、クラスと他の型に 1 つの階層構造を整理するために使用します。 ランタイムの視点からは、名前空間はありません。  
  
 場合、現在<xref:System.Type>構築されたジェネリック型を表し、このプロパティは、ジェネリック型定義を含む名前空間を返します。 同様に場合、現在<xref:System.Type>ジェネリック パラメーターを表す`T`、このプロパティを定義するジェネリック型定義を含む名前空間が返されます`T`です。  
  
 場合、現在<xref:System.Type>オブジェクトは、ジェネリック パラメーターを表す、このプロパティを返します`null`です。  
  
   
  
## 例  
 この次の例を使用して、`Namespace`と<xref:System.Type.Module%2A>プロパティおよび<xref:System.Type.ToString%2A>メソッドの<xref:System.Type>します。  
  
 [!code-cpp[Type\_ToString\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type\_ToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type\_ToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Type" /> オブジェクトが等しいかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> に等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Type" /> オブジェクトが等しくないかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> と等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーを取得するために使用したクラス オブジェクトを取得します。</summary>
        <value>この <see langword="Type" /> オブジェクトを取得するために使用した <see cref="T:System.Type" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Type>オブジェクト、このプロパティの値は、の値と同じでは常に、<xref:System.Type.DeclaringType%2A>プロパティです。  
  
   
  
## 例  
 この例では、入れ子になったクラスのリフレクションされた型を表示します。  
  
 [!code-cpp[Classic Type.ReflectedType Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する <see cref="T:System.Type" /> のアセンブリ修飾名。</param>
        <param name="throwIfNotFound">型が見つからない場合に <see cref="T:System.TypeLoadException" /> をスローするには <see langword="true" />。型が見つからない場合に <see langword="null" /> を返すには <see langword="false" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」セクションを参照してください。</param>
        <param name="ignoreCase">大文字と小文字を区別せずに <c>typeName</c> の検索を実行するには <see langword="true" />。大文字と小文字を区別して <c>typeName</c> の検索を実行するには <see langword="false" />。</param>
        <summary>大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <see cref="T:System.Type" /> を取得します。 型は実行ではなくリフレクションのためだけに読み込まれます。</summary>
        <returns>存在する場合は、指定した名前を持つ型。それ以外の場合は <see langword="null" />。 型が見つからない場合、<paramref name="throwIfNotFound" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwIfNotFound" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して型を含むアセンブリがリフレクションのみのコンテキスト読み込まれない場合、<xref:System.Type.ReflectionOnlyGetType%2A>メソッドは、最初のと同じアセンブリの読み込み、リフレクションのためだけを使用して、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>メソッド、およびアセンブリの呼び出すことによって、型を読み込む<xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>メソッドです。 アセンブリ修飾名については、次を参照してください。、<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName>プロパティです。 型名の指定の詳細については、次を参照してください。、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
 アセンブリが既に実行のために読み込まれている場合は、別のコピーがリフレクションのみのコンテキストに読み込まれます。  
  
 `throwIfNotFound`パラメーターは、例外のセクションで説明した型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。 値に関係なく一部の例外がスローされた`throwIfNotFound`です。 たとえば、アセンブリが有効でない場合、<xref:System.BadImageFormatException>スローされる場合でも`throwIfNotFound`は`false`します。  
  
 詳細については、リフレクションのみのコンテキストを使用して、次を参照してください。[How to: Load Assemblies into the Reflection\-Only Context](http://msdn.microsoft.com/ja-jp/9818b660-52f5-423d-a9af-e75163aa7068)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> が <see langword="true" /> です。型が見つかりません。  
  
 または  
  
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。埋め込まれたタブなどの正しくない文字が <paramref name="typeName" /> に含まれています。  
  
 または  
  
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。  
  
 または  
  
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。<paramref name="typeName" /> は正しくないサイズの配列型を表します。  
  
 または  
  
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> オブジェクトの配列を表しています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> にはアセンブリ名は含まれません。  
  
 または  
  
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。<paramref name="typeName" /> に正しくない構文 \("MyType\[,\*,\]" など\) が含まれています。  
  
 または  
  
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
 \-または\-  
  
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
 \-または\-  
  
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリ、またはその依存関係のうちの 1 つは見つかりましたが、読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のレイアウトを説明する <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> を取得します。</summary>
        <value>現在の型のレイアウト機能全体を説明する <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> を取得します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> によって返されない、 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドです。 代わりに、このプロパティを使用して、それを取得します。  
  
   
  
## 例  
 次のコード例は、まず、クラス、構造体、および特殊なレイアウト属性 \(構造体は、クラス内で入れ子になった\) を含む構造体を定義します。 使用して、 <xref:System.Type.StructLayoutAttribute%2A> を取得するプロパティ、 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 各型、および属性のプロパティを表示します。  
  
 [!code-cpp[Type.StructLayoutAttribute\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetIDsOfNames`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインター。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 \(0 または 1\) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfoCount`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::Invoke`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see langword="String" /> の名前を表す <see langword="Type" /> を返します。</summary>
        <returns>現在の <see cref="T:System.String" /> の名前を表す <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、すべてのプリミティブ型の名前と共通言語ランタイムの完全修飾名前空間を返します。 たとえば、c\# 命令は、 `(long)0.Type().ToString()` "Int64"だけではなく"System.Int64"を返します。  
  
 場合、現在<xref:System.Type>名前空間と入れ子にされた型がアセンブリではなく、ジェネリック型、型と型引数が修飾名を表します。 場合、現在<xref:System.Type>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターが、型パラメーターの非修飾名を返します。  
  
   
  
## 例  
 この次の例を使用して、<xref:System.Type.Namespace%2A>と<xref:System.Type.Module%2A>プロパティおよび`ToString`メソッドの<xref:System.Type>します。  
  
 [!code-cpp[Type\_ToString\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type\_ToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type\_ToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 次の例で返される文字列の比較、<xref:System.Type.ToString%2A>メソッドおよび`Name`、 <xref:System.Type.FullName%2A>、および<xref:System.Type.AssemblyQualifiedName%2A>プロパティです。  
  
 [!code-csharp[System.Type.ToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のハンドルを取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> のハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `TypeHandle`型を表す内部データ構造体へのポインターをカプセル化します。 このハンドルは、プロセスの有効期間中には一意です。 ハンドルは、取得されているアプリケーション ドメイン内でのみ有効です。  
  
   
  
## 例  
 次の例では、対応する型のハンドルを返し、ハンドルをハンドルから型を取得し、それを表示するメソッドに渡します。  
  
 [!code-cpp[Type\_TypeHandle\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type\_TypeHandle\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type\_TypeHandle\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在、.NET Compact Framework は、このプロパティをサポートしていません。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の初期化子を取得します。</summary>
        <value>
          <see cref="T:System.Type" /> のクラス コンストラクターの名前を格納するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クラス初期化子は、使用、<xref:System.Type.FindMembers%2A>メソッド、またはのオーバー ロードを通じて、 <xref:System.Type.GetMember%2A>、 <xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetConstructor%2A>、および<xref:System.Type.GetConstructors%2A>受け取るメソッドを<xref:System.Reflection.BindingFlags>パラメーターとして。  
  
 場合、現在<xref:System.Type>このプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`null`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型を表す共通言語ランタイムによって提供された型を示します。</summary>
        <value>
          <see cref="T:System.Type" /> の基になるシステム型。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のメンバーのうち、指定したメンバーを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> 内で入れ子になっている特定の型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のコンストラクターを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で実装または継承されている特定のインターフェイスを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> 内で入れ子になっている型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のメソッドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したクラス識別子 \(CLSID\) に関連付けられている型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のプロパティを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の型の配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のプロパティを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された型を表す <see cref="T:System.Type" /> オブジェクトを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の基になるシステム型が、指定した <see cref="T:System.Object" /> または <see cref="T:System.Type" /> の基になるシステム型と同じかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のコンストラクターを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のフィールドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のメンバーを呼び出します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のメソッドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のメンバー \(プロパティ、メソッド、フィールド、イベントなど\) を取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したプログラム ID \(ProgID\) に関連付けられている型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のフィールドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で宣言または継承されているイベントを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で宣言または継承されている特定のイベントを取得します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>