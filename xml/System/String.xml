<Type Name="String" FullName="System.String">
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>テキストを一連の UTF\-16 コード単位として表現します。  
  
 この型の .NET Framework ソース コードを参照するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/string.cs#8281103e6f23cb5c)です。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを表示するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/string.cs#8281103e6f23cb5c)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース \(パッチや更新を含む\) をステップsee [instructions](http://referencesource.microsoft.com/).  
  
 文字列は、テキストを表現するために使用される文字のシーケンシャル コレクションです。 A<xref:System.String>オブジェクトは、シーケンシャル コレクションの<xref:System.Char?displayProperty=fullName>オブジェクトを表す文字列です。<xref:System.Char?displayProperty=fullName>オブジェクトは utf\-16 コード単位に対応します。 値、<xref:System.String>オブジェクトのシーケンシャル コレクションの内容は、<xref:System.Char?displayProperty=fullName>オブジェクト、および値が変更可能である \(つまり、これが読み取り専用\)。 文字列の不変性に関する詳細については、次を参照してください。、[不変性と StringBuilder クラス](#Immutability)このトピックで後述します。 最大サイズ、<xref:System.String>メモリ内のオブジェクトが 2 GB、または約 10億文字です。  
  
 このセクションの内容:  
  
 [文字列オブジェクトをインスタンス化します。](#Instantiation)   
 [Char 型のオブジェクトと Unicode 文字](#Characters)   
 [文字列と Unicode 標準](#Unicode)   
 [文字列と埋め込まれた null 文字](#EmbeddedNulls)   
 [文字列とインデックス](#Indexes)   
 [Null 文字列と空の文字列](#Nulls)   
 [不変性と StringBuilder クラス](#Immutability)   
 [カルチャに依存する操作との序数](#CultureSensitive)   
 [正規化](#Normalization)   
 [カテゴリ別の文字列操作](#ByCategory)  
  
<a name="Instantiation"></a>   
## 文字列オブジェクトをインスタンス化します。  
 インスタンス化、<xref:System.String>次の方法でオブジェクト。  
  
-   文字列リテラルを割り当てることによって、<xref:System.String>変数。 これは、文字列を作成するための最も一般的に使用されるメソッドです。 次の例では、割り当てを使用して、いくつかの文字列を作成します。 C\# の場合は、円記号 \(\\\) が、エスケープ文字、文字列にリテラル円記号をエスケープする必要がありますか、または @\-引用符で囲まれた文字列全体をする必要がありますに注意してください。  
  
     [!code-cpp[System.String.Class.Instantiate\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   呼び出して、<xref:System.String>クラスのコンス トラクターです。 次の例では、いくつかのクラスのコンス トラクターを呼び出すことによって文字列がインスタンス化します。 文字配列またはパラメーターとして符号付きバイト配列へのポインターを含むコンス トラクターの一部に注意してください。 Visual Basic は、これらのコンス トラクターの呼び出しをサポートしていません。 詳細については<xref:System.String>コンス トラクターを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要です。  
  
     [!code-cpp[System.String.Class.Instantiate\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   文字列連結演算子を使用して \(\+、C\# の場合と \>\/documents\/report1.rdl」のまたは \+ Visual Basic で\) の任意の組み合わせから 1 つの文字列を作成する<xref:System.String>インスタンスと文字列リテラルです。 次の例では、文字列連結演算子の使用を示します。  
  
     [!code-cpp[System.String.Class.Instantiate\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   プロパティを取得するか、メソッドを呼び出すとしている文字列を返します。 次の例のメソッドを使用して、<xref:System.String>大きな文字列から部分文字列を抽出するクラス。  
  
     [!code-cpp[System.String.Class.Instantiate\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   値またはオブジェクトを文字列形式に変換する書式指定メソッドを呼び出します。 次の例では、[複合書式指定](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)を文字列に 2 つのオブジェクトの文字列形式を埋め込む機能です。  
  
     [!code-cpp[System.String.Class.Instantiate\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## Char 型のオブジェクトと Unicode 文字  
 文字列内の各文字は、Unicode コード ポイントまたは Unicode 文字の序数 \(数値\) 値とも呼ばれます、Unicode スカラー値によって定義されます。 各コード ポイントは utf\-16 エンコーディングを使用してエンコードされており、エンコーディングの各要素の数値として表されます、<xref:System.Char>オブジェクト。  
  
> [!NOTE]
>  注意してください。、 <xref:System.String> utf\-16 コード単位のシーケンシャル コレクションのインスタンスを構成、作成することは、<xref:System.String>整形式の Unicode 文字列ではないオブジェクトです。 たとえば、対応する上位サロゲートせず、下位サロゲートを含む文字列を作成することはできます。 エンコードとデコード内のオブジェクトのメソッドなど、いくつかの方法、<xref:System.Text>名前空間がチェックを実行して文字列が整形式であることを確認<xref:System.String>クラスのメンバーは、文字列が整形式であることを確認できません。  
  
 1 つ<xref:System.Char>オブジェクトは通常、1 つを表すコード ポイントです。 つまり、の数値、<xref:System.Char>コード ポイントに等しい。 たとえば、コード ポイントの文字"a"は U \+0 0061 です。 ただし、コード ポイントがエンコードされた 1 つ以上の要素を必要があります \(1 つ以上<xref:System.Char>オブジェクト\)。 Unicode 標準を複数の対応する文字の 2 種類の定義<xref:System.Char>オブジェクト: graphemes、および Unicode の補助平面内の文字に対応する Unicode 補助コード ポイント。  
  
-   書記素は、基本文字の後に 1 つまたは複数の結合文字で表されます。 Ä 文字が a でどのように表されるなど、<xref:System.Char>オブジェクト コード ポイントは U \+0 0061 a 続けて<xref:System.Char>コード ポイントが u\+0308 オブジェクト。 この文字は、1 つで定義することも<xref:System.Char>U \+0 00E4 のコード ポイントを持つオブジェクトです。 次の例に示す、等しいかどうかのカルチャに依存した比較ことを示しますこれら 2 つの表現と等しい場合は、通常の序数に基づく比較はありません。 ただし、2 つの文字列は、正規化された場合、序数に基づく比較もあることを示します等しい。 \(文字列を正規化する方法については、次を参照してください、[正規化](#Normalization)セクションです。\)。  
  
     [!code-cpp[System.String.Class\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   補助コード ポイント \(サロゲート ペア\) として表されます Unicode を<xref:System.Char>コード ポイントが上位サロゲート オブジェクトが続くを<xref:System.Char>コード ポイントが下位サロゲートであるオブジェクト。 高サロゲート範囲が u\+d800 から U\+DBFF のコード単位です。 低サロゲート範囲が u\+dc00 から U\+DFFF のコード単位です。 サロゲート ペアは、16 の Unicode 補助平面内の文字を表すために使用されます。 次の例は、サロゲート文字を作成しに渡します、<xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=fullName>サロゲート ペアであるかどうかを調べます。  
  
     [!code-cpp[System.String.Class\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## 文字列と Unicode 標準  
 文字列の文字に対応する utf\-16 でエンコードされたコード単位で表される<xref:System.Char>値。  
  
 文字列内の各文字が、関連付けられている Unicode 文字カテゴリで .NET Framework で表現される、<xref:System.Globalization.UnicodeCategory>列挙します。 文字またはサロゲート ペアのカテゴリを呼び出すことで決定できます、<xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=fullName>メソッドです。  
  
 .NET Framework では、文字と、対応するカテゴリのさまざまなプラットフォームで実行されている .NET Framework のバージョンが同一文字カテゴリ情報を返すことを実行できるように独自のテーブルを保持します。 次の表には、.NET Framework のバージョンと文字カテゴリを基になる Unicode 標準のバージョンが一覧表示します。  
  
|.NET Framework のバージョン|Unicode 標準のバージョン|  
|---------------------------|----------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[The Unicode Standard, Version 4.0.0](http://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[The Unicode Standard, Version 8.0.0](http://www.unicode.org/versions/Unicode8.0.0/)|  
  
 さらに、.NET Framework は、文字列比較をサポートし、Unicode 標準に基づく並べ替え。 を介して、.NET Framework のバージョンでは、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、.NET Framework が独自の文字列データのテーブルを保持します。 以降の .NET Framework のバージョンの場合は true。 これはまた、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 7 で実行されています。 以降で、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]ウィンドウ 8 および Windows オペレーティング システムの以降のバージョンで実行されている、実行時デリゲート文字列の比較と並べ替え、オペレーティング システムを操作します。 次の表には、.NET Framework のバージョンとは、どの文字比較と並べ替えの基に、Unicode 規格のバージョンが一覧表示します。  
  
|.NET Framework のバージョン|Unicode 標準のバージョン|  
|---------------------------|----------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[The Unicode Standard, Version 4.0.0](http://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]Windows 7 以降|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]および Windows 8 以降の Windows オペレーティング システムでそれ以降|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
  
<a name="EmbeddedNulls"></a>   
## 文字列と埋め込まれた null 文字  
 .NET Framework で、<xref:System.String>オブジェクトは、文字列の長さの一部としてカウント埋め込まれた null 文字を含めることができます。 ただし、C や C\+\+ などの一部の言語で null 文字は、文字列の末尾を示す以外の場合は、文字列の一部ではありませんし、文字列の長さの一部としてはカウントされません。 つまり、C および C\+\+ プログラマまたは C または C\+\+ で記述されたライブラリ行うことが文字列の次の一般的な前提条件に適用すると、必ずしも無効である<xref:System.String>オブジェクト。  
  
-   によって返される値、`strlen`または`wcslen`関数が必ずしもと等しくない<xref:System.String.Length%2A?displayProperty=fullName>です。  
  
-   によって作成される文字列、`strcpy_s`または`wcscpy_s`関数が必ずしも同じによって作成される文字列ではありません、<xref:System.String.Copy%2A?displayProperty=fullName>メソッドです。  
  
 そのネイティブ C および C\+\+ コードをインスタンス化することを確認する必要があります<xref:System.String>オブジェクト、および渡されるコード<xref:System.String>プラットフォームを使用したオブジェクトの起動は、埋め込みの null 文字が文字列の末尾をマークすることは限りません。  
  
 文字列に埋め込まれた null 文字も扱い文字列が並べ替えられます \(またはと比較して\)、および文字列を検索します。 インバリアント カルチャを使用する比較を含む 2 つの文字列のカルチャに依存した比較を実行するときに、null 文字は無視されます。 序数に基づくまたは区別しない序数に基づく比較ののみと見なされます。 その一方で、埋め込まれた null 文字は常に考慮などのメソッドに文字列を検索するときに<xref:System.String.Contains%2A>、 <xref:System.String.StartsWith%2A>、および<xref:System.String.IndexOf%2A>です。  
  
<a name="Indexes"></a>   
## 文字列とインデックス  
 インデックスの位置とは、<xref:System.Char>内のオブジェクト \(Unicode 文字ではない\)、<xref:System.String>です。 インデックスとは、0 から始まる、負でない番号を文字列で、インデックス位置 0 は、最初の位置から開始します。 いくつかの検索方法など<xref:System.String.IndexOf%2A>と<xref:System.String.LastIndexOf%2A>文字のインデックスを返しますまたは、文字列インスタンスで文字列を指定します。  
  
 <xref:System.String.Chars%2A>プロパティでは、個別にアクセスできます。<xref:System.Char>文字列内のインデックス位置でのオブジェクト。<xref:System.String.Chars%2A>プロパティ \(Visual Basic\) の既定のプロパティまたはインデクサー \(C\# の場合\) は、個別にアクセスすることができます<xref:System.Char>次のようなコードを使用して、文字列内のオブジェクト。 このコードは、空白文字または文字列に含まれる文字数を判断するための文字列の区切り文字を検索します。  
  
 [!code-cpp[System.String.Class\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 <xref:System.String>クラスが実装する、<xref:System.Collections.IEnumerable>インターフェイスも反復処理できる、<xref:System.Char>を使用して、文字列内のオブジェクト、`foreach`構築は、次の例のようにします。  
  
 [!code-cpp[System.String.Class\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 文字は、Unicode でエンコードされた 1 つ以上にするため、連続したインデックス値は連続する Unicode 文字に対応しない可能性があります<xref:System.Char>オブジェクト。 具体的には、文字列には、テキストの文字の後に 1 つまたは複数の結合文字またはサロゲート ペアで形成される複数の文字の単位があります。 代わりに Unicode 文字を使用する<xref:System.Char>オブジェクトを使用しての<xref:System.Globalization.StringInfo?displayProperty=fullName>と<xref:System.Globalization.TextElementEnumerator>クラスです。 次の例は、コードで動作する違いを示しています。<xref:System.Char>オブジェクトと Unicode 文字を操作するコードです。 文字または文の各単語のテキスト要素の数を比較します。 文字列には、基本文字、組み合わせ文字の 2 つのシーケンスが含まれています。  
  
 [!code-cpp[System.String.Class\#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 この例を使用して、テキスト要素では処理、<xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=fullName>メソッドおよび<xref:System.Globalization.TextElementEnumerator>文字列内のすべてのテキスト要素を列挙するクラス。 呼び出すことによってテキストの各要素の開始インデックスを含む配列を取得することも、<xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=fullName>メソッドです。  
  
 個人ではなくテキスト単位の使用の詳細については<xref:System.Char>値を参照してください、<xref:System.Globalization.StringInfo>クラスです。  
  
<a name="Nulls"></a>   
## Null 文字列と空の文字列  
 宣言されていますが、値が割り当てられていない文字列が`null`です。 その文字列に対するメソッドの呼び出しを試みるとスロー、<xref:System.NullReferenceException>です。 Null 文字列とは異なる値が文字列である空の文字列""または<xref:System.String.Empty?displayProperty=fullName>です。 場合によっては、メソッド呼び出しで引数として文字列を null または空の文字列のいずれかを渡すことによってスローされる例外。 たとえば、null 文字列を渡すこと、<xref:System.Int32.Parse%2A?displayProperty=fullName>メソッドがスローされます、<xref:System.ArgumentNullException>がスローされます、空の文字列を渡すと、<xref:System.FormatException>です。 それ以外の場合に、メソッド引数は、null 文字列または空の文字列のいずれかを指定できます。 たとえば、提供している場合、<xref:System.IFormattable>と同じ null 文字列と空の文字列の両方で \[全般\] \("G"\) 書式指定子とするクラスの実装、します。  
  
 <xref:System.String>クラスには、文字列があるかどうかをテストすることができるようにする次の 2 つの便利なメソッドが含まれています。`null`または空。  
  
-   <xref:System.String.IsNullOrEmpty%2A>、文字列のいずれかの形式があるかどうかを示します`null`かと等しい<xref:System.String.Empty?displayProperty=fullName>です。 このメソッドは、次のようなコードを使用する必要を排除できます。  
  
     [!code-cpp[System.String.Class.Null\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>、文字列の形式があるかどうかを示します`null`、equals <xref:System.String.Empty?displayProperty=fullName>、または空白文字のみで構成されています。 このメソッドは、次のようなコードを使用する必要を排除できます。  
  
     [!code-cpp[System.String.Class.Null\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 次の例では、<xref:System.String.IsNullOrEmpty%2A>メソッドで、 <xref:System.IFormattable.ToString%2A?displayProperty=fullName> 、カスタムの実装`Temperature`クラスです。 メソッドは、"G"、"C"、"F"および"K"書式指定文字列をサポートします。 空の書式指定文字列または形式の文字列値を持つ場合は、`null`渡される、メソッドにその値が"G"書式指定文字列に変更します。  
  
 [!code-cpp[System.String.Class.Null\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## 不変性と StringBuilder クラス  
 A<xref:System.String>オブジェクトは不変と呼ばれる \(読み取り専用\) が作成された後、その値を変更できないためです。 表示を変更する方法、<xref:System.String>オブジェクトは実際には、新しい返す<xref:System.String>変更を含むオブジェクトです。  
  
 文字列は変更できないため文字列操作ルーチンを実行するには、追加または削除する 1 つの文字列が大幅なパフォーマンスの低下を正確に表示される内容が繰り返されます。 たとえば、次のコードは、0x0001 に 0x052F の範囲の 1000 文字に文字列を作成するのに乱数ジェネレーターを使用します。 という名前の既存の文字列に文字を追加する文字列の連結を使用するように見えますが、コード`str`、実際に作成、新しい<xref:System.String>各連結操作のオブジェクト。  
  
 [!code-cpp[System.String.Class\#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class\#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class\#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 使用することができます、<xref:System.Text.StringBuilder>クラスの代わりに、<xref:System.String>文字列の値に複数の変更を構成する操作のクラスです。 インスタンスとは異なり、<xref:System.String>クラス、<xref:System.Text.StringBuilder>オブジェクトが変更可能です。 1 つの文字列で行われる連結、追加、または文字列から部分文字列を削除するときにします。 値の変更が完了したらを<xref:System.Text.StringBuilder>オブジェクトを呼び出すことができますの<xref:System.Text.StringBuilder.ToString%2A?displayProperty=fullName>を文字列に変換します。 次の例が置き換えられます、<xref:System.String>で 0x052F を 0x0001 に範囲の 1000 ランダムな文字を連結する、前の例で使用される、<xref:System.Text.StringBuilder>オブジェクト。  
  
 [!code-cpp[System.String.Class\#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## カルチャに依存する操作との序数  
 メンバー、<xref:System.String>クラスで序数に基づくか、カルチャ \(言語\) 操作を実行する、<xref:System.String>オブジェクト。 序数に基づく操作の対象とそれぞれの数値に基づいて<xref:System.Char>オブジェクト。 カルチャに依存した操作の値には、機能、<xref:System.String>オブジェクト、およびはカルチャに固有の大文字小文字の区別、並べ替え、書式設定、およびアカウントにルールを解析します。 カルチャに依存する操作は、明示的に宣言されたカルチャまたは現在のカルチャのコンテキストで実行します。 操作の 2 つの種類は、同じ文字列で実行されるときに、非常に異なる結果を生成できます。  
  
 .NET Framework では、インバリアント カルチャを使用してカルチャに依存しない言語的な文字列操作もがサポートしています \(<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName>\)、これは、領域の独立した英語の言語のカルチャ設定に基づいて疎です。 その他のとは異なり<xref:System.Globalization.CultureInfo?displayProperty=fullName>設定、インバリアント カルチャの設定はシステム、および .NET Framework のバージョン間でのシステムからの 1 台のコンピューター上の一貫性を保持することが保証されます。 インバリアント カルチャでは、すべてのカルチャに種類の文字列比較の安定性を保証するための黒いボックスとして表示と順序を存在できます。  
  
> [!IMPORTANT]
>  アプリケーションの場合、ファイル名などのシンボル id のセキュリティを決定や名前付きパイプ、または XML ファイル内のテキスト ベースのデータなどの永続化されたデータは、操作は、カルチャに依存した比較ではなく、序数に基づく比較を使用してください。 これは、序数に基づく比較が比較する文字のバイナリ値にのみ異なりますが、カルチャに依存した比較では、カルチャによって異なる結果を実際には、yield ためです。  
  
> [!IMPORTANT]
>  文字列操作を実行するほとんどのメソッドを型のパラメーターを持つオーバー ロードは、<xref:System.StringComparison>メソッドが序数に基づくまたはカルチャに依存した操作を実行しているかどうかを指定できます。 一般に、クリア呼び出し、メソッドの意図をこのオーバー ロードを呼び出す必要があります。 ベスト プラクティスと文字列の序数とカルチャの操作の使用に関するガイダンスは、次を参照してください。[Best Practices for Using Strings in the .NET Framework](http://msdn.microsoft.com/ja-jp/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7)です。  
  
 操作を[大文字小文字の区別](#casing)、[解析および書式設定](#parsing)、[比較と並べ替え](#comparison)、および[等価性テスト](#equality)序数またはカルチャに依存できます。 次のセクションでは、操作の各カテゴリについて説明します。  
  
> [!TIP]
>  常に呼び出し、クリア、メソッドの意図は、メソッドのオーバー ロードを呼び出す必要があります。 たとえば、呼び出す代わりに、 <xref:System.String.Compare%28System.String%2CSystem.String%29> 、現在のカルチャの規則を使用して 2 つの文字列のカルチャに依存した比較を実行するメソッドを呼び出す必要があります、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>の値を持つメソッド<xref:System.StringComparison.CurrentCulture?displayProperty=fullName>の`comparisonType`引数。 詳細については、「[Best Practices for Using Strings in the .NET Framework](http://msdn.microsoft.com/ja-jp/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7)」を参照してください。  
  
<a name="casing"></a>   
### 大文字小文字の区別  
 大文字小文字の規則は Unicode 文字の大文字と小文字を変更する方法を決定します。たとえばから小文字を大文字にします。 多くの場合、大文字と小文字の操作は、文字列を比較する前に実行されます。 たとえば、別の文字列を大文字で比較ができるように文字列を大文字に変換する可能性があります。 呼び出すことによって小文字文字列内の文字に変換することができます、<xref:System.String.ToLower%2A>または<xref:System.String.ToLowerInvariant%2A>メソッド、およびすることができますに変換したり大文字を呼び出して、<xref:System.String.ToUpper%2A>または<xref:System.String.ToUpperInvariant%2A>メソッドです。 さらに、使用は<xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=fullName>文字列を大文字に変換します。  
  
 大文字と小文字の操作は、現在のカルチャを指定したカルチャまたはインバリアント カルチャの規則に基づくことができます。 大文字小文字マップは、使用するカルチャによって異なることができます、ため、大文字と小文字の操作の結果がカルチャによって異なることができます。 大文字と小文字の実際の相違点は、次の 3 種類のことです。  
  
-   大文字のマッピングに、ラテン語 I CAPITAL LETTER の相違点 \(u\+0049\) ラテン小さい文字 I \(u\+0069\)、LATIN CAPITAL LETTER I \(u\+0130\) 上のドットとラテン小さい文字ドットなし I \(0131 U \+\) です。 TR\-TR \(トルコ語 \(トルコ\)\) と \(アゼルバイジャン、ラテン文字\) の az\-Latn\-AZ カルチャ、および tr、az、および\-az\-latn ニュートラル カルチャで LATIN SMALL 文字ドットなし I、LATIN CAPITAL LETTER I の小文字表現は、ラテン小さい文字 I の大文字表現 LATIN CAPITAL LETTER I とドットの上。 その他のすべてのカルチャで LATIN SMALL 文字 I と同等の大文字と小文字は LATIN CAPITAL LETTER、インバリアント カルチャをなどです。  
  
     次の例は、ファイル システムへのアクセスを防ぐために失敗する場合、カルチャの大文字と小文字の比較に依存しているに設計された、文字列の比較方法を示します。 \(インバリアント カルチャの大文字と小文字の規則が使用されています。\)  
  
     [!code-csharp[System.String.Class\#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class\#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   インバリアント カルチャと他のすべてのカルチャで大文字小文字マップ違いです。 このような場合、インバリアント カルチャの大文字小文字の規則を使用して、文字を大文字または小文字を変更すると、同じ文字を返します。 その他のすべてのカルチャの場合は、別の文字を返します。 一部の影響を受ける文字は、次の表に一覧表示されます。  
  
    |文字|変更した場合|戻り値|  
    |--------|------------|---------|  
    |ミクロン記号 \(U \+0 00B5\)|大文字|ギリシャ語 CAPITAL LETTER MU \(U \+0\-39 C\)|  
    |ラテン文字の大文字、文字ではドット \(U\+0130\) 上|小文字|文字で表されるラテン小 \(U\+0069\)|  
    |ドットなしの LATIN SMALL LETTER $I \(U \+0 0131\)|大文字|文字で表されるラテン文字の大文字 \(U\+0049\)|  
    |LATIN SMALL LETTER 長い S \(U \+0 017F\)|大文字|LATIN CAPITAL LETTER S \(U \+0 0053\)|  
    |キャロン付き文字 Z で LATIN CAPITAL LETTER D \(U \+0 01C 5\)|小文字|キャロン付き LATIN SMALL LETTER DZ \(U \+0 01C 6\)|  
    |結合ギリシャ YPOGEGRAMMENI \(U \+0 0345\)|大文字|ギリシャ語 CAPITAL LETTER IOTA \(0399 U \+\)|  
  
-   ASCII 文字の範囲内で、大文字と小文字が混在ペアの 2 文字の大文字小文字マップの違い。 ほとんどのカルチャで、2 文字、大文字と小文字が混在してペアが等しい等価 2 文字の大文字または小文字の組み合わせにします。 次のカルチャで次の 2 文字のペアの場合は true、digraph に各ケースで比較されます。  
  
    -   "lJ"と"nJ"\(クロアチア語 \(クロアチア\)\) を HR\-HR カルチャでします。  
  
    -   "cH"CS\-CZ \(チェコ語 \(チェコ共和国\)\) と sk\-SK \(スロバキア語 \(スロバキア\)\) のカルチャでします。  
  
    -   "aA"DA\-DK \(デンマーク語 \(デンマーク\)\) のカルチャ。  
  
    -   "cS"、"dZ"、"dZS"、"nY"、"sZ"、"tY"および"zS"HU\-HU \(ハンガリー語 \(ハンガリー\)\) のカルチャ。  
  
    -   "cH"と"lL"es\-es\_tradnl \(スペイン語 \(スペイン、トラディショナル ソート\)\) のカルチャ。  
  
    -   "cH"、"gI"、"kH"、"nG""nH"、"pH"、"qU'、"tH"と"tR"vi VN \(ベトナム語 \(ベトナム\)\) のカルチャ。  
  
     ただし、これらのペアは固定文字列または識別子が一般的ではないために、これらのペアのカルチャに依存した比較が、問題を作成する状態を発生するのにいつもはありません。  
  
 次の例は、大文字小文字の規則のカルチャ文字列を大文字に変換するときに間の違いの一部を示しています。  
  
 [!code-cpp[System.String.Class\#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### 解析および書式設定  
 書式設定と解析は、逆の操作です。 書式指定規則は、解析規則など、日付と時刻の値を文字列形式に変換する方法を決定する一方の文字列形式に日付と時刻や数値など、値を変換する方法を決定します。 書式設定と解析規則の両方には、文化的慣習に依存します。 次の例は、カルチャ固有の日付文字列を解釈するときに生じる可能性のある、あいまいさを示しています。 日付の文字列を生成するために使用されたカルチャの規則がわからなければ、2011 年 1 月 3 日または 2011 年 3 月 1 日の 03\/01\/2011、2011 年 3 月 1 日と 01\/03\/2011 を表すかどうかを知ることはできません。  
  
 [!code-cpp[System.String.Class\#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 同様に、次の例に示す 1 つの文字列は解析操作での規則を使用する、カルチャによって異なる日付を生成できます。  
  
 [!code-cpp[System.String.Class\#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### 文字列比較と並べ替え  
 比較すると、文字列の並べ替え規則には、カルチャが異なります。 たとえば、並べ替え順序は、表音または文字のビジュアル表現に基づいて可能性があります。 東アジア圏の言語では、文字が表意文字の画数と部首によって並べ替えられます。 また、並べ替えは、言語やカルチャで使用されているアルファベットの順序によっても異なります。 たとえば、デンマーク語の文字 "Æ" は、アルファベットでは "Z" の後に位置します。 さらに、または、区別しない比較を実行でき、場合によっては大文字小文字の規則もカルチャによって異なります。 序数に基づく比較は、その一方で、文字列を比較すると、文字列の並べ替えで個別の文字の Unicode コード ポイントを使用します。  
  
 並べ替えに関する規則は、Unicode 文字のアルファベット順とどのように 2 つの文字列を相互に比較を決定します。 たとえば、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=fullName>メソッドに基づく 2 つの文字列を比較し、<xref:System.StringComparison>パラメーター。 パラメーター値が場合<xref:System.StringComparison.CurrentCulture?displayProperty=fullName>をメソッドは、パラメーターの値がある場合に現在のカルチャの規則を使用する言語的な比較を実行<xref:System.StringComparison.Ordinal?displayProperty=fullName>をこのメソッドは、序数に基づく比較を実行します。 そのため、例を次に、現在のカルチャが米国の場合英語、最初の呼び出し、 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=fullName> \(カルチャに依存した比較を使用して\) メソッドが"A","a"未満と見なしますが、\(序数に基づく比較を使用して\)、同じメソッドに 2 番目の呼び出しでは考慮"a""A"より大きい。  
  
 [!code-cpp[System.String.Class\#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET Framework には、word、文字列、および序数の並べ替え規則がサポートされています。  
  
-   単語での並べ替えでは、英数字以外の特定の Unicode 文字には特別な重みが割り当てられる、カルチャに依存した文字列の比較が行われます。 たとえば、ハイフン \(\-\) は、"coop"と"co\-op"、並べ替え済みリストで互いの横に表示されるように割り当てられている重みは非常に小さい場合があります。 一覧については、<xref:System.String>単語の並べ替え規則を使用して 2 つの文字列を比較するメソッドを参照してください、[カテゴリ別の文字列操作](#ByCategory)セクションです。  
  
-   文字列の並べ替えには、カルチャに依存した比較もを実行します。 特殊なケースがないと、英数字以外のすべてのシンボルは英数字のすべての Unicode 文字の前にする点を除いて、単語の並べ替えに似ています。 文字列の並べ替え規則を使用して呼び出すことによって、2 つの文字列を比較することができます、<xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=fullName>を持つメソッド オーバー ロード、`options`がパラメーターには、値が指定されている<xref:System.Globalization.CompareOptions.StringSort?displayProperty=fullName>です。 これは文字列の並べ替え規則を使用して 2 つの文字列を比較する、.NET Framework が提供する唯一の方法であることに注意してください。  
  
-   序数の並べ替えでは、文字列内の各 <xref:System.Char> オブジェクトの数値に基づいて文字列を比較します。 序数に基づく比較は、文字の大文字と小文字のバージョンがあるコード ポイントが異なるため自動的に区別されます。 ただし、ケースが重要ではない場合は、小文字を無視する序数に基づく比較を指定できます。 これは、インバリアント カルチャを使用して、結果に序数に基づく比較を実行することで大文字に文字列の変換と同じです。 一覧については、<xref:System.String>序数の並べ替え規則を使用して 2 つの文字列を比較するメソッドを参照してください、[カテゴリ別の文字列操作](#ByCategory)セクションです。  
  
 カルチャに依存した比較は、明示的または暗黙的に使用する任意の比較、 <xref:System.Globalization.CultureInfo> 、インバリアント カルチャで指定されているを含む、オブジェクト、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName>プロパティです。 暗黙のカルチャは、現在のカルチャで指定されている、<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=fullName>および<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>プロパティです。 アルファベット文字の並べ替え順序ではかなりのばらつきがある \(つまり、対象の文字、<xref:System.Char.IsLetter%2A?displayProperty=fullName>プロパティから返される`true`\) 複数のカルチャでします。 指定することによって、特定のカルチャの規則を使用するカルチャに依存した比較を指定することができます、<xref:System.Globalization.CultureInfo>などオブジェクトの文字列比較メソッドを<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>です。 指定することによって、現在のカルチャの規則を使用するカルチャに依存した比較を指定する<xref:System.StringComparison.CurrentCulture?displayProperty=fullName>、 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=fullName>、またはのメンバーはすべて、<xref:System.Globalization.CompareOptions>以外の列挙<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=fullName>または<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=fullName>の適切なオーバー ロードに、<xref:System.String.Compare%2A>メソッドです。 カルチャに依存した比較は序数比較では、一方の並べ替えは適切です。 序数に基づく比較に適した一般的に 2 つの文字列が等しいかどうかを決定する \(つまり、識別情報を確認するため\) カルチャに依存した比較では、一方です。  
  
 次の例は、カルチャと序数の比較の違いを示しています。 例では、評価の 3 つの文字列、"Apple"、"Æble"および"AEble"、序数に基づく比較と DA\-DK および EN\-US カルチャの規則を使用して \(時の既定のカルチャは、それぞれが、<xref:System.String.Compare%2A>メソッドが呼び出されます\)。 デンマーク語の言語は文字「Æ」個々 の文字として扱いますおよびのでアルファベットでは、"Z"の後に並べ替え、文字列"Æble"が"Apple"を超えています。 ただし、"Æble"がないと見なされます"AEble"に相当"Æble"が"AEble"より大きいも。 EN\-US カルチャでは、文字「Æ」が含まれていないが、"AE"は、"Æble"は、"Apple"よりも"AEble"に等しい少ない理由について説明しますと同等として扱われます。 序数に基づく比較は、その一方で、"AEble"より大きい値を指定するには、"Æble"と"Æble"よりも小さくするには、"Apple"を考慮します。  
  
 [!code-csharp[System.String.Class\#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class\#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 適切な文字列の並べ替えまたは比較方法を選択するのにには、次の一般的なガイドラインを使用します。  
  
-   順序付けるために、文字列をユーザーのカルチャに基づいて、する場合の現在のカルチャの規則に基づいてを注文する必要があります。 ユーザーのカルチャが変更された場合の文字列の並べ替え順序はそれに従って変更もできます。 たとえば、類義語辞典アプリケーションは、ユーザーのカルチャに基づいて単語を常に並べ替える必要があります。  
  
-   する場合は、文字列を並べ替える特定のカルチャの規則に基づいて、する必要があります順序を指定することによって、<xref:System.Globalization.CultureInfo>比較方法をカルチャを表すオブジェクト。 たとえば、アプリケーションでは、特定の言語について説明するように設計、する文字列を並べ替えるその言語を話すのカルチャのいずれかの規則に基づいて。  
  
-   そのまま複数のカルチャで文字列の順序を設定する場合は、インバリアント カルチャの規則に基づく順序か、序数に基づく比較を使用してください。 たとえば、ファイル、プロセス、ミュー テックスの名前を整理する序数の並べ替えを使用して、または、名前付きパイプです。  
  
-   比較については、セキュリティ上の決定 \(ユーザー名が有効かどうか\) などを含むは常にテストを実行する、序数に基づく等しいかどうかのオーバー ロードを呼び出すことによって、<xref:System.String.Equals%2A>メソッドです。  
  
> [!NOTE]
>  カルチャに依存した並べ替えおよび文字列比較で使用されるルール大文字小文字の区別は、.NET Framework のバージョンによって異なります。[!INCLUDE[net_v45](~/includes/net-v45-md.md)]で実行されている、 [!INCLUDE[win8](~/includes/win8-md.md)] Unicode 6.0 標準に準拠しているオペレーティング システム、並べ替え、大文字小文字の区別、正規化、および Unicode 文字に関する情報。 他のオペレーティング システムでは、Unicode 5.0 標準に準拠しています。  
  
 Word、文字列、および序数の並べ替え規則に関する詳細については、次を参照してください。、<xref:System.Globalization.CompareOptions?displayProperty=fullName>トピックです。 各ルールを使用する場合の追加の推奨事項を参照してください[Best Practices for Using Strings in the .NET Framework](http://msdn.microsoft.com/ja-jp/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7)です。  
  
 通常は、呼び出すことはありません文字列などの比較メソッド<xref:System.String.Compare%2A>直接を文字列の並べ替え順序を決定します。 などのメソッドを並べ替えて比較メソッドが呼び出されます代わりに、<xref:System.Array.Sort%2A?displayProperty=fullName>または<xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=fullName>です。 次の例を使用する比較の種類を指定する操作を行いますが文字列比較メソッドを明示的に呼び出さずに 4 つの異なる並べ替え操作 \(単語の並べ替えが現在のカルチャ、インバリアント カルチャを使用して word 並べ替えを序数の並べ替えおよびインバリアント カルチャを使用して文字列の並べ替えを使用して\) を実行します。 並べ替えの種類ごとに、配列内の文字列の一意な順序付けが生成されることに注意してください。  
  
 [!code-cpp[System.String.Class\#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  内部的には、.net Framework では、並べ替えキーを使用して、culturallysensitive 文字列比較をサポートします。 文字列内の各文字には、アルファベット順、大文字と小文字の区別、発音の区別など、さまざまなカテゴリの並べ替えウェイトが指定されます。 並べ替えキーがで表される、<xref:System.Globalization.SortKey>クラス、特定の文字列をこれらの規則のリポジトリを提供します。 アプリでは、多数の検索や並べ替え文字列の同じセットの操作を実行する場合は、生成および格納するために使用するすべての文字列の並べ替えキーによってそのパフォーマンスを向上できます。 並べ替えまたは比較操作が必要な場合、文字列の代わりに並べ替えキーを使用できます。 詳細については、<xref:System.Globalization.SortKey> クラスを参照してください。  
  
 文字列の比較規則を指定しない場合は、並べ替え方法など、<xref:System.Array.Sort%28System.Array%29?displayProperty=fullName>は、文字列のカルチャ、大文字小文字を区別する並べ替えを実行します。 次の例は、現在のカルチャを変更すると、配列の並べ替えられた文字列の順序にどのように影響する方法を示しています。 3 つの文字列の配列を作成します。 最初に、`System.Threading.Thread.CurrentThread.CurrentCulture` プロパティを en\-US に設定し、<xref:System.Array.Sort%28System.Array%29?displayProperty=fullName> メソッドを呼び出します。 これよって、英語 \(米国\) カルチャの並べ替え規則に基づく並べ替え順序が適用されます。 次に、`System.Threading.Thread.CurrentThread.CurrentCulture` プロパティを da\-DK に設定し、再度 <xref:System.Array.Sort%2A?displayProperty=fullName> メソッドを呼び出します。 適用される並べ替え順序が en\-US の並べ替え順序と異なる点に注意してください。これは、デンマーク語 \(デンマーク\) の並べ替え規則が使用されるためです。  
  
 [!code-csharp[Conceptual.Strings.Comparing\#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  文字列を比較する主な目的は、これらが等しいかどうかを呼び出す必要がありますを決定する場合、<xref:System.String.Equals%2A?displayProperty=fullName>メソッドです。 通常、使用する必要があります<xref:System.String.Equals%2A>序数に基づく比較を実行します。<xref:System.String.Compare%2A?displayProperty=fullName>メソッドは、主に文字列を並べ替えます。  
  
 などの文字列検索メソッド、<xref:System.String.StartsWith%2A?displayProperty=fullName>および<xref:System.String.IndexOf%2A?displayProperty=fullName>、またカルチャまたは序数の文字列比較を実行します。 次の例を使用する序数とカルチャに依存した比較の違いを示しています、<xref:System.String.IndexOf%2A>メソッドです。 現在のカルチャが英語 \(米国\) カルチャに依存した検索では、"oe"合字の「œ」と一致する部分文字列と見なします。 検索はソフト ハイフンと同等として処理にソフト ハイフン \(U \+0 00AD\) は、ゼロ幅の文字であるため<xref:System.String.Empty>文字列の先頭で一致を見つけるとします。 序数に基づく検索の場合、一方は一致が見つかりませんいずれの場合。  
  
 [!code-cpp[System.String.Class\#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class\#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class\#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### 文字列の検索  
 などの文字列検索メソッド、<xref:System.String.StartsWith%2A?displayProperty=fullName>と<xref:System.String.IndexOf%2A?displayProperty=fullName>、またカルチャを実行または指定した文字列の文字または部分文字列かどうかを決定する序数に基づく文字列比較が見つかった。  
  
 検索方法、<xref:System.String>など、個々 の文字を検索するクラス、<xref:System.String.IndexOf%2A>メソッド、または文字のセットのいずれかのように、<xref:System.String.IndexOfAny%2A>メソッド、序数に基づく検索を実行します。 呼び出す必要がありますの文字をカルチャに依存した検索を実行する、<xref:System.Globalization.CompareInfo>などのメソッド<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName>または<xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName>です。 序数とカルチャに依存した比較を使用して文字の検索の結果が大きく異なるできることに注意してください。 など、\(U \+ 00 C 6\) が構成済みの Unicode 文字合字の「Æ」などの検索に出現するすべてのコンポーネントが正しい順序で"AE"などの一致があります \(U \+0 041U \+ 0045\)、カルチャに応じて。 次の例は、違いを示しています、<xref:System.String.IndexOf%28System.Char%29?displayProperty=fullName>と<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName>個々 の文字を検索するときの方法です。 合字の「æ」\(U \+0 00E6\) は、文字列内にある「航空写真」EN\-US カルチャの規則を使用する場合は da DK カルチャの規則を使用するときではなくまたは序数に基づく比較を実行するときにします。  
  
 [!code-csharp[System.String.Class\#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class\#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 その一方で、<xref:System.String>を検索する文字ではなく、文字列型のパラメーターは、検索オプションを明示的に指定しない場合カルチャに依存した検索を実行するメソッドをクラス<xref:System.StringComparison>です。 唯一の例外は<xref:System.String.Contains%2A>、序数に基づく検索を実行します。  
  
<a name="equality"></a>   
### 等価性テスト  
 使用して、<xref:System.String.Compare%2A?displayProperty=fullName>並べ替え順序で 2 つの文字列の関係を判断するメソッド。 通常、これは、カルチャに依存した操作です。 これに対しを呼び出す、<xref:System.String.Equals%2A?displayProperty=fullName>等しいかどうかをテストするメソッド。 等しいかどうかテストが通常有効なユーザー名、パスワード、またはファイル システム パスなどのいくつかの既知文字列でユーザー入力を比較するため序数に基づく操作では通常です。  
  
> [!WARNING]
>  呼び出して等価性をテストすることは、<xref:System.String.Compare%2A?displayProperty=fullName>メソッドおよび戻り値が 0 であるかどうかを決定します。 ただし、この方法はお勧めできません。 2 つの文字列が等しいかどうかを判断するのに、1 つのオーバー ロードを呼び出す必要があります、<xref:System.String.Equals%2A?displayProperty=fullName>メソッドです。 優先のオーバー ロードを呼び出すには、いずれかのインスタンス<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>メソッドまたは静的<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッド、両方のメソッドが含まれるため、<xref:System.StringComparison?displayProperty=fullName>比較の種類を明示的に指定するパラメーターです。  
  
 次の例は、カルチャに依存した比較を実行するときにいずれかの代わりに使用する必要があります、序数に等しいかどうかの危険があることを示しています。 この場合、コードの意図は、文字列 FILE:\/\/ で URL の先頭の大文字と小文字を実行することによって FILE:\/\/ または file:\/\/ で始まる Url をファイル システムへのアクセスを禁止するです。 ただし、file:\/\/ で始まる URL をトルコ語 \(トルコ\) のカルチャを使用してカルチャに依存した比較を実行する場合の等価比較、失敗、トルコ語の大文字表現小文字の"i"は「İ」、"I"の代わりにします。 その結果、ファイル システム アクセスは許可されている誤ってです。 その一方で、序数に基づく比較を実行する場合は、等価性の比較は成功し、ファイル システム アクセスが拒否されました。  
  
 [!code-cpp[System.String.Class\#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## 正規化  
 Unicode 文字の一部では、複数の表現があります。 たとえば、次のコード ポイントのいずれか、文字「いずれも」を表すことができます。  
  
-   U \+0 1EAF  
  
-   U \+0 0103 U \+0 0301  
  
-   U \+0 0061 U \+0 0306 U \+0 0301  
  
 1 つの文字の複数の表現には、検索、並べ替え、照合、およびその他の文字列操作が複雑になります。  
  
 Unicode 規格では、そのバイナリ表現のいずれかの Unicode 文字の 1 つのバイナリ表現を返します正規化と呼ばれるプロセスを定義します。 正規化には、異なる規則に従って、正規化形式と呼ばれるいくつかのアルゴリズムを使用できます。 .NET Framework では、C、D、KC、および KD の Unicode 正規化形式をサポートします。 文字列は、同じ正規形で正規化されている、ときに、序数に基づく比較を使用して比較できます。  
  
 序数に基づく比較は対応する Unicode スカラー値のバイナリ比較<xref:System.Char>それぞれの文字列オブジェクト。<xref:System.String>クラスには、次を含む、序数に基づく比較を実行できるメソッドの数が含まれています。  
  
-   オーバー ロード、 <xref:System.String.Compare%2A>、 <xref:System.String.Equals%2A>、 <xref:System.String.StartsWith%2A>、 <xref:System.String.EndsWith%2A>、 <xref:System.String.IndexOf%2A>、および<xref:System.String.LastIndexOf%2A>メソッドを含む、<xref:System.StringComparison>のパラメーターです。 値を指定する場合、このメソッドは序数に基づく比較を実行<xref:System.StringComparison.Ordinal?displayProperty=fullName>または<xref:System.StringComparison.OrdinalIgnoreCase>このパラメーターにします。  
  
-   オーバー ロード、<xref:System.String.CompareOrdinal%2A>メソッドです。  
  
-   既定では、序数に基づく比較を使用するメソッド<xref:System.String.Contains%2A>、 <xref:System.String.Replace%2A>、および<xref:System.String.Split%2A>です。  
  
-   検索する方法を<xref:System.Char>値または内の要素を<xref:System.Char>arrayin 文字列インスタンス。 このような方法には、<xref:System.String.IndexOf%28System.Char%29>と<xref:System.String.Split%28System.Char%5B%5D%29>です。  
  
 呼び出して、文字列が正規形 C に正規化されたかどうかを決定できます、<xref:System.String.IsNormalized?displayProperty=fullName>するか、メソッドを呼び出すことができます、<xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=fullName>文字列は、指定された正規形を正規化するかどうかを調べます。 呼び出すことも、<xref:System.String.Normalize?displayProperty=fullName>正規形 C、または文字列に変換するメソッドを呼び出すことができます、<xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=fullName>文字列を指定された正規形に変換します。 正規化して、文字列の比較に関する詳細な手順については、次を参照してください。、<xref:System.String.Normalize>と<xref:System.String.Normalize%28System.Text.NormalizationForm%29>メソッドです。  
  
 次の例は、文字列の正規化を示しています。 次の 3 つの異なる文字列に 3 つの異なる方法で、文字「ố」を定義し、等しいかどうか序数に基づく比較を使用して、各文字列は、その他の 2 つの文字列によって異なりますを決定します。 各文字列をサポートされている正規化形式に変換し、指定された正規形で各文字列の序数に基づく比較をもう一度実行します。 各ケースでは、等しいかどうかは、2 番目のテストは、文字列が等しいことを示します。  
  
 [!code-cpp[System.String.Class\#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class\#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class\#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 正規化と正規化フォームの詳細については、次を参照してください。<xref:System.Text.NormalizationForm?displayProperty=fullName>をだけでなく[Unicode Standard Annex \#15: Unicode Normalization Forms](http://unicode.org/reports/tr15/)と[Normalization FAQ](http://www.unicode.org/faq/normalization.html) unicode.org web サイトです。  
  
<a name="ByCategory"></a>   
## カテゴリ別の文字列操作  
 <xref:System.String>クラス文字列を比較する、文字列の等価性をテスト、文字を検索するメンバーを提供または文字列の組み合わせ、値の書式設定、文字列のコピー、および文字列の正規化文字列から部分文字列の抽出、文字列を変更する、文字列の部分文字列します。  
  
### 文字列の比較  
 以下を使用して、並べ替え順序におけるそれらの相対位置を決定する文字列を比較することができます<xref:System.String>メソッド。  
  
-   <xref:System.String.Compare%2A>並べ替え順序で 2 番目の文字列を 1 つの文字列の関係を示す整数を返します。  
  
-   <xref:System.String.CompareOrdinal%2A>コード ポイントの比較に基づく 2 番目の文字列を 1 つの文字列の関係を示す整数を返します。  
  
-   <xref:System.String.CompareTo%2A>並べ替え順序で 2 番目の文字列を現在の文字列インスタンスの関係を示す整数を返します。<xref:System.String.CompareTo%28System.String%29>メソッドを提供します<xref:System.IComparable>と<xref:System.IComparable%601>の実装の<xref:System.String>クラスです。  
  
### 文字列の等価性をテストします。  
 呼び出す、 <xref:System.String.Equals%2A> 2 つの文字列が等しいかどうかを判断するメソッド。 インスタンス<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>と静的<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>オーバー ロードを使用して、比較ではカルチャを区別するか、序数に基づくかどうかと、ケースと見なされますまたは無視するかどうかを指定できます。 等しいかどうかのほとんどのテストは、序数に基づくと、\(ファイル システム オブジェクトの場合\) などのシステム リソースへのアクセスを決定する等価性の比較は、序数に基づく必要があります。  
  
### 文字列の文字を検索します。  
 <xref:System.String>クラスには、検索方法の 2 種類が含まれています。  
  
-   返すメソッド、<xref:System.Boolean>特定の部分文字列は文字列のインスタンス上に存在するかどうかを示す値。 ように、 <xref:System.String.Contains%2A>、 <xref:System.String.EndsWith%2A>、および<xref:System.String.StartsWith%2A>メソッドです。  
  
-   文字列インスタンス内の部分文字列の開始位置を示すメソッド。 ように、 <xref:System.String.IndexOf%2A>、 <xref:System.String.IndexOfAny%2A>、 <xref:System.String.LastIndexOf%2A>、および<xref:System.String.LastIndexOfAny%2A>メソッドです。  
  
> [!WARNING]
>  特定の部分文字列ではなく、特定のパターンの文字列を検索する場合は、正規表現を使用する必要があります。 詳細については、「[.NET Framework Regular Expressions](http://msdn.microsoft.com/ja-jp/521b3f6d-f869-42e1-93e5-158c54a6895d)」を参照してください。  
  
### 文字列を変更します。  
 <xref:System.String>クラスには、文字列の値を変更する表示される次のメソッドが含まれています。  
  
-   <xref:System.String.Insert%2A>現在に文字列を挿入<xref:System.String>インスタンス。  
  
-   <xref:System.String.PadLeft%2A>文字列の先頭に 1 つまたは複数出現する指定された文字を挿入します。  
  
-   <xref:System.String.PadRight%2A>文字列の先頭に 1 つまたは複数出現する指定された文字を挿入します。  
  
-   <xref:System.String.Remove%2A>現在の部分文字列を削除<xref:System.String>インスタンス。  
  
-   <xref:System.String.Replace%2A>現在の別の部分文字列の部分文字列に置換<xref:System.String>インスタンス。  
  
-   <xref:System.String.ToLower%2A> <xref:System.String.ToLowerInvariant%2A>文字列のすべての文字を小文字に変換します。  
  
-   <xref:System.String.ToUpper%2A> <xref:System.String.ToUpperInvariant%2A>文字列のすべての文字を大文字に変換します。  
  
-   <xref:System.String.Trim%2A>先頭と文字列の末尾から文字のすべての出現を削除します。  
  
-   <xref:System.String.TrimEnd%2A>文字列の末尾から文字のすべての出現を削除します。  
  
-   <xref:System.String.TrimStart%2A>文字列の先頭から文字のすべての出現を削除します。  
  
> [!IMPORTANT]
>  すべての文字列の変更メソッドを返す新しい<xref:System.String>オブジェクト。 これらには、現在のインスタンスの値は変更しないでください。  
  
### 文字列から部分文字列の抽出  
 <xref:System.String.Split%2A?displayProperty=fullName>メソッドで複数の文字列を 1 つの文字列に分割します。 メソッドのオーバー ロードを使用すると、複数の区切り記号、メソッドを抽出する部分文字列の最大数を決定し、空の文字列 \(区切り文字が隣接する場合に発生する\) が返される文字列に含まれるかどうかを決定するを指定できます。  
  
### 文字列の結合  
 次<xref:System.String>メソッドは、文字列の連結を使用できます。  
  
-   <xref:System.String.Concat%2A>1 つの文字列の 1 つまたは複数の部分文字列を結合します。  
  
-   <xref:System.String.Join%2A>1 つの要素に 1 つまたは複数の部分文字列を連結し、各部分文字列間の区切り記号を追加します。  
  
### 値の書式設定  
 <xref:System.String.Format%2A?displayProperty=fullName>メソッドでは、複合書式指定機能を使用して一部のオブジェクトまたは値の文字列形式を文字列内の 1 つまたは複数のプレース ホルダーを置き換えます。<xref:System.String.Format%2A>メソッドは、次の操作によく使用します。  
  
-   文字列に数値の文字列形式を埋め込む。  
  
-   文字列の日付と時刻の値の文字列形式を埋め込む。  
  
-   文字列の列挙値の文字列形式を埋め込む。  
  
-   サポートするいくつかのオブジェクトの文字列形式を埋め込むには、<xref:System.IFormattable>文字列内のインターフェイスです。  
  
-   右揃えまたは左揃えの文字列内のフィールド内の部分文字列。  
  
 操作と例を書式設定に関する詳細については、次を参照してください。、<xref:System.String.Format%2A>オーバー ロードの概要です。  
  
### 文字列のコピー  
 以下を呼び出すことができます<xref:System.String>文字列のコピーを作成する方法。  
  
-   <xref:System.String.Clone%2A>既存の参照を返します<xref:System.String>オブジェクト。  
  
-   <xref:System.String.Copy%2A>既存の文字列のコピーを作成します。  
  
-   <xref:System.String.CopyTo%2A>文字列の一部を文字配列にコピーします。  
  
### 文字列の正規化  
 Unicode では、1 つの文字は、複数のコード ポイントを持つことができます。 正規化は、これらと同等の文字を同じのバイナリ表現に変換します。<xref:System.String.Normalize%2A?displayProperty=fullName>メソッドは、正規化を実行し、<xref:System.String.IsNormalized%2A?displayProperty=fullName>メソッドでは、文字列を正規化するかどうかを判断します。  
  
 例および詳細については、次を参照してください。、[正規化](#Normalization)このトピックの前半の「します。  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このセクションの内容:  
  
 [オーバー ロード コンス トラクター構文](#Syntax)   
 [パラメーター](#Params)   
 [例外](#Exceptions)   
 [どのメソッドが呼び出し?](#Tasks)   
 [文字列を作成する](#Creating_Strings)   
 [反復的な文字列を処理する](#Repetitive)   
インスタンス化する文字列の例:   
[文字列の割り当てを使用する](#Ctor1_Example)  
[文字配列を使用して](#Ctor2_Example)  
[文字配列の部分を使用して、1 つの文字の繰り返し](#Ctor3_Example)  
[文字配列へのポインターを使用して](#Ctor4_Example)  
[ポインターと配列の範囲を使用して](#Ctor5_Example)  
[を使用して、符号付きバイト配列へのポインター](#Ctor6_Example)  
[バージョン情報](#Versions)  
  
<a name="Syntax"></a>   
## オーバー ロードされたコンス トラクターの構文  
 文字列のコンス トラクターは 2 つのカテゴリに分類されます。 ポインター パラメーターを指定しないと、ポインター パラメーターを使用します。 ポインターを使用するコンス トラクターは CLS 準拠ではありません。 さらに、Visual Basic は、ポインターの使用をサポートしていませんし、C\# の場合、unsafe コンテキストで実行するポインターを使用したコードが必要です。 詳細については、「[unsafe \(C\# Reference\)](http://msdn.microsoft.com/ja-jp/7e818009-1c6e-4b9e-b769-3728a01586a0)」を参照してください。  
  
 オーバー ロードを選択するための追加のガイダンスについては、次を参照してください[どのメソッドが呼び出ししますか?。](#Tasks)  
  
 `String(Char[]`  `value` `)`  
 Unicode 文字の配列により示される値の新しいインスタンスを初期化します。 このコンス トラクターは、Unicode 文字をコピー \([例](#Ctor2_Example)\)。  
  
 `String(Char[]`  `value` `, Int32`  `startIndex` `, Int32`  `length` `)`  
 配列、および長さ内の開始文字位置の Unicode 文字の配列により示される値に新しいインスタンスを初期化します \([例](#Ctor3_Example)\)。  
  
 `String(Char`  `c` `, Int32`  `count` `)`  
 指定した Unicode 文字で示される値の新しいインスタンスを初期化しますが、指定した回数だけを繰り返す \([例](#Ctor3_Example)\)。  
  
 `String(char*`  `value` `)`  
 **\(非 CLS 準拠\)**は null 文字で終了する Unicode 文字の配列を指すポインターにより示される値に新しいインスタンスを初期化します \(u\+0000 と '\\0'\)。 \([example](#Ctor4_Example)\).  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>、直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。  
  
 `String(char*`  `value` `, Int32`  `startIndex` `, Int32`  `length` `)`  
 **\(非 CLS 準拠\)** Unicode 文字配列、および長さ内の開始文字位置の配列を指すポインターにより示される値に新しいインスタンスを初期化します。 コンス トラクターから Unicode 文字をコピーする`value`インデックスから始まります`startIndex`日と終了インデックスに`startIndex`\+ `length` – 1 \([例](#Ctor5_Example)\)。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>、直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。  
  
 `String(SByte*`  `value` `)`  
 **\(非 CLS 準拠\)** 8 ビット符号付き整数の配列を指すポインターにより示される値に新しいインスタンスを初期化します。 配列を現在のシステム コード ページを使用してエンコードされた文字列を表すと想定されます \(つまりで指定するエンコード<xref:System.Text.Encoding.Default%2A?displayProperty=fullName>\)。 コンス トラクターから文字を処理する`value`null 文字 \(0x00\) に到達するまで、ポインターは、指定された場所から起動 \([例](#Ctor6_Example)\)。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>、直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。  
  
 `String(SByte*`  `value` `, Int32`  `startIndex` `, Int32`  `length` `)`  
 **\(非 CLS 準拠\)** 8 ビット符号付き整数、配列、および長さ内の開始位置の配列を指すポインターにより示される値に新しいインスタンスを初期化します。  配列を現在のシステム コード ページを使用してエンコードされた文字列を表すと想定されます \(つまりで指定するエンコード<xref:System.Text.Encoding.Default%2A?displayProperty=fullName>\)。 コンス トラクターは、値の先頭から文字を処理する`startIndex`で終わる`startIndex`\+ `length` – 1 \([例](#Ctor6_Example)\)。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>、直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。  
  
 `String(SByte*`  `value` `, Int32`  `startIndex` `, Int32`  `length` `, Encoding`  `enc` `)`  
 **\(非 CLS 準拠\)** 、長さ、配列内の開始位置、8 ビット符号付き整数の配列を指すポインターにより示される値に新しいインスタンスを初期化し、<xref:System.Text.Encoding>オブジェクト。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>、直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。  
  
<a name="Params"></a>   
## パラメーター  
 によって使用されるパラメーターの完全な一覧を次に示します<xref:System.String>ポインター パラメーターを含まないコンス トラクターです。 各オーバー ロードで使用するパラメーター、上記のオーバー ロードの構文を参照してください。  
  
|パラメーター|型|説明|  
|------------|-------|--------|  
|`value`|<xref:System.Char>\[\]|Unicode 文字の配列。|  
|`c`|<xref:System.Char>|Unicode 文字。|  
|`startIndex`|<xref:System.Int32>|内の開始位置`value`の新しい文字列の最初の文字です。<br /><br /> 既定値: 0|  
|`length`|<xref:System.Int32>|文字数`value`新しい文字列に含めます。<br /><br /> 既定値:<xref:System.Array.Length%2A?displayProperty=fullName>|  
|`count`|<xref:System.Int32>|回数文字`c`新しい文字列で繰り返されます。 場合`count`0 の場合は、新しいオブジェクトの値は<xref:System.String.Empty?displayProperty=fullName>します。|  
  
 によって使用されるパラメーターの完全な一覧を次に示します<xref:System.String>ポインター パラメーターを含むコンス トラクターです。 各オーバー ロードで使用するパラメーター、上記のオーバー ロードの構文を参照してください。  
  
|パラメーター|型|説明|  
|------------|-------|--------|  
|`value`|<xref:System.Char>\*<br /><br /> または<br /><br /> <xref:System.SByte>\*|Unicode 文字の null で終わる配列、または 8 ビット符号付き整数の配列へのポインター。 場合`value`は`null`か、空の配列の新しい文字列の値が<xref:System.String.Empty?displayProperty=fullName>です。|  
|`startIndex`|<xref:System.Int32>|新しい文字列の最初の文字を定義する配列要素のインデックス。<br /><br /> 既定値: 0|  
|`length`|<xref:System.Int32>|使用して、新しい文字列を作成する配列要素の数。 長さが 0 の場合は、コンス トラクターは、値の文字列を作成<xref:System.String.Empty?displayProperty=fullName>です。<br /><br /> 既定値:<xref:System.Array.Length%2A?displayProperty=fullName>|  
|`enc`|<xref:System.Text.Encoding>|オブジェクトを指定する方法、`value`配列をエンコードします。<br /><br /> 既定値: <xref:System.Text.Encoding.Default%2A?displayProperty=fullName>、またはシステムの現在の ANSI コード ページ|  
  
<a name="Exceptions"></a>   
## 例外  
 ポインター パラメーターを含まないコンス トラクターによってスローされた例外の一覧を次に示します。  
  
|例外|条件|によってスローされます。|  
|--------|--------|------------------|  
|<xref:System.ArgumentNullException>|`value` は `null` です。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`、`length`、または`count`が 0 未満です。<br /><br /> または<br /><br /> `startIndex` と `length` の合計が、`value` にある要素の数を超えています。<br /><br /> または<br /><br /> `count` が 0 未満です。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 ポインター パラメーターを含むコンス トラクターによってスローされた例外の一覧を次に示します。  
  
|例外|条件|によってスローされます。|  
|--------|--------|------------------|  
|<xref:System.ArgumentException>|`value`無効な Unicode 文字を格納する配列を指定します。<br /><br /> または<br /><br /> `value`または`value`\+ `startIndex`64 K 未満であるアドレスを指定します。<br /><br /> または<br /><br /> 新しい<xref:System.String>からインスタンスを初期化できませんでした、`value`バイト配列のため`value`既定コード ページ エンコーディングは使用されません。|ポインターの使用のすべてのコンス トラクターです。|  
|<xref:System.ArgumentNullException>|`value` が null です。|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|現在のプロセスは、アドレス指定されたすべての文字に対する読み取りアクセス権を持っているわけではありません。<br /><br /> または<br /><br /> `startIndex` または `length` が 0 未満であるか、`value` \+ `startIndex` によりポインターのオーバーフローが発生するか、または現在のプロセスにはすべてのアドレス指定された文字に対する読み取りアクセス許可がありません。<br /><br /> または<br /><br /> 新しい文字列の長さが大きすぎて割り当てられません。|ポインターの使用のすべてのコンス トラクターです。|  
|<xref:System.AccessViolationException>|`value`、または`value`\+ `startIndex` \+ `length` – 1、無効なアドレスを指定します。|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## どのメソッドが呼び出ししますか。  
  
|目的|呼び出しまたは使用します。|  
|--------|-------------------|  
|文字列を作成します。|文字列リテラルまたは既存の文字列からの割り当て \([例](#Ctor1_Example)\)|  
|全体の文字配列から文字列を作成します。|<xref:System.String.%23ctor%28System.Char%5B%5D%29>\([example](#Ctor2_Example)\)|  
|文字配列の部分から文字列を作成します。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>\([example](#Ctor3_Example)\)|  
|同じ文字が複数回繰り返されている文字列を作成します。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>\([example](#Ctor3_Example)\)|  
|Unicode またはワイド文字配列へのポインターから文字列を作成します。|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Unicode またはワイド文字配列の部分から文字列を作成するには、そのポインターを使用します。|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|C\+\+ から文字列を作成して`char`配列。|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> または<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|ASCII 文字の文字列を作成します。|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=fullName>|  
  
<a name="Creating_Strings"></a>   
## 文字列の作成  
 最もよく使用される手法単純代入では、文字列をプログラムで作成するために示すように[この例](#Ctor1_Example)です。<xref:System.String>クラスには、次の値から文字列を作成するのに便利なコンス トラクター オーバー ロードの 4 つの型も含まれています。  
  
-   文字配列 \(UTF 16 でエンコードされた文字の配列\)。 新規に作成することができます<xref:System.String>オブジェクトの配列全体またはその一部の文字からです。<xref:System.String.%23ctor%28System.Char%5B%5D%29>コンス トラクターは、配列内のすべての文字を新しい文字列にコピーします。<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターは、インデックスから文字をコピー`startIndex`インデックスに`startIndex`\+ `length` – 新しい文字列に 1 です。 場合`length`0 の場合は、新しい文字列の値は<xref:System.String.Empty?displayProperty=fullName>します。  
  
     コードは、同じ値を持つ文字列に繰り返しインスタンスを作成する場合、は、その他の文字列を作成する方法を使用して、アプリケーションのパフォーマンスを向上できます。 詳細については、次を参照してください。[反復的な文字列を処理する](#Repetitive)です。  
  
-   1 つの文字重複 0、1 つ、または他にも使用して、<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>コンス トラクターです。 場合`count`0 の場合は、新しい文字列の値は<xref:System.String.Empty?displayProperty=fullName>します。  
  
-   Null で終わる文字配列へのポインターから次を使用して、<xref:System.String.%23ctor%28System.Char%2A%29>または<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターです。 文字列を初期化するためには、配列全体または指定された範囲のいずれかを使用できます。 コンス トラクターは、指定したポインターから、またはプラスの指定されたポインターから始まる Unicode 文字のシーケンスをコピーする`startIndex`または配列の末尾を続行して`length`文字です。 場合`value`null ポインターまたは`length`0 の場合は、コンス トラクターは、値がある文字列を作成する<xref:System.String.Empty?displayProperty=fullName>です。 コピー操作は、配列の末尾にプロセスが実行され、配列が null で終わる、コンス トラクターの動作がシステムに依存します。 このような条件アクセス違反が発生する可能性があります。  
  
     配列には、埋め込まれた null 文字が含まれている場合 \(u\+0000 と '\\0'\) と<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードを呼び出すと、文字列のインスタンスに含まれる`length`も含めて文字には、null 値が埋め込まれています。 次の例を次の 2 つの null 文字を含む 10 個の要素の配列へのポインターが渡されたときの動作、<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>メソッドです。 アドレスは、配列の先頭であり、配列内のすべての要素が文字列に追加するのには、ために、コンス トラクターには、10 文字を 2 つの埋め込み null 値を含む文字列がインスタンス化します。 その一方で、同じ配列が渡された場合、<xref:System.String.%23ctor%28System.Char%2A%29>コンス トラクター、結果は、最初の null 文字を含まない 4 文字の文字列。  
  
     [!code-cpp[System.String.ctor\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     配列には、Unicode 文字を含める必要があります。 C\+\+ では、つまり文字配列でなければならないこと、管理対象として定義されている<xref:System.Char>型またはアンマネージ`wchar_t`型です。  
  
     場合、<xref:System.String.%23ctor%28System.Char%2A%29>オーバー ロードが呼び出され、配列が null で終わる場合、または、<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードが呼び出されたと`startIndex`\+ `length`\-1 には文字のシーケンスに割り当てられたメモリの外側に範囲が含まれています、コンス トラクターの動作はシステムに依存する、およびアクセス違反が発生する可能性があります。 さらに、Intel Itanium プロセッサ上への呼び出し、<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターがスローする可能性があります、<xref:System.DataMisalignedException>例外。 この場合、呼び出し、<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>代わりにします。  
  
-   符号付きバイト配列へのポインター。 文字列を初期化するためには、配列全体または指定された範囲のいずれかを使用できます。 バイト シーケンスにエンコードするには、既定のコード ページを使用して解釈できます。 またはコンス トラクターの呼び出しでのエンコーディングを指定できます。 コンス トラクターは、null 終端ではない配列全体から文字列インスタンスを作成しようとする場合、または配列の範囲`value`\+`startIndex`に`value`\+ `startIndex` \+ `length` \-1 は、配列に割り当てられたメモリの外部では、このコンス トラクターの動作はシステムに依存する、およびアクセス違反が発生する可能性があります。  
  
     パラメーターとして符号付きバイト配列を含む 3 つのコンス トラクターは C\+\+ に変換するには、主に設計されています`char`この例で示すように、文字列配列。  
  
     [!code-cpp[System.String.Ctor\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     値が 0、null 文字 \('\\0'\) またはバイト配列が含まれている場合、<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードを呼び出すと、文字列のインスタンスに含まれる`length`も含めて文字には、null 値が埋め込まれています。 次の例を次の 2 つの null 文字を含む 10 個の要素の配列へのポインターが渡されたときの動作、<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>メソッドです。 アドレスは、配列の先頭であり、配列内のすべての要素が文字列に追加するのには、ために、コンス トラクターには、10 文字を 2 つの埋め込み null 値を含む文字列がインスタンス化します。 その一方で、同じ配列が渡された場合、<xref:System.String.%23ctor%28System.SByte%2A%29>コンス トラクター、結果は、最初の null 文字を含まない 4 文字の文字列。  
  
     [!code-cpp[System.String.ctor\#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     <xref:System.String.%23ctor%28System.SByte%2A%29>と<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターを解釈`value`既定の ANSI コード ページを使用すると、同一のバイト配列でこれらのコンス トラクターを呼び出すことがあります文字列を作成をそれぞれ異なるシステムで異なる値を持ちます。  
  
<a name="Repetitive"></a>   
## 反復的な文字列を処理します。  
 解析、または多くの場合、テキストのストリームをデコードするアプリを使用して、<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターまたは<xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName>の文字のシーケンスを文字列に変換します。 メモリを浪費繰り返しを作成して、1 つの文字列を再利用ではなく同じ値を持つ新しい文字列を作成します。 繰り返し呼び出すことによって同じ文字列値を作成する可能性がありますか、<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターでわからない場合でもはそれらのと同じ文字列値がありますを進める、ルックアップ テーブルを代わりに使用することができます。  
  
 たとえば、読み取り、XML タグと属性を含むファイルからの文字のストリームを解析するとします。 ストリームを解析するときに繰り返しが発生する特定のトークン \(つまり、シンボリック意味を持つ文字のシーケンス\)。 文字列「0」、「1」、"true"および"false"に相当するトークンは、XML ストリームで頻繁に発生する可能性があります。  
  
 各トークンを新しい文字列に変換する代わりに作成することができます、<xref:System.Xml.NameTable?displayProperty=fullName>頻出する文字列を保持するオブジェクト。<xref:System.Xml.NameTable>一時メモリを割り当てずに格納された文字列を取得するために、オブジェクトによってパフォーマンスが向上します。 トークンを検出するときに使用して、<xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName>テーブルからトークンを取得します。 トークンが存在する場合、メソッドは、対応する文字列を返します。 トークンが存在しない場合は、使用、<xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName>メソッド テーブルに、トークンを挿入して、対応する文字列を取得します。  
  
<a name="Ctor1_Example"></a>   
## 例 1: を使用して文字列を代入  
 次の例では、文字列リテラルを割り当てることによって新しい文字列を作成します。 最初の文字列の値を代入によって 2 番目の文字列を作成します。 これらの新しいインスタンスを作成する 2 つの最も一般的な方法は、<xref:System.String>オブジェクト。  
  
 [!code-cpp[System.String.ctor\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## 例 2: 使用する文字配列  
 次の例では、新しい<xref:System.String>文字配列からのオブジェクト。  
  
 [!code-cpp[stringexample1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## 例 3: 文字の配列の部分を使用して、1 つの文字の繰り返し  
 次の例では、新規作成<xref:System.String>オブジェクトを新規作成方法と、文字配列の部分から<xref:System.String>を 1 つの文字の複数の発生を含むオブジェクト。  
  
 [!code-cpp[stringexample1\#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1\#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## 例 4: の文字配列へのポインターを使用します。  
 次の例では、新しい<xref:System.String>文字の配列へのポインターからのオブジェクト。 C\# の例を使用してコンパイルする必要があります、`/unsafe`コンパイラ スイッチ。  
  
 [!code-cpp[System.String.Ctor\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## 例 5: ポインターと配列の範囲から文字列をインスタンス化します。  
 次の例では、ピリオドまたは感嘆符のいずれかの文字の配列の要素を調べます。 1 つが見つかった場合は、配列内の区切り記号を前にある文字の文字列がインスタンス化します。 それ以外の場合は、配列の内容全体を含む文字列をインスタンス化します。 C\# の例を使用してコンパイルする必要があります、`/unsafe`コンパイラ スイッチ。  
  
 [!code-cpp[System.String.Ctor\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## 例 6: 符号付きバイト配列へのポインターから文字列をインスタンス化します。  
 次の例では、インスタンスを作成する方法を示しています、<xref:System.String>クラス、<xref:System.String.%23ctor%28System.SByte%2A%29>コンス トラクターです。  
  
 [!code-cpp[stringexample1\#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1\#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## バージョン情報  
 .NET Framework  
 すべてのオーバー ロードではサポートされて: 4.5、4、3.5、3.0、2.0、1.1、1.0  
  
 .NET Framework Client Profile  
 すべてのオーバー ロードではサポートされて: 4、3.5 SP1  
  
 汎用性のあるクラス ライブラリ  
 すべてのオーバー ロードせず、 <xref:System.SByte>`*`パラメーターがサポートされています。  
  
 Windows ストア アプリ用 .NET  
 なくすべてのオーバー ロード、 <xref:System.SByte>`*`でパラメーターがサポートされます Windows 8。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の null で終わる配列へのポインター。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、指定した Unicode 文字配列を指すポインターにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例とおよびその他の包括的な使用法について`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のプロセスは、アドレス指定されたすべての文字に対する読み取りアクセス権を持っているわけではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> が正しくない Unicode 文字を含む配列を指定しているか、<paramref name="value" /> が 64000 未満のアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列により示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例とおよびその他の包括的な使用法について`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">終端が null の 8 ビット符号付き整数の配列へのポインター。 整数は、現在のシステム コード ページ エンコーディング \(つまり、<see cref="P:System.Text.Encoding.Default" /> が指定したエンコーディング\) を使用して解釈されます。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指すポインターにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例とおよびその他の包括的な使用法について`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.String" /> の新しいインスタンス を、<paramref name="value" /> を使用して初期化できませんでした。<paramref name="value" /> が ANSI でエンコードされていると想定しています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> の Null 終端文字によって決定される初期化する新しい文字列の長さが、大きすぎて割り当てられません。</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> に指定されたアドレスが正しくありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Unicode 文字。</param>
        <param name="count">
          <c>c</c> の発生回数。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、指定した回数だけ繰り返した指定の Unicode 文字が示す値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例とおよびその他の包括的な使用法について`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列を指すポインター。</param>
        <param name="startIndex">
          <c>value</c> 内の開始位置。</param>
        <param name="length">使用する <c>value</c> 内の文字数。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列を指す指定のポインター、配列内の開始文字位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例とおよびその他の包括的な使用法について`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満であるか、<paramref name="value" /> \+ <paramref name="startIndex" /> によりポインターのオーバーフローが発生するか、または現在のプロセスにはすべてのアドレス指定された文字に対する読み取りアクセス許可がありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> が無効な Unicode 文字を含む配列を指定しているか、<paramref name="value" /> \+ <paramref name="startIndex" /> が 64000 未満のアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列。</param>
        <param name="startIndex">
          <c>value</c> 内の開始位置。</param>
        <param name="length">使用する <c>value</c> 内の文字数。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列、配列内の開始文字位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例とおよびその他の包括的な使用法について`String`コンス トラクター オーバー ロードを参照してください、[String コンストラクター \(Char\<xref:System.String.%23ctor%2A>コンス トラクターの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> と <paramref name="length" /> の合計が、<paramref name="value" /> にある要素の数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">8 ビット符号付き整数の配列へのポインター。 整数は、現在のシステム コード ページ エンコーディング \(つまり、<see cref="P:System.Text.Encoding.Default" /> が指定したエンコーディング\) を使用して解釈されます。</param>
        <param name="startIndex">
          <c>value</c> 内の開始位置。</param>
        <param name="length">使用する <c>value</c> 内の文字数。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指す指定のポインター、配列内の開始位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例とこのおよび他の包括的な使用法について`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
 \-または\-  
  
 <paramref name="value" /> \+ <paramref name="startIndex" /> で指定されたアドレスが現在のプラットフォームにとって大きすぎて、アドレス計算がオーバーフローしました。  
  
 \-または\-  
  
 初期化する新しい文字列の長さが大きすぎて割り当てられません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> \+ <paramref name="startIndex" /> で指定されるアドレスは 64 K 未満です。  
  
 または  
  
 <see cref="T:System.String" /> の新しいインスタンスを、<paramref name="value" /> を使用して初期化できませんでした \(<paramref name="value" /> が ANSI でエンコードされていると想定\)。</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />、<paramref name="startIndex" />、<paramref name="length" /> 全体で、正しくないアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">8 ビット符号付き整数の配列へのポインター。</param>
        <param name="startIndex">
          <c>value</c> 内の開始位置。</param>
        <param name="length">使用する <c>value</c> 内の文字数。</param>
        <param name="enc">
          <c>value</c> が参照する配列のエンコード方法を指定するオブジェクト。<c>enc</c> が <see langword="null" /> の場合は、ANSI エンコーディングが指定されていると見なされます。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指す指定のポインター、配列内の開始位置、長さ、および <see cref="T:System.Text.Encoding" /> オブジェクトにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例とおよびその他の包括的な使用法について`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
 \-または\-  
  
 <paramref name="value" /> \+ <paramref name="startIndex" /> で指定されたアドレスが現在のプラットフォームにとって大きすぎて、アドレス計算がオーバーフローしました。  
  
 \-または\-  
  
 初期化する新しい文字列の長さが大きすぎて割り当てられません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> \+ <paramref name="startIndex" /> で指定されるアドレスは 64 K 未満です。  
  
 \-または\-  
  
 <see cref="T:System.String" /> の新しいインスタンスを、<paramref name="value" /> を使用して初期化できませんでした。<paramref name="value" /> が <paramref name="enc" /> の指定に従ってエンコードされていると想定しています。</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />、<paramref name="startIndex" />、<paramref name="length" /> 全体で、正しくないアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">現在の文字列内の位置。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクト内の指定された位置にある <see cref="T:System.Char" /> オブジェクトを取得します。</summary>
        <value>
          <paramref name="index" /> 位置にあるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `index`パラメーターは 0 から始まる。  
  
 このプロパティを返します、<xref:System.Char>オブジェクトで指定された位置にある、`index`パラメーター。 ただし、Unicode 文字 1 つ以上によって表現されます<xref:System.Char>です。 使用して、<xref:System.Globalization.StringInfo?displayProperty=fullName>の代わりに文字が Unicode を使用するクラス<xref:System.Char>オブジェクト。 詳細についてを参照してください「のオブジェクトと Unicode の文字を Char する」、<xref:System.String>クラスの概要です。  
  
 C\# で、<xref:System.String.Chars%2A>プロパティは、インデクサーです。 Visual basic での既定のプロパティは、<xref:System.String>クラスです。 各<xref:System.Char>文字列内のオブジェクトは、次のようなコードを使用してアクセスできます。  
  
 [!code-csharp[System.String.Chars\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## 例  
 次の例では、文字列を検証するルーチンにこのインデクサーを使用する方法を示します。  
  
 [!code-cpp[Uri\_IsHexDigit\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri\_IsHexDigit\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri\_IsHexDigit\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> がこのオブジェクトの長さ以上か、0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.String" /> インスタンスへの参照を返します。</summary>
        <returns>この <see cref="T:System.String" /> のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 戻り値は、このインスタンスの独立したコピーではありません。同じデータのもう 1 つ表示することをお勧めします。 使用して、<xref:System.String.Copy%2A>または<xref:System.String.CopyTo%2A>メソッドごとに別々 に<xref:System.String>このインスタンスと同じ値を持つオブジェクト。  
  
 <xref:System.String.Clone%2A>メソッドでは、既存の文字列インスタンスだけを返します、これを直接呼び出す理由はほとんどがありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 すべてのオーバー ロード、<xref:System.String.Compare%2A>メソッドが 2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数を返します。  
  
|値|状態|  
|-------|--------|  
|0 より小さい値|最初の部分文字列には、並べ替え順序で 2 番目の部分文字列が前に付きます。|  
|0|部分文字列は並べ替え順序で同じ位置で発生するか、`length` はゼロです。|  
|0 より大きい値|最初の部分文字列には、並べ替え順序で別の部分文字列が次に示します。|  
  
> [!WARNING]
>  オーバー ロードを呼び出す必要があります、可能な限り、<xref:System.String.Compare%2A>を含むメソッド、<xref:System.StringComparison>パラメーター。 詳細については、「[Best Practices for Using Strings in the .NET Framework](http://msdn.microsoft.com/ja-jp/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description> 並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="strA" /> は並べ替え順序で、<paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description> 並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 比較では、現在のカルチャを使用して、大文字小文字の規則や個別の文字のアルファベット順などのカルチャに固有の情報を取得します。 たとえば、カルチャでは、文字の並べ替え順が前または後の文字に依存しているか、特定の文字の組み合わせが単一の文字として扱うことも、大文字と小文字の文字が特定の方法で比較することを指定できます。  
  
 単語の並べ替え規則を使用して、比較が実行されます。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=fullName>です。  
  
> [!WARNING]
>  文字列を比較するときに呼び出す必要があります、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドで、メソッドを使用する文字列比較の種類を明示的に指定することが必要です。 詳細については、「[Best Practices for Using Strings in the .NET Framework](http://msdn.microsoft.com/ja-jp/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7)」を参照してください。  
  
 1 つまたは両方の比較対照値を指定できます`null`です。 定義上、任意の文字列を含む空の文字列 \(""\)、比較に null 参照ですより大きい。2 つの null 参照が互いに等しいと比較します。  
  
 非等値が検出されるか、両方の文字列を比較したときに、比較が終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列場合は、し、残りの文字の文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 予期しない結果は、比較がカルチャに固有の大文字と小文字の規則によって影響を受けるときに発生します。 たとえば、トルコ語では次の例間違った結果が生成トルコ語で、ファイル システムは、文字"i"の言語の文字種の規則を使用しないためファイル」で。  
  
 [!code-cpp[System.String.Compare\#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 序数に基づく比較を使用して、"file"パス名を比較します。 これを行う正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare\#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## 例  
 次の例では、<xref:System.String.Compare%28System.String%2CSystem.String%29>文字列の 3 つのセットを比較するメソッド。  
  
 [!code-cpp[System.String.Compare\#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare\#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare\#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 次の例で、`ReverseStringComparer`クラスで 2 つの文字列を評価する方法を示しています、<xref:System.String.Compare%2A>メソッドです。  
  
 [!code-cpp[ArrayList\#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList\#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison. For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.  
  
 [!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)]
 [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]  
  
 To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを設定できます。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description> 並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="strA" /> は並べ替え順序で、<paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description> 並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 比較では、現在のカルチャを使用して、大文字小文字の規則や個別の文字のアルファベット順などのカルチャに固有の情報を取得します。 たとえば、カルチャでは、文字の並べ替え順序は、その前またはそれに続く文字に依存すること、または特定の文字の組み合わせは、1 文字として扱うことも、大文字と小文字の文字が特定の方法で比較することを指定できます。  
  
 単語の並べ替え規則を使用して、比較が実行されます。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=fullName>です。  
  
> [!WARNING]
>  文字列を比較するときに呼び出す必要があります、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドで、メソッドを使用する文字列比較の種類を明示的に指定することが必要です。 詳細については、「[Best Practices for Using Strings in the .NET Framework](http://msdn.microsoft.com/ja-jp/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7)」を参照してください。  
  
 1 つまたは両方の比較対照値は、`null`です。 定義上、任意の文字列を含む空の文字列 \(""\)、比較に null 参照ですより大きい。2 つの null 参照が互いに等しいと比較します。  
  
 非等値が検出されるか、両方の文字列を比較したときに、比較が終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、に残りの文字の文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 カルチャに固有の大文字と小文字の規則によって影響を受ける比較、予期しない結果が発生します。 たとえば、トルコ語では次の例間違った結果が生成トルコ語で、ファイル システムで、文字"i"の言語の文字種の規則が使用されていないため"file"にします。  
  
 [!code-cpp[System.String.Compare\#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 序数に基づく比較を使用して"file"へのパス名を比較します。 これを行う正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare\#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare\#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare\#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## 例  
 次の例では、ことを示しますの<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29>はメソッドを使用すると同じ<xref:System.String.ToUpper%2A>または<xref:System.String.ToLower%2A>文字列を比較するときにします。  
  
 [!code-cpp[System.String.Compare\#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare\#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare\#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> method does not consider such characters when it performs a culture-sensitive comparison. For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.  
  
 [!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)]
 [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]  
  
 To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定した規則を使用して、指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description> 並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="strA" /> は並べ替え順序で、<paramref name="strB" /> と同じ位置にあります。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description> 並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `comparisonType`パラメーターかを示します、比較には、現在またはインバリアント カルチャを使用する必要があります、優先するか、比較対照値の大文字と小文字を無視する word \(カルチャ\) を使用してまたは序数に基づく \(カルチャに依存しない\) の並べ替え規則。  
  
 1 つまたは両方の比較対照値を指定できます`null`です。 定義上、任意の文字列を含む空の文字列 \(""\)、比較に null 参照ですより大きい。2 つの null 参照が互いに等しいと比較します。  
  
 比較は、非等値が検出されるか、両方の文字列を比較した時点で終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列場合は、残りの文字の文字列は大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 予期しない結果は、比較がカルチャに固有の大文字と小文字の規則によって影響を受けるときに発生します。 たとえば、トルコ語では次の例間違った結果が生成トルコ語で、ファイル システムは、文字"i"の言語の文字種の規則を使用しないためファイル」で。  
  
 [!code-cpp[System.String.Compare\#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 序数に基づく比較を使用して、"file"パス名を比較します。 これを行う正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare\#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare\#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare\#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## 例  
 次の例では、3 つのバージョン、文字"I"です。 結果は、カルチャ、大文字と小文字の区別するかどうか、および序数に基づく比較を実行するかどうかの選択の影響を受けます。  
  
 [!code-cpp[System.String.CompareCmp\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> がサポートされていません。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method does not consider such characters when it performs a culture-sensitive comparison. To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを指定し、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description> 並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="strA" /> は並べ替え順序で、<paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description> 並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 比較を使用して、`culture`パラメーターを大文字小文字の規則や個別の文字のアルファベット順などのカルチャに固有の情報を取得します。 たとえば、カルチャでは、文字の並べ替え順が前または後の文字に依存すること、または特定の文字の組み合わせが、1 文字として扱うことも、大文字と小文字の文字が特定の方法で比較することを指定できます。  
  
 比較を実行するには、word の並べ替え規則を使用します。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=fullName>です。  
  
 1 つまたは両方の比較対照値を指定できます`null`です。 定義上、任意の文字列を含む空の文字列 \(""\)、比較に null 参照ですより大きい。2 つの null 参照が互いに等しいと比較します。  
  
 非等値が検出されるか、両方の文字列を比較したときに、比較が終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、に残りの文字の文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 予期しない結果は、比較がカルチャに固有の大文字と小文字の規則によって影響を受けるときに発生します。 たとえば、トルコ語では次の例間違った結果が生成トルコ語で、ファイル システムでは、文字"i"の言語の文字種の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare\#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare\#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare\#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 序数に基づく比較を使用して、"file"パス名を比較します。 これを行う正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare\#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare\#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare\#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## 例  
 次の例では、カルチャが比較に影響を及ぼすを示しています。 チェコ語、チェコ共和国カルチャ"ch"は単一の文字"d"よりも大きいです。 ただし、英語 \- 米国のカルチャで"ch"から成る 2 つの文字と、"c"が"d"より小さい。  
  
 [!code-cpp[string.comp4\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider such characters when it performs a culture-sensitive comparison. For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.  
  
 [!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)]
 [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]  
  
 To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="culture">カルチャ固有の比較情報を提供するカルチャ。</param>
        <param name="options">比較の実行時に使用するオプション \(大文字と小文字の違いや記号を無視するなど\)。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、2 つの文字列の互いのリレーションシップを並べ替え順序で示す整数を返します。比較時に、指定した比較オプションと、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>
          <paramref name="strA" /> と <paramref name="strB" /> との構文上の関係を示す 32 ビット符号付き整数。次の表を参照してください。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description> 並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="strA" /> は並べ替え順序で、<paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description> 並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 比較を使用して、`culture`パラメーターを大文字小文字の規則や個別の文字のアルファベット順など、カルチャに固有の情報を取得します。 たとえば、特定のカルチャでは、すべてのユーザーを特定の方法で大文字と小文字を比較することや、文字の並べ替え順序は、その前またはそれに続く文字によって異なりますが 1 文字として扱われる特定の文字の組み合わせを指定できます。  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>メソッドが、主に、並べ替えや操作をアルファベット順に並べ替えに使用するために設計されています。 これはできません、メソッド呼び出しの主な目的は、\(メソッド呼び出しの目的は、ゼロの戻り値をテストするには\) の場合は、2 つの文字列が等価かどうかを決定するときに使用する必要があります。 2 つの文字列が等価かどうかを判断するのには、呼び出し、<xref:System.String.Equals%2A>メソッドです。  
  
 比較は、によってさらに指定することができます、`options`パラメーターの 1 つまたは複数のメンバーで構成される<xref:System.Globalization.CompareOptions>列挙体です。 ただし、このメソッドの目的は、カルチャに依存した文字列の比較を実行するため、<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=fullName>と<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=fullName>値がある影響しません。  
  
 比較対象値のいずれかまたは両方を指定できます`null`です。 定義では、任意の文字列を含む<xref:System.String.Empty?displayProperty=fullName>、相互に比較して 2 つの null 参照と、null 参照を超えるが等しい。  
  
 非等値が検出されるか、両方の文字列を比較したときに、比較が終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列場合は、残りの文字の文字列は大きいと見なされます。  
  
   
  
## 例  
 次の例は、次の 3 つの異なる方法で 2 つの文字列を比較します、EN\-US カルチャでは、の言語的な比較を使用する。による、EN\-US カルチャでは、大文字小文字を区別の言語的な比較序数に基づく比較を使用してください。 比較の 3 つのメソッドが 3 つの異なる結果を生成する方法を示しています。  
  
 [!code-cpp[System.String.Compare\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> は <see cref="T:System.Globalization.CompareOptions" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. The <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider such characters when it performs a culture-sensitive comparison. To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <c>strA</c> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <c>strB</c> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0  
  
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において後続します。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 比較する部分文字列の開始`strA`で`indexA`し、`strB`で`indexB`です。 両方`indexA`および`indexB`は 0 から始まるです。 つまり、最初の文字`strA`および`strB`位置 0 です。 最初の部分文字列の長さがの長さと等しい`strA`マイナス`indexA`1 を加算します。 2 番目の部分文字列の長さがの長さと等しい`strB`マイナス`indexB`1 を加算します。  
  
 比較する文字の数が 2 つの部分文字列の長さの小さい方と`length`です。`indexA`、 `indexB`、および`length`パラメーターを負にする必要があります。  
  
 比較では、大文字小文字の規則や個別の文字のアルファベット順などのカルチャに固有の情報を取得するのに現在のカルチャを使用します。 たとえば、カルチャでは、文字の並べ替え順序は、その前またはそれに続く文字に依存すること、または特定の文字の組み合わせは、1 文字として扱うことも、大文字と小文字の文字が特定の方法で比較することを指定できます。  
  
 単語の並べ替え規則を使用して、比較が実行されます。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=fullName>です。  
  
> [!WARNING]
>  文字列を比較するときに呼び出す必要があります、<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>メソッドで、メソッドを使用する文字列比較の種類を明示的に指定することが必要です。 詳細については、「[Best Practices for Using Strings in the .NET Framework](http://msdn.microsoft.com/ja-jp/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7)」を参照してください。  
  
 1 つまたは両方の比較対照値を指定できます`null`です。 定義上、任意の文字列を含む空の文字列 \(""\)、比較に null 参照ですより大きい。2 つの null 参照が互いに等しいと比較します。  
  
 非等値が検出されるか、両方の部分文字列を比較したときに、比較が終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、に残りの文字の文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 予期しない結果は、比較がカルチャに固有の大文字と小文字の規則によって影響を受けるときに発生します。 たとえば、トルコ語では次の例間違った結果が生成トルコ語で、ファイル システムでは、文字"i"の言語の文字種の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 序数に基づく比較を使用して、"file"パス名を比較します。 これを行う正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## 例  
 次の例では、次の 2 つの部分文字列を比較します。  
  
 [!code-cpp[string.compare3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
 または  
  
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きいです。  
  
 または  
  
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
 または  
  
 <paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 より大きいです。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison. To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <c>strA</c> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <c>strB</c> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを設定できます。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0  
  
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において後続します。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 比較する部分文字列を起動`strA`で`indexA`、し、`strB`で`indexB`です。 両方`indexA`と`indexB`は 0 から始まるです。 つまり、最初の文字`strA`と`strB`位置 0 です。 最初の部分文字列の長さがの長さと等しい`strA`マイナス`indexA`1 を加算します。 2 番目の部分文字列の長さがの長さと等しい`strB`マイナス`indexB`1 を加算します。  
  
 比較する文字の数が 2 つの部分文字列の長さの小さい方と`length`です。`indexA`、 `indexB`、および`length`パラメーターは、負以外である必要があります。  
  
 比較では、大文字小文字の規則や個別の文字のアルファベット順などのカルチャに固有の情報を取得するのに現在のカルチャを使用します。 たとえば、カルチャでは、文字の並べ替え順が前または後の文字に依存すること、または特定の文字の組み合わせが、1 文字として扱うことも、大文字と小文字の文字が特定の方法で比較することを指定できます。  
  
 単語の並べ替え規則を使用して、比較が実行されます。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=fullName>です。  
  
> [!WARNING]
>  文字列を比較するときに呼び出す必要があります、<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>メソッドで、メソッドを使用する文字列比較の種類を明示的に指定することが必要です。 詳細については、「[Best Practices for Using Strings in the .NET Framework](http://msdn.microsoft.com/ja-jp/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7)」を参照してください。  
  
 比較対象値の 1 つまたは両方を指定できます`null`です。 定義上、任意の文字列を含む空の文字列 \(""\)、比較に null 参照ですより大きい。2 つの null 参照が互いに等しいと比較します。  
  
 非等値が検出されるか、両方の部分文字列を比較したときに、比較が終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、に残りの文字の文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 予期しない結果は、比較がカルチャに固有の大文字と小文字の規則によって影響を受けるときに発生します。 たとえば、トルコ語では次の例間違った結果が生成トルコ語で、ファイル システムでは、文字"i"の言語の文字種の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 パス名は、ロケールに依存しない方法で比較する必要があります。 これを行う正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## 例  
 次の例では、場合だけが異なる 2 つの部分文字列を比較する 2 を実行します。 最初の比較と小文字を無視し、2 つ目の比較では大文字です。  
  
 [!code-cpp[string.compare4\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
 または  
  
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きいです。  
  
 または  
  
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
 または  
  
 <paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 より大きいです。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison. To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <c>strA</c> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <c>strB</c> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定した規則を使用して、指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0  
  
 </term><description> 部分文字列が並べ替え順序内の同じ位置で発生する、または<paramref name="length" />パラメーターが 0 です。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description> 内の部分文字列<paramref name="strA" />follllows 部分文字列で<paramref name="strB" />並べ替え順序で。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 比較する部分文字列を起動`strA`で`indexA`し、`strB`で`indexB`です。 両方`indexA`と`indexB`は 0 から始まるです。 つまり、最初の文字`strA`と`strB`がゼロの位置にある、1 つを配置できません。 最初の部分文字列の長さがの長さと等しい`strA`マイナス`indexA`1 を加算します。 2 番目の部分文字列の長さがの長さと等しい`strB`マイナス`indexB`1 を加算します。  
  
 比較する文字の数が 2 つの部分文字列の長さの小さい方と`length`です。`indexA`、 `indexB`、および`length`パラメーターを負にする必要があります。  
  
 `comparisonType`パラメーターかを示します比較は、現在またはインバリアント カルチャを使用する必要があります、優先するか、比較対照値の大文字と小文字を無視する word \(カルチャ\) を使用してまたは序数に基づく \(カルチャに依存しない\) の並べ替え規則。  
  
 1 つまたは両方の比較対照値を指定できます`null`です。 定義上、任意の文字列を含む空の文字列 \(""\)、比較に null 参照ですより大きい。2 つの null 参照が互いに等しいと比較します。  
  
 非等値が検出されるか、両方の部分文字列を比較したときに、比較が終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列場合は、残りの文字の文字列は大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 予期しない結果は、比較がカルチャに固有の大文字と小文字の規則によって影響を受けるときに発生します。 たとえば、トルコ語では次の例間違った結果が生成トルコ語で、ファイル システムでは、文字"i"の言語の文字種の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare\#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 序数に基づく比較を使用して、"file"パス名を比較します。 これを行う正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare\#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## 例  
 次の例では、次の 2 つの部分文字列を比較します。  
  
 [!code-cpp[string.compare3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
 または  
  
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きいです。  
  
 または  
  
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
 または  
  
 <paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison. To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <c>strA</c> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <c>strB</c> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを指定し、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0  
  
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において後続します。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 比較する部分文字列の開始`strA`で`indexA`、し、`strB`で`indexB`です。 両方`indexA`と`indexB`は 0 から始まるです。 つまり、最初の文字`strA`と`strB`で位置の 0、1 つを配置できません。 最初の部分文字列の長さがの長さと等しい`strA`マイナス`indexA`1 を加算します。 2 番目の部分文字列の長さがの長さと等しい`strB`マイナス`indexB`1 を加算します。  
  
 比較する文字の数が 2 つの部分文字列の長さの小さい方と`length`です。`indexA`、 `indexB`、および`length`パラメーターを負にする必要があります。  
  
 比較を使用して、`culture`パラメーターを大文字小文字の規則や個別の文字のアルファベット順などのカルチャに固有の情報を取得します。 たとえば、カルチャでは、文字の並べ替え順が前または後の文字に依存すること、または特定の文字の組み合わせが、1 文字として扱うことも、大文字と小文字の文字が特定の方法で比較することを指定できます。  
  
 比較を実行するには、word の並べ替え規則を使用します。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=fullName>です。  
  
 1 つまたは両方の比較対照値を指定できます`null`です。 定義上、任意の文字列を含む空の文字列 \(""\)、比較に null 参照ですより大きい。2 つの null 参照が互いに等しいと比較します。  
  
 非等値が検出されるか、両方の部分文字列を比較したときに、比較が終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、に残りの文字の文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 予期しない結果は、比較がカルチャに固有の大文字と小文字の規則によって影響を受けるときに発生します。 たとえば、トルコ語では次の例間違った結果が生成トルコ語で、ファイル システムでは、文字"i"の言語の文字種の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare\#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 序数に基づく比較を使用して、"file"パス名を比較します。 これを行う正しいコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare\#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## 例  
 次の例では、別のカルチャを使用して部分文字列の大文字と小文字を無視して 2 つの部分文字列を比較します。 選択したカルチャに影響する方法は、文字"I"が比較されます。  
  
 [!code-cpp[string.compare5\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きくなっています。  
  
 または  
  
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きいです。  
  
 または  
  
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
 または  
  
 <paramref name="strA" /> または <paramref name="strB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison. To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <c>strA</c> 内の部分文字列の開始位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <c>strB</c> 内の部分文字列の開始位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <param name="options">比較の実行時に使用するオプション \(大文字と小文字の違いや記号を無視するなど\)。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、2 つの部分文字列の互いのリレーションシップを並べ替え順序で示す整数を返します。比較時に、指定した比較オプションと、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの部分文字列の構文上の関係を示す整数。次の表を参照してください。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0  
  
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において後続します。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 比較する部分文字列の開始`strA`位置にある`indexA`し、`strB`位置にある`indexB`です。 最初の部分文字列の長さがの長さ`strA`マイナス`indexA`です。 2 番目の部分文字列の長さがの長さ`strB`マイナス`indexB`です。  
  
 比較する文字の数が 2 つの部分文字列の長さの小さい方と`length`です。`indexA`、 `indexB`、および`length`のパラメーターを負にする必要があります。  
  
 比較を使用して、`culture`パラメーターを大文字小文字の規則や個別の文字のアルファベット順など、カルチャに固有の情報を取得します。 たとえば、特定のカルチャでは、すべてのユーザーを特定の方法で大文字と小文字を比較することや、文字の並べ替え順序は、その前またはそれに続く文字によって異なりますが 1 文字として扱われる特定の文字の組み合わせを指定できます。  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>メソッドが、主に並べ替えや操作をアルファベット順に並べ替えに使用するために設計されています。 これはありません、メソッド呼び出しの主な目的は、\(メソッド呼び出しの目的は、ゼロの戻り値をテストするには\) の場合は、2 つの部分文字列は等価であるかどうかを決定するときに使用する必要があります。 2 つの文字列が等価かどうかを判断するのには、呼び出し、<xref:System.String.Equals%2A>メソッドです。  
  
 一方または両方の`strA`と`strB`できます`null`です。 定義上、任意の文字列を含む<xref:System.String.Empty?displayProperty=fullName>を比較して 2 つの null 参照と、null 参照を超えるが互いに等しいと比較します。  
  
 によってさらに、比較を指定することができます、 `options` 、パラメーターの 1 つまたは複数のメンバーで構成される、<xref:System.Globalization.CompareOptions?displayProperty=fullName>列挙します。 ただし、このメソッドの目的は、カルチャに依存した文字列の比較を実行するため、<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=fullName>および<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=fullName>値がある影響しません。  
  
 非等値が検出されるか、両方の部分文字列を比較したときに、比較が終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列場合は、残りの文字の文字列は大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
   
  
## 例  
 次の例では、 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 2 人のユーザーの姓を比較するメソッド。 次にアルファベット順に表示されます。  
  
 [!code-csharp[System.String.Compare5\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> は <see cref="T:System.Globalization.CompareOptions" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> が <paramref name="strA" /><see langword=".Length" /> より大きくなっています。  
  
 または  
  
 <paramref name="indexB" /> が <paramref name="strB" /><see langword=".Length" /> より大きくなっています。  
  
 または  
  
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
 または  
  
 <paramref name="strA" /> または <paramref name="strB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison. To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <summary>それぞれの文字列の対応する <see cref="T:System.String" /> オブジェクトの数値を評価することで、指定した 2 つの <see cref="T:System.Char" /> を比較します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description><paramref name="strA" /> は <paramref name="strB" /> より小さい値です。  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="strA" /> と <paramref name="strB" /> が等しい。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description><paramref name="strA" /> が <paramref name="strB" /> より大きくなっています。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、序数の並べ替え規則を使用して、区別する比較を実行します。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=fullName>です。 実行するには、大文字と小文字は序数の並べ替え規則を使用して呼び出し、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドを`comparisonType`引数に設定されて<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=fullName>です。  
  
 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>静的メソッドでは、`strA`と`strB`できます`null`です。 両方の値が場合`null`、メソッドがあることを示す 0 \(ゼロ\) を返します`strA`と`strB`が等しい。 値の一方のみが`null`メソッドが長くなるように null 以外の値を考慮します。  
  
   
  
## 例  
 次の例を実行し、2 つの序数に基づく比較文字列の場合のみが異なります。  
  
 [!code-cpp[string.compareordinal\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <c>strA</c> 内の部分文字列の開始インデックス。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <c>strB</c> 内の部分文字列の開始インデックス。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <summary>それぞれの部分文字列の対応する <see cref="T:System.Char" /> オブジェクトの数値を評価することにより、指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列が <paramref name="strB" /> 内の部分文字列より小さいです。  
  
 </description></item><item><term> 0  
  
 </term><description> これらの部分文字列が等しいか、または <paramref name="length" /> が 0 です。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description><paramref name="strA" /> 内の部分文字列が <paramref name="strB" /> 内の部分文字列より大きいです。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `indexA`、 `indexB`、および`length`パラメーターを負にする必要があります。  
  
 比較する文字数は、いずれか小さいほうの長さの`strA`小さい`indexA`の長さ`strB`小さい`indexB`、および`length`です。  
  
 このメソッドは、序数の並べ替え規則を使用して、区別する比較を実行します。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=fullName>です。 実行するには、大文字と小文字は序数の並べ替え規則を使用して呼び出し、<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>メソッドを`comparisonType`引数に設定されて<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=fullName>です。  
  
 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>静的メソッドでは、`strA`と`strB`できます`null`です。 両方の値が場合`null`、メソッドがあることを示す 0 \(ゼロ\) を返します`strA`と`strB`が等しい。 値の一方のみが`null`メソッドが長くなるように null 以外の値を考慮します。  
  
   
  
## 例  
 次の例では、ことを示します<xref:System.String.CompareOrdinal%2A>と<xref:System.String.Compare%2A>異なる並べ替え順を使用します。  
  
 [!code-cpp[StringCompareOrdinal\#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal\#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> は <see langword="null" /> でありません。また <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> を超えています。  
  
 または  
  
 <paramref name="strB" /> は <see langword="null" /> でありません。また <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> を超えています。  
  
 または  
  
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスと指定したオブジェクトまたは <see cref="T:System.String" /> とを比較し、並べ替え順序において、このインスタンスの位置が指定したオブジェクトまたは <see cref="T:System.String" /> の前、後ろ、または同じのいずれであるかを示す整数を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 両方のオーバー ロード、<xref:System.String.CompareTo%2A>メソッドはカルチャと区別する比較を実行します。 このメソッドを使用して、カルチャに依存しないまたは序数比較を実行することはできません。 コードをわかりやすく、ことをお勧めは避けること、<xref:System.String.CompareTo%2A>メソッドを呼び出し、<xref:System.String.Compare%2A>メソッド代わりにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.String" /> に評価されるオブジェクト。</param>
        <summary>このインスタンスと指定した <see cref="T:System.Object" /> とを比較し、並べ替え順序において、このインスタンスの位置が指定した <see cref="T:System.Object" /> の前、後ろ、または同じのいずれであるかを示します。</summary>
        <returns>並べ替え順序において、このインスタンスの位置が <paramref name="value" /> パラメーターよりも前、後ろ、または同じのいずれであるかを示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description> このインスタンスの位置が <paramref name="value" /> よりも前です。  
  
 </description></item><item><term> 0  
  
 </term><description> このインスタンスの位置が、並べ替え順序において <paramref name="value" /> と同じです。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description> このインスタンスの位置が <paramref name="value" /> よりも後ろです。  
  
 または  
  
 <paramref name="value" /> は <see langword="null" /> です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `value`必要があります、<xref:System.String>オブジェクト。  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A>メソッドが並べ替えまたは操作をアルファベット順に並べ替えで使用するため、主に設計されています。 これはありません、メソッド呼び出しの主な目的は、2 つの文字列が等価かどうかを決定するときに使用する必要があります。 2 つの文字列が等価かどうかを判断するのには、呼び出し、<xref:System.String.Equals%2A>メソッドです。  
  
 このメソッドは、現在のカルチャを使用して、単語 \(大文字小文字を区別やカルチャ\) 比較を実行します。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=fullName>です。  
  
 このメソッドの動作に関する詳細については、の「解説」セクションを参照してください、<xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=fullName>メソッドです。  
  
   
  
## 例  
 次の例では、<xref:System.String.CompareTo%2A>メソッドを<xref:System.Object>です。 しようとすると比較するため、<xref:System.String>インスタンスを`TestClass`オブジェクト、メソッドをスロー、<xref:System.ArgumentException>です。  
  
 [!code-cpp[ExToString\#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> が <see cref="T:System.String" /> ではありません。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.CompareTo(System.Object)" /> method does not consider such characters when it performs a culture-sensitive comparison. For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.  
  
 [!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  
  
 To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと指定した <see cref="T:System.String" /> オブジェクトとを比較し、並べ替え順序において、このインスタンスの位置が指定した文字列の前、後ろ、または同じのいずれであるかを示します。</summary>
        <returns>並べ替え順序において、このインスタンスの位置が <paramref name="strB" /> パラメーターよりも前、後ろ、または同じのいずれであるかを示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値  
  
 </term><description> 状態  
  
 </description></listheader><item><term> 0 より小さい値  
  
 </term><description> このインスタンスの位置が <paramref name="strB" /> よりも前です。  
  
 </description></item><item><term> 0  
  
 </term><description> このインスタンスの位置が、並べ替え順序において <paramref name="strB" /> と同じです。  
  
 </description></item><item><term> 0 より大きい値  
  
 </term><description> このインスタンスの位置が <paramref name="strB" /> よりも後ろです。  
  
 または  
  
 <paramref name="strB" /> は <see langword="null" /> です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、現在のカルチャを使用して、単語 \(大文字小文字を区別やカルチャ\) 比較を実行します。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=fullName>です。  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A>メソッドが並べ替えまたは操作をアルファベット順に並べ替えで使用するため、主に設計されています。 これはありません、メソッド呼び出しの主な目的は、2 つの文字列が等価かどうかを決定するときに使用する必要があります。 2 つの文字列が等価かどうかを判断するのには、呼び出し、<xref:System.String.Equals%2A>メソッドです。  
  
 このメソッドの動作に関する詳細については、の「解説」セクションを参照してください、<xref:System.String.Compare%28System.String%2CSystem.String%29>メソッドです。  
  
 このメソッドを実装する、<xref:System.IComparable%601?displayProperty=fullName>インターフェイスし、実行よりもわずかに向上、<xref:System.String.CompareTo%28System.Object%29?displayProperty=fullName>メソッドを決定するがあるないためかどうか、`strB`引数は、ボックス化する必要があります変更可能な値の型およびからは、そのパラメーターをキャストする必要はありません、<xref:System.Object>を<xref:System.String>です。  
  
   
  
## 例  
 次の例では、<xref:System.String.CompareTo%2A>別の文字列の現在の文字列インスタンスと比較するメソッド。  
  
 [!code-cpp[stringcompareto\#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto\#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 次の例では、いくつかの値と参照型の CompareTo メソッドのジェネリックと非ジェネリックのバージョンを示します。  
  
 [!code-cpp[T.CompareTo\#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo\#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters. The <see cref="M:System.String.CompareTo(System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison. For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.  
  
 [!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  
  
 To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を実装し、ジェネリック型引数が <see cref="T:System.String" /> であるコレクション オブジェクト。</param>
        <summary>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の構築された <see cref="T:System.String" /> コレクションのメンバーを連結します。</summary>
        <returns>
          <paramref name="values" /> 内の文字列の連結結果。または、<paramref name="values" /> が空の <see langword="IEnumerable(Of String)" /> である場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッド内の各オブジェクトを連結する`values`; 任意の区切り記号を追加することはできません。 各メンバーの間の区切り記号を指定する`values`を呼び出して、<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>メソッドです。  
  
 <xref:System.String.Empty>文字列は、の任意の null 要素の代わりに使用`values`です。  
  
 場合`values`は、空`IEnumerable(Of String)`、メソッドを返します<xref:System.String.Empty?displayProperty=fullName>です。 場合`values`は`null`がスローされます、<xref:System.ArgumentNullException>例外。  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>内の各要素を連結できる便利なメソッドは、`IEnumerable(Of String)`を文字列配列の要素を変換せずコレクション。 統合言語クエリ \(LINQ\) クエリ式で特に便利です。 次の例では、`List(Of String)`と等しいか \(つまり、例では、"M"\) 特定の文字を超える文字を選択する、ラムダ式にアルファベットの大文字または小文字の文字を含むオブジェクトです。`IEnumerable(Of String)`によって返されるコレクション、<xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName>にメソッドが渡される、<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>を 1 つの文字列として結果を表示するメソッド。  
  
 [!code-csharp[System.String.Concat\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## 例  
 次の例では、エラトステネスの篩というアルゴリズムを使用して、小さいか 100 素数を計算します。 結果を割り当てます、<xref:System.Collections.Generic.List%601>型のオブジェクト<xref:System.String>、しに渡されます、<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>メソッドです。  
  
 [!code-csharp[System.String.Concat\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">表現するオブジェクトまたは <see langword="null" />。</param>
        <summary>指定されたオブジェクトの文字列形式を作成します。</summary>
        <returns>
          <paramref name="arg0" /> の値の文字列形式。<paramref name="arg0" /> が <see langword="null" /> の場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.Concat%28System.Object%29>メソッドを表します`arg0`を呼び出して、パラメーターなしの文字列として`ToString`メソッドです。  
  
   
  
## 例  
 次の例で、<xref:System.String.Concat%2A>メソッドです。  
  
 [!code-cpp[string.concat5\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">連結する要素を格納しているオブジェクト配列。</param>
        <summary>指定された <see cref="T:System.Object" /> 配列の要素の文字列表記を連結します。</summary>
        <returns>
          <paramref name="args" /> の各要素の値を連結した文字列表記。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The method concatenates each object in **parameterReference tag is not supported!!!!**  
 by calling the parameterless **languageKeyword tag is not supported!!!!**  
 method of that object; it does not add any delimiters.  
  
 <xref:System.String.Empty?displayProperty=fullName> is used in place of any null object in the array.  
  
   
  
## 例  
 The following example demonstrates the use of the <xref:System.String.Concat%2A> method with an <xref:System.Object> array.  
  
 [!code-csharp[stringconcat1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <block subset="none" type="usage">
          <para>This method is not called by C++ code. The C++ compiler resolves calls to <see cref="Overload:System.String.Concat" /> that have four or more object parameters as a call to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">文字列インスタンスの配列。</param>
        <summary>指定した <see cref="T:System.String" /> 配列の要素を連結します。</summary>
        <returns>連結された <paramref name="values" /> の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッド内の各オブジェクトを連結する`values`; 任意の区切り記号を追加することはできません。  
  
 <xref:System.String.Empty>文字列は、配列内の任意の null オブジェクトの代わりに使用します。  
  
   
  
## 例  
 次の例での使用、<xref:System.String.Concat%2A>メソッドを<xref:System.String>配列。  
  
 [!code-cpp[stringconcat3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <summary>指定した 2 つのオブジェクトの文字列形式を連結します。</summary>
        <returns>
          <paramref name="arg0" /> および <paramref name="arg1" /> の値の文字列形式を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドを連結`arg0`と`arg1`パラメーターなしで呼び出すことによって`ToString`メソッドの`arg0`と`arg1`; 任意の区切り記号を追加することはできません。  
  
 <xref:System.String.Empty?displayProperty=fullName>任意の null の引数の代わりに使用されます。  
  
 場合、引数の配列参照は、メソッドは、そのメンバー \(たとえば、"System.String\[\]"\) 代わりに、その配列を表す文字列を連結します。  
  
   
  
## 例  
 次の例で、<xref:System.String.Concat%2A>メソッドです。  
  
 [!code-cpp[string.concat5\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> インスタンスを連結します。</summary>
        <returns>
          <paramref name="str0" /> と <paramref name="str1" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The method concatenates **parameterReference tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
; it does not add any delimiters.  
  
> [!NOTE]
>  You can also use your language's string concatenation operator, such as **languageKeyword tag is not supported!!!!**  
>  in C\#, or **languageKeyword tag is not supported!!!!**  
>  and **languageKeyword tag is not supported!!!!**  
>  in Visual Basic\)  
>   
>  , to concatenate strings.  
  
 An <xref:System.String.Empty> string is used in place of any null argument.  
  
   
  
## 例  
 The following example concatenates a person's first, middle, and last name.  
  
 [!code-cpp[stringconcat4\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <param name="arg2">連結する 3 番目のオブジェクト。</param>
        <summary>指定した 3 つのオブジェクトの文字列形式を連結します。</summary>
        <returns>
          <paramref name="arg0" />、<paramref name="arg1" /> および <paramref name="arg2" /> の値の文字列形式を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドを連結`arg0`、 `arg1`、および`arg2`パラメーターなしで呼び出すことによって`ToString`; 各オブジェクトの任意の区切り記号を追加することはできません。  
  
 <xref:System.String.Empty?displayProperty=fullName>任意の null の引数の代わりに使用されます。  
  
   
  
## 例  
 次の例で、<xref:System.String.Concat%2A>メソッドです。  
  
 [!code-cpp[string.concat5\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <param name="str2">連結する 3 番目の文字列。</param>
        <summary>
          <see cref="T:System.String" /> の指定した 3 つのインスタンスを連結します。</summary>
        <returns>
          <paramref name="str0" />、<paramref name="str1" />、および <paramref name="str2" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The method concatenates **parameterReference tag is not supported!!!!**  
, **parameterReference tag is not supported!!!!**  
, and **parameterReference tag is not supported!!!!**  
; it does not add any delimiters.  
  
> [!NOTE]
>  You can also use your language's string concatenation operator, such as **languageKeyword tag is not supported!!!!**  
>  in C\#, or **languageKeyword tag is not supported!!!!**  
>  and **languageKeyword tag is not supported!!!!**  
>  in Visual Basic\)  
>   
>  , to concatenate strings.  
  
 An <xref:System.String.Empty> string is used in place of any null argument.  
  
   
  
## 例  
 The following example uses the <xref:System.String.Concat%2A> method to concatenate three strings and displays the result.  
  
 [!code-cpp[System.String.Concat\#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <param name="arg2">連結する 3 番目のオブジェクト。</param>
        <param name="arg3">連結する 4 番目のオブジェクト。</param>
        <summary>4 つの指定したオブジェクトと、オプションの可変長パラメーター リストで指定した任意のオブジェクトの文字列表現を連結します。</summary>
        <returns>パラメーター リスト内の各値の文字列を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この API は、CLS に準拠していません。 CLS 準拠の代わりとして <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=fullName> を使用できます。 C\# および Visual Basic コンパイラへの呼び出しとして、このメソッドの呼び出しを自動的に解決<xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=fullName>です。  
  
 メソッドを呼び出して、パラメーターなしのパラメーター リスト内の各オブジェクトの連結`ToString`メソッド; 任意の区切り記号を追加することはできません。  
  
 <xref:System.String.Empty?displayProperty=fullName>任意の null の引数の代わりに使用されます。  
  
> [!NOTE]
>  最後のパラメーター、<xref:System.String.Concat%2A>メソッドは、連結する追加のオブジェクトを 1 つまたは複数のオプションのコンマ区切りリスト。  
  
   
  
## 例  
 次の例では、使用、<xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>変数パラメーターのリストを連結する方法です。 この場合、メソッドは 9 個のパラメーターで呼び出されます。  
  
 [!code-csharp[System.String.Concat\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>This method is marked with the <see langword="vararg" /> keyword, which means that it supports a variable number of parameters. The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code. The C# and Visual Basic compilers resolve calls to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> as calls to <see cref="M:System.String.Concat(System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <param name="str2">連結する 3 番目の文字列。</param>
        <param name="str3">連結する 4 番目の文字列。</param>
        <summary>指定した 4 つの <see cref="T:System.String" /> インスタンスを連結します。</summary>
        <returns>
          <paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" />、および <paramref name="str3" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドを連結`str0`、 `str1`、 `str2`、および`str3`; 任意の区切り記号を追加することはできません。  
  
> [!NOTE]
>  など、言語の文字列連結演算子を使用することもできます`+`C\# の場合、または`&`と`+`Visual basic\)。  
>   
>  、文字列を連結します。  
  
 <xref:System.String.Empty>文字列は、配列内の任意の null オブジェクトの代わりに使用します。  
  
   
  
## 例  
 次の例では、4 文字単語の配列を定義し、それらを暗号化するために、個々 の文字を文字列配列を格納します。 呼び出して、<xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29>スクランブルされた単語を再構成するためのメソッドです。  
  
 [!code-csharp[System.String.Concat\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <c>values</c> のメンバーの型。</typeparam>
        <param name="values">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> インターフェイスを実装するコレクション オブジェクト。</param>
        <summary>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 実装のメンバーを連結します。</summary>
        <returns>
          <paramref name="values" /> 内のメンバーの連結結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッド内の各オブジェクトを連結する`values`; 任意の区切り記号を追加することはできません。  
  
 <xref:System.String.Empty>文字列は、任意の null の引数の代わりに使用します。  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>内の各要素を連結できる便利なメソッドは、<xref:System.Collections.Generic.IEnumerable%601>文字列に要素を変換せずコレクション。 この例に示すように統合言語クエリ \(LINQ\) のクエリ式で特に便利です。 内の各オブジェクトの文字列形式を、<xref:System.Collections.Generic.IEnumerable%601>を呼び出してそのオブジェクトのコレクションを派生`ToString`メソッドです。  
  
   
  
## 例  
 次の例は非常に単純な定義`Animal`動物とそれが属する注文書の名前を表すクラス。 定義し、<xref:System.Collections.Generic.List%601>の数を格納するオブジェクト`Animal`オブジェクト。<xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName>抽出する拡張メソッドが呼び出される、`Animal`オブジェクト`Order`"Rodent"と等しい。 結果に渡される、<xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドされ、コンソールに表示されます。  
  
 [!code-csharp[System.String.Concat\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定した部分文字列がこの文字列内に存在するかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="value" /> パラメーターがこの文字列内に存在するか、<paramref name="value" /> が空の文字列 \(""\) の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、序数に基づく \(大文字小文字を区別とカルチャに依存しない\) 比較を実行します。 検索はこの文字列の最初の文字位置から開始し、最後の文字位置から続行します。  
  
 序数に基づく比較 \(カルチャに依存した比較や大文字と小文字は序数\) 以外のものを使用して指定した部分文字列を含む文字列かどうかを判断する、カスタム メソッドを作成することができます。 次の例では、このような 1 つのアプローチを示します。 定義、<xref:System.String>拡張メソッドが含まれている<xref:System.StringComparison>パラメーターと、文字列比較の指定されたフォームを使用する場合に、文字列が文字列を含んでいるかどうかを示します。  
  
 [!code-csharp[System.String.Contains\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 次の例は、呼び出し、`Contains`序数に基づく比較と大文字と小文字の序数に基づく比較を使用して部分文字列が文字列で見つかったかどうかを決定する拡張メソッド。  
  
 [!code-csharp[System.String.Contains\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 部分文字列の位置に興味のあるかどうかは`value`、現在のインスタンスで呼び出すことができます、 <xref:System.String.IndexOf%2A> 、最初に見つかった、またはの開始位置を取得するメソッドを呼び出すことができます、<xref:System.String.LastIndexOf%2A>最後に見つかった位置の開始位置を取得します。 例への呼び出しが含まれています、<xref:System.String.IndexOf%28System.String%29>文字列インスタンスの部分文字列が見つかった場合はメソッドです。  
  
   
  
## 例  
 次の例"について fox"という文字列が使い慣れた引用符の部分文字列であるかどうかを判断します。 "Fox"がある場合、文字列でも、その開始位置を表示します。  
  
 [!code-cpp[String.Contains\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">コピーする文字列。</param>
        <summary>指定した <see cref="T:System.String" /> と同じ値を使用して、<see cref="T:System.String" /> の新しいインスタンスを作成します。</summary>
        <returns>
          <paramref name="str" /> と同じ値を持つ新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.Copy%2A>メソッドを返します、<xref:System.String>オブジェクトがあるが、元の文字列と同じ値を持つ別のオブジェクトの参照を表します。 既存の文字列参照を他のオブジェクトを変数に割り当てます代入演算とは異なります。 この例では、この違いを示します。  
  
   
  
## 例  
 次の例では、値が異なる 2 つの文字列オブジェクトを作成します。 呼び出すとき、 <xref:System.String.Copy%2A> 2 番目の文字列に、最初の値を割り当てる方法、出力は、その値が同じようになりましたが、文字列が別のオブジェクト参照を表すことを示します。 その一方で、最初の文字列が 2 番目の文字列に割り当てられると、2 つの文字列値を持つ同一同じオブジェクト参照を表すためです。  
  
 [!code-csharp[System.String.Copy\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">コピーする、このインスタンス内の最初の文字のインデックス。</param>
        <param name="destination">このインスタンスの文字のコピー先となる Unicode 文字の配列。</param>
        <param name="destinationIndex">コピー操作を開始する <c>destination</c> のインデックス。</param>
        <param name="count">
          <c>destination</c> へコピーされるこのインスタンスの文字の数。</param>
        <summary>このインスタンスの指定位置から指定した数の文字を、Unicode 文字の配列内の指定位置へコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コピー`count`の文字、`sourceIndex`とこのインスタンスの位置、`destinationIndex`位置`destination`文字配列。 このメソッドがサイズ変更されない、`destination`文字配列にコピーされた文字を対応する要素のための十分な数である; またはがスローされます、[CopyTo メソッド \(Int32, Char\<xref:System.ArgumentOutOfRangeException>です。  
  
 `sourceIndex` `destinationIndex`は 0 から始まります。  
  
   
  
## 例  
 次の例で、[CopyTo メソッド \(Int32, Char\<xref:System.String.CopyTo%2A>メソッドです。  
  
 [!code-cpp[stringcopyto\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />、<paramref name="destinationIndex" />、または <paramref name="count" /> が負の値です。  
  
 \-または\-  
  
 <paramref name="sourceIndex" /> が現在のインスタンス内の位置を識別していません。  
  
 \-または\-  
  
 <paramref name="destinationIndex" /> が、<paramref name="destination" /> 配列内の有効なインデックスを識別していません。  
  
 \-または\-  
  
 <paramref name="count" /> は、このインスタンスの <paramref name="startIndex" /> から末尾までの部分文字列の長さを超えています。  
  
 または  
  
 <paramref name="count" /> は、<paramref name="destination" /> 配列の <paramref name="destinationIndex" /> から末尾までの部分配列の長さを超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>空の文字列を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The value of this field is the zero\-length string, "".  
  
 In application code, this field is most commonly used in assignments to initialize a string variable to an empty string. To test whether the value of a string is either **languageKeyword tag is not supported!!!!**  
 or <xref:System.String.Empty?displayProperty=fullName>, use the <xref:System.String.IsNullOrEmpty%2A> method.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <summary>この文字列インスタンスの末尾が、指定した文字列と一致するかどうかを判断します。</summary>
        <returns>このインスタンスの末尾が <paramref name="value" /> と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method compares **parameterReference tag is not supported!!!!**  
 to the substring at the end of this instance that is the same length as **parameterReference tag is not supported!!!!**  
, and returns an indication whether they are equal. To be equal, **parameterReference tag is not supported!!!!**  
 must be a reference to this same instance or match the end of this instance.  
  
 This method performs a word \(case\-sensitive and culture\-sensitive\) comparison using the current culture.  
  
   
  
## 例  
 The following example indicates whether each string in an array ends with a period \("."\).  
  
 [!code-csharp[System.String.EndsWith\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 The following example defines a `StripEndTags` method that uses the <xref:System.String.EndsWith%28System.String%29> method to remove HTML end tags from the end of a line. Note that the  `StripEndTags` method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.  
  
 [!code-cpp[stringendswith\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <param name="comparisonType">この文字列と <c>value</c> との比較方法を決定する列挙値の 1 つ。</param>
        <summary>指定された比較オプションを使って比較した場合に、この文字列インスタンスの末尾が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns>
          <paramref name="value" /> パラメーターがこの文字列の末尾と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.String.EndsWith%2A> method compares the **parameterReference tag is not supported!!!!**  
 parameter to the substring at the end of this string and returns a value that indicates whether they are equal. To be equal, **parameterReference tag is not supported!!!!**  
 must be a reference to this same string, must be the empty string \(""\), or must match the end of this string. The type of comparison performed by the <xref:System.String.EndsWith%2A> method depends on the value of the **parameterReference tag is not supported!!!!**  
parameter.  
  
   
  
## 例  
 The following example determines whether a string ends with a particular substring. The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.  
  
 [!code-cpp[System.String.EndsWithCmp\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">このインスタンスと <c>value</c> との比較方法を決定するカルチャ情報。<c>culture</c> が <see langword="null" /> の場合は、現在のカルチャが使用されます。</param>
        <summary>指定されたカルチャを使って比較した場合に、この文字列インスタンスの末尾が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns>
          <paramref name="value" /> パラメーターがこの文字列の末尾と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method compares the **parameterReference tag is not supported!!!!**  
 parameter to the substring at the end of this string that is the same length as **parameterReference tag is not supported!!!!**  
, and returns a value that indicates whether they are equal. To be equal, **parameterReference tag is not supported!!!!**  
 must be a reference to this same instance or match the end of this string.  
  
 This method performs a word \(culture\-sensitive\) comparison using the specified casing and culture.  
  
   
  
## 例  
 The following example determines whether a string occurs at the end of another string. The <xref:System.String.EndsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.  
  
 [!code-csharp[system.string.EndsWithCI\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと、指定したオブジェクトの値が同一かどうかを判断します。<see cref="T:System.String" /> オブジェクトを指定する必要があります。</summary>
        <returns>
          <see langword="true" /> が <paramref name="obj" /> で、このインスタンスと同じ値を保持している場合は <see cref="T:System.String" />。それ以外の場合は <see langword="false" />。<paramref name="obj" /> が <see langword="null" /> の場合、メソッドは <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method performs an ordinal \(case\-sensitive and culture\-insensitive\) comparison.  
  
   
  
## 例  
 The following example demonstrates the <xref:System.String.Equals%2A> method.  
  
 [!code-cpp[string.equals\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと、指定した別の <see cref="T:System.String" /> の値が同一かどうかを判断します。</summary>
        <returns>
          <see langword="true" /> パラメーターの値がこのインスタンスの値と同じ場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。<paramref name="value" /> が <see langword="null" /> の場合、メソッドは <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method performs an ordinal \(case\-sensitive and culture\-insensitive\) comparison.  
  
   
  
## 例  
 The following example demonstrates the <xref:System.String.Equals%2A> method.It compares the title\-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I \(U\+0131\) instead of LATIN SMALL LETTER I \(U\+0069\). Because the <xref:System.String.Equals%28System.String%29> method performs an ordinal comparison, only the comparison with an identical word returns `true`.  
  
 [!code-csharp[System.String.Equals\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。</summary>
        <returns>
          <paramref name="a" /> の値が <paramref name="b" /> の値と同じ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。<paramref name="a" /> と <paramref name="b" /> の両方が <see langword="null" /> の場合、メソッドは <see langword="true" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method performs an ordinal \(case\-sensitive and culture\-insensitive\) comparison.  
  
   
  
## 例  
 The following example demonstrates the <xref:System.String.Equals%2A> method.  
  
 [!code-cpp[string.equals\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスと比較する文字列。</param>
        <param name="comparisonType">文字列の比較方法を指定する列挙値の 1 つ。</param>
        <summary>この文字列と、指定した <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。 比較に使用するカルチャ、大文字と小文字の区別、および、並べ替え規則をパラメーターで指定します。</summary>
        <returns>
          <see langword="true" /> パラメーターの値がこの文字列と同じ場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The **parameterReference tag is not supported!!!!**  
 parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.  
  
   
  
## 例  
 The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı". It then calls the <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method to compare them by using each possible <xref:System.StringComparison> enumeration value.  
  
 [!code-csharp[System.String.Equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.  The comparisons use the conventions of the English \(United States\) and Sami \(Upper Sweden\) cultures. Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en\-US culture but not in the Sami \(Northern Sweden\) culture.  
  
 [!code-csharp[System.String.Equals\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <param name="comparisonType">比較の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。 比較に使用するカルチャ、大文字と小文字の区別、および、並べ替え規則をパラメーターで指定します。</summary>
        <returns>
          <see langword="true" /> パラメーターの値が <paramref name="a" /> パラメーターの値に等しい場合は <paramref name="b" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The **parameterReference tag is not supported!!!!**  
 parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.  
  
   
  
## 例  
 The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.  The comparisons use the conventions of the English \(United States\) and Sami \(Upper Sweden\) cultures. Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en\-US culture but not in the Sami \(Northern Sweden\) culture.  
  
 [!code-csharp[System.String.Equals\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された形式に基づいてオブジェクトの値を文字列に変換し、別の文字列に挿入します。  
  
 初めて使用する場合、<see cref="Overload:System.String.Format" />メソッドを参照してください、[String.Format メソッドの使用を開始する](#Starting)概要セクションです。  
  
 参照してください、[解説](#Format_Syntax)すべてに関する完全なドキュメントのセクション<see cref="Overload:System.String.Format" />オーバー ロードします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このセクションの内容:  
  
 [String.Format メソッドの使用を開始する](#Starting)   
 [メソッド構文をオーバー ロードされた](#Format_Syntax)   
 [パラメーター](#Format_Params)   
 [値を返す](#Format_Returns)   
 [例外](#Format_Exceptions)   
 [どのメソッドが呼び出し?](#FTaskList)   
 [の概要 Format メソッド](#Format_Brief)   
 [、書式指定項目](#FormatItem)   
 [引数の書式設定方法](#HowFormatted)   
 [インデックスが同じであるアイテムの書式設定](#SameIndex)   
 [書式とカルチャ](#Format_Culture)   
 [カスタム書式設定操作](#Format_Custom)   
例:   
[1 つの引数の書式設定](#Format1_Example)  
[2 つの引数の書式設定](#Format2_Example)  
[3 つの引数の書式設定](#Format3_Example)  
[以上 3 つの引数の書式設定](#Format4_Example)  
[カルチャの書式設定](#Format5_Example)  
[カスタム書式指定操作](#Format6_Example)  
[切片プロバイダーとローマ数字フォーマッタ](#Format7_Example)  
[バージョン情報](#Format_Versions)  
[String.Format Q & A](#QA)  
  
<a name="Starting"></a>   
## String.Format メソッドの使用を開始します。  
 使用する<xref:System.String.Format%2A?displayProperty=fullName>オブジェクト、変数、または式の値を別の文字列に挿入する必要がある場合。 値を挿入するなど、<xref:System.Decimal>に 1 つの文字列としてユーザーに表示する文字列値。  
  
 [!code-cpp[System.String.Format\#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp[System.String.Format\#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format\#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 その値の書式を制御することができます。  
  
 [!code-cpp[System.String.Format\#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format\#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format\#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 書式設定、以外に配置と間隔を制御することもできます。  
  
 文字列を挿入します。  
 <xref:System.String.Format%2A?displayProperty=fullName>書式指定文字列を続けてオブジェクトまたは文字列に変換および書式指定文字列の指定した位置に挿入される式の 1 つまたは複数を開始します。 例:  
  
 [!code-cpp[System.String.Format\#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp[System.String.Format\#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format\#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}`形式の文字列は、書式指定項目。`0`文字列値を持つはその位置に挿入するオブジェクトのインデックスです。 \(インデックスは、0 から始まります\)。 挿入されるオブジェクトが、文字列ではない場合、`ToString`結果の文字列に挿入する前にいずれかに変換するメソッドが呼び出されます。  
  
 オブジェクトの一覧で 2 つの書式指定項目と 2 つのオブジェクトを使用する別の例を次に示します。  
  
 [!code-cpp[System.String.Format\#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format\#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format\#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 多くの書式項目を持つことができ、数のオブジェクトとオブジェクトの一覧で、各書式項目のインデックスには、オブジェクト リストに一致するオブジェクトが含まれている限りです。 する必要はありません心配のどのオーバー ロードに関する次の操作を呼び出します。コンパイラを適切なものを選択します。  
  
 書式設定の制御  
 オブジェクトを書式設定する方法を制御する書式指定文字列の書式指定項目内のインデックスを行うことができます。 たとえば、 `{0:d}` "d"書式指定文字列をオブジェクトの一覧の最初のオブジェクトに適用されます。 単一のオブジェクトでの使用例を次に示し、2 つのアイテムの書式設定します。  
  
 [!code-cpp[System.String.Format\#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format\#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format\#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 型のサポートの数値書式指定文字列、すべての数値型を含む \(両方[標準](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467)と[カスタム](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)書式指定文字列\)、すべての日付と時刻 \(両方[標準](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b)と[カスタム](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)書式指定文字列\) と時間間隔 \(両方[標準](http://msdn.microsoft.com/ja-jp/9f6c95eb-63ae-4dcc-9c32-f81985c75794)と[カスタム](http://msdn.microsoft.com/ja-jp/a63ebf55-7269-416b-b4f5-286f6c03bf0e)書式指定文字列\)、すべての列挙型[列挙型](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)、および[GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx)です。 独自の型に書式指定文字列のサポートを追加することもできます。  
  
 間隔を制御します。  
 などの構文を使用して、結果の文字列に挿入する文字列の幅を定義する`{0,12}`、12 文字の文字列を挿入します。 ここでは、最初のオブジェクトの文字列形式は右揃えで 12 文字のフィールドです。  \(最初のオブジェクトの文字列形式が複数の 12 文字である場合は、ただし、推奨されるフィールドの幅は無視され、文字列全体が、結果の文字列に挿入します。\)  
  
 次の例では、文字列を保持する、6 文字のフィールド"Year"と年の一部の文字列だけでなく、15 文字のフィールド"Population"文字列を保持して人口データの一部です。 文字がある右揃えのフィールドに注意してください。  
  
 [!code-cpp[System.String.Format\#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format\#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#33)]
 [!code-vb[System.String.Format\#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 配置を制御します。  
 既定では、文字列は、そのフィールド内で右揃えのフィールド幅を指定する場合。 フィールドに文字列を左揃えにするを先頭に負の符号とフィールドの幅など`{0,-12}`12 文字の右揃えのフィールドを定義します。  
  
 次の例は、それを左揃えのラベルとデータの両方する点を除いて、1 つ前に似ています。  
  
 [!code-cpp[System.String.Format\#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format\#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format\#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=fullName>複合書式指定機能を利用します。 詳細については、「[Composite Formatting](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)」を参照してください。  
  
<a name="Format_Syntax"></a>   
## オーバー ロードされたメソッドの構文  
 オーバー ロードを選択するための追加のガイダンスについては、次を参照してください[どのメソッドが呼び出ししますか?。](#FTaskList)  
  
 `String String.Format(String`  `format` `, Object`  `arg0` `)`  
 書式項目を指定したオブジェクトの文字列形式に置き換えます \([例](#Format1_Example)\)。  
  
 `String String.Format(String`  `format` `, Object`  `arg0` `, Object`  `arg1` `)`  
 書式項目を 2 つのオブジェクトの文字列形式に置き換えます \([例](#Format2_Example)\)。  
  
 `String String.Format(String`  `format` `, Object`  `arg0` `, Object`  `arg1` `, Object`  `arg2` `)`  
 書式項目を 3 つの指定したオブジェクトの文字列形式に置き換えます \([例](#Format3_Example)\)。  
  
 `String String.Format(String`  `format` `, params Object[]`  `args` `)`  
 指定した配列内の対応するオブジェクトの文字列形式の書式項目置換 \([例](#Format4_Example)\)。  
  
 `String String.Format(IFormatProvider`  `provider` `, String`  `format` `, params Object[]`  `args` `)`  
 書式項目を指定した配列内の対応するオブジェクトの文字列形式に置換し、指定したカルチャに固有の書式情報を使用して \([例](#Format5_Example)\) またはカスタム情報を書式設定 \([例](#Format6_Example)\)。  
  
<a name="Format_Params"></a>   
## パラメーター  
 これは、パラメーターの完全な一覧、<xref:System.String.Format%2A>メソッド; 各オーバー ロードによって使用されるパラメーターの上記のオーバー ロードの構文を参照してください。 のみ、`format`パラメーターは、すべてのオーバー ロードを使用します。  
  
|パラメーター|型|説明|  
|------------|-------|--------|  
|`format`|<xref:System.String>|1 つまたは複数の書式項目を含む複合書式指定文字列 \(を参照してください[書式指定項目](#FormatItem)\)。|  
|`arg0`|<xref:System.String>|最初のページまたは書式指定するオブジェクトのみです。|  
|`arg1`|<xref:System.String>|2 番目に書式設定するオブジェクト。|  
|`arg2`|<xref:System.String>|3 番目に書式設定するオブジェクト。|  
|`args`|<xref:System.String>\[\]|0 個以上のオブジェクトを書式設定すると、コンマ区切りの一覧で、または配列として指定します。|  
|`provider`|<xref:System.IFormatProvider>|カスタムまたはカルチャに固有の書式情報を提供するオブジェクト。|  
  
<a name="Format_Returns"></a>   
## 戻り値  
 型: <xref:System.String>  
のコピー`format`される書式指定項目に置換された対応する引数の文字列形式。  
  
<a name="Format_Exceptions"></a>   
## 例外  
  
|例外|条件|によってスローされます。|  
|--------|--------|------------------|  
|<xref:System.ArgumentNullException>|`format` は `null` です。|すべてのオーバー ロードします。|  
|<xref:System.FormatException>|`format` が正しくありません。<br /><br /> または<br /><br /> 書式指定項目のインデックスは、ゼロ未満、またはより大きいか、引数リスト内の引数の数と同じです。|すべてのオーバー ロードします。|  
  
<a name="FTaskList"></a>   
## どのメソッドが呼び出ししますか。  
  
|目的|Call|  
|--------|----------|  
|現在のカルチャの規則を使用して 1 つまたは複数のオブジェクトの書式設定します。|含むオーバー ロードを除く、`provider`パラメーター、残りの<xref:System.String.Format%2A>オーバー ロードが含まれて、<xref:System.String>パラメーターの後に 1 つまたは複数のオブジェクトのパラメーターです。 このためを決定する必要はありません<xref:System.String.Format%2A>オーバー ロードを呼び出そうとします。 言語コンパイラがないオーバー ロードの中から適切なオーバー ロードを選択して、`provider`引数リストに基づくパラメーター。 たとえば、引数リストに 5 つの引数がある場合、コンパイラが呼び出す、<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>メソッドです。|  
|特定のカルチャの規則を使用して 1 つまたは複数のオブジェクトの書式設定します。|各<xref:System.String.Format%2A>オーバー ロードで始まり、`provider`パラメーターの後に、<xref:System.String>パラメーターと 1 つまたは複数オブジェクトのパラメーターです。 このためはどの固有の仕様を決定する必要はありません<xref:System.String.Format%2A>オーバー ロードを呼び出そうとします。 言語コンパイラがオーバー ロードの中から適切なオーバー ロードを選択して、`provider`引数リストに基づくパラメーター。 たとえば、引数リストに 5 つの引数がある場合、コンパイラが呼び出す、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>メソッドです。|  
|いずれかで、カスタムの書式設定操作を実行、<xref:System.ICustomFormatter>実装または<xref:System.IFormattable>実装します。|持つ 4 つのオーバー ロードのいずれか、`provider`パラメーター。 コンパイラを持つオーバー ロードの中から適切なオーバー ロードを選択して、`provider`引数リストに基づくパラメーター。|  
  
<a name="Format_Brief"></a>   
## Format メソッドの概要  
 各オーバー ロード、<xref:System.String.Format%2A>メソッドを使用、[複合書式指定機能](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)を 0 から始まるインデックス付きプレース ホルダーを含む、複合書式指定文字列の書式指定項目と呼ばれます。 実行時に、各書式項目は、パラメーター リスト内の対応する引数の文字列形式に置き換えられます。 引数の値が場合`null`、書式指定項目が置き換え<xref:System.String.Empty?displayProperty=fullName>です。 たとえば、次の呼び出し、<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>メソッドには、次の 3 つの書式項目と {0}、{1}、{2}、書式指定文字列と 3 つの項目を含む引数のリストが含まれています。  
  
 [!code-cpp[System.String.Format\#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## 書式指定項目  
 書式指定項目には、この構文があります。  
  
```  
  
{  
index[,alignment][ :formatString] }  
```  
  
 角かっこは省略可能な要素を示します。 開始タグと右中かっこが必要です。 \(をリテラルの開くを含めたり、「エスケープ中かっこ」セクションを参照して、書式指定文字列に中かっこを閉じる、[Composite Formatting](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)資料です\)。  
  
 たとえば、通貨値可能性があります形式に書式指定項目は、次のように表示されます。  
  
 [!code-cpp[System.String.Format\#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
  
 書式指定項目には、次の要素があります。  
  
 *インデックス*  
 文字列表現を引数の 0 から始まるインデックス、文字列内のこの位置に含まれています。 この引数は場合`null`文字列のこの位置での空の文字列が含まれます。  
  
 *配置*  
 省略可能です。 引数が挿入されるとは、右揃え \(正の整数\) または左揃え \(負の整数値\) かどうかに、フィールドの長さの合計を示す符号付き整数。 省略した場合*配置*、先頭または末尾のスペースなしであるフィールドに対応する引数の文字列表現を挿入します。  
  
 場合の値*配置*が挿入される引数の長さよりも小さい*配置*は無視されます、引数の文字列表現の長さは、フィールド幅として使用されます。  
  
 *formatString*  
 省略可能です。 対応する引数の結果の文字列の形式を指定する文字列。 省略した場合*formatString*、対応する引数のパラメーターなしの`ToString`メソッドは、文字列形式を生成するために呼び出されます。 指定した場合*formatString*、書式指定項目によって参照される引数を実装する必要があります、<xref:System.IFormattable>インターフェイスです。 書式指定文字列をサポートする型は次のとおりです。  
  
-   すべての整数および浮動小数点型があります。 \(See [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) and [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4).\)  
  
-   <xref:System.DateTime> および <xref:System.DateTimeOffset>。 \(See                                                 [Standard Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b) and [Custom Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984).\)  
  
-   すべての列挙型。 \(「[Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)」を参照\)。  
  
-   <xref:System.TimeSpan> 値。 \(See [Standard TimeSpan Format Strings](http://msdn.microsoft.com/ja-jp/9f6c95eb-63ae-4dcc-9c32-f81985c75794) and [Custom TimeSpan Format Strings](http://msdn.microsoft.com/ja-jp/a63ebf55-7269-416b-b4f5-286f6c03bf0e).\)  
  
-   GUID。 \(を参照してください、<xref:System.Guid.ToString%28System.String%29?displayProperty=fullName>メソッドです\)。  
  
 ただし、カスタムの型を実装することを<xref:System.IFormattable>、既存の型の拡張または<xref:System.IFormattable>実装します。  
  
 次の例では、`alignment`と`formatString`書式付き出力を生成する引数。  
  
 [!code-cpp[System.String.Format\#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp[System.String.Format\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## 引数の書式設定方法  
 書式項目は、文字列の先頭から順に処理されます。 各書式項目には、メソッドの引数リスト内のオブジェクトに対応するインデックスがあります。<xref:System.String.Format%2A>メソッドは、引数を取得し、その文字列形式を次のように派生します。  
  
-   引数が場合`null`、メソッドを挿入します。<xref:System.String.Empty?displayProperty=fullName>結果の文字列にします。  
  
-   呼び出す場合は、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>オーバー ロードおよび`provider`パラメーターを実装する、<xref:System.ICustomFormatter>インターフェイスに渡される引数、`provider`オブジェクトの<xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=fullName>メソッドです。 書式指定項目が含まれている場合、 *formatString* 、引数として渡される最初の引数メソッドにします。 場合、<xref:System.ICustomFormatter>実装は、書式指定サービスを提供することが、引数の文字列表現を返しますそれ以外の場合を返しますそれ以外の場合、`null`し、次の手順を実行します。  
  
-   引数を実装する場合、<xref:System.IFormattable>インターフェイス、その<xref:System.IFormattable.ToString%2A?displayProperty=fullName>実装が呼び出されます。  
  
-   引数のパラメーターなしの`ToString`がオーバーライドまたはから継承するメソッド、<xref:System.Object>クラスが呼び出されて、します。  
  
 呼び出しをインターセプトする例については、<xref:System.ICustomFormatter.Format%2A?displayProperty=fullName>メソッド情報を表示することができます、<xref:System.String.Format%2A>メソッドは、複合書式指定文字列内の各書式項目を書式設定メソッドを参照してください[例 7: 切片プロバイダーとローマ数字フォーマッタ](#Format7_Example)です。  
  
<a name="SameIndex"></a>   
## インデックスが同じである書式指定項目  
 <xref:System.String.Format%2A>メソッドがスローされます、<xref:System.FormatException>インデックス項目のインデックスが、引数リスト内の引数の数以上の場合は例外です。 ただし、`format`同じインデックスを複数の書式項目がある限り、引数がある数より多くの書式項目を含めることができます。 呼び出しで、<xref:System.String.Format%28System.String%2CSystem.Object%29>次の例では、引数リスト内のメソッドが 1 つの引数が、書式指定文字列には、次の 2 つの書式項目が含まれています。 10 進値、数値のいずれかが表示されます、16 進値、もう 1 つ表示します。  
  
 [!code-csharp[System.String.Format2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## 書式とカルチャ  
 によって返される、現在のカルチャの規則を使用して、引数リスト内のオブジェクトをそれぞれの文字列表現に変換されます一般に、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>プロパティです。 オーバー ロードのいずれかを呼び出すことによってこの動作を制御する<xref:System.String.Format%2A>が含まれている、`provider`パラメーター。`provider`パラメーターは、<xref:System.IFormatProvider>中程度の書式設定に使用されるカスタムおよびカルチャに固有の書式情報を提供する実装を処理します。  
  
 <xref:System.IFormatProvider>インターフェイスが 1 つのメンバー、<xref:System.IFormatProvider.GetFormat%2A>はの書式情報を提供するオブジェクトを返すことを担当します。 .NET Framework には 3 つ<xref:System.IFormatProvider>カルチャに固有の書式を提供する実装。  
  
-   <xref:System.Globalization.CultureInfo>。 その<xref:System.Globalization.CultureInfo.GetFormat%2A>メソッドはカルチャ固有の仕様を返します<xref:System.Globalization.NumberFormatInfo>数値およびカルチャに固有の書式設定オブジェクト<xref:System.Globalization.DateTimeFormatInfo>日付と時刻の値を書式設定するためのオブジェクト。  
  
-   <xref:System.Globalization.DateTimeFormatInfo>、日付と時刻の値のカルチャに固有の書式設定に使用されます。 その<xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A>メソッドでは、それ自体を返します。  
  
-   <xref:System.Globalization.NumberFormatInfo>、数値のカルチャに固有の書式設定に使用されます。 その<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>プロパティには、それ自体を返します。  
  
<a name="Format_Custom"></a>   
## カスタムの書式設定操作  
 いずれかのオーバー ロードを呼び出すことができます、<xref:System.String.Format%2A>メソッドが指定されて、`provider`パラメーター<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>のオーバー ロードをカスタムの書式設定操作を実行します。 たとえば、書式を設定する整数識別番号、または電話番号として。 カスタム書式設定を実行する、`provider`引数は、両方を実装する必要があります、<xref:System.IFormatProvider>と<xref:System.ICustomFormatter>インターフェイスです。 ときに、<xref:System.String.Format%2A>メソッドに渡されます、<xref:System.ICustomFormatter>実装として、`provider`引数、<xref:System.String.Format%2A>メソッドの呼び出し、<xref:System.IFormatProvider.GetFormat%2A?displayProperty=fullName>実装型のオブジェクトを要求して<xref:System.ICustomFormatter>です。 呼び出して、返された<xref:System.ICustomFormatter>オブジェクトの<xref:System.ICustomFormatter.Format%2A>に複合文字列の各書式項目の書式を設定するメソッドに渡されます。  
  
 詳細については、カスタムの書式設定ソリューションを提供する、次を参照してください。[How to: Define and Use Custom Numeric Format Providers](http://msdn.microsoft.com/ja-jp/a281bfbf-6596-45ed-a2d6-3782d535ada2)と<xref:System.ICustomFormatter>です。 整数を書式設定されたカスタムの数値に変換する例は、次を参照してください。[例 6: カスタムの書式設定操作](#Format6_Example)です。 符号なしバイトをローマ数字に変換する例は、次を参照してください。[例 7: 切片プロバイダーとローマ数字フォーマッタ](#Format7_Example)です。  
  
<a name="Format1_Example"></a>   
## 例 1: 1 つの引数の書式設定  
 次の例では、<xref:System.String.Format%28System.String%2CSystem.Object%29>を文字列の途中で個々 のユーザーの年齢を埋め込む方法。  
  
 [!code-cpp[System.String.Format\#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp[System.String.Format\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  
  
<a name="Format2_Example"></a>   
## 例 2: 2 つの引数の書式設定  
 この例では、<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29>ジェネリック型に格納されている時刻と温度のデータを表示するメソッドを<xref:System.Collections.Generic.Dictionary%602>オブジェクト。 書式設定する 2 つのオブジェクトが、書式指定文字列が次の 3 つの書式指定項目に注意してください。 これは、\(日付と時刻の値\) の一覧の最初のオブジェクトが 2 つの書式指定項目によって使用されるため、: 最初書式項目が表示されます、時刻、および 2 番目の日付を表示します。  
  
 [!code-cpp[System.String.Format\#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
  
<a name="Format3_Example"></a>   
## 例 3: 3 つの引数の書式設定  
 この例では、<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>ブール値の結果を示す文字列を作成するメソッド`And`2 つの整数値で操作します。 各項目が 2 つの方法で書式設定されたため、書式指定文字列には、6 つの書式項目が含まれていますが、メソッドのパラメーター リストの 3 つだけのアイテムに注意してください。  
  
 [!code-cpp[System.String.Format\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp[System.String.Format\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
  
<a name="Format4_Example"></a>   
## 例 4: 複数の 3 つの引数の書式設定  
 この例では、特定の日付の上限と下限の温度上のデータを含む文字列を作成します。 複合書式指定文字列は、c\# の例では 5 つの書式指定項目と Visual Basic の例は 6 つがします。 形式の対応する値の文字列形式の幅を定義する 2 つの書式項目をおよび最初の書式項目は、標準の日時書式指定文字列にも含まれます。  
  
 [!code-cpp[System.String.Format\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 配列として書式設定するオブジェクトを渡すこともできますではなく、引数リストを指定します。  
  
 [!code-cpp[System.String.Format\#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp[System.String.Format\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  
  
<a name="Format5_Example"></a>   
## 例 5: カルチャに依存した書式指定  
 この例では、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>メソッドを複数の異なるカルチャを使用して、一部の日付と時刻の値と数値の文字列形式を表示します。  
  
 [!code-csharp[System.String.Format2\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  
  
<a name="Format6_Example"></a>   
## 例 6: カスタム書式指定操作  
 この例では、フォーム x\-xxxxx\-xx で顧客アカウント番号として整数値を書式設定する書式設定プロバイダーを定義します。  
  
 [!code-cpp[System.String.Format\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp[System.String.Format\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
## 例 7: インターセプト プロバイダーとローマ数字フォーマッタ  
 この例で定義を実装するカスタム書式設定プロバイダー、<xref:System.ICustomFormatter>と<xref:System.IFormatProvider>インターフェイスを 2 つの処理を行うには。  
  
-   渡されるパラメーターが表示されます、<xref:System.ICustomFormatter.Format%2A?displayProperty=fullName>実装します。 これにより、どのようなパラメーターを表示する、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>書式を設定しようとする各オブジェクトのカスタム書式設定を実装するメソッドを渡します。 これは、アプリケーションをデバッグするときに役立ちます。  
  
-   書式設定するオブジェクトが"R"標準書式指定文字列を使用して書式設定対象である符号なしバイト値の場合は、カスタム フォーマッタ ローマ数字として、数値の書式設定します。  
  
 [!code-cpp[System.String.Format\#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="Format_Versions"></a>   
## バージョン情報  
 .NET Framework  
 すべてのオーバー ロードではサポートされて: 4.5、4、3.5、3.0、2.0、1.1、1.0  
  
 .NET Framework Client Profile  
 すべてのオーバー ロードではサポートされて: 4、3.5 SP1  
  
 汎用性のあるクラス ライブラリ  
 のみ<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>と<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>はサポートされています。  
  
 Windows ストア アプリ用 .NET  
 のみ<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>と<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>Windows 8 でサポートされます  
  
<a name="QA"></a>   
## String.Format Q \>\/images\/image1.jpg」の A  
  
### 書式指定項目で使用できる定義済み書式指定文字列の一覧を検索する場所は?  
  
-   すべての整数および浮動小数点型を参照してください。[Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467)と[Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。  
  
-   日付と時刻の値を参照してください。[Standard Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/bb79761a-ca08-44ee-b142-b06b3e2fc22b)と[Custom Date and Time Format Strings](http://msdn.microsoft.com/ja-jp/98b374e3-0cc2-4c78-ab44-efb671d71984)です。  
  
-   列挙値の場合は、次を参照してください。[Enumeration Format Strings](http://msdn.microsoft.com/ja-jp/dd1ff672-1052-42cf-8666-4924fb6cd1a1)です。  
  
-   <xref:System.TimeSpan>値を参照してください[Standard TimeSpan Format Strings](http://msdn.microsoft.com/ja-jp/9f6c95eb-63ae-4dcc-9c32-f81985c75794)と[Custom TimeSpan Format Strings](http://msdn.microsoft.com/ja-jp/a63ebf55-7269-416b-b4f5-286f6c03bf0e)です。  
  
-   <xref:System.Guid>値では、「解説」セクションを参照してください、<xref:System.Guid.ToString%28System.String%29?displayProperty=fullName>リファレンス ページ。  
  
### 書式項目を置換する結果文字列の配置を制御する方法は?  
 書式指定項目の一般的な構文です。  
  
```  
{index[,alignment][: formatString]}  
```  
  
 ここで*配置*フィールドの幅を定義する符号付き整数します。 この値が負の場合は、フィールド内のテキストを左揃えです。 正の場合は、テキストが右揃えです。  
  
### 小数点区切り文字の後に数字の数が制御する方法  
 すべて[標準数値書式指定文字列](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467)\(整数のみで使用される\) を"D"、"G"、"R"を除くし、"X"は、結果の文字列の小数点以下桁数を定義する有効桁数指定子を許可します。 次の例では、標準の数値書式指定文字列を使用して、結果の文字列の 10 進数字の数を制御します。  
  
 [!code-csharp[System.String.Format\#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format\#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 使用する場合、[カスタム数値書式指定文字列](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)結果の文字列に次の例のようにの 10 進数字の数を制御する、「0」書式指定子を使用します。  
  
 [!code-csharp[System.String.Format\#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format\#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### 整数部の桁の数を制御する方法は?  
 既定では、書式設定操作は、整数の桁を 0 以外をのみ表示されます。 整数の書式を設定する場合は、数字の数を制御する、精度指定子"D"と"X"標準書式指定文字列を使用できます。  
  
 [!code-csharp[System.String.Format\#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format\#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 「0」を使用して、指定された数の整数部の桁の結果の文字列を生成するために整数または浮動小数点数に先行ゼロを埋め込む[カスタム数値書式指定子](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)次の例を示します。  
  
 [!code-csharp[System.String.Format\#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format\#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### 項目の数形式の一覧で含めることはできますか。  
 実際の制限はありません。 2 番目のパラメーター、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>メソッドは割り当てられ、<xref:System.ParamArrayAttribute>属性は、コンマ区切りのリストまたは、\[形式\] ボックスの一覧としてオブジェクトの配列のいずれかを含めることができます。  
  
### リテラルのかっこを含める方法 \("{"と"}"\) は結果文字列にしますか?  
 たとえば、どのようにするには次のメソッド呼び出しからスロー、<xref:System.FormatException>例外しますか?  
  
 [!code-csharp[System.String.Format\#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format\#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 1 つの始めまたは終わりかっこは、常に先頭または書式項目の末尾として解釈がします。 どおりに解釈するのにそれをエスケープする必要があります。 別の中かっこを追加することによって、かっこをエスケープする \("{{"と"}}"の代わりに"{"と"}"\)、次のメソッド呼び出しのように。  
  
 [!code-csharp[System.String.Format\#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format\#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 ただし、さらにエスケープされた中かっこは簡単に誤ったです。 形式の一覧で中かっこを含めるし、次の例のように、結果の文字列に挿入の書式項目を使用することをお勧めします。  
  
 [!code-csharp[System.String.Format\#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format\#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### マイ String.Format メソッドの呼び出しが、FormatException をスローする理由  
 例外の最も一般的な原因は、書式指定項目のインデックスが形式 リスト内のオブジェクトに対応していないことです。 通常このエラーは、書式指定項目のインデックスを misnumbered したか、オブジェクトの一覧に含める、形式を忘れてしまったことを示します。 場合によっては、例外は、入力ミス; の結果入力し間違えたによくある間違いは、たとえば、"\["\(左角かっこ\) の代わりに"{"\(左中かっこ\)。  
  
### 場合は Format\(System.IFormatProvider,System.String,System.Object\[\]\) メソッドは、理由コード、例外がスロー配列を使用する場合、パラメーター配列をサポートしますか。  
 たとえば、次のコードがスローされます、<xref:System.FormatException>例外。  
  
 [!code-csharp[System.String.Format\#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format\#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 これは、コンパイラのオーバー ロードの解決の問題です。 コンパイラでは、整数の配列をオブジェクト配列に変換することはできません、ため、整数の配列として扱われます、単一の引数を呼び出すので、<xref:System.String.Format%28System.String%2CSystem.Object%29>メソッドです。 次の 4 つの書式項目が形式の一覧で 1 つの項目のみがあるために、例外がスローされます。  
  
 呼び出しの前に自分で変換を実行する必要があるため、Visual Basic でも C\# の場合は、整数の配列をオブジェクト配列に変換できます、<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>メソッドです。 次の例では、1 つの実装を提供します。  
  
 [!code-csharp[System.String.Format\#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format\#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A[複合書式指定文字列](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)です。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>指定された文字列の 1 つ以上の書式項目を、指定されたオブジェクトの文字列表記に置換します。</summary>
        <returns>書式項目が <paramref name="arg0" /> の文字列表記に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例と包括的な使用状況についての他のオーバー ロードは、`Format`メソッドを参照してください、<xref:System.String.Format%2A>オーバー ロードの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> の書式指定項目が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A[複合書式指定文字列](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)です。</param>
        <param name="args">0 個以上の書式設定対象オブジェクトを含んだオブジェクト配列。</param>
        <summary>指定した文字列の書式項目を、指定した配列内の対応するオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="args" /> の対応するオブジェクトの文字列表記に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例と包括的な使用状況についての他のオーバー ロードは、`Format`メソッドを参照してください、<xref:System.String.Format%2A>オーバー ロードの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 \(ゼロ\) 未満か、または <paramref name="args" /> 配列の長さ以上です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">A[複合書式指定文字列](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)です。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>指定した文字列の 1 つまたは複数の書式項目を、対応するオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="arg0" /> の文字列形式に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例ととこの他のオーバー ロードに関する包括的な使用法について、`Format`メソッドを参照してください、<xref:System.String.Format%2A>オーバー ロードの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> または <paramref name="arg0" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 未満または 1 以上です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)。</param>
        <param name="args">0 個以上の書式設定対象オブジェクトを含んだオブジェクト配列。</param>
        <summary>指定した文字列の書式項目を、指定した配列内の対応するオブジェクトの文字列表記に置換します。 パラメーターにより、カルチャ固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="args" /> の対応するオブジェクトの文字列表記に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例と包括的な使用状況についての他のオーバー ロードは、 `Format` メソッドを参照してください、 <xref:System.String.Format%2A> オーバー ロードの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 \(ゼロ\) 未満か、または <paramref name="args" /> 配列の長さ以上です。</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A[複合書式指定文字列](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)です。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>指定した文字列の書式項目を、指定した 2 つのオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="format" /> と <paramref name="arg0" /> の文字列形式に置換された <paramref name="arg1" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例と包括的な使用状況についての他のオーバー ロードは、`Format`メソッドを参照してください、<xref:System.String.Format%2A>オーバー ロードの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 でも 1 でもありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">A[複合書式指定文字列](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)です。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>指定した文字列の書式項目を、指定した 2 つのオブジェクトの文字列形式に置換します。 パラメーターは、カルチャ固有の書式情報を指定します。</summary>
        <returns>書式項目が <paramref name="arg0" /> と <paramref name="arg1" /> の文字列形式に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例と包括的な使用状況についての他のオーバー ロードは、`Format`メソッドを参照してください、<xref:System.String.Format%2A>オーバー ロードの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />、<paramref name="arg0" />、または <paramref name="arg1" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 未満または 2 以上です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A[複合書式指定文字列](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)です。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。</param>
        <summary>指定した文字列の書式項目を、指定した 3 つのオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="format" />、<paramref name="arg0" />、および <paramref name="arg1" /> の文字列形式に置換された <paramref name="arg2" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例と包括的な使用状況についての他のオーバー ロードは、`Format`メソッドを参照してください、<xref:System.String.Format%2A>オーバー ロードの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 \-または\-  
  
 書式項目のインデックスが 0 より小さいか、または 2 より大きい値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">A[複合書式指定文字列](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)です。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。</param>
        <summary>指定した文字列の書式項目を、指定した 3 つのオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式設定情報を指定します。</summary>
        <returns>書式項目が <paramref name="format" />、<paramref name="arg0" />、および <paramref name="arg1" /> の文字列形式に置換された <paramref name="arg2" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  例と包括的な使用状況についての他のオーバー ロードは、`Format`メソッドを参照してください、<xref:System.String.Format%2A>オーバー ロードの概要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />、<paramref name="arg0" />、<paramref name="arg1" />、または <paramref name="arg2" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。  
  
 または  
  
 書式項目のインデックスが 0 未満または 3 以上です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列に含まれる個々の文字を反復処理するオブジェクトを取得します。</summary>
        <returns>列挙子オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!TIP]
>  Rather than calling the <xref:System.String.GetEnumerator%2A> method to retrieve a <xref:System.CharEnumerator> object that you then use to enumerate a string, you should instead use your language's iteration construct \( in C\#,  in C\+\+\/CLR, and  in Visual Basic\).   				[foreach](http://msdn.microsoft.com/ja-jp/5a9c5ddc-5fd3-457a-9bb6-9abffcd874ec) in C\#,                  [for each](http://msdn.microsoft.com/ja-jp/0c3a364b-2747-43f3-bb8d-b7d3b7023f79) in C\+\+\/CLR, and                  [For Each](http://msdn.microsoft.com/ja-jp/ebce3120-95c3-42b1-b70b-fa7da40c75e2) in Visual Basic\).  
  
 This method enables you to iterate the individual characters in a string. For example, the Visual Basic **languageKeyword tag is not supported!!!!**  
 and C\# **languageKeyword tag is not supported!!!!**  
 statements invoke this method to return a <xref:System.CharEnumerator> object that can provide read\-only access to the characters in this string instance.  
  
   
  
## 例  
 The following example iterates the characters in several strings and displays information about their individual characters. It uses the language iteration construct rather than a call to the <xref:System.String.GetEnumerator%2A> method.  
  
 [!code-cpp[system.string.getenumerator\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 動作<xref:System.String.GetHashCode%2A>はその実装は、共通言語ランタイムの 1 つのバージョン別に異なる可能性がありますに依存します。 パフォーマンスを向上させるためには、なぜこのエラーが発生理由<xref:System.String.GetHashCode%2A>です。  
  
> [!IMPORTANT]
>  2 つの文字列オブジェクトが等しい場合は、<xref:System.String.GetHashCode%2A>メソッドと同じ値を返します。 ただし、一意の文字列値ごとに一意のハッシュ コード値はありません。 異なる文字列は、同じハッシュ コードを返すことができます。  
>   
>  ハッシュ コード自体は、安定しているは保証されません。 .NET Framework のバージョンとプラットフォーム \(32 ビットおよび 64 ビット\) など、.NET Framework の 1 つのバージョンを全体と同じ文字列のハッシュ コードは異なることができます。 場合によっては、アプリケーション ドメインによっても異なることができます。  
>   
>  その結果、ハッシュが作成された、アプリケーション ドメインの外部のコードを使用しないで、コレクション内のキー フィールドとして使用する必要がありますしないと、永続化することはありません。  
>   
>  最後に、暗号強度が高いハッシュする必要がある場合に、暗号ハッシュ関数によって返される値ではなくはハッシュ コードを使用しないでください。 暗号法のハッシュから派生するクラスを使用して、<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName>または<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName>クラスです。  
>   
>  ハッシュ コードの詳細については、次を参照してください。<xref:System.Object.GetHashCode%2A?displayProperty=fullName>です。  
  
 デスクトップ アプリで使用することができます、 [\<UseRandomizedStringHashAlgorithm\>要素](http://msdn.microsoft.com/ja-jp/c08125d6-56cc-4b23-b482-813ff85dc630)に一意のハッシュ コードを生成するのアプリケーション ドメインごと\<\/UseRandomizedStringHashAlgorithm\>。 競合の数を減らしてでき挿入とハッシュ テーブルを使用する参照の全体的なパフォーマンスを向上できます。 次の例を使用する方法を示しています、 [\<UseRandomizedStringHashAlgorithm\>要素](http://msdn.microsoft.com/ja-jp/c08125d6-56cc-4b23-b482-813ff85dc630)\<\/UseRandomizedStringHashAlgorithm\>。 定義するの一意のハッシュ コードを生成する、アプリケーション ドメインごとです。 競合の数を減らしてでき挿入とハッシュ テーブルを使用する参照の全体的なパフォーマンスを向上できます。 次の例を使用する方法を示しています、します。 定義する、`DisplayString`をあるプライベート文字列定数を含むクラス`s`値は「は文字列です」。 また、メソッドを実行しているアプリケーション ドメインの名前と共に文字列値とハッシュ コードを表示する `ShowStringHashCode` メソッドも含まれています。  
  
 [!code-csharp[System.String.GetHashCode\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 構成ファイルを指定せずにこの例を実行すると、次のような出力が表示されます。 文字列のハッシュ コードが 2 つアプリケーション ドメインで同じであることに注意してください。  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 ただし、例のディレクトリに次の構成ファイルを追加して例を実行すると、同じ文字列のハッシュ コードがアプリケーション ドメインによって異なります。  
  
```  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 構成ファイルが存在する場合、次の出力が表示されます。  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  ハッシュ コードは、挿入し、ハッシュ テーブルのキー付きのオブジェクトを効率的に取得に使用されます。 ただし、ハッシュ コードは文字列を一意に識別しないでください。 同一の文字列と同じハッシュ コードが共通言語ランタイムが別の文字列に同じハッシュ コードを割り当てることもできます。 さらに、ハッシュ コードでは、.NET Framework のバージョン、1 つのバージョンでプラットフォームおよびアプリケーション ドメインを変更できます。 このため、シリアル化またはハッシュ コード値を保持する必要がありますいないもする必要があります使用すること、ハッシュ テーブルまたはディクショナリのキーとして。  
  
 ハッシュ コードの使用に関する追加情報と`GetHashCode`メソッドを参照してください<xref:System.Object.GetHashCode%2A?displayProperty=fullName>です。  
  
   
  
## 例  
 次の例で、<xref:System.String.GetHashCode%2A>を使用してさまざまなメソッドは、文字列を入力します。  
  
 [!code-cpp[system.string.gethashcode\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>The value returned by <see cref="M:System.String.GetHashCode" /> is platform-dependent. It differs on the 32-bit and 64-bit versions of the .NET Framework. It also can differ between versions of the .NET Framework.</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.TypeCode" /> クラスには <see cref="T:System.String" /> を返します。</summary>
        <returns>列挙型定数 <see cref="F:System.TypeCode.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例を表示、<xref:System.TypeCode>に対して列挙定数、<xref:System.String>型です。  
  
 [!code-cpp[string.gettypecode\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。  
  
 このメソッドは、ここで、文字と見なされます別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName>メソッド、ここで構成済みなどの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが"AE"などの正しいシーケンス内の文字のコンポーネントの検索 \(u\+0041、u\+0045\) カルチャに応じて、します。  
  
   
  
## 例  
 次の例では、検索する方法を示しています、<xref:System.String>文字を使用するため、<xref:System.String.IndexOf%2A>メソッドです。  
  
 [!code-cpp[System.String.IndexOf\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は \-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。  
  
 このメソッドは、現在のカルチャを使用して単語 \(大文字小文字を区別やカルチャ\) 検索を実行します。 検索は、このインスタンスの最初の文字位置から開始され、最後の文字位置まで継続されます。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合`value`1 つまたは複数の無視できる文字のみで構成されて、<xref:System.String.IndexOf%28System.String%29>メソッドは常に現在のインスタンスの先頭に一致が見つかったことを示すために 0 \(ゼロ\) を返します。 次の例で、<xref:System.String.IndexOf%28System.String%29>を 2 つの文字列 \(ソフト ハイフン \(U \+0 00AD\)、"n"で後にソフト ハイフンおよびにソフト ハイフンの後に"m"\) の 3 つの部分文字列を検索するメソッドを使用します。 文字列の 1 つのみにソフト ハイフンが含まれます。 この例を実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]後で、各ケースではソフト ハイフンに無視できる文字であるため、結果は、場合と同じにソフト ハイフンが含まれていない必要があるか`value`です。 ソフト ハイフンのみを検索するときに、このメソッドは、文字列の先頭に一致するものを発見したを示すために 0 \(ゼロ\) を返します。  
  
 [!code-csharp[System.String.IndexOf\#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf\#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## 例  
 次の例は、「動物」で"n"を検索します。 文字列のインデックスは、1 つではなく、0 から始まるため、<xref:System.String.IndexOf%28System.String%29>メソッドでは、"n"が、位置 1 ことを示します。  
  
 [!code-cpp[System.String.IndexOf\#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 次の例では、<xref:System.String.IndexOf%2A>文で動物名の開始位置を決定するメソッド。 この位置を使用して、文に動物を説明する形容詞を挿入します。  
  
 [!code-cpp[stringinsert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns>その文字が見つかった場合は、文字列の先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、\-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は 0 から始まります。`startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 場合`startIndex`文字列インスタンスの長さと等しい、\-1 が返されます。  
  
 検索の範囲`startIndex`文字列の末尾にします。  
  
 このメソッドは、ここで文字と見なされます別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName>メソッド、ここで構成済みなどの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが"AE"などの正しいシーケンス内の文字のコンポーネントの検索 \(u\+0041、u\+0045\) カルチャに応じて、します。  
  
   
  
## 例  
 次の例で、<xref:System.String.IndexOf%2A>メソッドです。  
  
 [!code-cpp[string.indexof1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が、0 \(ゼロ\) 未満か、または文字列の長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、\-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックスの番号は 0 から始まります。`startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 場合 `startIndex` 文字列インスタンスの長さと等しい、\-1 が返されます。  
  
 このメソッドは、現在のカルチャを使用して単語 \(大文字小文字を区別し、カルチャに依存\) 検索を実行します。 検索を開始、 `startIndex` のこのインスタンスの位置の文字し、最後の文字位置まで続きます。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合 `value` 1 つまたは複数の無視できる文字だけで構成されて、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> メソッドは常に返します `startIndex`, 、これは、検索を開始する文字位置。 次の例では、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> で、2 つの文字列に"m"の後にソフト ハイフン \(U \+ 00AD\) の位置を検索するメソッドを使用します。 文字列の 1 つのみに必要な部分文字列が含まれます。 例を実行すると、 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] または後で、どちらの場合も、ソフト ハイフンに無視できる文字であるためメソッドを返す文字列の"m"のインデックス。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.IndexOf\#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf\#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## 例  
 次の例は、ターゲット文字列内の指定した文字列と一致する箇所をすべて検索します。  
  
 [!code-cpp[stringindexof4\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が、0 未満か、またはこの文字列の長さを超えています。</exception>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターのインデックス位置。見つからなかった場合は \-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。  
  
 `comparisonType` パラメーターが検索されるように指定、 `value` パラメーターの現在またはインバリアント カルチャを使用して、大文字または小文字を区別しない検索を使用する単語または序数比較規則を使用します。  
  
   
  
## 例  
 次 exampledemonstrates 3 つのオーバー ロードにより、 <xref:System.String.IndexOf%2A> の別の値を使用して別の文字列内の文字列の最初の出現箇所を検索するメソッド、 <xref:System.StringComparison> 列挙します。  
  
 [!code-csharp[system.string.IndexOfCmp\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.  
  
 In the following example, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings. Only one of the strings contains a soft hyphen. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string. An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.  
  
 [!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)]
 [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定文字がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns>その文字が見つかった場合は、文字列の先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、\-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 検索を開始`startIndex`され、引き続き`startIndex`\+ `count` \-1 です。 ある文字`startIndex`\+`count`検索には含まれません。  
  
 インデックス番号は 0 \(ゼロ\) から始まります。`startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 このメソッドは、場所文字と見なされます別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには使用の<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName>場所構成などの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが出現するすべての"AE"など、正しいシーケンスでの文字のコンポーネントと同じメソッド \(u\+0041 を u\+0045\) のカルチャに応じて、します。  
  
   
  
## 例  
 次の例で、<xref:System.String.IndexOf%2A>メソッドです。  
  
 [!code-cpp[system.string.indexof\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
 または  
  
 <paramref name="startIndex" /> がこの文字列の長さより大きいです。  
  
 または  
  
 <paramref name="count" /> がこの文字列の長さ \- <paramref name="startIndex" /> より大きいです。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、\-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Index numbering starts from 0 \(zero\). The **parameterReference tag is not supported!!!!**  
 parameter can range from 0 to the length of the string instance.  
  
 This method performs a word \(case\-sensitive and culture\-sensitive\) search using the current culture. The search begins at **parameterReference tag is not supported!!!!**  
 and continues to **parameterReference tag is not supported!!!!**  
 \+ **parameterReference tag is not supported!!!!**  
 \-1. The character at **parameterReference tag is not supported!!!!**  
 \+ **parameterReference tag is not supported!!!!**  
 is not included in the search.  
  
 Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture\-sensitive comparison. In a culture\-sensitive search, if **parameterReference tag is not supported!!!!**  
 contains an ignorable character, the result is equivalent to searching with that character removed. If **parameterReference tag is not supported!!!!**  
 consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method always returns **parameterReference tag is not supported!!!!**  
, which is the character position at which the search begins. In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method is used to find the position of a soft hyphen \(U\+00AD\) followed by an "m" starting in the third through sixth character positions in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture\-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".  
  
 [!code-csharp[System.String.IndexOf\#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf\#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## 例  
 The following example finds the index of all occurrences of the string "he" within a substring of another string. Note that the number of characters to be searched must be recalculated for each search iteration.  
  
 [!code-cpp[string.indexof8\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
 または  
  
 <paramref name="startIndex" /> がこの文字列の長さより大きいです。  
  
 または  
  
 <paramref name="count" /> がこの文字列の長さ \- <paramref name="startIndex" /> より大きいです。</exception>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To use the comparison rules of the current culture to perform this operation, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 現在の文字列内での検索の開始位置、および指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> パラメーターの 0 から始まるインデックス位置。見つからなかった場合は、\-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は 0 から始まります。`startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 場合`startIndex`文字列インスタンスの長さと等しい、\-1 が返されます。  
  
 `comparisonType`検索するパラメーターを指定します、`value`パラメーター現在またはインバリアント カルチャを使用して、または区別しない検索を使用して、word または序数比較規則を使用します。  
  
   
  
## 例  
 次の exampledemonstrates 3 つのオーバー ロードが、<xref:System.String.IndexOf%2A>メソッドの別の値を使用して別の文字列内の文字列の最初の出現箇所を<xref:System.StringComparison>列挙します。  
  
 [!code-csharp[system.string.IndexOfCmp\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が、0 未満か、またはこの文字列の長さを超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.  
  
 In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings. Only one of the strings contains the required substring.If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m". The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.  
  
 [!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)]
 [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 現在の文字列での検索開始位置、現在の文字列で検索する文字の数、および指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> パラメーターの 0 から始まるインデックス位置。見つからなかった場合は、\-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は 0 \(ゼロ\) から始まります。`startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 検索を開始`startIndex`され、引き続き`startIndex`\+ `count` \-1 です。 ある文字`startIndex`\+`count`検索には含まれません。  
  
 `comparisonType`を検索するパラメーターを指定します、`value`パラメーターの現在またはインバリアント カルチャを使用して、大文字小文字を区別や大文字と小文字の検索を使用して word または序数比較規則を使用しています。  
  
   
  
## 例  
 次の exampledemonstrates 3 つのオーバー ロードが、<xref:System.String.IndexOf%2A>メソッドの別の値を使用して別の文字列内の文字列の最初の出現箇所を<xref:System.StringComparison>列挙します。  
  
 [!code-csharp[system.string.IndexOfCmp\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
 または  
  
 <paramref name="startIndex" /> はこのインスタンスの長さを超えています。  
  
 または  
  
 <paramref name="count" /> がこの文字列の長さ \- <paramref name="startIndex" /> より大きいです。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.  
  
 In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. When it performs an ordinal comparison, however, it finds the substring only in the first string. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison. The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.  
  
 [!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)]
 [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。  
  
 検索`anyOf`小文字が区別されます。 場合`anyOf`メソッド検索文字列の先頭に一致するものが、空の配列 \(つまり、インデックス 0\) です。  
  
 このメソッドは、場所文字と見なされます別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには使用の<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName>場所構成などの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが出現するすべての"AE"など、正しいシーケンスでの文字のコンポーネントと同じメソッド \(u\+0041 を u\+0045\) のカルチャに応じて、します。  
  
   
  
## 例  
 次の例は、文字列内の最初の母音を検索します。  
  
 [!code-csharp[System.String.IndexOfAny\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。`startIndex`パラメーター範囲は 0 ~ 1 文字列インスタンスの長さよりも小さい値です。  
  
 検索の範囲`startIndex`文字列の末尾にします。  
  
 検索`anyOf`小文字が区別されます。  
  
 このメソッドは、ここで、文字と見なされます別の文字に相当その Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには、[IndexOfAny メソッド \(Char\<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName>メソッド、ここで構成済みなどの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが"AE"などの正しいシーケンス内の文字のコンポーネントの検索 \(u\+0041、u\+0045\) カルチャに応じて、します。  
  
   
  
## 例  
 次の例では、別の文字列の部分文字列に、"is"を文字列の任意の文字に見つかった位置のインデックスを検索します。  
  
 [!code-cpp[string.indexofany2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が負の値です。  
  
 または  
  
 <paramref name="startIndex" /> が、このインスタンス中の文字数を超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 検索を開始`startIndex`され、引き続き`startIndex`ながら`count`\-1 です。 ある文字`startIndex`\+`count`検索には含まれません。  
  
 インデックス番号は、0 から始まります。`startIndex`パラメーター範囲は 0 ~ 1 文字列インスタンスの長さよりも小さい値です。  
  
 検索`anyOf`小文字が区別されます。  
  
 このメソッドは、ここで、文字と見なされます別の文字に相当その Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには、[IndexOfAny メソッド \(Char\<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName>メソッド、ここで構成済みなどの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが"AE"などの正しいシーケンス内の文字のコンポーネントの検索 \(u\+0041、u\+0045\) カルチャに応じて、します。  
  
   
  
## 例  
 次の例では、別の文字列の部分文字列に文字列「補助」の任意の文字に見つかった位置のインデックスを検索します。  
  
 [!code-cpp[string.indexofany3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
 \-または\-  
  
 <paramref name="count" /> \+ <paramref name="startIndex" /> が、このインスタンス中の文字数を超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">挿入した箇所で 0 から始まるインデックス位置。</param>
        <param name="value">挿入する文字列。</param>
        <summary>このインスタンス内の指定したインデックス位置に指定した文字列を挿入した、新しい文字列を返します。</summary>
        <returns>このインスタンスと等価で、<paramref name="startIndex" /> の位置に <paramref name="value" /> が挿入された新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `startIndex` は、このインスタンスの長さと等しい `value` がこのインスタンスの末尾に追加されます。  
  
> [!NOTE]
>  このメソッドでは、現在のインスタンスの値は変更されません。 代わりに、これで新しい文字列を返します `value` が現在のインスタンスに挿入します。  
  
 戻り値など `"abc".Insert(2, "XYZ")` "abXYZc"です。  
  
   
  
## 例  
 次の例では、文字列の 4 番目の文字位置 \(インデックス 3 文字\) に空白文字を挿入します。  
  
 [!code-csharp[System.String.Insert\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 次のコンソール アプリケーションでは、ユーザーが 2 つの動物を記述する 1 つまたは複数の形容詞の入力を求めます。 呼び出して、 <xref:System.String.Insert%2A> を文字列に、ユーザーが入力したテキストを挿入します。  
  
 [!code-cpp[stringinsert\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が負の数値か、またはこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">インターン プールから検索する文字列。</param>
        <summary>指定した <see cref="T:System.String" /> へのシステム参照を取得します。</summary>
        <returns>
          <paramref name="str" /> がインターン プールに存在する場合は、それに対するシステム参照。それ以外の場合は、値が <paramref name="str" /> の文字列への新しい参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 共通言語ランタイムは、それぞれ一意のリテラル文字列宣言またはプログラムによって作成された、プログラムで 1 つの参照を含むインターン プールと呼ばれる、テーブルを維持することで文字列ストレージを節約できます。 その結果、特定の値を持つリテラル文字列のインスタンスのみ 1 回、システムに存在します。  
  
 たとえば、複数の変数に同じリテラル文字列を割り当てると場合、ランタイムはインターン プールから同じ参照をリテラル文字列を取得し、各変数に代入します。  
  
 <xref:System.String.Intern%2A>メソッドの値と等しい文字列を検索するインターン プールを使用して`str`です。 このような文字列が存在する場合は、インターン プール内の参照が返されます。 文字列が存在しないかどうかへの参照を`str`その参照が返されますが、インターン プールに追加します。  
  
 次の例では、"MyTest"の値を持つ文字列 s1 既に隔離されている場合、プログラム内のリテラルになっているためです。<xref:System.Text.StringBuilder?displayProperty=fullName>クラスを s1 と同じ値を持つ新しい文字列オブジェクトが生成されます。 その文字列への参照は、s2 に割り当てられます。<xref:System.String.Intern%2A>メソッド s2 として同じ値を持つ文字列を検索します。 このような文字列が存在するため、このメソッドは、s1 に割り当てられているものと同じ参照を返します。 S3 には、その参照が割り当てられます。 参照 s1 および s2 と比較して等しくない別のオブジェクトを参照しているため同じ文字列を参照しているために、参照 s1 と s3 は等しい比較されます。  
  
 [!code-csharp[System.String.Intern\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 このメソッドは<xref:System.String.IsInterned%2A>メソッドです。  
  
## バージョンの考慮事項  
 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]、<xref:System.String.Intern%2A>メソッドは .NET Framework 1.0 および 1.1 空の文字列がインターン処理に関しては、その動作に戻ります。 次の例では、変数`str1`への参照が割り当てられている<xref:System.String.Empty>、および変数`str2`への参照が割り当てられている<xref:System.String.Empty>呼び出しによって返される、<xref:System.String.Intern%2A>メソッドへの変換した後に、<xref:System.Text.StringBuilder>値があるオブジェクト<xref:System.String.Empty>文字列にします。 含まれる参照し、`str1`と`str2`等しいかどうかを比較します。  
  
 [!code-csharp[System.String.Intern\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 In the [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], and [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` and `str2` are equal. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]と[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]、`str1`と`str2`が等しくないです。  
  
## パフォーマンスに関する考慮事項  
 メモリの総量を削減しようとしている場合、アプリケーションを割り当てます、ある文字列がインターン処理 2 つの望ましくない副作用に注意してください。 最初に、割り当てられたメモリ インターンの<xref:System.String>オブジェクトは可能性がありますするまで解放されません、共通言語ランタイム \(CLR\) を終了します。 その理由は、インターンへの参照を CLR の<xref:System.String>オブジェクトは、アプリケーションまたはアプリケーション ドメインも後に永続化できる、終了します。 次に、文字列をインターン プールには、文字列を最初作成する必要があります。 によって使用されるメモリ、<xref:System.String>オブジェクト必要があります割り当てられたままに、場合でも、メモリのガベージ コレクションは最終的に実行します。  
  
 .NET Framework version 2.0 では、<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=fullName>列挙体のメンバーです。<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>メンバーとしてリテラル文字列がインターン処理を必要としないアセンブリをマークします。 適用できる<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>使用してアセンブリを<xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute>属性。 また、使用、[Native Image Generator \(Ngen.exe\)](http://msdn.microsoft.com/ja-jp/44bf97aa-a9a4-4eba-9a0d-cfaa6fc53a66)実行時の前にアセンブリをコンパイルする文字列がないモジュール間でインターンされます。  
  
   
  
## 例  
 次の例では、新しく作成された文字列かどうかを決定する値に等しい 3 つの文字列で、インターン処理後の文字列が等しい。  
  
 [!code-cpp[string.intern\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">インターン プールから検索する文字列。</param>
        <summary>指定した <see cref="T:System.String" /> への参照を取得します。</summary>
        <returns>
          <paramref name="str" /> が共通言語ランタイムのインターン プール内にある場合は、それへの参照。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 共通言語ランタイムが自動的に 1 つのインスタンスの一意のインスタンスと同様に、プログラムで宣言されている各一意のリテラル文字列定数を含むインターン プールと呼ばれる、テーブルを保持します<xref:System.String>呼び出すことによってプログラムで追加する、<xref:System.String.Intern%2A>メソッドです。  
  
 インターン プールには、文字列の記憶域が節約されます。 各変数が参照のいくつかの異なるインスタンスを参照するのではなく、インターン プール内で同じ定数に設定されているいくつかの変数にリテラル文字列定数を割り当てる場合<xref:System.String>同一の値があります。  
  
 このメソッドを検索`str`インターン プールにします。 場合`str`は既にインターン、そのインスタンスへの参照を返します。 それ以外の場合、`null`が返されます。  
  
 このメソッドは<xref:System.String.Intern%2A>メソッドです。  
  
 このメソッドは、ブール値を返しません。 特定の文字列がインターン プールに存在するかどうかを示すブール値にするために、メソッドを呼び出す場合は、次のようなコードを使用できます。  
  
 [!code-csharp[System.String.IsInterned\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  以降、.NET Framework version 2.0 では、オーバーライドできますインターン プールの使用を使用するときに、[\(Ngen.exe\) Native Image Generator](http://msdn.microsoft.com/ja-jp/44bf97aa-a9a4-4eba-9a0d-cfaa6fc53a66)にローカル コンピューター上のネイティブ イメージ キャッシュにアセンブリをインストールします。 詳細については、パフォーマンスに関する考慮事項については、「解説」セクションを参照してください、<xref:System.String.Intern%2A>プロパティです。  
  
   
  
## 例  
 次の例では、リテラル文字列がコンパイラによって自動的にインターンすることを示します。  
  
 [!code-cpp[string.isinterned\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列が、Unicode 正規形 C であるかどうかを示します。</summary>
        <returns>この文字列が正規形 C である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Unicode 文字の一部がある複数バイナリ表現組み合わせから成るおよび\/または複合の Unicode 文字。 複数の表現の 1 つの文字の存在には、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、文字のバイナリ表現のいずれかを指定すると 1 つのバイナリ表現を返します正規化と呼ばれるプロセスを定義します。 別の規則に従う、正規化形式と呼ばれる、複数のアルゴリズムでは、正規化を実行できます。 .NET Framework では、C、D、KC、および KD 正規化形式がサポートされています。  
  
 サポートされている Unicode 正規化形式の説明は、次を参照してください。<xref:System.Text.NormalizationForm?displayProperty=fullName>です。  
  
   
  
## 例  
 次の例では、さまざまな正規化フォームへの文字列が正常に正規化されたかどうかを判断します。  
  
 [!code-cpp[string.normalize\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスには、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage">
          <para>The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string. Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Unicode 正規形。</param>
        <summary>この文字列が、指定された Unicode 正規形であるかどうかを示します。</summary>
        <returns>この文字列が <paramref name="normalizationForm" /> パラメーターで指定された正規形である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 いくつかの Unicode 文字の組み合わせで構成される同等の複数のバイナリ表現があるおよび複合の Unicode 文字。 単一の文字に対して複数の表現の存在には、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、文字のバイナリ表現のいずれかが指定されると 1 つのバイナリ表現を表す正規化と呼ばれるプロセスを定義します。 別の規則に従う、正規化形式と呼ばれる複数のアルゴリズムでは、正規化を実行できます。 .NET Framework では、C、D、KC、および KD 正規化形式がサポートされています。  
  
 サポートされている Unicode 正規化形式については、次を参照してください。 <xref:System.Text.NormalizationForm?displayProperty=fullName>します。  
  
   
  
## 例  
 次の例は、 <xref:System.String.IsNormalized%2A> と <xref:System.String.Normalize%2A> メソッドです。  
  
 [!code-cpp[string.normalize\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスには、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage">
          <para>The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string. Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">テストする文字列。</param>
        <summary>指定された文字列が <see langword="null" /> または <see cref="F:System.String.Empty" /> 文字列であるかどうかを示します。</summary>
        <returns>
          <see langword="true" /> パラメーターが <paramref name="value" /> または空の文字列 \(""\) の場合は <see langword="null" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.IsNullOrEmpty%2A>便利なメソッドを同時にテストすることができるかどうか、<xref:System.String>は`null`またはその値が<xref:System.String.Empty>です。 これは、次のコードに相当します。  
  
 [!code-cpp[System.String.IsNullOrEmpty\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 使用することができます、<xref:System.String.IsNullOrWhiteSpace%2A>文字列があるかどうかをテストするメソッド`null`、その値は<xref:System.String.Empty?displayProperty=fullName>の空白文字だけで構成されていますか。  
  
## Null 文字列とは何ですか。  
 文字列は`null`値 \(C\+\+ および Visual Basic\) 割り当てられていない場合、またはの値が割り当てられて明示的に`null`です。 ただし、[複合書式指定](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)として例を次に、そのメンバーがスローされた場合、いずれかの呼び出しをしようとして機能が、null 文字列を適切に処理、<xref:System.NullReferenceException>です。  
  
 [!code-cpp[System.String.IsNullOrEmpty\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## 空の文字列とは何ですか。  
 文字列が空の文字列が明示的に割り当てられる場合は空 \(""\) または<xref:System.String.Empty?displayProperty=fullName>です。 空の文字列が、<xref:System.String.Length%2A>は 0 です。  次の例では、空の文字列を作成し、その値とその長さを表示します。  
  
 [!code-cpp[System.String.IsNullOrEmpty\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## 例  
 次の例は、3 つの文字列を検査し、それぞれの文字列値を持つ、空の文字列、されるかを決定`null`です。  
  
 [!code-cpp[String.IsNullOrEmpty\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">テストする文字列。</param>
        <summary>指定された文字列が <see langword="null" /> または空であるか、空白文字だけで構成されているかどうかを示します。</summary>
        <returns>
          <see langword="true" /> パラメーターが <paramref name="value" /> または <see langword="null" /> であるか、<see cref="F:System.String.Empty" /> が空白文字だけで構成されている場合は <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.IsNullOrWhiteSpace%2A>優れたパフォーマンスを提供する点を除いて次のコードでは、次のような便利なメソッドを示します。  
  
 [!code-csharp[System.String.IsNullOrWhitespace\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 空白文字は、Unicode 規格によって定義されます。<xref:System.String.IsNullOrWhiteSpace%2A>メソッドの値を返す任意の文字は解釈`true`に渡されたときに、<xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName>メソッドの空白文字として。  
  
   
  
## 例  
 次の例は、文字列配列を作成し、先の配列の各要素を渡す、<xref:System.String.IsNullOrWhiteSpace%2A>メソッドです。  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">区切り文字として使用する文字列。戻される文字列に <c>separator</c> が含まれるのは、<c>values</c> に複数の要素がある場合のみです。</param>
        <param name="values">連結する文字列を格納しているコレクション。</param>
        <summary>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の構築された <see cref="T:System.String" /> コレクションのメンバーを連結します。各メンバーの間には、指定した区切り記号が挿入されます。</summary>
        <returns>
          <paramref name="values" /> のメンバーからなる、<paramref name="separator" /> 文字列で区切られた文字列。<paramref name="values" /> にメンバーがない場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合`separator`は`null`、空の文字列 \(<xref:System.String.Empty?displayProperty=fullName>\) 代わりに使用されます。 場合のメンバーはすべて`values`は`null`、空の文字列が代わりに使用されます。  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>内の各要素を連結できる便利なメソッドは、`IEnumerable(Of String)`を文字列配列の要素を変換せずコレクション。 統合言語クエリ \(LINQ\) クエリ式で特に便利です。 次の例では、`List(Of String)`と等しいか \(つまり、例では、"M"\) 特定の文字を超える文字を選択する、ラムダ式にアルファベットの大文字または小文字の文字を含むオブジェクトです。`IEnumerable(Of String)`によって返されるコレクション、<xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName>にメソッドが渡される、<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>を 1 つの文字列として結果を表示するメソッド。  
  
 [!code-csharp[System.String.Join\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## 例  
 次の例では、エラトステネスの篩というアルゴリズムを使用して、小さいか 100 素数を計算します。 結果を割り当てます、<xref:System.Collections.Generic.List%601>型のオブジェクト<xref:System.String>、しに渡されます、<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>メソッドです。  
  
 [!code-csharp[System.String.Join\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。<c>values</c> が 2 つ以上の要素を含む場合のみ、<c>separator</c> が返される文字列に含まれます。</param>
        <param name="values">連結する要素を格納している配列。</param>
        <summary>オブジェクト配列の要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns>
          <paramref name="values" /> の要素からなる、<paramref name="separator" /> 文字列で区切られた文字列。<paramref name="values" /> が空の配列の場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
 or if any element of **parameterReference tag is not supported!!!!**  
 other than the first element is **languageKeyword tag is not supported!!!!**  
, an empty string \(<xref:System.String.Empty?displayProperty=fullName>\) is used instead. See the Notes for Callers section if the first element of **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings. The string representation of each object in the array is derived by calling that object's `ToString` method.  
  
   
  
## 例  
 The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100. It assigns the result to a integer array, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> method.  
  
 [!code-csharp[System.String.Join\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>If the first element of <paramref name="values" /> is <see langword="null" />, the <see cref="M:System.String.Join(System.String,System.Object[])" /> method does not concatenate the elements in <paramref name="values" /> but instead returns <see cref="F:System.String.Empty" />. A number of workarounds for this issue are available. The easiest is to assign a value of <see cref="F:System.String.Empty" /> to the first element of the array, as the following example shows.  
  
 [!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)]
 [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。<c>value</c> が 2 つ以上の要素を含む場合のみ、<c>separator</c> が返される文字列に含まれます。</param>
        <param name="value">連結する要素を格納している配列。</param>
        <summary>文字列配列のすべての要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns>
          <paramref name="value" /> 内の要素からなる、<paramref name="separator" /> 文字列で区切られた文字列。<paramref name="value" /> が空の配列の場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 たとえば場合、`separator`は「,」と、要素の`value`は、"apple"、「オレンジ」、「ぶどう」および「洋ナシ」 `Join(separator, value)` 「apple、オレンジ色、ぶどう、洋ナシ」を返します。  
  
 場合`separator`は`null`、空の文字列 \(<xref:System.String.Empty?displayProperty=fullName>\) 代わりに使用されます。 場合内の要素で`value`は`null`、空の文字列が代わりに使用されます。  
  
   
  
## 例  
 次の例で、<xref:System.String.Join%2A>メソッドです。  
  
 [!code-cpp[stringjoin\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。<c>value</c> が 2 つ以上の要素を含む場合のみ、<c>separator</c> が返される文字列に含まれます。</param>
        <param name="value">連結する要素を格納している配列。</param>
        <param name="startIndex">使用する <c>value</c> の最初の要素。</param>
        <param name="count">使用する <c>value</c> の要素の数。</param>
        <summary>文字列配列の指定した要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns>
          <paramref name="value" /> 内の文字列からなる、<paramref name="separator" /> 文字列で区切られた文字列。  
  
 または  
  
 <paramref name="count" /> が 0 である場合、または <paramref name="value" /> に要素がない場合、または <paramref name="separator" /> と <paramref name="value" /> のすべての要素が <see cref="F:System.String.Empty" /> である場合、<see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 たとえば場合、`separator`は「,」と、要素の`value`は、"apple"、「オレンジ」、「ぶどう」および「洋ナシ」`Join(separator, value, 1, 2)`を返します「オレンジ, ぶどう」です。  
  
 場合`separator`は`null`、空の文字列 \([Join メソッド \(String, String\<xref:System.String.Empty?displayProperty=fullName>\) 代わりに使用されます。 場合内の要素で`value`は`null`、空の文字列が代わりに使用されます。  
  
   
  
## 例  
 次の例では、成果物の名前の配列から 2 つの要素を連結します。  
  
 [!code-cpp[string.join2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> と <paramref name="count" /> を加算すると、<paramref name="value" /> にある要素の数を超えます。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <c>values</c> のメンバーの型。</typeparam>
        <param name="separator">区切り文字として使用する文字列。戻される文字列に <c>separator</c> が含まれるのは、<c>values</c> に複数の要素がある場合のみです。</param>
        <param name="values">連結するオブジェクトを格納しているコレクション。</param>
        <summary>コレクションのメンバーを連結します。各メンバーの間には、指定した区切り記号が挿入されます。</summary>
        <returns>
          <paramref name="values" /> のメンバーからなる、<paramref name="separator" /> 文字列で区切られた文字列。<paramref name="values" /> にメンバーがない場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合`separator`は`null`、空の文字列 \(<xref:System.String.Empty?displayProperty=fullName>\) 代わりに使用されます。 場合のメンバーはすべて`values`は`null`、空の文字列が代わりに使用されます。  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>各メンバーを連結できる便利なメソッドは、<xref:System.Collections.Generic.IEnumerable%601>最初を文字列に変換なしのコレクション。 内の各オブジェクトの文字列形式を、<xref:System.Collections.Generic.IEnumerable%601>を呼び出してそのオブジェクトのコレクションを派生`ToString`メソッドです。  
  
 このメソッドは、特定統合言語クエリ \(LINQ\) クエリ式で便利です。 たとえば、次のコードは非常に単純な定義`Animal`動物とそれが属する注文書の名前を表すクラス。 定義し、<xref:System.Collections.Generic.List%601>オブジェクトの数値を含んだ`Animal`オブジェクト。<xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName>抽出する拡張メソッドが呼び出される、`Animal`オブジェクト`Order`"Rodent"と等しい。 結果に渡される、<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドです。  
  
 [!code-csharp[System.String.Join\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## 例  
 次の例では、エラトステネスの篩というアルゴリズムを使用して、小さいか 100 素数を計算します。 結果を割り当てます、<xref:System.Collections.Generic.List%601>しに渡されます整数型のオブジェクト、<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドです。  
  
 [!code-csharp[System.String.Join\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。 つまり、文字列の最初の文字インデックス 0 の位置は、最後に<xref:System.String.Length%2A>\- 1。  
  
 このメソッドは、このインスタンスの最後の文字位置から検索を開始し、されるまで、先頭に向かって逆方向に進みます`value`が見つかったか、最初の文字位置が検査されています。 検索では大文字小文字を区別します。  
  
 このメソッドは、ここで文字と見なされます別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName>メソッド、ここで構成済みなどの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが"AE"などの正しいシーケンス内の文字のコンポーネントの検索 \(u\+0041、u\+0045\) カルチャに応じて、します。  
  
   
  
## 例  
 次の例では定義、`ExtractFilename`で使用する方法、<xref:System.String.LastIndexOf%28System.Char%29>文字列内の最後のディレクトリの区切り記号を検索して、文字列のファイル名を抽出する方法です。 ファイルが存在する場合は、そのパスがない場合、ファイル名を返します。  
  
 [!code-csharp[System.String.LastIndexOf\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合は \-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値はこのインスタンスの最後のインデックス位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。 つまり、文字列の最初の文字インデックス 0 の位置は、最後に<xref:System.String.Length%2A>\- 1。  
  
 検索は、このインスタンスの最後の文字位置から開始され、されるまで、先頭に向かって逆方向に進みます`value`が見つかった最初の文字位置が検査されているか。  
  
 このメソッドは、単語 \(大文字小文字を区別やカルチャ\) を現在のカルチャを使用して検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合`value`1 つまたは複数の無視できる文字のみで構成されて、<xref:System.String.LastIndexOf%28System.String%29>メソッドは常に返します<xref:System.String.Length%2A?displayProperty=fullName>– 1 で、現在のインスタンスで最後のインデックス位置を表します。 次の例で、 <xref:System.String.LastIndexOf%28System.String%29> 2 つの文字列内で \(ソフト ハイフン \(U \+0 00AD\)、"n"で後にソフト ハイフンおよびにソフト ハイフンの後に"m"\) の 3 つの部分文字列を検索するメソッドを使用します。 文字列の 1 つのみにソフト ハイフンが含まれます。 この例を実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]後で、各ケースではソフト ハイフンに無視できる文字であるため、結果は、場合と同じにソフト ハイフンが含まれていない必要があるか`value`です。 ソフト ハイフンのみを検索するときに、このメソッドは、6 および 5 を返します。 これらの値は、2 つの文字列の最後の文字のインデックスに対応します。  
  
 [!code-csharp[System.String.LastIndexOf\#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf\#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## 例  
 次の例では、タグと終了タグで開始する場合、文字列および文字列の末尾から HTML タグを削除します。 場合は、文字列が終わりで終わる文字を角かっこ \("\>"\)、この例では、<xref:System.String.LastIndexOf%2A>メソッド終了タグの開始位置をします。  
  
 [!code-csharp[System.String.LastIndexOf\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索の開始位置。 検索は、このインスタンスの先頭に向かって <c>startIndex</c> から開始されます。</param>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。 文字列の最初の文字インデックス 0 の位置は、最後に<xref:System.String.Length%2A>\-1. このメソッド検索開始位置、`startIndex`文字のこのインスタンスとが実行されるまで、現在のインスタンスの先頭に向かって逆方向の位置`value`が見つかった最初の文字位置が検査されているか。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>\- 1、先頭に文字列の最後の文字からすべての文字が検索します。 検索では大文字小文字を区別します。  
  
 このメソッドは、ここで文字と見なされます別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName>メソッド、場所、構成済みの文字を表す、合字の「Æ」など \(U \+ 00 C 6\)、Unicode スカラー値と見なすことが"AE"などの正しいシーケンス内の文字のコンポーネントの検索 \(u\+0041、u\+0045\) カルチャに応じて、です。  
  
   
  
## 例  
 次の例では、文字列の先頭に、文字列の末尾から作業をして、文字列に出現する文字をすべてのインデックスを検索します。  
  
 [!code-cpp[string.lastindexof1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、このインスタンスの長さ以上です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <c>startIndex</c> から開始されます。</param>
        <summary>このインスタンス内で最後に出現する指定された文字列の 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は \-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。 つまり、文字列の最初の文字インデックス 0 の位置は、最後に<xref:System.String.Length%2A>\- 1。  
  
 検索を開始、`startIndex`文字のこのインスタンスと続行されるまで、先頭に向かって逆方向の位置`value`見つかった最初の文字位置が検査されているか。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>\- 1、メソッドは、先頭に文字列で最後の文字からすべての文字を検索します。  
  
 このメソッドは、単語 \(大文字小文字を区別やカルチャ\) を現在のカルチャを使用して検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合`value`1 つまたは複数の無視できる文字のみで構成されて、<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>メソッドは常に返します`startIndex`、これは、検索を開始する文字位置。 次の例で、<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>メソッドはソフト ハイフン \(U \+0 00AD\) が含まれているしよりも前または最後の"m"を文字列に含まれます部分文字列を検索に使用します。 この例を実行している場合は[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または後で、検索文字列にソフト ハイフンが無視されるための呼び出しはソフト ハイフンで構成される部分文字列を検索する呼び出しはソフト ハイフンと"m"で構成される部分文字列が文字列で、"m"の位置を返し、"n"は"n"の位置を返しますを検索するメソッド。 メソッドが、"m"の値を表すのインデックスを返します、検索文字列には、ソフト ハイフンのみが含まれている、`startIndex`です。  
  
 [!code-csharp[System.String.LastIndexOf\#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf\#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## 例  
 次の例では、対象の文字列の先頭に、ターゲット文字列の末尾から作業をして、ターゲット文字列のすべての出現する文字列のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof7\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、または現在のインスタンスの長さを超えています。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="startIndex" /> が \-1 未満であるか、または 0 を超えています。</exception>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最後に見つかった 0 から始まる位置のインデックスをレポートします。 指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合は \-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値はこのインスタンスの最後のインデックス位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。 つまり、文字列の最初の文字インデックス 0 の位置は、最後に<xref:System.String.Length%2A>\- 1。  
  
 `comparisonType`を検索するパラメーターを指定します、`value`パラメーター現在またはインバリアント カルチャを使用して、または区別しない検索を使用して、word または序数比較規則を使用します。  
  
 検索は、このインスタンスの最後の文字位置から開始され、されるまで、先頭に向かって逆方向に進みます`value`が見つかった最初の文字位置が検査されているか。  
  
   
  
## 例  
 次の exampledemonstrates 3 つのオーバー ロードが、<xref:System.String.LastIndexOf%2A>の異なる値を使用して別の文字列内の文字列の最後の出現箇所を検索するメソッド、<xref:System.StringComparison>列挙します。  
  
 [!code-csharp[system.string.LastIndexOfCmp\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="options" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method always returns <see cref="P:System.String.Length" /> – 1, which represents the last index position in the current instance.  
  
 In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings. Only one of the strings contains a soft hyphen. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string. An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.  
  
 [!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)]
 [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索の開始位置。 検索は、このインスタンスの先頭に向かって <c>startIndex</c> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>このインスタンス内の部分文字列で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。 つまり、文字列の最初の文字インデックス 0 の位置は、最後に<xref:System.String.Length%2A>\- 1。  
  
 このメソッドで検索を開始、`startIndex`文字の位置やが実行されるまで、このインスタンスの先頭に向かって逆方向`value`が見つかるまたは`count`文字位置します。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>\- 1、メソッドは逆方向に検索`count`文字、文字列の最後の文字をします。 検索では大文字小文字を区別します。  
  
 このメソッドは、ここで、文字と見なされます別の文字に相当その Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName>メソッド、ここで構成済みなどの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが"AE"などの正しいシーケンス内の文字のコンポーネントの検索 \(u\+0041、u\+0045\) カルチャに応じて、します。  
  
   
  
## 例  
 次の例では、部分文字列の末尾から部分文字列の先頭に作業をして、部分文字列内で出現する文字をすべてのインデックスが検索されます。  
  
 [!code-cpp[string.lastindexof2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、このインスタンスの長さ以上です。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> \- <paramref name="count" /> \+ 1 が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <c>startIndex</c> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始され、指定した文字位置の数だけ文字列の先頭に向かって逆向きに移動して実行されます。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は \-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。 つまり、文字列の最初の文字インデックス 0 の位置は、最後に<xref:System.String.Length%2A>\- 1。  
  
 検索を開始、`startIndex`このインスタンスとが実行されるまで、先頭に向かって逆方向の位置の文字`value`が見つかるまたは`count`の文字位置します。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>\- 1、メソッドは逆方向に検索`count`文字、文字列の最後の文字をします。  
  
 このメソッドは、単語 \(大文字小文字を区別やカルチャ\) を現在のカルチャを使用して検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合`value`1 つまたは複数の無視できる文字のみで構成されて、<xref:System.String.LastIndexOf%2A>メソッドは常に返します`startIndex`、これは、検索を開始する文字位置。 次の例で、<xref:System.String.LastIndexOf%2A>メソッドを使用して、2 つの文字列の最後の"m"の前に 2 つの文字にソフト ハイフン \(U \+0 00AD\) の位置を調べます。 文字列の 1 つのみに必要な部分文字列が含まれます。 この例を実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]後で、どちらの場合はソフト ハイフンに無視できる文字であるため、メソッドのインデックスを返します、文字列に"m"カルチャに依存した比較を実行するときまたはします。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.LastIndexOf\#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf\#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## 例  
 次の例では、先頭の部分文字列の末尾から部分文字列の先頭に、文字列のすべての出現箇所のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof8\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が負の値です。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が負の値です。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンスの長さより大きいです。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> \- <paramref name="count" />\+ 1 した値がこのインスタンス内にはない位置を指定しています。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="start" /> が \-1 より小さいか 0 より大きいです。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="count" /> が 1 より大きいです。</exception>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To perform this operation by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <c>startIndex</c> から開始されます。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最後に見つかった 0 から始まる位置のインデックスをレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。 指定した文字列を検索するときに実行する比較の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は \-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。 つまり、文字列の最初の文字インデックス 0 の位置は、最後に<xref:System.String.Length%2A>\- 1。  
  
 検索を開始、`startIndex`文字の位置やが実行されるまで、旧バージョンと`value`が見つかった最初の文字位置が検査しましたか。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>\- 1、メソッドが、先頭に文字列の最後の文字からすべての文字を検索します。  
  
 `comparisonType`検索するパラメーターを指定します、`value`パラメーター現在またはインバリアント カルチャを使用して、または区別しない検索を使用して、word または序数比較規則を使用します。  
  
   
  
## 例  
 次の exampledemonstrates 3 つのオーバー ロードが、<xref:System.String.LastIndexOf%2A>メソッドの別の値を使用して別の文字列内の文字列の最後の出現箇所を<xref:System.StringComparison>列挙します。  
  
 [!code-csharp[system.string.LastIndexOfCmp\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、または現在のインスタンスの長さを超えています。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="startIndex" /> が \-1 未満であるか、または 0 を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.  
  
 In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m". The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.  
  
 [!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)]
 [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <c>startIndex</c> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。 指定した文字列を検索するときに実行する比較の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は \-1。<paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。 つまり、文字列の最初の文字インデックス 0 の位置は、最後に<xref:System.String.Length%2A>\- 1。  
  
 検索を開始、`startIndex`文字の位置や収入されるまで、旧バージョンと`value`見つかったまたは`count`文字位置します。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>\- 1、メソッドは逆方向に検索`count`文字、文字列の最後の文字をします。  
  
 `comparisonType`を検索するパラメーターを指定します、`value`パラメーターの現在またはインバリアント カルチャを使用して、大文字小文字を区別や大文字と小文字の検索を使用して word または序数比較規則を使用しています。  
  
   
  
## 例  
 次の exampledemonstrates 3 つのオーバー ロードが、<xref:System.String.LastIndexOf%2A>の異なる値を使用して別の文字列内の文字列の最後の出現箇所を検索するメソッド、<xref:System.StringComparison>列挙します。  
  
 [!code-csharp[system.string.LastIndexOfCmp\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が負の値です。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が負の値です。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンスの長さより大きいです。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> \+ 1 \- <paramref name="count" /> した値がこのインスタンス内にはない位置を指定しています。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="start" /> が \-1 より小さいか 0 より大きいです。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="count" /> が 1 より大きいです。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.  
  
 In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. When it performs an ordinal comparison, however, it finds the substring only in the first string. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison. The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.  
  
 [!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)]
 [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。  
  
 このメソッドは、このインスタンスの最後の文字位置から検索を開始し、内の文字までの先頭に向かって逆方向に進みます`anyOf`が見つかったか、最初の文字位置が検査されています。 検索では大文字小文字を区別します。  
  
 このメソッドは、ここで文字と見なされます別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName>メソッド、ここで構成済みなどの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが"AE"などの正しいシーケンス内の文字のコンポーネントの検索 \(u\+0041、u\+0045\) カルチャに応じて、します。  
  
   
  
## 例  
 次の例では、別の文字列内で、"is"を任意の文字、文字列内で最後に見つかった位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <c>startIndex</c> から開始されます。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。  
  
 このメソッドで検索を開始、`startIndex`文字位置のこのインスタンスと内の文字までの先頭に向かって後方に進み`anyOf`が見つかった最初の文字位置が検査されているか。 検索では大文字小文字を区別します。  
  
 このメソッドは、ここで文字と見なされます別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには、[LastIndexOfAny メソッド \(Char\<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName>メソッド、ここで構成済みなどの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが"AE"などの正しいシーケンス内の文字のコンポーネントの検索 \(u\+0041、u\+0045\) カルチャに応じて、します。  
  
   
  
## 例  
 次の例では、別の文字列の部分文字列に、"is"を任意の文字、文字列内で最後に見つかった位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンス内にはない位置を指定しています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <c>startIndex</c> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス番号は、0 から始まります。  
  
 このメソッドで検索を開始、`startIndex`このインスタンスと収益内の文字までの先頭に向かって逆方向の位置の文字`anyOf`が見つかるまたは`count`の文字位置します。 検索では大文字小文字を区別します。  
  
 このメソッドは、ここで、文字が同等と見なさ他の文字の Unicode スカラー値が同じ場合にのみ、序数に基づく \(カルチャに依存しない\) 検索を実行します。 カルチャに依存した検索を実行するには、[LastIndexOfAny メソッド \(Char\<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName>構成済みなどの文字「Æ」合字 \(U \+ 00 C 6\) を表す Unicode スカラー値と見なすことが"AE"などの正しいシーケンス内の文字のコンポーネントのと同じメソッド \(u\+0041、u\+0045\) カルチャに応じて、します。  
  
   
  
## 例  
 次の例では、別の文字列の部分文字列に文字列「補助」内にある文字の最後に見つかった位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
 または  
  
 現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> \- <paramref name="count" /> \+ 1 が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクト内の文字数を取得します。</summary>
        <value>現在の文字列の文字数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.Length%2A>プロパティの数を返します<xref:System.Char>オブジェクトがこのインスタンスで、Unicode 文字の数値ではありません。 その理由は、1 つ以上の Unicode 文字を表すこと<xref:System.Char>です。 使用して、<xref:System.Globalization.StringInfo?displayProperty=fullName>ごとではなく各 Unicode 文字を使用するクラス<xref:System.Char>です。  
  
 C や C\+\+ など、一部の言語では、null 文字は、文字列の末尾を示します。 .NET Framework では、文字列の null 文字を埋め込むことできます。 文字列には、1 つまたは複数の null 文字が含まれている場合は、それらの合計の文字列の長さに含まれます。 たとえば、次の文字列では、"abc"と"def"が、null 文字で区切られた部分文字列で。<xref:System.String.Length%2A>プロパティを返します 7、6 文字のアルファベットだけでなく null 文字が含まれていることを示します。  
  
 [!code-cpp[System.String.Class\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## 例  
 次の例で、<xref:System.String.Length%2A>プロパティです。  
  
 [!code-cpp[string.length\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が Unicode 正規形 C である新しい文字列を返します。</summary>
        <returns>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が正規形 C である新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 一部の Unicode 文字の組み合わせで構成される同等の複数のバイナリ表現があるおよび\/または複合の Unicode 文字。 たとえば、文字「いずれも」を表す次のコード ポイントのいずれかのことができます。  
  
-   U \+0 1EAF  
  
-   U \+0 0103 U \+0 0301  
  
-   U \+0 0061 U \+0 0306 U \+0 0301  
  
 複数の表現の 1 つの文字の存在には、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、文字のバイナリ表現のいずれかを指定すると 1 つのバイナリ表現を返します正規化と呼ばれるプロセスを定義します。 正規化は、別の規則に従う、正規化形式と呼ばれるいくつかのアルゴリズムで実行できます。 .NET Framework には、4 つ正規化の形式 \(C、D、KC、および KD\)、Unicode 規格によって定義されているがサポートしています。2 つの文字列は、同じ正規形で表されている、theycan 序数に基づく比較を使用して比較します。  
  
 正規化し、2 つの文字列を比較するには、次の操作を行います。  
  
1.  ファイルや、ユーザー入力デバイスなどの入力ソースから比較する文字列を取得します。  
  
2.  呼び出す、<xref:System.String.Normalize>正規形 C に文字列を正規化する方法  
  
3.  2 つの文字列を比較するように序数に基づく文字列比較をサポートするメソッドを呼び出す、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドの値を指定<xref:System.StringComparison.Ordinal?displayProperty=fullName>または<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=fullName>として、<xref:System.StringComparison>引数。 正規化された文字列の配列を並べ替えるに渡す、`comparer`値<xref:System.StringComparer.Ordinal%2A?displayProperty=fullName>または<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=fullName>の適切なオーバー ロードに<xref:System.Array.Sort%2A?displayProperty=fullName>です。  
  
4.  前の手順で示される順序に基づいて並べ替えられる出力内の文字列を出力します。  
  
 サポートされている Unicode 正規化形式の説明は、次を参照してください。<xref:System.Text.NormalizationForm?displayProperty=fullName>です。  
  
   
  
## 例  
 次の例は、文字列を正規化形式の 4 つのそれぞれを正規化、文字列は、指定した正規形が正規化されたし、正規化後の文字列内のコード ポイントのリストを確認します。  
  
 [!code-cpp[string.normalize\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスには、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage">
          <para>The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string. Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Unicode 正規形。</param>
        <summary>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が、指定された Unicode 正規形である新しい文字列を返します。</summary>
        <returns>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が、<paramref name="normalizationForm" /> パラメーターで指定された正規形である新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 一部の Unicode 文字の組み合わせで構成される同等の複数のバイナリ表現があるおよび\/または複合の Unicode 文字。 複数の表現の 1 つの文字の存在には、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 Unicode 規格では、文字のバイナリ表現のいずれかを指定すると 1 つのバイナリ表現を返します正規化と呼ばれるプロセスを定義します。 別の規則に従う、正規化形式と呼ばれる、複数のアルゴリズムでは、正規化を実行できます。 .NET Framework には、4 つの正規化の形式 \(C、D、KC、および KD\)、Unicode 規格によって定義されているがサポートしています。2 つの文字列は、同じ正規形で表示されるときに、序数に基づく比較を使用して比較できます。  
  
 正規化し、2 つの文字列を比較するには、次の操作を行います。  
  
1.  ファイルや、ユーザー入力デバイスなどの入力ソースから比較する文字列を取得します。  
  
2.  呼び出す、<xref:System.String.Normalize%28System.Text.NormalizationForm%29>文字列を指定された正規形を正規化する方法です。  
  
3.  2 つの文字列を比較するように序数に基づく文字列比較をサポートするメソッドを呼び出す、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドの値を指定<xref:System.StringComparison.Ordinal?displayProperty=fullName>または<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=fullName>として、<xref:System.StringComparison>引数。 正規化された文字列の配列を並べ替えるに渡す、`comparer`値<xref:System.StringComparer.Ordinal%2A?displayProperty=fullName>または<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=fullName>の適切なオーバー ロードを<xref:System.Array.Sort%2A?displayProperty=fullName>です。  
  
4.  前の手順で示される順序に基づいて並べ替えられる出力内の文字列を出力します。  
  
 サポートされている Unicode 正規化形式の説明は、次を参照してください。<xref:System.Text.NormalizationForm?displayProperty=fullName>です。  
  
   
  
## 例  
 次の例では、それぞれ 4 つの正規化形式の文字列を正規化、文字列は、指定した正規形が正規化されたし、正規化後の文字列内のコード ポイントをリストのことを確認します。  
  
 [!code-cpp[string.normalize\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスには、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage">
          <para>The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string. Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method may throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの文字列の値が同一かどうかを判断します。</summary>
        <returns>
          <paramref name="a" /> の値が <paramref name="b" /> の値と同じ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.String.op_Equality%2A> method defines the operation of the equality operator for the <xref:System.String> class. It enables code such as that shown in the Example section. The operator, in turn, calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which performs an ordinal \(case\-sensitive and culture\-insensitive\) comparison.  
  
> [!NOTE]
>  The Visual Basic compiler does not resolve the equality operator as a call to the <xref:System.String.op_Equality%2A> method. Instead, the equality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=fullName> method.  
  
   
  
## 例  
 The following example demonstrates the equality operator.  
  
 [!code-cpp[system.string.equality\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの文字列の値が異なるかどうかを判断します。</summary>
        <returns>
          <paramref name="a" /> の値が <paramref name="b" /> の値と異なる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.op_Inequality%2A> メソッドの非等値演算子の動作を定義する、 <xref:System.String> クラスです。   例に示すように示すようなコードを使用します。  
  
 <xref:System.String.op_Inequality%2A> 演算子を呼び出して、静的な <xref:System.String.Equals%28System.String%2CSystem.String%29> 序数に基づく \(大文字小文字の区別とカルチャに依存しない\) 比較を実行するメソッドにします。  
  
> [!NOTE]
>  Visual Basic コンパイラでは、呼び出しと非等値演算子が解決しない、 <xref:System.String.op_Inequality%2A> メソッドです。 非等値演算子がへの呼び出しをラップする代わりに、 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 次の例では、非等値演算子を示します。  
  
 [!code-cpp[system.string.inequality\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <summary>指定された文字数になるまで左側に空白を埋め込むことで、このインスタンス内の文字を右寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし右揃えであり、<paramref name="totalWidth" /> の長さになるまで左側に空白が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。<paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Unicode の領域は、16 進数の 0x0020 として定義されます。  
  
 <xref:System.String.PadLeft%28System.Int32%29>メソッドに返される文字列の先頭が埋められます。 これは、右から左への言語に使用する場合、文字列の右側の部分が埋められることを意味します。  
  
> [!NOTE]
>  場合、<xref:System.String.PadLeft%2A>メソッドには空白文字の現在のインスタンスが埋め込まれます、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、その合計の長さが実行されるように、先頭の空白文字で埋められますした新しい文字列を返します`totalWidth`文字です。  
  
   
  
## 例  
 次の例で、<xref:System.String.PadLeft%2A>メソッドです。  
  
 [!code-cpp[Classic String.PadLeft Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <param name="paddingChar">Unicode 埋め込み文字。</param>
        <summary>指定された文字数になるまで左側に指定された Unicode 文字を埋め込むことで、このインスタンス内の文字を右寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし右揃えであり、<paramref name="totalWidth" /> の長さになるまで左側に <paramref name="paddingChar" /> の文字が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。<paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29>メソッドに返される文字列の先頭が埋められます。 これは、右から左への言語に使用する場合、文字列の右側の部分が埋められることを意味します。  
  
> [!NOTE]
>  場合、<xref:System.String.PadLeft%2A>メソッドには空白文字の現在のインスタンスが埋め込まれます、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、先頭が埋め込まれたした新しい文字列を返します`paddingChar`、合計の長さになるよう`totalWidth`文字です。  
  
   
  
## 例  
 次の例で、<xref:System.String.PadLeft%2A>メソッドです。  
  
 [!code-cpp[Classic String.PadLeft1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <summary>指定された文字数になるまで右側に空白を埋め込むことで、この文字列内の文字を左寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし左揃えであり、<paramref name="totalWidth" /> の長さになるまで右側に空白が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。<paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Unicode の領域は、16 進数の 0x0020 として定義されます。  
  
 <xref:System.String.PadRight%28System.Int32%29>メソッドに返される文字列の末尾が埋められます。 これは、右から左への言語に使用する場合、文字列の左側の部分が埋められることを意味します。  
  
> [!NOTE]
>  場合、<xref:System.String.PadRight%2A>メソッドには空白文字の現在のインスタンスが埋め込まれます、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、その合計の長さが実行されるように末尾の空白文字で埋められますした新しい文字列を返します`totalWidth`文字です。  
  
   
  
## 例  
 次の例で、<xref:System.String.PadRight%2A>メソッドです。  
  
 [!code-cpp[Classic String.PadRight Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <param name="paddingChar">Unicode 埋め込み文字。</param>
        <summary>指定された文字数になるまで右側に指定された Unicode 文字を埋め込むことで、この文字列内の文字を左寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし左揃えであり、<paramref name="totalWidth" /> の長さになるまで右側に <paramref name="paddingChar" /> の文字が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。<paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29>メソッドに返される文字列の末尾が埋められます。 これは、右から左への言語に使用する場合、文字列の左側の部分が埋められることを意味します。  
  
> [!NOTE]
>  場合、<xref:System.String.PadRight%2A>メソッドには空白文字の現在のインスタンスが埋め込まれます、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、末尾の埋め込みありした新しい文字列が返されます`paddingChar`、合計の長さになるよう`totalWidth`文字です。  
  
   
  
## 例  
 次の例で、<xref:System.String.PadRight%2A>メソッドです。  
  
 [!code-cpp[Classic String.PadRight1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">文字を削除する際の 0 から始まる開始位置。</param>
        <summary>現在のインスタンスの指定した位置から指定した最後の位置までの全文字が削除された新しい文字列を返します。</summary>
        <returns>この文字列から対象となる文字を取り除いた新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]文字列は 0 から始まります。 値、`startIndex`パラメーターの範囲は 0 から文字列インスタンスの長さより 1 小さい値にします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、その新しい文字列を返すすべての文字位置から`startIndex`元の文字列の末尾までが削除されました。  
  
   
  
## 例  
 次の例で、<xref:System.String.Remove%2A>メソッドです。 次への最後のケースでは、文字列の末尾から指定したインデックスから始まるすべてのテキストを削除します。 最後の場合は、指定したインデックスから始まる次の 3 つの文字を削除します。  
  
 [!code-cpp[string.remove\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> が、この文字列内にはない位置を指定しています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">文字を削除する際の 0 から始まる開始位置。</param>
        <param name="count">削除する文字数。</param>
        <summary>現在のインスタンス内の指定した位置から指定した文字数が削除された新しい文字列を返します。</summary>
        <returns>このインスタンスから対象となる文字を取り除いた新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]文字列は 0 から始まります。 値、`startIndex`パラメーターの範囲は 0 から文字列インスタンスの長さより 1 小さい値にします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、文字の数がで指定されている新しい文字列を返します、`count`パラメーターが削除されました。 指定された位置にある、文字を削除する`startIndex`です。  
  
   
  
## 例  
 次の例では、完全な名前から、ミドル ネームを削除する方法を示します。  
  
 [!code-cpp[stringremove\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="count" /> のいずれかが 0 より小さい値です。  
  
 \-または\-  
  
 <paramref name="startIndex" /> に <paramref name="count" /> を加えたものが、このインスタンスの外部の位置を指定しています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">置換する Unicode 文字。</param>
        <param name="newChar">出現するすべての <c>oldChar</c> を置換する Unicode 文字。</param>
        <summary>このインスタンスに出現する指定された Unicode 文字をすべて、別の指定された Unicode 文字に置換した新しい文字列を返します。</summary>
        <returns>
          <paramref name="oldChar" /> のすべてのインスタンスが <paramref name="newChar" /> で置換されることを除いて、このインスタンスと等価な文字列。<paramref name="oldChar" /> が現在のインスタンス内に見つからない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを検索する序数に基づく \(大文字小文字を区別とカルチャに依存しない\) 検索を実行`oldChar`です。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、すべての出現箇所で新しい文字列を返します`oldChar`は置き換えられます`newChar`です。  
  
 このメソッドは、変更後の文字列を返す、ので連結できます。 を連続して呼び出す、 <xref:System.String.Replace%2A> 、元の文字列に対して複数の置換を実行するメソッド。 メソッドの呼び出しは、左から右に実行されます。 具体的な例を次に示します。  
  
 [!code-csharp[System.String.Replace\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## 例  
 次の例では、コンマ、空白かどうか、一連の数値の間に置き換えることによって値のコンマ区切りリストを作成します。  
  
 [!code-cpp[string.replace1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換される文字列。</param>
        <param name="newValue">出現するすべての <c>oldValue</c> を置換する文字列。</param>
        <summary>現在のインスタンスに出現する指定した文字列をすべて、別に指定した文字列に置換した新しい文字列を返します。</summary>
        <returns>
          <paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> で置き換えられることを除いて、現在の文字列と等価な文字列。<paramref name="oldValue" /> が現在のインスタンス内に見つからない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合`newValue`は`null`、出現するすべての`oldValue`が削除されます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、すべての出現箇所で新しい文字列を返します`oldValue`は置き換えられます`newValue`です。  
  
 このメソッドを検索する序数に基づく \(大文字小文字を区別とカルチャに依存しない\) 検索を実行`oldValue`です。  
  
 このメソッドは、変更後の文字列を返す、ので連結できます。 を連続して呼び出す、 <xref:System.String.Replace%2A> 、元の文字列に対して複数の置換を実行するメソッド。 メソッドの呼び出しは、左から右に実行されます。 具体的な例を次に示します。  
  
 [!code-csharp[System.String.Replace\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## 例  
 次の例では、使用する方法を示しています、<xref:System.String.Replace%2A>スペル ミスを修正する方法です。  
  
 [!code-cpp[stringreplace\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> が空の文字列 \(""\) です。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内の、指定された文字列または Unicode 文字の配列の要素で区切られた部分文字列を格納する文字列配列を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.Split%2A> is used to break a delimited string into substrings. You can use either a character array to specify zero, one, or multiple delimiting characters \(the <xref:System.String.Split%28System.Char%5B%5D%29> method\), or you can use a character array to specify zero, one, or multiple delimiting strings. Overloads of the <xref:System.String.Split%2A> method allow you to limit the number of substrings returned by the method \(the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> method\), to determine whether empty strings are included in the returned substrings \(the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> methods, or to do both \(the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> methods\).  
  
> [!IMPORTANT]
>  For more detailed information on the <xref:System.String.Split%2A> method, as well as for examples that call each overload, see the documentation for the individual overloads of <xref:System.String.Split%2A>.  
  
 The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings. If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.  
  
## Regular expressions  
 If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements. For example, if strings take the form "**placeholder tag is not supported!!!!**  
**placeholder tag is not supported!!!!**  
**placeholder tag is not supported!!!!**  
" you can use a [regular expression](http://msdn.microsoft.com/ja-jp/521b3f6d-f869-42e1-93e5-158c54a6895d) to extract and handle the string's elements. Here's an example:  
  
 [!code-csharp[System.String.Split\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:  
  
|Pattern|Description|  
|-------------|-----------------|  
|`(\d+)`|Match one or more decimal digits. This is the first capturing group.|  
|`\s+`|Match one or more whitespace characters.|  
|`([-+*/])`|Match an arithmetic operator sign \(\+, \-, \*, or \/\). This is the second capturing group.|  
|`\s+`|Match one or more whitespace characters.|  
|`(\d+)`|Match one or more decimal digits. This is the third capturing group.|  
  
 You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters. This is a common scenario when either of these conditions occurs:  
  
-   One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.  
  
-   The sequence and number of delimiter characters is variable or unknown.  
  
 For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of **languageKeyword tag is not supported!!!!**  
 \(in C\#\) or **languageKeyword tag is not supported!!!!**  
 \(in Visual Basic\) characters is variable, and they do not always serve as delimiters.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 A regular expression can split this string easily, as the following example shows.  
  
 [!code-csharp[System.String.Split\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 The regular expression pattern `\[([^\[\]]+)\]` is defined like this:  
  
|Pattern|Description|  
|-------------|-----------------|  
|`\[`|Match an opening bracket.|  
|`([^\[\]]+)`|Match any character that is not an opening or a closing bracket one or more times. This is the first capturing group.|  
|`\]`|Match a closing bracket.|  
  
 The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName> method is almost identical to <xref:System.String.Split%2A?displayProperty=fullName>, except that it splits a string based on a regular expression pattern instead of a fixed character set. For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.  
  
 [!code-csharp[System.String.Split\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:  
  
|Pattern|Description|  
|-------------|-----------------|  
|`\s-`|Match a whitespace character followed by a hyphen.|  
|`\s?`|Match zero or one whitespace character.|  
|`[+*]?`|Match zero or one occurrence of either the \+ or \* character.|  
|`\s?`|Match zero or one whitespace character.|  
|`-\s`|Match a hyphen followed by a whitespace character.|  
  
## Search methods and the Substring method  
 If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins. You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want. The string comparison methods include:  
  
-   <xref:System.String.IndexOf%2A>, which returns the zero\-based index of the first occurrence of a character or string in a string instance.  
  
-   <xref:System.String.IndexOfAny%2A>, which returns the zero\-based index in the current string instance of the first occurrence of any character in a character array.  
  
-   <xref:System.String.LastIndexOf%2A>, which returns the zero\-based index of the last occurrence of a character or string in a string instance.  
  
-   <xref:System.String.LastIndexOfAny%2A>, which returns a zero\-based index in the current string instance of the last occurrence of any character in a character array.  
  
 The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string. It then uses the <xref:System.String.Substring%2A> method to return full sentences.  
  
 [!code-csharp[System.String.Split\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <summary>配列内の文字に基づいて文字列を部分文字列に分割します。</summary>
        <returns>このインスタンスを <paramref name="separator" /> の 1 つ以上の文字で区切った部分文字列を要素に格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 文字列は、既知の文字のセットで区切られた、ときに行うこともできます、<xref:System.String.Split%28System.Char%5B%5D%29>部分文字列に分割する方法です。 文字列から部分文字列を抽出するには、他の方法を参照してください、 [String.Split に代わる方法](#Alternatives)セクションです。  
  
## 戻り値の詳細  
 返される配列の要素では、区切り文字は含まれません。 たとえば、区切り文字の配列には、文字が含まれています。"\-"と現在の文字列インスタンスの値"aa bb cc"は、次の 3 つの要素を含む配列を返します:"aa"、"bb"、および"cc"です。  
  
 このインスタンスに内の文字が含まれていないかどうかは`separator`で返される配列は、このインスタンスを含む 1 つの要素で構成されます。  
  
 各要素`separator`別の区切り記号を定義します。 返される配列に対応する要素に含まれる 2 つの区切り記号は、隣接するセル、または、区切り記号が先頭またはこのインスタンスの末尾に見つかった、<xref:System.String.Empty>です。 次にいくつかの例を示します。  
  
|文字列値|区切り記号|返される配列|  
|----------|-----------|------------|  
|"42, 12, 19"|新しい Char\[\] {',', ''} \(c\#\)<br /><br /> Char\(\) \= {「,」c""c}\) \(Visual Basic\)|{"42", "", "12", "", "19"}|  
|"42..12..19"|新しい Char\[\] {'. '} \(C\#\)<br /><br /> Char\(\) \= {"です"。c} \(Visual Basic\)|{"42", "", "12", "", "19"}|  
|「バナナ」|新しい Char\[\] {'. '} \(C\#\)<br /><br /> Char\(\) \= {"です"。c} \(Visual Basic\)|{「バナナ」}|  
|"Darb\\nSmarba"\(c\#\)<br /><br /> "Darb"\>\/documents\/report1.rdl」の vbLf \>\/documents\/report1.rdl」の"Smarba"\(Visual Basic\)|新しい Char {} \(c\#\)<br /><br /> Char\(\) \= {} \(Visual Basic\)|{"Darb"、"Smarba"}|  
|"Darb\\nSmarba"\(c\#\)<br /><br /> "Darb"\>\/documents\/report1.rdl」の vbLf \>\/documents\/report1.rdl」の"Smarba"\(Visual Basic\)|null \(C\#\)<br /><br /> Nothing \(Visual Basic\)|{"Darb"、"Smarba"}|  
  
## 区切り文字の配列  
 区切り記号の各要素は、1 つの文字で構成される個別の区切り記号を定義します。 場合、`separator`引数は`null`文字が含まれていないか、メソッドは、区切り記号として空白文字をどのように処理します。 空白文字が Unicode 標準; で定義されています。返される`true`に渡される場合、<xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName>メソッドです。  
  
## String.Split\(Char\[\]\) コンパイラ オーバー ロードの解決  
 このオーバー ロードの 1 つのパラメーター<xref:System.String.Split%2A?displayProperty=fullName>文字配列では、次の例のように単一の文字を呼び出すことができます。  
  
 [!code-csharp[System.String.Split\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 の`separator`でパラメーターを修飾します<xref:System.ParamArrayAttribute>属性に、コンパイラでは、1 つの要素の文字配列として単一の文字を解釈します。 これはその他のケースではありません<xref:System.String.Split%2A?displayProperty=fullName>を含むオーバー ロードを`separator`パラメーター; 明示的に渡す必要がありますこれらのオーバー ロードを文字配列としての`separator`引数。  
  
## 比較の詳細  
 <xref:System.String.Split%28System.Char%5B%5D%29>メソッドが 1 つまたは複数の文字で区切られた、この文字列内の部分文字列を抽出し、 `separator`配列や配列の要素としてそれらの部分文字列を返します。  
  
 <xref:System.String.Split%28System.Char%5B%5D%29>メソッドは大文字小文字を区別序数の並べ替え規則を使用する比較を実行することによって区切り記号を検索します。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。、<xref:System.Globalization.CompareOptions?displayProperty=fullName>列挙します。  
  
<a name="Alternatives"></a>   
## String.Split に代わる方法  
 <xref:System.String.Split%2A>常に、区切られた文字列を部分文字列に分割する最善の方法がメソッドではありません。 すべての区切られた文字列の部分文字列を抽出したくない場合、または区切り記号文字のセットではなくパターンに基づいて文字列を解析する場合は、次の方法を検討してください。  
  
### 正規表現  
 場合は、文字列は、一定のパターンに準拠しているを抽出し、その要素を処理する正規表現を使用できます。 たとえば、次の文字列形式をとる"*数* *オペランド* *数*"を使用することができます、[正規表現](http://msdn.microsoft.com/ja-jp/521b3f6d-f869-42e1-93e5-158c54a6895d)を抽出し、文字列の要素を処理します。 次に例を示します。  
  
 [!code-csharp[System.String.Split\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 正規表現パターン`(\d+)\s+([-+*/])\s+(\d+)`は次のように定義されています。  
  
|パターン|説明|  
|----------|--------|  
|`(\d+)`|1 個以上の 10 進数と一致します。 これが最初のキャプチャ グループです。|  
|`\s+`|1 つ以上の空白文字と一致します。|  
|`([-+*/])`|一致、算術演算子の符号 \(\+、\-、\*、または\/\)。 これが 2 番目のキャプチャ グループです。|  
|`\s+`|1 つ以上の空白文字と一致します。|  
|`(\d+)`|1 個以上の 10 進数と一致します。 これが 3 番目のキャプチャ グループです。|  
  
 正規表現を使用して、文字の固定セットではなく、パターンに基づく文字列から部分文字列を抽出することができますも。 これは、これらの条件のいずれかが発生したときの一般的なシナリオです。  
  
-   1 つ以上の区切り記号文字の常に機能していませんの区切り記号として、<xref:System.String>インスタンス。  
  
-   区切り文字の数と順序は、変数または不明です。  
  
 たとえば、<xref:System.String.Split%2A>ために、次の文字列を分割する方法を使用できませんの数`\n`\(C\# の場合\) または`vbCrLf`\(Visual Basic\) の文字は、変数、および区切り記号として常に使用できません。  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 正規表現では、簡単に、次の例のように、この文字列を分割できます。  
  
 [!code-csharp[System.String.Split\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 正規表現パターン`\[([^\[\]]+)\]`は次のように定義されています。  
  
|パターン|説明|  
|----------|--------|  
|`\[`|開きかっこと一致します。|  
|`([^\[\]]+)`|開始タグまたは右角かっこ 1 回以上の任意の文字に一致します。 これが最初のキャプチャ グループです。|  
|`\]`|右角かっこと一致します。|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName>メソッドはほぼ同じである<xref:System.String.Split%2A?displayProperty=fullName>固定された文字セットではなく正規表現パターンに基づく文字列を分割する点を除いて、します。 たとえば、次の例を使用して、<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName>ハイフン、およびその他の文字のさまざまな組み合わせで区切られた部分文字列を表す文字列を分割する方法です。  
  
 [!code-csharp[System.String.Split\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 正規表現パターン`\s-\s?[+*]?\s?-\s`は次のように定義されています。  
  
|パターン|説明|  
|----------|--------|  
|`\s-`|後にハイフン、空白文字に一致します。|  
|`\s?`|0 個または 1 つの空白文字に一致します。|  
|`[+*]?`|いずれかの 0 個または 1 つの出現と照合、\+ または \* 文字です。|  
|`\s?`|0 個または 1 つの空白文字に一致します。|  
|`-\s`|ハイフン、および空白文字と一致します。|  
  
### 検索方法と Substring メソッド  
 文字列から部分文字列のすべてに興味がない場合、照合を開始するインデックスを返す文字列比較メソッドのいずれかの作業に使用可能性があります。 呼び出すことができます、<xref:System.String.Substring%2A>メソッドを使用する部分文字列を抽出します。 文字列比較メソッドは次のとおりです。  
  
-   <xref:System.String.IndexOf%2A>、文字列インスタンスの文字または文字列の最初に見つかった位置の 0 から始まるインデックスが返されます。  
  
-   <xref:System.String.IndexOfAny%2A>、文字配列内の任意の文字の最初に見つかった位置の現在の文字列インスタンスで、0 から始まるインデックスが返されます。  
  
-   <xref:System.String.LastIndexOf%2A>、文字列インスタンスの文字または文字列の最後に見つかった位置の 0 から始まるインデックスが返されます。  
  
-   <xref:System.String.LastIndexOfAny%2A>、、現在文字列のインスタンスで最後に出現する文字配列内にある文字の 0 から始まるインデックスが返されます。  
  
 次の例では、<xref:System.String.IndexOf%2A>メソッドを文字列内の期間を検索します。 次を使用して、<xref:System.String.Substring%2A>完全な文章を返します。  
  
 [!code-csharp[System.String.Split\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A>メソッドは、返される配列オブジェクトのメモリを割り当て、および<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはメモリの割り当てを管理するが、アプリケーションで重大な場合は、使用を検討、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>メソッドです。 使用するオプションもある、<xref:System.String.Compare%2A>文字列内の部分文字列を検索するメソッド。  
  
 区切り文字の文字列を分割するには、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>文字列の区切り文字を検索するメソッド。 文字列の区切り記号文字列を分割するには、使用は<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>の区切り記号文字列の最初の文字を検索するメソッド。 使用して、<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号文字列の残りの文字に等しいかどうかを調べます。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する<xref:System.String.Split%2A>メソッド呼び出しには、1 つの配列を作成して、各メソッド呼び出し内での参照が検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## 例  
 次の例では、区切り記号として空白や句読点を扱うことで、テキストのブロックから個々 の単語を抽出する方法を示します。 渡された文字配列、`separator`のパラメーター、<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=fullName>メソッドは、空白文字とタブ文字、いくつかの一般的な区切り記号とで構成されます。  
  
 [!code-csharp[System.String.Split\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <summary>配列内の文字に基づいて文字列を最大数の部分文字列に分割します。 返される部分文字列の最大数を指定します。</summary>
        <returns>このインスタンスを、<paramref name="separator" /> 配列のいずれかまたは複数の要素 \(文字\) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返される配列の要素では、区切り文字は含まれません。  
  
 このインスタンスに内の文字が含まれていないかどうかは`separator`、返される配列は、このインスタンスを含む 1 つの要素で構成されます。 場合`count`0 の場合は、空の配列が返されます。  
  
 場合、`separator`パラメーターは`null`文字が含まれていない、または空白文字が区切り記号と見なされます。 空白文字は、Unicode standard、および戻り値によって定義`true`に渡される場合、[Split メソッド \(Char\<xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName>メソッドです。  
  
 各要素`separator`別の区切り記号を定義します。 配列の対応する要素を含む 2 つの区切り記号は、隣接するセル、または、区切り記号が先頭またはこのインスタンスの末尾に見つかった、[Split メソッド \(Char\<xref:System.String.Empty>です。  
  
 ある場合は、複数の`count`、このインスタンス内の部分文字列最初`count`マイナス 1 の部分文字列は、最初に返されます`count`マイナス 1 の要素の戻り値は、このインスタンスの残りの文字は、戻り値の最後の要素で返されます。  
  
 場合`count`数よりも大きいの部分文字列の使用可能な部分文字列が返され、例外はスローされません。  
  
 次の表は、例を示します。  
  
|文字列値|区切り記号|カウント|返される配列|  
|----------|-----------|----------|------------|  
|"42, 12, 19"|新しい Char\[\] {',', ''} \(c\#\)<br /><br /> Char\(\) \= {「,」c""c} \(Visual Basic\)|2|{"42", " 12, 19"}|  
|"42..12..19"|新しい Char\[\] {'. '} \(C\#\)<br /><br /> Char\(\) \= {"です"。c} \(Visual Basic\)|4|{"42", "", "12", ".19"}|  
|「バナナ」|新しい Char\[\] {'. '} \(C\#\)<br /><br /> Char\(\) \= {"です"。c} \(Visual Basic\)|2|{「バナナ」}|  
|"Darb\\nSmarba"\(c\#\)<br /><br /> "Darb"\>\/documents\/report1.rdl」の vbLf \>\/documents\/report1.rdl」の"Smarba"\(Visual Basic\)|新しい Char {} \(c\#\)<br /><br /> Char\(\) \= {} \(Visual Basic\)|1|{"Darb\\nSmarba"}\(C\#\)<br /><br /> "Darb"\>\/documents\/report1.rdl」の vbLf \>\/documents\/report1.rdl」の"Smarba"\(Visual Basic\)|  
|"Darb\\nSmarba"\(c\#\)<br /><br /> "Darb"\>\/documents\/report1.rdl」の vbLf \>\/documents\/report1.rdl」の"Smarba"\(Visual Basic\)|新しい char\[\] null \(c\#\)<br /><br /> Char\(\) \= なし|2|{"Darb"、"Smarba"}|  
|"Darb\\nSmarba"\(c\#\)<br /><br /> "Darb"\>\/documents\/report1.rdl」の vbLf \>\/documents\/report1.rdl」の"Smarba"\(Visual Basic\)|新しい char\[\] null \(c\#\)<br /><br /> Char\(\) \= なし|100|{"Darb"、"Smarba"}|  
  
## パフォーマンスに関する考慮事項  
 [Split メソッド \(Char\<xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当て、および[Split メソッド \(Char\<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはメモリの割り当てを管理するが、アプリケーションで重大な場合は、使用を検討、[Split メソッド \(Char\<xref:System.String.IndexOf%2A>または[Split メソッド \(Char\<xref:System.String.IndexOfAny%2A>メソッド、および必要に応じて、[Split メソッド \(Char\<xref:System.String.Compare%2A>メソッドは、文字列内の部分文字列を検索します。  
  
 区切り文字で文字列を分割する場合を使用して、[Split メソッド \(Char\<xref:System.String.IndexOf%2A>または[Split メソッド \(Char\<xref:System.String.IndexOfAny%2A>文字列の区切り文字を検索するメソッド。 文字列の区切り記号文字列を分割している場合を使用して、[Split メソッド \(Char\<xref:System.String.IndexOf%2A>または[Split メソッド \(Char\<xref:System.String.IndexOfAny%2A>の区切り記号文字列の最初の文字を検索するメソッド。 使用して、[Split メソッド \(Char\<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号文字列の残りの文字に等しいかどうかを調べます。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する[Split メソッド \(Char\<xref:System.String.Split%2A>メソッド呼び出しは、1 つの配列を作成して、各メソッド呼び出し内での参照を検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## 例  
 次の例でどのように`count`によって返される文字列の数に影響を与える[Split メソッド \(Char\<xref:System.String.Split%2A>です。  
  
 [!code-csharp[StringSplit2\#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が負の値です。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字に基づいて文字列を部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 \(文字\) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
## 戻り値の詳細  
 区切り文字 \(内の文字、`separator`配列\) は、返された配列の要素に含まれません。 たとえば場合、`separator`配列には、文字が含まれています。"\-"と、現在の文字列インスタンスの値は"aa、bb、cc"、メソッドを 3 つの要素を含む配列を返します:"aa"、"bb"、および"cc"です。  
  
 このインスタンスに内の文字が含まれていないかどうかは`separator`、返される配列は、のこのインスタンスを含む 1 つの要素で構成されています。  
  
 場合、`options`パラメーターが[Split メソッド \(Char\<xref:System.StringSplitOptions.RemoveEmptyEntries>とこのインスタンスの長さがゼロ、メソッドは、空の配列を返します。  
  
 各要素`separator`の 1 つの文字で構成されている別の区切り記号を定義します。 場合、`options`引数は[Split メソッド \(Char\<xref:System.StringSplitOptions.None>、および隣接する 2 つの区切り記号または配列の対応する要素が含まれています、先頭または、このインスタンスの末尾に、区切り記号が見つかった[Split メソッド \(Char\<xref:System.String.Empty?displayProperty=fullName>です。 たとえば場合、 `separator` 2 つの要素が含まれています"\-"と「\_」、文字列インスタンスの値が「\- \_aa\-\_」での値、`options`引数は[Split メソッド \(Char\<xref:System.StringSplitOptions.None>メソッドは、次の 5 つの要素の文字列配列を返します。  
  
1.  [Split メソッド \(Char\<xref:System.String.Empty?displayProperty=fullName>、前にある空の文字列を表す、"\-"インデックス 0 にある文字。  
  
2.  [Split メソッド \(Char\<xref:System.String.Empty?displayProperty=fullName>、間の空の文字列を表す、"\-"インデックス 0 とインデックス 1 の文字「\_」で文字です。  
  
3.  "aa"など  
  
4.  [Split メソッド \(Char\<xref:System.String.Empty?displayProperty=fullName>、インデックス 4 文字「\_」に続く空の文字列を表します。  
  
5.  [Split メソッド \(Char\<xref:System.String.Empty?displayProperty=fullName>、これに続く空の文字列を表す、"\-"インデックス 5 文字です。  
  
## 区切り文字の配列  
 場合、`separator`パラメーターは`null`文字が含まれていない、または空白文字が区切り記号と見なされます。 空白文字は、Unicode standard、および戻り値によって定義`true`に渡される場合、[Split メソッド \(Char\<xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName>メソッドです。  
  
 場合、`separator`このメソッドのオーバー ロードの呼び出しでパラメーターが`null`コンパイラのオーバー ロードの解決は失敗します。 呼び出されたメソッドを明確に識別するのには、コードがの種類を示す必要があります、`null`です。 次の例では、このオーバー ロードを明確に指定するいくつかの方法を示します。  
  
 [!code-csharp[System.String.Split\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## 比較の詳細  
 [Split メソッド \(Char\<xref:System.String.Split%2A>メソッドが 1 つまたは複数の文字で区切られた、この文字列内の部分文字列を抽出し、`separator`パラメーター、配列の要素としてそれらの部分文字列を返します。  
  
 [Split メソッド \(Char\<xref:System.String.Split%2A>メソッドは大文字小文字を区別序数の並べ替え規則を使用する比較を実行することによって区切り記号を検索します。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。、[Split メソッド \(Char\<xref:System.Globalization.CompareOptions?displayProperty=fullName>列挙します。  
  
## パフォーマンスに関する考慮事項  
 [Split メソッド \(Char\<xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当てると、[Split メソッド \(Char\<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはアプリケーションに不可欠なメモリの割り当てを管理する場合は、使用を検討します[Split メソッド \(Char\<xref:System.String.IndexOf%2A>または[Split メソッド \(Char\<xref:System.String.IndexOfAny%2A>メソッド、および必要に応じての[Split メソッド \(Char\<xref:System.String.Compare%2A>メソッド、文字列内の部分文字列を検索します。  
  
 区切り文字の文字列を分割している場合は、使用は[Split メソッド \(Char\<xref:System.String.IndexOf%2A>または[Split メソッド \(Char\<xref:System.String.IndexOfAny%2A>文字列の区切り文字を検索するメソッド。 文字列の区切り記号文字列を分割している場合を使用して、[Split メソッド \(Char\<xref:System.String.IndexOf%2A>または[Split メソッド \(Char\<xref:System.String.IndexOfAny%2A>の区切り記号文字列の最初の文字を検索するメソッド。 使用して、[Split メソッド \(Char\<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号文字列の残りの文字に等しいかどうかを調べます。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する[Split メソッド \(Char\<xref:System.String.Split%2A>メソッド呼び出しは、1 つの配列を作成して、各メソッド呼び出し内での参照を検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## 例  
 次の例では、[Split メソッド \(Char\<xref:System.StringSplitOptions>列挙体によって生成された部分文字列を含めたり、[Split メソッド \(Char\<xref:System.String.Split%2A>メソッドです。  
  
 [!code-cpp[string.split3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字列配列。区切り文字が含まれていない空の配列。または <see langword="null" />。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字列に基づいて文字列を部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 \(文字列\) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 文字列は、既知の一連の文字列で区切られた、ときに行うこともできます、[Split メソッド \(String\<xref:System.String.Split%2A>部分文字列に分割する方法です。  
  
## 戻り値の詳細  
 区切り記号の文字列は、返される配列の要素には含まれません。 たとえば場合、`separator`配列には、文字列が含まれています。"\-"および現在の文字列インスタンスの値は"aa\-\-bb cc"、3 つの要素を格納している配列を返します:"aa"、"bb"、および"cc"です。  
  
 このインスタンスに内の文字列が含まれていないかどうかは`separator`、返される配列は、のこのインスタンスを含む 1 つの要素で構成されています。  
  
 場合、`options`パラメーターは[Split メソッド \(String\<xref:System.StringSplitOptions.RemoveEmptyEntries>とこのインスタンスの長さがゼロ、空の配列が返されます。  
  
 各要素`separator`1 つ以上の文字で構成されている別の区切り記号を定義します。 場合、`options`引数は[Split メソッド \(String\<xref:System.StringSplitOptions.None>、および隣接する 2 つの区切り記号または配列の対応する要素が含まれています、先頭または、このインスタンスの末尾に、区切り記号が見つかった[Split メソッド \(String\<xref:System.String.Empty?displayProperty=fullName>です。 たとえば場合、 `separator` 2 つの要素が含まれています"\-"と「\_」、文字列インスタンスの値が「\- \_aa\-\_」での値、`options`引数は[Split メソッド \(String\<xref:System.StringSplitOptions.None>メソッドは、次の 5 つの要素の文字列配列を返します。  
  
1.  [Split メソッド \(String\<xref:System.String.Empty?displayProperty=fullName>を前にある空の文字列を表すは"\-"インデックスが 0 の部分文字列。  
  
2.  [Split メソッド \(String\<xref:System.String.Empty?displayProperty=fullName>、との間の空の文字列を表す、"\-"インデックス 0 とインデックス 1 の「\_」の部分文字列のサブスト リングします。  
  
3.  "aa"など  
  
4.  [Split メソッド \(String\<xref:System.String.Empty?displayProperty=fullName>、インデックス 4「\_」の部分文字列に続く空の文字列を表します。  
  
5.  [Split メソッド \(String\<xref:System.String.Empty?displayProperty=fullName>、空の文字列に続くを表す、"\-"インデックス 5 にある部分文字列。  
  
## 区切り文字の配列  
 内の要素のいずれかの`separator`は、複数の文字の部分文字列全体は、区切り記号と見なされます。 たとえば、1 つの要素の`separator`「10」、"This10is10a10string"文字列を分割しようとしています。 次の 4 つの要素の配列を返します: {"This"、"is"、"a"、「文字列です」。 }.  
  
 場合、`separator`パラメーターは`null`文字が含まれていない、または空白文字が区切り記号と見なされます。 空白文字は、Unicode standard、および戻り値によって定義`true`に渡される場合、[Split メソッド \(String\<xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName>メソッドです。  
  
 場合、`separator`このメソッドのオーバー ロードの呼び出しでパラメーターが`null`コンパイラのオーバー ロードの解決は失敗します。 コードに、呼び出されたメソッドを明確に識別するには、型を示す必要があります、`null`です。 次の例では、このオーバー ロードを明確に指定するいくつかの方法を示します。  
  
 [!code-csharp[System.String.Split\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## 比較の詳細  
 [Split メソッド \(String\<xref:System.String.Split%2A>メソッドは、この文字列で区切られた部分文字列内の文字列の 1 つ以上を抽出し、`separator`パラメーター、配列の要素としてそれらの部分文字列を返します。  
  
 [Split メソッド \(String\<xref:System.String.Split%2A>メソッドは大文字小文字を区別序数の並べ替え規則を使用する比較を実行することによって区切り記号を検索します。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。、[Split メソッド \(String\<xref:System.Globalization.CompareOptions?displayProperty=fullName>列挙します。  
  
 [Split メソッド \(String\<xref:System.String.Split%2A>メソッドのいずれかの要素は無視`separator`値がある`null`または空の文字列 \(""\) です。  
  
 あいまいな結果を回避するときに文字列`separator`に共通の文字を含む、[Split メソッド \(String\<xref:System.String.Split%2A>操作が、インスタンスの値の末尾に、最初からプロセスが実行され、最初の要素と一致する`separator`インスタンス内の区切り記号と同じです。 部分文字列が、インスタンスで発生した順序で要素の順序よりも優先`separator`です。  
  
 たとえば、値を持つ"abcdef"のインスタンスがあるとします。 場合の最初の要素`separator`"ef"と 2 番目の要素が"bcde"、split 操作のために発生する 2 つの要素を格納する文字列配列には、"a"および"f"です。 これは、"bcde"、インスタンス内の部分文字列が検出され、内の要素と一致するため`separator`"f"の部分文字列が発生するまでにします。  
  
 ただし場合の最初の要素`separator`"bc"を"bcd"と 2 番目の要素が、split 操作の結果は 2 つの要素を格納する文字列配列になりますが、"a"と"ef"です。 これは、"bcd"での最初の区切り記号であるため`separator`インスタンス内の区切り記号に一致します。 最初の要素が"bc"区切り記号の順序が取り消された場合と 2 番目の要素が"bcd"結果は 2 つの要素を格納する文字列配列になります"a"と"def"。  
  
## パフォーマンスに関する考慮事項  
 [Split メソッド \(String\<xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当て、および[Split メソッド \(String\<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはメモリの割り当てを管理するが、アプリケーションで重大な場合は、使用を検討、[Split メソッド \(String\<xref:System.String.IndexOf%2A>または[Split メソッド \(String\<xref:System.String.IndexOfAny%2A>メソッド、および必要に応じて、[Split メソッド \(String\<xref:System.String.Compare%2A>メソッドは、文字列内の部分文字列を検索します。  
  
 区切り文字で文字列を分割する場合を使用して、[Split メソッド \(String\<xref:System.String.IndexOf%2A>または[Split メソッド \(String\<xref:System.String.IndexOfAny%2A>文字列の区切り文字を検索するメソッド。 文字列の区切り記号文字列を分割している場合を使用して、[Split メソッド \(String\<xref:System.String.IndexOf%2A>または[Split メソッド \(String\<xref:System.String.IndexOfAny%2A>の区切り記号文字列の最初の文字を検索するメソッド。 使用して、[Split メソッド \(String\<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号文字列の残りの文字に等しいかどうかを調べます。  
  
 さらに場合は、同じ一連の文字は分割に使用される複数の文字列[Split メソッド \(String\<xref:System.String.Split%2A>メソッド呼び出しは、1 つの配列を作成して、各メソッド呼び出し内での参照を検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## 例  
 次の例は、文字列の呼び出しによって返された配列の違いを示しています。[Split メソッド \(String\<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=fullName>メソッドをその`options`パラメーターと等しい[Split メソッド \(String\<xref:System.StringSplitOptions.None?displayProperty=fullName>と[Split メソッド \(String\<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=fullName>です。  
  
 [!code-csharp[System.String.Split\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 次の例では、区切り記号と空白文字が含まれている区切り記号の配列を定義します。 この配列の値と一緒に渡す[Split メソッド \(String\<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=fullName>を[Split メソッド \(String\<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>メソッドは、文字列から個々 の単語で構成される配列を返します。  
  
 [!code-csharp[System.String.Split\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Note that the method is called with the **parameterReference tag is not supported!!!!**  
 argument set to [Split メソッド \(String\<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=fullName>. This prevents the returned array from including[Split メソッド \(String\<xref:System.String.Empty?displayProperty=fullName> values that represent empty substring matches between punctuation marks and white\-space characters.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字に基づいて文字列を最大数の部分文字列に分割します。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 \(文字\) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返される配列の要素では、区切り文字は含まれません。  
  
 このインスタンスに内の文字が含まれていないかどうかは`separator`、または`count`パラメーターが 1、返される配列は、このインスタンスを含む 1 つの要素で構成されます。 場合、`separator`パラメーターは`null`文字が含まれていない、または空白文字が区切り記号と見なされます。 空白文字は、Unicode standard、および戻り値によって定義`true`に渡される場合、[Split メソッド \(Char\<xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName>メソッドです。 ただし場合、`separator`このメソッドのオーバー ロードの呼び出しでパラメーターが`null`コンパイラのオーバー ロードの解決は失敗します。 呼び出されたメソッドを明確に識別するには、コードは、null の種類を示す必要があります。 次の例では、このオーバー ロードを明確に指定するいくつかの方法を示します。  
  
 [!code-csharp[System.String.Split\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 場合、`count`パラメーターが 0、または`options`パラメーターは[Split メソッド \(Char\<xref:System.StringSplitOptions.RemoveEmptyEntries>し、このインスタンスの長さが 0、空の配列が返されます。  
  
 各要素`separator`別の区切り記号を定義します。 場合、`options`パラメーターは[Split メソッド \(Char\<xref:System.StringSplitOptions.None>、および隣接する 2 つの区切り記号または配列の対応する要素が含まれています、先頭または、このインスタンスの末尾に、区切り記号が見つかった[Split メソッド \(Char\<xref:System.String.Empty>です。  
  
 ある場合は、複数の`count`、このインスタンス内の部分文字列最初`count`マイナス 1 の部分文字列は、最初に返されます`count`マイナス 1 の要素の戻り値は、このインスタンスの残りの文字は、戻り値の最後の要素で返されます。  
  
 場合`count`数よりも大きいの部分文字列の使用可能な部分文字列が返され、例外はスローされません。  
  
## パフォーマンスに関する考慮事項  
 [Split メソッド \(Char\<xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当て、および[Split メソッド \(Char\<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはメモリの割り当てを管理するが、アプリケーションで重大な場合は、使用を検討、[Split メソッド \(Char\<xref:System.String.IndexOf%2A>または[Split メソッド \(Char\<xref:System.String.IndexOfAny%2A>メソッド、および必要に応じて、[Split メソッド \(Char\<xref:System.String.Compare%2A>メソッドは、文字列内の部分文字列を検索します。  
  
 区切り文字で文字列を分割する場合を使用して、[Split メソッド \(Char\<xref:System.String.IndexOf%2A>または[Split メソッド \(Char\<xref:System.String.IndexOfAny%2A>文字列の区切り文字を検索するメソッド。 文字列の区切り記号文字列を分割している場合を使用して、[Split メソッド \(Char\<xref:System.String.IndexOf%2A>または[Split メソッド \(Char\<xref:System.String.IndexOfAny%2A>の区切り記号文字列の最初の文字を検索するメソッド。 使用して、[Split メソッド \(Char\<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号文字列の残りの文字に等しいかどうかを調べます。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する[Split メソッド \(Char\<xref:System.String.Split%2A>メソッド呼び出しに、1 つの配列を作成して、各メソッド呼び出し内での参照が検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## 例  
 次の例では、[Split メソッド \(Char\<xref:System.StringSplitOptions>列挙体によって生成された部分文字列を含めたり、[Split メソッド \(Char\<xref:System.String.Split%2A>メソッドです。  
  
 [!code-cpp[string.split3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字列配列。区切り文字が含まれていない空の配列。または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字列に基づいて文字列を最大数の部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 \(文字列\) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
## 戻り値の詳細  
 区切り記号の文字列は、返される配列の要素には含まれません。  
  
 このインスタンスに内の文字列が含まれていないかどうかは`separator`、または`count`パラメーターが 1、返される配列は、このインスタンスを含む 1 つの要素で構成されます。 場合、`separator`パラメーターは`null`文字が含まれていない、または空白文字が区切り記号と見なされます。 空白文字は、Unicode standard、および戻り値によって定義`true`に渡される場合、[Split メソッド \(String\<xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName>メソッドです。 ただし場合、`separator`このメソッドのオーバー ロードの呼び出しでパラメーターが`null`コンパイラのオーバー ロードの解決は失敗します。 コードに、呼び出されたメソッドを明確に識別するには、種類を指定する必要があります、`null`です。 次の例では、このオーバー ロードを明確に指定するいくつかの方法を示します。  
  
 [!code-csharp[System.String.Split\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 場合、`count`パラメーターが 0、または`options`パラメーター[Split メソッド \(String\<xref:System.StringSplitOptions.RemoveEmptyEntries>し、このインスタンスの長さが 0、空の配列が返されます。  
  
 各要素`separator`の 1 つまたは複数の文字から成る別の区切り記号を定義します。 場合、`options`パラメーターは[Split メソッド \(String\<xref:System.StringSplitOptions.None>、および隣接する 2 つの区切り記号または配列の対応する要素が含まれています、先頭または、このインスタンスの末尾に、区切り記号が見つかった[Split メソッド \(String\<xref:System.String.Empty>です。  
  
 ある場合は、複数の`count`、このインスタンス内の部分文字列最初`count`マイナス 1 の部分文字列は、最初に返されます`count`マイナス 1 の要素の戻り値は、このインスタンスの残りの文字は、戻り値の最後の要素で返されます。  
  
 場合`count`数よりも大きいの部分文字列の使用可能な部分文字列が返され、例外はスローされません。  
  
## 区切り文字の配列  
 内の要素のいずれかの`separator`は、複数の文字の部分文字列全体は、区切り記号と見なされます。 たとえば、1 つの要素の`separator`「10」、"This10is10a10string"文字列を分割しようとしています。 この 4 つの要素の配列を返します: {"This"、"is"、"a"、「文字列です」。 }.  
  
## 比較の詳細  
 [Split メソッド \(String\<xref:System.String.Split%2A>メソッドが 1 つまたは複数の文字列で区切られた、この文字列内の部分文字列を抽出し、`separator`パラメーター、配列の要素としてそれらの部分文字列を返します。  
  
 [Split メソッド \(String\<xref:System.String.Split%2A>序数で大文字小文字を区別の並べ替え規則を使用して比較を実行することによってメソッドは区切り記号を検索します。 Word、文字列、および序数の並べ替えの詳細については、次を参照してください。、[Split メソッド \(String\<xref:System.Globalization.CompareOptions?displayProperty=fullName>列挙します。  
  
 [Split メソッド \(String\<xref:System.String.Split%2A>メソッドのいずれかの要素は無視`separator`値がある`null`または空の文字列 \(""\) です。  
  
 あいまいな結果を回避するときに文字列`separator`に共通の文字を含む、[Split メソッド \(String\<xref:System.String.Split%2A>メソッドが、インスタンスの値の末尾に、最初からプロセスが実行され、最初の要素と一致する`separator`インスタンス内の区切り記号と同じです。 部分文字列が、インスタンスで発生した順序で要素の順序よりも優先`separator`です。  
  
 たとえば、値を持つ"abcdef"のインスタンスがあるとします。 場合の最初の要素`separator`"ef"と 2 番目の要素が"bcde"、split 操作の結果になりますが、"a"および"f"です。 これは、"bcde"、インスタンス内の部分文字列が検出され、内の要素と一致するため`separator`"f"の部分文字列が発生するまでにします。  
  
 ただし場合の最初の要素`separator`"bc"を"bcd"と 2 番目の要素が、split 操作の結果になりますが、"a"と"ef"です。 これは、"bcd"での最初の区切り記号であるため`separator`インスタンス内の区切り記号に一致します。 最初の要素が"bc"区切り記号の順序が取り消された場合は、"bcd"に、2 番目の要素が結果になります"a"と"def"。  
  
## パフォーマンスに関する考慮事項  
 [Split メソッド \(String\<xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当て、および[Split メソッド \(String\<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスが必要な場合、またはメモリの割り当てを管理するが、アプリケーションで重大な場合は、使用を検討、[Split メソッド \(String\<xref:System.String.IndexOf%2A>または[Split メソッド \(String\<xref:System.String.IndexOfAny%2A>メソッド、および必要に応じて、[Split メソッド \(String\<xref:System.String.Compare%2A>メソッドは、文字列内の部分文字列を検索します。  
  
 区切り文字で文字列を分割する場合を使用して、[Split メソッド \(String\<xref:System.String.IndexOf%2A>または[Split メソッド \(String\<xref:System.String.IndexOfAny%2A>文字列の区切り文字を検索するメソッド。 文字列の区切り記号文字列を分割している場合を使用して、[Split メソッド \(String\<xref:System.String.IndexOf%2A>または[Split メソッド \(String\<xref:System.String.IndexOfAny%2A>の区切り記号文字列の最初の文字を検索するメソッド。 使用して、[Split メソッド \(String\<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号文字列の残りの文字に等しいかどうかを調べます。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する[Split メソッド \(String\<xref:System.String.Split%2A>メソッド呼び出しは、1 つの配列を作成して、各メソッド呼び出し内での参照を検討してください。 これにより、各メソッド呼び出しのオーバーヘッドが大幅に減少します。  
  
   
  
## 例  
 次の例では、[Split メソッド \(String\<xref:System.StringSplitOptions>列挙体によって生成された部分文字列を含めたり、[Split メソッド \(String\<xref:System.String.Split%2A>メソッドです。  
  
 [!code-cpp[string.split3\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage">
          <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <summary>この文字列インスタンスの先頭が、指定した文字列と一致するかどうかを判断します。</summary>
        <returns>この文字列の先頭が <paramref name="value" /> と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは比較`value`、長さと同じであるこのインスタンスの先頭部分文字列`value`、し、それらが等しいかどうか示す値を返します。 等しく、`value`空の文字列を指定する必要があります \(<xref:System.String.Empty?displayProperty=fullName>\)、この同じインスタンスへの参照があります。 または、このインスタンスの先頭に一致する必要があります。  
  
 このメソッドは、現在のカルチャを使用して、単語 \(大文字小文字を区別やカルチャ\) 比較を実行します。  
  
   
  
## 例  
 次の例、`StripStartTags`で使用する方法、 <xref:System.String.StartsWith%28System.String%29> HTML を削除する方法は、文字列の先頭からタグを開始します。 なお、`StripStartTags`メソッドは再帰的に、行の先頭に複数の HTML 開始タグを削除することを確認します。 この例では、文字列に埋め込まれている HTML タグは削除されません。  
  
 [!code-cpp[stringstartswith\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <param name="comparisonType">この文字列と <c>value</c> との比較方法を決定する列挙値の 1 つ。</param>
        <summary>指定された比較オプションを使って比較した場合に、この文字列インスタンスの先頭が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns>インスタンスが <see langword="true" /> で開始する場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.StartsWith%2A>メソッドに比較して、`value`この文字列の先頭にある部分文字列にパラメーターをそれらが等しいかどうかを示す値を返します。 等しく、`value`この同じ文字列への参照を指定する必要があります、空の文字列にする必要があります \(""\)、またはこの文字列の先頭に一致する必要があります。 によって実行される比較の種類、<xref:System.String.StartsWith%2A>メソッドの値によって異なります、`comparisonType`パラメーター。 比較は、現在のカルチャの規則を使用できます \(<xref:System.StringComparison.CurrentCulture?displayProperty=fullName>と<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=fullName>\) のカルチャまたはインバリアント カルチャ \(<xref:System.StringComparison.InvariantCulture?displayProperty=fullName>と<xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=fullName>\)、または、コード ポイントの文字の比較で構成されていることができます \(<xref:System.StringComparison.Ordinal?displayProperty=fullName>または<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=fullName>\)。 比較は大文字小文字を区別することもできます \(<xref:System.StringComparison.CurrentCulture?displayProperty=fullName>、 <xref:System.StringComparison.InvariantCulture?displayProperty=fullName>、または<xref:System.StringComparison.Ordinal?displayProperty=fullName>\)、大文字小文字を区別、または \(<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=fullName>、 <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=fullName>、 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=fullName>\)。  
  
   
  
## 例  
 次の例は、文字列の検索の"the"という単語で始まる長い文字列の先頭に"The"です。 例への呼び出しからの出力として、<xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29>カルチャおよび大文字小文字 insensitive の比較を実行する呼び出し文字列と一致するときに、文字列に一致するカルチャを認識しないが、区別する比較を実行するメソッドが失敗します。  
  
 [!code-cpp[System.String.StartsWith\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 次の例では、文字列が特定の部分文字列で始まるかどうかを判断します。 これには、2 次元の文字列配列を初期化します。 2 番目の次元内の最初の要素を含む文字列、および 2 番目の要素には、最初の文字列の開始時に検索する文字列が含まれています。 結果は、カルチャ、大文字と小文字の区別するかどうか、および序数に基づく比較を実行するかどうかの選択の影響を受けます。 文字列のインスタンスにする合字が含まれている場合、連続する文字のカルチャに依存した比較が正常に一致する注意してください。  
  
 [!code-cpp[System.String.StartsWith\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">この文字列と <c>value</c> との比較方法を決定するカルチャ情報。<c>culture</c> が <see langword="null" /> の場合は、現在のカルチャが使用されます。</param>
        <summary>指定されたカルチャを使って比較した場合に、この文字列インスタンスの先頭が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> パラメーターがこの文字列の先頭と一致する場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを比較して、`value`パラメーターと同じ長さであるこの文字列の先頭にある部分文字列を`value`、し、それらが等しいかどうかを示す値を返します。 等しく、`value`空の文字列を指定する必要があります \(<xref:System.String.Empty?displayProperty=fullName>\)、この同じインスタンスへの参照があります。 または、このインスタンスの先頭に一致する必要があります。  
  
 このメソッドは、指定した大文字小文字の区別とカルチャを使用して、比較を実行します。  
  
   
  
## 例  
 次の例では、文字列が別の文字列の先頭に出現するかどうかを判断します。<xref:System.String.StartsWith%2A>大文字小文字の区別、大文字と小文字の区別、および検索の結果に影響する異なるカルチャを使用して数回メソッドが呼び出されます。  
  
 [!code-csharp[system.string.StartsWithCI\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の 0 から始まる開始文字位置。</param>
        <summary>このインスタンスから部分文字列を取得します。 部分文字列は、文字列中の指定した文字の位置で開始し、文字列の末尾まで続きます。</summary>
        <returns>このインスタンスの <paramref name="startIndex" /> で始まる部分文字列と等価な文字列。または、<paramref name="startIndex" /> がこのインスタンスの長さと等しい場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す、<xref:System.String.Substring%2A>メソッドを指定した文字位置から開始し、文字列の末尾で終了する文字列から部分文字列を抽出します。 開始する文字位置が、0 から始まります。つまり、文字列の最初の文字はインデックス 0、インデックス 1 ではありません。 指定した文字位置から開始され、文字列の末尾にする前に終了する部分文字列を抽出するを呼び出す、<xref:System.String.Substring%2A>メソッドです。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりで開始された新しい文字列を返します、`startIndex`現在の文字列内の位置。  
  
 特定の文字または文字のシーケンスで始まる部分文字列を抽出するにメソッドを呼び出すよう<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOf%2A>の値を取得する`startIndex`です。 2 番目の例を示します。「\=」文字の後に 1 つの文字位置を開始するキーの値を抽出します。  
  
 場合`startIndex`は 0、元の文字列が変更されていないメソッドを返します。  
  
   
  
## 例  
 次の例では、文字列から部分文字列の取得を示します。  
  
 [!code-cpp[System.String.Substring\#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 次の例では、<xref:System.String.Substring%2A>は等号で区切られたキーと値のペアを区切るメソッド \(「\=」\) 文字です。  
  
 [!code-csharp[System.String.Substring\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.. The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <xref:System.String.IndexOf%2A> method. The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key. It starts at one character position beyond the equals character and extends to the end of the string.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の 0 から始まる開始文字位置。</param>
        <param name="length">部分文字列の文字数。</param>
        <summary>インスタンスから部分文字列を取得します。 この部分文字列は、指定した文字位置から開始し、指定した文字数の文字列です。</summary>
        <returns>このインスタンスの <paramref name="startIndex" /> から始まる長さ <paramref name="length" /> の部分文字列と等価な文字列。または、<paramref name="startIndex" /> がこのインスタンスの長さと等しく、<paramref name="length" /> がゼロの場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す、<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>メソッドを指定した文字位置から開始され、文字列の終了前に終了する文字列から部分文字列を抽出します。 開始する文字位置が、0 から始まります。つまり、文字列の最初の文字はインデックス 0、インデックス 1 ではありません。 指定した文字位置から開始し、文字列の末尾に続行する部分文字列を抽出するを呼び出して、<xref:System.String.Substring%28System.Int32%29>メソッドです。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりを持つ新しい文字列を返します`length`から文字、`startIndex`現在の文字列内の位置。  
  
 `length`パラメーターが現在の文字列のインスタンスから抽出する文字の合計数を表します。 これにより、インデックスにある検出の開始文字が含まれます。`startIndex`です。  言い換えると、<xref:System.String.Substring%2A>メソッドが、インデックスから文字を抽出しようとしています。`startIndex`インデックスに`startIndex`\+ `length` \- 1。  
  
 特定の文字または文字のシーケンスで始まる部分文字列を抽出するにメソッドを呼び出すよう<xref:System.String.IndexOf%2A>または<xref:System.String.LastIndexOf%2A>の値を取得する`startIndex`です。  
  
 部分文字列の場合`startIndex`、指定された文字シーケンスにできるメソッドを呼び出すよう<xref:System.String.IndexOf%2A>または<xref:System.String.LastIndexOf%2A>終了文字または文字のシーケンスのインデックスを取得します。  文字列内のインデックス位置に次のように、その値を変換できます。  
  
-   部分文字列の末尾を設定する単一の文字を検索する場合、`length`パラメーターと等しい`endIndex`\-`startIndex`は \+ 1、場所`endIndex`の戻り値は、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOf%2A>メソッドです。 次の例では、文字列から文字"b"の連続ブロックを抽出します。  
  
     [!code-csharp[System.String.Substring\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   部分文字列の末尾を示すための複数の文字を検索する場合の`length`パラメーターと等しい`endIndex`\+ `endMatchLength` \-`startIndex`ここで、`endIndex`の戻り値は、の<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOf%2A>メソッド。 および`endMatchLength`部分文字列の末尾をマークする文字シーケンスの長さです。 次の例は、XML を含むテキストのブロックを抽出`<definition>`要素。  
  
     [!code-csharp[System.String.Substring\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   、部分文字列の末尾には、文字または文字シーケンスは含まれていない場合、`length`パラメーターと等しい`endIndex`\-`startIndex`ここで、`endIndex`の戻り値は、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOf%2A>メソッドです。  
  
 場合`startIndex`は 0 と equals メソッド、現在の文字列の長さが変更されていない元の文字列を返します。  
  
   
  
## 例  
 次の例では、単純な呼び出しを<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>6 番目の文字位置から始まる文字列から 2 つの文字を抽出する方法 \(つまり、インデックス 5\)。  
  
 [!code-csharp[System.String.Substring\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 次の例では、<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>メソッドで、次の 3 つの場合、文字列内の部分文字列を分離します。 比較では、2 つの場合、部分文字列を使用して、無効なパラメーターが指定されているため、3 番目のケースで、例外がスローされます。  
  
-   1 つの文字と \(インデックス 2\) の文字列の 3 番目の位置を抽出し、"c"と比較します。 この比較を返します`true`です。  
  
-   \(インデックス 3\) の文字列の 4 番目の位置にあるゼロ文字を抽出してに渡します、<xref:System.String.IsNullOrEmpty%2A>メソッドです。 これは true を返すためへの呼び出し、<xref:System.String.Substring%2A>メソッドを返します。<xref:System.String.Empty?displayProperty=fullName>です。  
  
-   文字列の 4 番目の位置以降にある 1 つの文字を抽出しようとします。 その位置にある文字がないため、メソッドの呼び出しがスローされます、<xref:System.ArgumentOutOfRangeException>例外。  
  
 [!code-csharp[Classic String.Substring1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 次の例では、<xref:System.String.Substring%2A>メソッドは等号で区切られたキーと値のペアを区切る文字 \(「\=」\)。  
  
 [!code-csharp[System.String.Substring\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.. The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <xref:System.String.IndexOf%2A> method. The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key. It starts at one character position beyond the equals character and extends to the end of the string.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> に<paramref name="length" /> を加算した値はこのインスタンスの範囲外である位置を示します。  
  
 または  
  
 <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトを反復処理する列挙子を返します。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトを反復処理するために使用できる、厳密に型指定された列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 使用する場合にのみ、<xref:System.String>にインスタンスをキャスト、<xref:System.Collections.Generic.IEnumerable%601>インターフェイス オブジェクト。 詳細については、<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> メソッドを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトを反復処理する列挙子を返します。</summary>
        <returns>現在の文字列を反復処理するために使用できる列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.Collections.IEnumerable> インターフェイスにキャストされる場合にのみ、使用できます。 詳細については、<xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=fullName> メソッドを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の文字列の値が <see cref="F:System.Boolean.TrueString" /> の場合は <see langword="true" />。現在の文字列の値が <see cref="F:System.Boolean.FalseString" /> の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段が呼び出されて、<xref:System.Convert.ToBoolean%28System.String%29?displayProperty=fullName>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の文字列の値が <see cref="F:System.Boolean.TrueString" /> または <see cref="F:System.Boolean.FalseString" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Byte.MaxValue" /> より大きい数か、<see cref="F:System.Byte.MinValue" /> 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトのインデックス 0 位置にある文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段が呼び出されて、<xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段が呼び出されて、<xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Decimal.MinValue" /> 未満か、<see cref="F:System.Decimal.MaxValue" /> より大きい数です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段が呼び出されて、<xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Double.MinValue" /> 未満か、<see cref="F:System.Double.MaxValue" /> より大きい数です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段が呼び出されて、<xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Int16.MaxValue" /> より大きい数か、<see cref="F:System.Int16.MinValue" /> 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段が呼び出されて、<xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.SByte.MaxValue" /> より大きい数か、<see cref="F:System.SByte.MinValue" /> 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">取得するオブジェクトの型。</param>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段が呼び出されて、<xref:System.Convert.ChangeType%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidCastException">現在の <see cref="T:System.String" /> オブジェクトの値を、<paramref name="type" /> パラメーターで指定された型に変換できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.UInt16.MaxValue" /> より大きい数か、<see cref="F:System.UInt16.MinValue" /> 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段が呼び出されて、<xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.UInt32.MaxValue" /> より大きい数か、<see cref="F:System.UInt32.MinValue" /> 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段が呼び出されて、<xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの文字を Unicode 文字配列へコピーします。</summary>
        <returns>このインスタンスの各文字を要素とする Unicode 文字配列。 このインスタンスが空の文字列である場合、返される配列は空で、長さは 0 になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、各文字をコピー \(つまり、各<xref:System.Char>オブジェクト\) を文字配列への文字列にします。 コピーされる最初の文字が返される文字配列のインデックス 0 の位置がインデックス位置にコピーされる最後の文字がある<xref:System.Array.Length%2A?displayProperty=fullName>– 1。  
  
 文字配列内の文字の文字列を作成するには、呼び出し、<xref:System.String.%23ctor%28System.Char%5B%5D%29>コンス トラクターです。  
  
 文字列でエンコードされた文字を格納するバイト配列を作成する、適切なインスタンス化<xref:System.Text.Encoding>オブジェクト呼び出しとその<xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=fullName>メソッドです。 .NET Framework で使用できる標準エンコーディングの一部を以下に示します。  
  
|エンコード|オブジェクト|  
|-----------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF\-7|<xref:System.Text.UTF7Encoding>|  
|UTF\-8|<xref:System.Text.UTF8Encoding>|  
|UTF\-16|<xref:System.Text.UnicodeEncoding>|  
|UTF\-32|<xref:System.Text.UTF32Encoding>|  
  
 詳細については、「[Character Encoding in the .NET Framework](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください。  
  
   
  
## 例  
 次の例では、<xref:System.String.ToCharArray%2A>文字配列への文字列に文字を抽出します。 配列の元の文字列と要素が表示されます。  
  
 [!code-csharp[System.String.ToCharArray\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 次の例では、区切られた文字列内の区切り記号として機能する文字を含む文字列を定義します。 呼び出して、<xref:System.String.ToCharArray%2A>メソッドに渡すことができる文字配列を作成する、<xref:System.String.Split%28System.Char%5B%5D%29>その個々 の部分文字列に区切られた文字列を分割する方法です。  
  
 [!code-cpp[StringSplit2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)]
 [!code-csharp[StringSplit2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/Split1.cs#1)]
 [!code-csharp[StringSplit2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)]
 [!code-vb[StringSplit2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の開始位置。</param>
        <param name="length">このインスタンス内の部分文字列の長さ。</param>
        <summary>このインスタンスの指定した部分文字列の文字を Unicode 文字配列へコピーします。</summary>
        <returns>文字位置 <paramref name="startIndex" /> から始まる、このインスタンス内の文字の <paramref name="length" /> 数を要素とする Unicode 文字配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、文字配列に文字列の一部の文字をコピーします。 文字配列内の文字の範囲から文字列を作成するには、呼び出し、<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターです。  
  
 `startIndex`パラメーターは 0 から始まる。 つまり、文字列インスタンスで最初の文字のインデックスには 0 です。  
  
 場合`length`0 の場合は、返される配列が空、長さは 0 です。 このインスタンスが場合`null`または空の文字列 \(""\)、返される配列が空、長さは 0 です。  
  
 文字列の一部でエンコードされた文字を格納するバイト配列を作成する、適切なインスタンス化<xref:System.Text.Encoding>オブジェクト呼び出しとその<xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29>メソッドです。 .NET Framework で使用できる標準エンコーディングの一部を以下に示します。  
  
|エンコード|オブジェクト|  
|-----------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF\-7|<xref:System.Text.UTF7Encoding>|  
|UTF\-8|<xref:System.Text.UTF8Encoding>|  
|UTF\-16|<xref:System.Text.UnicodeEncoding>|  
|UTF\-32|<xref:System.Text.UTF32Encoding>|  
  
 詳細については、「[Character Encoding in the .NET Framework](http://msdn.microsoft.com/ja-jp/bf6d9823-4c2d-48af-b280-919c5af66ae9)」を参照してください。  
  
   
  
## 例  
 次の例は、文字列内の部分文字列を文字の配列に変換しを列挙し、配列の要素が表示されます。  
  
 [!code-cpp[string.tochararray1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> に <paramref name="length" /> を加算した値がこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のコピーを小文字に変換して返します。</summary>
        <returns>小文字の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドでは、現在のカルチャの大文字小文字の規則が考慮されます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換した新しい文字列を返します。  
  
## セキュリティの考慮事項  
 呼び出し元からの結果の文字種操作、<xref:System.String.ToLower>メソッドは、現在のカルチャの大文字と小文字の表記規則を考慮に入れています。 名前付きパイプ、またはレジストリ キーの使用の小文字または大文字のバージョン、ファイル名などのオペレーティング システム識別子の必要がある場合、<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッドです。 すべてのカルチャで同じ結果が生成されます \(とは異なり、<xref:System.String.ToLower>メソッド\) しより効率的に実行します。  
  
   
  
## 例  
 次の例では、小文字にいくつかの混合大文字と小文字の文字列に変換します。  
  
 [!code-cpp[stringlowerupper\#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper\#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified. To convert a character to lowercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">カルチャ固有の大文字と小文字の規則を提供するオブジェクト。</param>
        <summary>指定されたカルチャの大文字と小文字の規則を使用して、この文字列のコピーを小文字に変換して返します。</summary>
        <returns>現在の文字列を小文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定されたカルチャの大文字と小文字の規則、`culture`パラメーターを変更する方法、文字列の大文字と小文字を決定します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換した新しい文字列を返します。  
  
## セキュリティの考慮事項  
 渡す場合、<xref:System.String.ToLower%28System.Globalization.CultureInfo%29>メソッド、<xref:System.Globalization.CultureInfo>以外のオブジェクト<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName>、大文字と小文字の操作をカルチャに固有のルールを考慮します。 ファイル名などのオペレーティング システム識別子の小文字または大文字のバージョンを必要がある場合は、パイプ、またはレジストリ キーの使用をという名前の<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッドです。 これにより、すべてのカルチャで同じ結果を生成するしより効率的に実行します。  
  
   
  
## 例  
 次の例では、アメリカ合衆国およびトルコ語\-トルコのカルチャを使用して文字を小文字に大文字の 2 つの文字列に変換し、小文字の文字列を比較します。 大文字の文字列は、LATIN CAPITAL LETTER I とドットの上、Unicode LATIN CAPITAL LETTER 世の 1 つの文字列に出現するたび、その他の文字列に含まれる点を除いて同じです。  
  
 [!code-cpp[string.tolower1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インバリアント カルチャの大文字と小文字の規則を使用して、この <see cref="T:System.String" /> オブジェクトのコピーを小文字に変換して返します。</summary>
        <returns>現在の文字列を小文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インバリアント カルチャでは、カルチャに依存しないられるカルチャを表します。 関連付けられている特定の国または地域ではなくが、英語の言語を使用します。 詳細については、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName> プロパティを参照してください。  
  
 使用して、現在のカルチャによって影響を受けるある予測可能な方法で変更する文字列の大文字と小文字で、アプリケーションが依存している場合、<xref:System.String.ToLowerInvariant%2A>メソッドです。<xref:System.String.ToLowerInvariant%2A>メソッドは`ToLower(CultureInfo.InvariantCulture)`します。 文字列のコレクションがユーザー インターフェイス コントロールでの予測可能な順序で表示する必要があるときに、メソッドの使用をお勧めします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換した新しい文字列を返します。  
  
## セキュリティの考慮事項  
 ファイル名などのオペレーティング システム識別子の小文字または大文字のバージョンを必要がある場合は、パイプ、またはレジストリ キーの使用をという名前の<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッドです。  
  
   
  
## 例  
 次の例では、さまざまな言語で 1 つの単語を含む文字列配列を定義します。<xref:System.String.ToLowerInvariant%2A>メソッドは、各単語の大文字と小文字のバージョンと並列配列の要素の設定に使用されます。<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=fullName>メソッドはこの要素が言語に関係なく同じ順序で表示されることを確認する小文字配列の要素の順序に基づいて大文字小文字を区別配列の並べ替えに使用します。  
  
 [!code-csharp[System.String.ToLowerInvariant\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.String" /> のこのインスタンスを返します。実際の変換処理は実行されません。</summary>
        <returns>現在の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、単に変更されていない現在の文字列を返す、ので、メソッドを直接呼び出す必要はありません。 これは通常暗黙的に呼び出されます、複合書式指定操作、例に示すようにします。  
  
   
  
## 例  
 次の例で、<xref:System.String.ToString%2A>メソッドです。例が明示的に呼び出さずに、<xref:System.String.ToString%2A>メソッドです。 代わりに、メソッドの呼び出しによって暗黙的に、[複合書式指定](http://msdn.microsoft.com/ja-jp/87b7d528-73f6-43c6-b71a-f23043039a49)機能します。  
  
 [!code-cpp[string.tostring\#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">\(予約済み\) カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>
          <see cref="T:System.String" /> のこのインスタンスを返します。実際の変換処理は実行されません。</summary>
        <returns>現在の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `provider`予約されていて、この操作に現在参加していません。  
  
 このメソッドは、単に変更されていない現在の文字列を返す、ので、メソッドを直接呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、現在のインスタンス内の各文字を等価な大文字に変換するのに、現在のカルチャの大文字小文字の規則を使用します。 文字が大文字にしたものを持たない場合に含まで返される文字列は変更されません。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換された新しい文字列を返します。  
  
 <xref:System.String.ToUpper%2A>メソッドは、大文字と小文字のために使用できるように文字列を大文字に変換によく使用します。 大文字と小文字の比較を実行するより優れたメソッドを持つ文字列比較メソッドを呼び出す、<xref:System.StringComparison>パラメーターを設定する値を持つ<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=fullName>カルチャ、大文字と小文字の比較についてはします。  
  
## セキュリティの考慮事項  
 呼び出し元からの結果の文字種操作、<xref:System.String.ToUpper>メソッドは、現在のカルチャの大文字と小文字の表記規則を考慮に入れています。 ファイル名などのオペレーティング システム識別子の小文字または大文字のバージョンを必要がある場合は、パイプ、またはレジストリ キーの使用をという名前の<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッドです。 すべてのカルチャで同じ結果が生成されます \(とは異なり、<xref:System.String.ToUpper>メソッド\) しより効率的に実行します。  
  
   
  
## 例  
 次の例では、<xref:System.String.ToUpper%2A>一連の基本的なラテン、ラテン語\-1 本追加ソフトウェア、およびラテン拡張 A 文字セット内の各文字を含む 1 つの文字文字列に変換します。 各文字列が大文字の文字とは異なる、小文字の文字が表示されます。  
  
 [!code-cpp[System.String.ToUpper\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified. To convert a string to uppercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">カルチャ固有の大文字と小文字の規則を提供するオブジェクト。</param>
        <summary>指定されたカルチャの大文字と小文字の規則を使用して、この文字列のコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定されたカルチャの大文字と小文字の規則、`culture`パラメーターを変更する方法、文字列の大文字と小文字を決定します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換された新しい文字列を返します。  
  
## セキュリティの考慮事項  
 渡す場合、<xref:System.String.ToUpper%28System.Globalization.CultureInfo%29>メソッド、<xref:System.Globalization.CultureInfo>以外のオブジェクト<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName>、大文字と小文字の操作をカルチャに固有のルールを考慮します。 名前付きパイプ、またはレジストリ キーの使用の小文字または大文字のバージョン、ファイル名などのオペレーティング システム識別子の必要がある場合、<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッドです。 これにより、すべてのカルチャで同じ結果を生成するしより効率的に実行します。  
  
   
  
## 例  
 次の例では、小文字の文字列をアメリカ合衆国およびトルコ語\-トルコのカルチャを使用して、大文字の 2 つの文字列に変換し、大文字の文字列を比較します。 大文字の文字列は、LATIN CAPITAL LETTER I とドットの上、Unicode LATIN CAPITAL LETTER 世の 1 つの文字列に出現するたび、その他の文字列に含まれる点を除いて同じです。  
  
 [!code-csharp[string.toupper1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インバリアント カルチャの大文字と小文字の規則を使用して、この <see cref="T:System.String" /> オブジェクトのコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インバリアント カルチャでは、カルチャに依存しないられるカルチャを表します。 関連付けられている特定の国または地域ではなくが、英語の言語を使用します。 詳細については、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName> プロパティを参照してください。  
  
 使用して、現在のカルチャによって影響を受けるある予測可能な方法で変更する文字列の大文字と小文字で、アプリケーションが依存している場合、<xref:System.String.ToUpperInvariant%2A>メソッドです。<xref:System.String.ToUpperInvariant%2A>メソッドは`ToUpper(CultureInfo.InvariantCulture)`します。 文字列のコレクションがユーザー インターフェイス コントロールでの予測可能な順序で表示する必要があるときに、メソッドの使用をお勧めします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換された新しい文字列を返します。  
  
## セキュリティの考慮事項  
 ファイル名などのオペレーティング システム識別子の小文字または大文字のバージョンを必要がある場合は、パイプ、またはレジストリ キーの使用をという名前の<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッドです。  
  
   
  
## 例  
 次の例では、さまざまな言語で 1 つの単語を含む文字列配列を定義します。<xref:System.String.ToUpperInvariant%2A>メソッドは、各単語の大文字と小文字のバージョンと並列配列の要素の設定に使用されます。<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=fullName>メソッドは大文字の要素が言語に関係なく同じ順序で表示されることを確認する配列内の要素の順序に基づいて、大文字小文字を区別配列の並べ替えに使用します。  
  
 [!code-csharp[System.String.ToUpperInvariant\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭および末尾にある空白文字をすべて削除します。</summary>
        <returns>現在の文字列の先頭および末尾から空白文字をすべて削除した後に残った文字列。 現在のインスタンスから文字をトリムできない場合は、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.Trim%2A>メソッドは現在の文字列から先頭および末尾の空白文字がすべて削除します。 各先頭および末尾のトリム操作は、空白以外の文字が検出されたときに停止します。 たとえば、現在の文字列が「abc"xyz"」、<xref:System.String.Trim%2A>メソッドには、"abc xyz"が返されます。 削除するには、文字列内の単語の間の空白文字を使用して、 [.NET Framework 正規表現](http://msdn.microsoft.com/ja-jp/521b3f6d-f869-42e1-93e5-158c54a6895d)です。  
  
> [!NOTE]
>  場合、<xref:System.String.Trim%2A>メソッドは、現在のインスタンスから任意の文字を削除、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで見つかったすべての先頭および末尾の空白文字が削除された新しい文字列を返します。  
  
 現在の文字列が等しい場合<xref:System.String.Empty>メソッドを返しますの現在のインスタンスのすべての文字は、空白文字で構成されている、または<xref:System.String.Empty>です。  
  
 空白文字は、Unicode 規格によって定義されます。<xref:System.String.Trim>メソッドの戻り値を生成する先頭および末尾の文字を削除する`true`に渡されるときに、<xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName>メソッドです。  
  
   
  
## 例  
 次の例では、<xref:System.String.Trim?displayProperty=fullName>連結する前に、ユーザーが入力した文字列から余分な空白を削除する方法です。  
  
 [!code-cpp[System.String.Trim\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintain an internal list of white-space characters that this method trims. Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method). Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove. In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭および末尾から、配列で指定された文字セットをすべて削除します。</summary>
        <returns>現在の文字列の先頭および末尾から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。<paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに空白文字が削除されます。 現在のインスタンスから文字をトリムできない場合は、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.Trim%2A>メソッドが現在の文字列からでは、すべての先頭および末尾の文字を削除、`trimChars`パラメーター。 各先頭と末尾の操作が停止するのではない文字をトリム`trimChars`が発生しました。 たとえば、現在の文字列が"123abc456xyz789"と`trimChars`桁の数字「1」~「9」が含まれています、 <xref:System.String.Trim%2A> "abc456xyz"を返します。  
  
> [!NOTE]
>  場合、<xref:System.String.Trim%2A>メソッドは、現在のインスタンスから任意の文字を削除、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、指定したすべての新しい文字列を返します先頭と末尾の`trimChars`現在のインスタンス内に見つかった文字が削除されます。  
  
 現在の文字列が等しい場合<xref:System.String.Empty>または現在のインスタンスのすべての文字の文字から成る、`trimChars`配列を返します<xref:System.String.Empty>です。  
  
 場合`trimChars`は`null`空の配列に、このメソッドは、メソッドの返されると、先頭または末尾の文字を削除または`true`に渡されるときに、<xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName>メソッド  
  
   
  
## 例  
 次の例では、<xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=fullName>文字列から文字、アスタリスク \(\*\)、およびアポストロフィ \('\) 文字を削除する方法です。  
  
 [!code-cpp[System.String.Trim\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array. Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method). Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove. In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの末尾から、配列で指定された文字セットをすべて削除します。</summary>
        <returns>現在の文字列の末尾から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。<paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに Unicode の空白文字が削除されます。 現在のインスタンスから文字をトリムできない場合は、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.TrimEnd%2A>メソッドが現在の文字列から内にあるすべての文字を削除、`trimChars`パラメーター。 トリム操作、最初の文字に含まれていない場合は停止`trimChars`文字列の最後に発生します。 たとえば、現在の文字列が"123abc456xyz789"と`trimChars`桁の数字「1」~「9」が含まれています、 <xref:System.String.TrimEnd%2A> "123abc456xyz"を返します。  
  
> [!NOTE]
>  場合、<xref:System.String.TrimEnd%2A>メソッドは、現在のインスタンスから任意の文字を削除、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、どのすべての末尾の文字で、新しい文字列を返します`trimChars`現在の文字列から削除されます。  
  
   
  
## 例  
 次の例では、使用する方法を示しています、<xref:System.String.TrimEnd%28System.Char%5B%5D%29>空白文字または文字列の末尾からの句読点をトリムするメソッド。  
  
 [!code-csharp[System.String.TrimEnd\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array. Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method). Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove. In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭から、配列で指定された文字セットをすべて削除します。</summary>
        <returns>現在の文字列の先頭から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。<paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに空白文字が削除されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.String.TrimStart%2A>メソッドが現在の文字列から内にあるすべての先頭の文字を削除、`trimChars`パラメーター。 トリム操作を停止するときにではなく、文字`trimChars`が発生しました。 たとえば、現在の文字列が"123abc456xyz789"と`trimChars`桁の数字「1」~「9」が含まれています、 <xref:System.String.TrimStart%2A> "abc456xyz789"を返します。  
  
> [!NOTE]
>  場合、<xref:System.String.TrimStart%2A>メソッドは、現在のインスタンスから任意の文字を削除、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで検出されたすべての先行する空白文字が削除された新しい文字列を返します。  
  
   
  
## 例  
 次の例では、<xref:System.String.TrimStart%2A>空白とソース コードの行からコメント文字をトリムするメソッド。`StripComments`メソッドへの呼び出しをラップする<xref:System.String.TrimStart%2A>し、Visual Basic および C\# の場合は、スラッシュ \(\/\)、スペースとは、アポストロフィ \('\) のコメント文字を格納した文字配列を渡します。<xref:System.String.TrimStart%2A>文字列がコメントであるかどうかを評価するときに、先頭の空白文字を削除するメソッドが呼び出されます。  
  
 [!code-csharp[System.String.TrimStart\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 `StripComments` メソッドを呼び出す例を次に示します。  
  
 [!code-csharp[System.String.TrimStart\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array. Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method). Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove. In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列インスタンスの先頭が、指定した文字列と一致するかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列の末尾に空白または指定された Unicode 文字が埋め込まれた指定された長さの新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列インスタンスの末尾が、指定した文字列と一致するかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイナリ表現が特定の Unicode 正規形である新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの文字を Unicode 文字配列へコピーします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>それぞれの文字列の対応する <see cref="T:System.String" /> オブジェクトの数値を評価することで、2 つの <see cref="T:System.Char" /> を比較します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列のコピーを大文字に変換して返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの値を <see cref="T:System.String" /> に変換します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列のコピーを小文字に変換して返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した配列の要素またはコレクションのメンバーを連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 このインスタンス内で配列内の文字が見つからない場合、このメソッドは \-1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列から指定された文字数を削除した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置のインデックスをレポートします。 このインスタンス内で配列内の文字が見つからない場合、このメソッドは \-1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.String" /> の 1 つ以上のインスタンス、または <see cref="T:System.String" /> の 1 つ以上のインスタンスの <see cref="T:System.Object" /> 形式の値を連結します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字または文字列の 0 から始まるインデックス位置をレポートします。 このインスタンス内で文字または文字列が見つからない場合、このメソッドは \-1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列の先頭に空白または指定された Unicode 文字が埋め込まれた指定された長さの新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭および末尾から、指定した文字セットをすべて削除した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列に出現する指定した Unicode 文字または <see cref="T:System.String" /> をすべて、別の指定した Unicode 文字または <see cref="T:System.String" /> に置換した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>インスタンスから部分文字列を取得します。  
  
 このメンバーはオーバーロードされます。 構文、使用方法、例など、このメンバーの詳細については、オーバーロード リストで名前をクリックしてください。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列が、特定の Unicode 正規形であるかどうかを示します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内で最初に出現する指定 Unicode 文字または文字列の 0 から始まるインデックスをレポートします。 このインスタンス内で文字または文字列が見つからない場合、このメソッドは \-1 を返します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>